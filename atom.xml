<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Henry&#39;s blog</title>
  
  <subtitle>focus works better than curiosity</subtitle>
  <link href="https://henryinshanghai.github.io/atom.xml" rel="self"/>
  
  <link href="https://henryinshanghai.github.io/"/>
  <updated>2020-09-01T02:51:43.298Z</updated>
  <id>https://henryinshanghai.github.io/</id>
  
  <author>
    <name>henryInSH</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>记一次面试（字节跳动）_java基础之线程池</title>
    <link href="https://henryinshanghai.github.io/interview/2020/08/28/interview/20200826-%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%9D%A2%E8%AF%95%EF%BC%88%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%EF%BC%89_java%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0.html"/>
    <id>https://henryinshanghai.github.io/interview/2020/08/28/interview/20200826-%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%9D%A2%E8%AF%95%EF%BC%88%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%EF%BC%89_java%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0.html</id>
    <published>2020-08-28T02:30:00.000Z</published>
    <updated>2020-09-01T02:51:43.298Z</updated>
    
    <content type="html"><![CDATA[<h4 id="关于线程池的初印象"><a href="#关于线程池的初印象" class="headerlink" title="关于线程池的初印象"></a>关于线程池的初印象</h4><p>由于接触到的项目都简单到只是CRUD，我并没有直接编码使用过线程池。所以感觉上非常生疏，甚至在被打击了一次之后，现在仍然觉得它就是个绣花枕头…</p><a id="more"></a><h5 id="预备知识：池化技术"><a href="#预备知识：池化技术" class="headerlink" title="预备知识：池化技术"></a>预备知识：池化技术</h5><ul><li>参考：<a href="https://mp.weixin.qq.com/s/_wP3w2sm0qzBaGC5O6heAg">能看得懂的文章</a></li><li>是：一种通用的技术思想；</li><li>作用：提前准备一些资源，以应对紧急的需求（紧急响应组）；</li><li>特征：<ul><li>提前准备资源（节省临时创建线程的开销）；</li><li>这些资源可以重复使用；</li></ul></li></ul><blockquote><p>知识卡：Java对象创建的过程；</p><ul><li>1 根据代码中<em>new关键字后面的参数</em>来在JVM常量池中找到<em>类的符号引用</em>；</li><li>2 如果没有找到，就把类的class文件加载到JVM中；</li><li>3 类加载完成后，JVM会执行一系列的操作：<ul><li>在堆空间中分配内存空间；</li><li>把分配的空间初始化为0[预初始化,尽量避免NPE]；</li><li>建立对象头的描述结构[<strong>耗时操作，因为在更新堆内存的状态</strong>]；</li></ul></li><li>4 调用对象的初始化方法，完成实例真正的初始化[<strong>耗时操作,因为有一系列的校验过程</strong>]；</li></ul><p>anyway, 创建一个类的实例对象是一个很耗时的过程；BUT,这和池化技术有什么关系呢？</p></blockquote><ul><li><p>应用：</p><ul><li><p>线程池；</p><p>原理：把线程池当作紧急响应组；</p><ul><li>池子中有多个沉睡的线程；</li><li>如果客户端来了一个请求，则唤醒池子中的一个线程；</li><li>线程对请求进行处理；</li><li>处理完成后，线程回到池子里继续睡觉；</li></ul><p>作用：在高并发的场景中，避免所有的CPU资源都耗费在创建线程的工作上（线程才能真正地处理请求）。</p></li><li><p>内存池；</p></li><li><p>数据库连接池等</p></li></ul></li><li><p>验证：使用线程池比起临时创建线程更高效；</p><ul><li><p>手段：创建两个方法，方法1使用线程池执行任务A，方法2临时创建线程执行任务A。比较方法1与方法2的执行耗时；</p></li><li><p>线程的用法；</p><ul><li><p>创建线程对象，创建时传入任务对象（任务类本身也是一个线程）；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread td = <span class="keyword">new</span> Thread(<span class="keyword">new</span> PerformanceRunnable()); <span class="comment">// 把要执行的任务添加到线程中</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><pre><code>- 启动线程;  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">td.start();</span><br></pre></td></tr></table></figure>- 等待线程执行完成；  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">td.join(); <span class="comment">// 确保线程执行完成</span></span><br></pre></td></tr></table></figure></code></pre><ul><li><p>线程池的用法；</p><ul><li><p>创建线程池对象（构造方法有5个参数😄）；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor tp = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">10</span>, <span class="number">10</span>, <span class="number">0</span>,</span><br><span class="line">                TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingDeque&lt;&gt;());</span><br></pre></td></tr></table></figure></li><li><p>使用线程池对象来执行任务；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tp.execute(<span class="keyword">new</span> PerformanceRunnable());</span><br></pre></td></tr></table></figure></li><li><p>关停线程池对象；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tp.shutdown(); <span class="comment">// 为什么任务还没有执行完，就要调用shutdown()?</span></span><br></pre></td></tr></table></figure></li><li><p>等待线程池执行完成；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tp.awaitTermination(<span class="number">1</span>, TimeUnit.SECONDS);  <span class="comment">// 等待线程池执行完成</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>运行耗时结果；</p><blockquote><p>线程执行时长：418 毫秒.<br>线程池执行时长：38 毫秒.</p></blockquote></li><li><p>结论：使用线程池能够大幅地提高程序性能；</p></li></ul><hr><h5 id="Java中的多线程与线程池"><a href="#Java中的多线程与线程池" class="headerlink" title="Java中的多线程与线程池"></a>Java中的多线程与线程池</h5><ul><li>应用场景：为了提高性能往往会在主线程里面开启一个新线程去执行；</li><li>事实：开启线程需要消耗很多资源；</li><li>issue：如果用户量上涨，如果每次任务都创建一个新的线程。服务器表示压力很大…</li><li>手段：使用线程池来预先创建线程，作为备用军团；</li></ul><h6 id="创建线程类的三种手段"><a href="#创建线程类的三种手段" class="headerlink" title="创建线程类的三种手段"></a>创建线程类的三种手段</h6><ul><li>1 继承Thread类；</li><li>2 实现Runnable接口；</li><li>3 实现Callable接口；</li></ul><h6 id="线程类的用法（启动）"><a href="#线程类的用法（启动）" class="headerlink" title="线程类的用法（启动）"></a>线程类的用法（启动）</h6><ul><li><p>如果是通过继承Thread类来创建的线程…</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  通过继承 thread 类</span></span><br><span class="line">Mytheard1 thread1 =  <span class="keyword">new</span> Mytheard1();</span><br><span class="line">thread1.start();</span><br></pre></td></tr></table></figure></li><li><p>如果是通过实现Runnable接口来创建的线程…</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  通过实现 runnable 接口</span></span><br><span class="line">Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Mytheard2()); <span class="comment">// 把实例作为Thread构造器的参数</span></span><br><span class="line">thread2.start();</span><br></pre></td></tr></table></figure></li><li><p>如果是通过实现Callable接口来创建的线程…</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  通过实现 callable 接口</span></span><br><span class="line">Mytheard3 th = <span class="keyword">new</span> Mytheard3();</span><br><span class="line">FutureTask&lt;Integer&gt; result = <span class="keyword">new</span> FutureTask&lt;&gt;(th); <span class="comment">// 把实例作为FutureTask构造器的参数</span></span><br><span class="line"><span class="keyword">new</span> Thread(result).start(); <span class="comment">// 把task对象再作为Thread构造器的参数</span></span><br></pre></td></tr></table></figure></li></ul><h6 id="线程类的特征"><a href="#线程类的特征" class="headerlink" title="线程类的特征"></a>线程类的特征</h6><ul><li>1 不会直接调用自定义线程类中的run()方法；</li><li>2 而是调用Thread类型对象的start()方法；<ul><li>原理：Thread实例对象的start()方法，会调用本地系统方法，并最终导致自定义线程类的run()方法被调用；</li></ul></li></ul><h6 id="线程的分类"><a href="#线程的分类" class="headerlink" title="线程的分类"></a>线程的分类</h6><ul><li><p>1 守护线程；</p><ul><li><p>任务：设置一个线程为守护线程；</p></li><li><p>手段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread.setDaemon(<span class="keyword">true</span>)；</span><br></pre></td></tr></table></figure></li><li><p>特征：</p><ul><li>1 必须在start()方法被调用之前完成set操作（否则会抛出异常）；</li><li>2 在守护线程中开启的新线程也是守护线程；</li></ul></li><li><p>作用：为所有的非守护进程提供守护服务；</p></li><li><p>应用：JVM中的垃圾回收(GC)线程；</p></li></ul></li><li><p>2 用户线程/非守护线程；</p><ul><li><p>特征：</p><ul><li>Java线程默认是非守护线程；</li><li>主线程运行结束后，如果主线程中还有非守护线程，则JVM就不会退出；</li><li>只有在所有的非守护线程执行完成后，JVM才会退出。</li></ul></li></ul></li></ul><blockquote><p>JVM退出时，只会考虑非守护线程的状态；</p></blockquote><h6 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h6><ul><li>场景：如果有多个并发同时访问主线程,而主线程中又创建了多个子线程。则创建线程的开销巨大;</li><li>解决手段：使用线程池来提前预备线程，避免短时间大量创建线程的情形；</li><li>作用：<ul><li>1 减少在创建和销毁线程上所花的时间以及系统资源的开销;</li><li>2 如不使用线程池，有可能造成系统创建大量线程而导致消耗完系统内存;</li></ul></li></ul><h6 id="自定义线程池"><a href="#自定义线程池" class="headerlink" title="自定义线程池"></a>自定义线程池</h6><ul><li><p>手段：</p><ul><li><p>1 自定义类型中持有具体的线程池类型；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> MyPool myPool = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//单例线程池中有两种具体的线程池</span></span><br><span class="line">    <span class="keyword">private</span> ThreadPoolExecutor threadPool = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> ScheduledThreadPoolExecutor scheduledPool = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure></li><li><p>2 以实例变量的方式来设置线程池的各项参数的大小；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置线程池的各个参数的大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> corePoolSize = <span class="number">10</span>;<span class="comment">// 池中所保存的线程数，包括空闲线程。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maximumPoolSize = <span class="number">20</span>;<span class="comment">// 池中允许的最大线程数。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> keepAliveTime = <span class="number">3</span>;<span class="comment">// 当线程数大于核心时，此为终止前多余的空闲线程等待新任务的最长时间。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> scheduledPoolSize = <span class="number">10</span>;</span><br></pre></td></tr></table></figure></li><li><p>3 在私有的构造方法中：</p><ul><li>实例化线程池；</li><li>实例化“计划任务线程池”；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">MyPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//实例化线程池，这里使用的 LinkedBlockingQueue 作为 workQueue ，使用 DiscardOldestPolicy 作为 handler</span></span><br><span class="line"><span class="keyword">this</span>.threadPool = <span class="keyword">new</span> ThreadPoolExecutor(corePoolSize, maximumPoolSize,</span><br><span class="line">keepAliveTime, TimeUnit.SECONDS,</span><br><span class="line"><span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(),</span><br><span class="line"><span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());<span class="comment">//不在新线程中执行任务，而是由调用者所在的线程来执行</span></span><br><span class="line"><span class="comment">//实例化计划任务线程池</span></span><br><span class="line"><span class="keyword">this</span>.scheduledPool = <span class="keyword">new</span> ScheduledThreadPoolExecutor(scheduledPoolSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>4 定义静态方法，返回线程池对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MyPool <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (myPool == <span class="keyword">null</span>)</span><br><span class="line">    create();</span><br><span class="line">    <span class="keyword">return</span> myPool;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>创建线程池时传入的参数说明：</p><ul><li>1 <code>corePoolSize（int）</code>：线程池中保持的线程数量，包括空闲线程在内。</li><li>2 <code>maximumPoolSize（int）</code>: 线程池中能够容纳最大线程数量；</li><li>3 <code>keepAliveTime(long)</code>：当线程池中线程数量大于 corePoolSize 的时候,空闲线程保持在线程池中的时间;</li><li>4 <code>unit(TimeUnit枚举类)</code>: 上面参数时间的单位，可以是分钟，秒，毫秒等等;</li><li>5 <code>workQueue（BlockingQueue）</code>: 任务队列；<ul><li>作用：当线程任务提交到线程池以后…<ul><li>1 首先放入队列中;</li><li>2 然后线程池按照该任务队列依次执行相应的任务;</li></ul></li></ul></li><li>6 <code>threadFactory(ThreadFactory类)</code>: 新线程产生工厂类;</li><li>7 <code>handler（RejectedExecutionHandler类）</code>: 当提交线程拒绝执行、异常的时候，处理异常的类;<ul><li>取值范围：<ul><li>AbortPolicy：丢弃任务并抛出异常；</li><li>DiscardPolicy：丢弃任务但是不抛出异常；</li><li>DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务；</li><li>CallerRunsPolicy：由调用线程处理该任务（？？？）；</li></ul></li></ul></li></ul></li><li><p>用法：获取线程池，并向其中添加任务；</p><ul><li><p>1 获取到线程池对象；</p><ul><li><p>手段1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor pool1 = (ThreadPoolExecutor) Executors.newCachedThreadPool(); <span class="comment">// 调用Executors类的newCachedThreadPool()方法</span></span><br></pre></td></tr></table></figure></li><li><p>手段2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor pool2 = MyPool.getInstance().getThreadPool(); <span class="comment">// 自定义类的静态方法</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>2 调用线程池对象的execute()方法执行指定的任务;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pool1.execute(() -&gt; System.out.println(<span class="string">"快捷线程池中的线程！"</span>));</span><br><span class="line"></span><br><span class="line">pool2.execute(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"pool2 普通线程池中的线程！"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">30</span>*<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;); <span class="comment">// 使用lambda表达式来表示待执行的任务</span></span><br></pre></td></tr></table></figure></li><li><p>3 打印线程池的状态信息；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"pool2 poolSize:"</span>+pool2.getPoolSize()); <span class="comment">// </span></span><br><span class="line">System.out.println(<span class="string">"pool2 corePoolSize:"</span>+pool2.getCorePoolSize()); <span class="comment">// 核心线程数</span></span><br><span class="line">System.out.println(<span class="string">"pool2 largestPoolSize:"</span>+pool2.getLargestPoolSize()); <span class="comment">// </span></span><br><span class="line">System.out.println(<span class="string">"pool2 maximumPoolSize:"</span>+pool2.getMaximumPoolSize()); <span class="comment">// ？？？</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>JDK中提供的几种常用线程池</p><ul><li><code>newFixedThreadPool</code> 创建固定大小数量线程池；</li><li><code>newSingleThreadExecutor</code> 创建容量为1的线程池——所有的线程依次执行；</li><li><code>newCachedThreadPool</code> 创建可缓存的线程池；<ul><li>特征：<ul><li>1 没有最大线程限制；</li><li>2 如果空闲线程等待时间超过1分钟，就关闭此线程；</li></ul></li></ul></li><li><code>newScheduledThreadPool</code> 创建计划 (延迟) 任务线程池；<ul><li>特征：可以设置线程池中线程的执行状态；<ul><li>1 使线程在特定的延迟时间后执行；</li><li>2 使线程周期性地执行；（作用等同于Timer）</li></ul></li></ul></li></ul></li></ul><h6 id="在SpringBoot中使用线程池"><a href="#在SpringBoot中使用线程池" class="headerlink" title="在SpringBoot中使用线程池"></a>在SpringBoot中使用线程池</h6><p>​    this is for further practice.</p><blockquote><p>全是文字，写着写着就没劲了。因为没有推理的过程，就只是照本宣科地陈列规则。<br>Plus,为什么一个构造方法需要有7个参数 OMG 🙃</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;关于线程池的初印象&quot;&gt;&lt;a href=&quot;#关于线程池的初印象&quot; class=&quot;headerlink&quot; title=&quot;关于线程池的初印象&quot;&gt;&lt;/a&gt;关于线程池的初印象&lt;/h4&gt;&lt;p&gt;由于接触到的项目都简单到只是CRUD，我并没有直接编码使用过线程池。所以感觉上非常生疏，甚至在被打击了一次之后，现在仍然觉得它就是个绣花枕头…&lt;/p&gt;</summary>
    
    
    
    <category term="interview" scheme="https://henryinshanghai.github.io/categories/interview/"/>
    
    
    <category term="Algorithm" scheme="https://henryinshanghai.github.io/tags/Algorithm/"/>
    
    <category term="Java stuff" scheme="https://henryinshanghai.github.io/tags/Java-stuff/"/>
    
  </entry>
  
  <entry>
    <title>记一次面试（字节跳动）_后续</title>
    <link href="https://henryinshanghai.github.io/interview/2020/08/28/interview/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%9D%A2%E8%AF%95%EF%BC%88%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%EF%BC%89_%E5%90%8E%E7%BB%AD.html"/>
    <id>https://henryinshanghai.github.io/interview/2020/08/28/interview/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%9D%A2%E8%AF%95%EF%BC%88%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%EF%BC%89_%E5%90%8E%E7%BB%AD.html</id>
    <published>2020-08-27T16:00:00.000Z</published>
    <updated>2020-08-28T15:33:14.166Z</updated>
    
    <content type="html"><![CDATA[<h4 id="ConcurrentHashMap的put-操作过程"><a href="#ConcurrentHashMap的put-操作过程" class="headerlink" title="ConcurrentHashMap的put()操作过程"></a>ConcurrentHashMap的put()操作过程</h4><p>这个问题在上次被问到后，我其实做了一番搜索。还搜索了一些文章，但都本着太长不看的原则跑进收藏夹里吃灰了</p><p>不过这次既然被同一个问题绊倒两次，还是坐下来跟它好好对付对付</p><a id="more"></a><h5 id="基本认识（5点认知）"><a href="#基本认识（5点认知）" class="headerlink" title="基本认识（5点认知）"></a>基本认识（5点认知）</h5><p>是：一个元素容器；</p><p>作用：对元素进行存储；</p><p>特征：</p><ul><li>与多线程相关；</li></ul><p>应用：xxx</p><p>用法：xxx</p><p>底层原理：散列表 + 红黑树；</p><h5 id="进一步认识"><a href="#进一步认识" class="headerlink" title="进一步认识"></a>进一步认识</h5><h6 id="底层数据结构（JDK1-8）"><a href="#底层数据结构（JDK1-8）" class="headerlink" title="底层数据结构（JDK1.8）"></a>底层数据结构（JDK1.8）</h6><p><img src="https://s1.ax1x.com/2020/08/28/dImSRf.md.png" alt="底层数据结构"></p><p>类的具体作用：参考源码中类上面的注释（不夸张的有两百行）；</p><p>简单概括（5点）：</p><ul><li>JDK1.8中的实现是散列表 + 红黑树；</li><li>ConcurrentHashMap支持高并发的访问与更新操作，因为它是线程安全的；</li><li>访问/检索操作不需要加锁；</li><li>get()方法是非阻塞的（啥意思？）；</li><li>key与value都不能为null；</li></ul><h6 id="WHY"><a href="#WHY" class="headerlink" title="WHY?"></a>WHY?</h6><ul><li>Hashtable实现线程安全的手段很直接（每个方法都添加了synchronized关键字），但是效率很低；</li><li>ConcurrentHashMap使用了更优的手段实现线程安全（部分加锁 + CAS算法）；</li></ul><h6 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h6><ul><li>CAS算法（compare and swap）<ul><li>作用：解决多个线程对变量的并发操作问题；</li><li>手段：规定对于任意一个线程，每次对变量进行修改操作时，都检查变量当前在主内存中的值 == 自己获取到的变量值；<ul><li>aka 判断主内存中的变量值是否被其他线程修改过了。</li><li>如果相等，说明没有其他线程修改主内存中的变量。则把修改过的值同步到主内存中；</li><li>如果不相等，说明已经有别的线程捷足先登，把主内存中的变量值修改了。则当前线程放弃自己计算的值，然后从主内存中重新获取变量的初始值，重新计算，然后再次尝试把计算结果同步到主内存中；</li></ul></li><li>知识卡：JMM(java内存模型 = CPU + 各个线程的工作内存 + 主内存；)</li></ul></li><li>volatile关键字<ul><li>作用：保证变量对所有线程的可见性（但是不保证原子性）；</li><li>原理-多线程环境下，变量对多个线程的可见性：一旦变量的值（主内存中）被某个线程修改，其他的线程都会看到修改后的变量；（从而重新获取、重新计算）</li><li>原理-无法保证变量操作的原子性：变量赋值的操作其实分成了多个步骤执行，而volatile没有对这一事实产生任何影响；</li></ul></li></ul><hr><h5 id="从源码认识类的实现原理"><a href="#从源码认识类的实现原理" class="headerlink" title="从源码认识类的实现原理"></a>从源码认识类的实现原理</h5><blockquote><p>bear this in mind：实现源码时，需要充分考虑底层数据结构被多个线程操作的可能性。以保证操作的线程安全</p></blockquote><h6 id="多线程下有哪些操作需要保证多线程安全呢？"><a href="#多线程下有哪些操作需要保证多线程安全呢？" class="headerlink" title="多线程下有哪些操作需要保证多线程安全呢？"></a>多线程下有哪些操作需要保证多线程安全呢？</h6><ul><li>增删改</li></ul><hr><h6 id="类的域对象（×10-不夸张的）"><a href="#类的域对象（×10-不夸张的）" class="headerlink" title="类的域对象（×10 不夸张的）"></a>类的域对象（×10 不夸张的）</h6><ul><li>Node&lt;K,V&gt;[] table; // 用于存储元素的散列表</li><li>其他域对象; // 为了其他API服务的</li><li>int sizeCtl; // 用于控制散列表的初始化与扩容； 规则：…</li></ul><h5 id="类的构造方法（×5-也不夸张）"><a href="#类的构造方法（×5-也不夸张）" class="headerlink" title="类的构造方法（×5 也不夸张）"></a>类的构造方法（×5 也不夸张）</h5><ul><li><p>构造方法的作用</p><ul><li>调用它，来创建实例对象；</li><li>强制调用者传入某些参数来初始化某些实例变量；</li></ul></li><li><p>选择一个构造方法进行代码分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* 参数判空代码... */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 为局部变量cap绑定一个值手段：判断xxx条件是否成立：如果是，绑定ooo。否则绑定tableSizeFor()方法的调用结果&gt;&gt;&gt;表示无符号右移操作</span></span><br><span class="line">        <span class="keyword">int</span> cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ?</span><br><span class="line">                   MAXIMUM_CAPACITY :</span><br><span class="line">                   tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>));</span><br><span class="line">    <span class="comment">// 把cap的值绑定到sizeCtl属性上</span></span><br><span class="line">        <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><p>tableSizeFor()方法的作用？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = c - <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        ...</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">return</span> ...;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这个实现手段不是重点，重点是它的作用是：获取到大于且最接近指定容量的2的指数数值；</p></li><li><p>this.sizeCtl = cap; // 指定下次扩容时，散列表容量的大小</p></li></ul></li></ul><h5 id="类的API-put-方法"><a href="#类的API-put-方法" class="headerlink" title="类的API-put()方法"></a>类的API-put()方法</h5><blockquote><p>OS:这是面试官真正问到的方法，我没有细致地看过 只能硬着头皮说，和HashMap地put()方法实现过程类似，只是添加了synchronized关键字吧吧🐷</p><p>参考:<a href="https://mp.weixin.qq.com/s/r1ErR7EroJt4b83Pm7Xk6g">Java3y</a></p></blockquote><ul><li><p>看之前推测一下子，put()作为一个添加键值对的api，可能的实现过程是怎样的；</p><ul><li>找到键值对应该存放的位置；</li><li>把键值对绑定到这个位置上；Over~</li></ul></li><li><p>真实情况是，put()方法需要做更多的工作（一方面是为了”容器的底层数据结构”,另一方面是为了“多线程操作的正确性”）</p><ul><li>代码拆解（源码基本没有给注释 引用图片：Java3y）</li></ul><p><img src="https://s1.ax1x.com/2020/08/28/do6lpn.png" alt="put()方法的工作"></p><p>这里面的步骤虽然多，但是层次还是能理清楚的。</p><ul><li><p>第一次插入键值对时，判断哈希表是否为空。如果是，就要先对哈希表进行初始化工作；</p></li><li><p>手段：调用initTable()方法，把方法的返回结果绑定到tab（在for循环中创建的局部变量）</p><p><img src="https://s1.ax1x.com/2020/08/28/dog6Fe.png" alt="初始化节点数组tab的代码"></p><ul><li>sizeCtl的规则：小于0时，表示有线程正在执行初始化操作。则，需要控制其他进程不能再次执行初始化的代码;</li><li>任务：对于多个线程，保证初始化的代码同一时刻就只能有唯一的线程在执行；</li><li>手段：<ul><li>1 在线程进入初始化的代码之前，先对sizeCtl属性进行判断；以决定线程能不能继续执行代码</li><li>2 如果线程能够执行初始化代码，在执行代码前，把sizeCtl设置为-1——支持1中的判断操作</li></ul></li><li>作用：多线程情况下，只会有一个线程取完成散列表的初始化操作；</li></ul></li></ul><blockquote><p>这种总结似乎缺了点意思 所以再从另一个角度补充下</p></blockquote></li></ul><h6 id="补充细节"><a href="#补充细节" class="headerlink" title="补充细节"></a>补充细节</h6><p>CAS操作的Java API：</p><ul><li><strong>tabAt</strong>    作用：获取 table 数组中索引为 i 的 Node 元素；</li><li><strong>casTabAt</strong>  作用：设置 table 数组中索引为 i 的元素</li><li><strong>setTabAt</strong>   作用：设置 table 数组中索引为 i 的元素</li></ul><h6 id="put-流程分析"><a href="#put-流程分析" class="headerlink" title="put()流程分析"></a>put()流程分析</h6><ul><li>1 计算出key应该在哈希表中插入的位置；<ul><li>手段：对key进行重哈希，以减少哈希冲突；</li></ul></li><li>2 判断当前数组是否为空，如果为空，就进行初始化操作intiTable();<ul><li>作用：只会有一个线程执行初始化的代码；</li></ul></li><li>3 判断key-value能不能直接添加到哈希表上；<ul><li>手段：<ul><li>1 计算key映射到的哈希表的索引； </li><li>2 调用CAS的tabAt()方法获取到该位置上的值； </li><li>3 如果当前值为null,直接调用casTabAt()完成插入操作；</li></ul></li></ul></li><li>4 如果预期插入哈希表的位置上的元素不为null,判断哈希表是不是正在扩容（多线程需要考虑的问题）<ul><li>手段：判断当前节点是不是特殊节点forwardingNode（这是ConcurrentHashMap中定义的一个内部类型，用于表示扩容操作状态下的节点）</li><li>具体方法：判断节点的hash值是不是等于-1（使用MOVED标识）；</li></ul></li><li>5 如果哈希表也没有在扩容中，说明可以执行插入节点的操作了（synchronzied加锁以实现线程安全性）</li><li>6 如果节点为链表的头节点：<ul><li>如果在链表中找到key相同的节点，则更新/覆盖节点的值</li><li>如果没有找到这样的节点，就直接在链表尾部添加一个新的节点</li></ul></li><li>7 如果节点为红黑树的根节点：<ul><li>说明：如果链表连接的节点长度太长的话，ConcurrentHashMap就会自动把链表转化成一个红黑树；</li><li>1 判断当前节点是不是红黑树的根节点；</li><li>2 判断红黑树中是否已经存在了键为key的节点；<ul><li>存在，则使用新的value来更新它；</li><li>不存在，则向红黑树中添加一个新的节点；</li></ul></li></ul></li><li>8 [<em>插入导致的结果</em>]根据当前链表的长度，来决定要不要把链表转化成一棵红黑树；</li><li>9 [<em>插入导致的结果</em>]插入新的键值对后，查看当前容量。如果超过临界值就进行扩容；</li></ul><h6 id="get-方法"><a href="#get-方法" class="headerlink" title="get()方法"></a>get()方法</h6><blockquote><p>get()的作用是取出数据</p></blockquote><ul><li>1 重hash；</li><li>2 找到节点在哈希表中的预期位置i；</li><li>3 如果哈希表的桶节点table[i]的key与待查找的key相等，则直接返回；</li><li>4 如果不相等，而根节点是红黑树节点。则<ul><li>在红黑树中查找</li></ul></li><li>5 如果不相等，而根节点是链表节点。则<ul><li>在链表中查找</li></ul></li></ul><blockquote><p>Java基础知识也挺繁杂的 until next time 😄</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;ConcurrentHashMap的put-操作过程&quot;&gt;&lt;a href=&quot;#ConcurrentHashMap的put-操作过程&quot; class=&quot;headerlink&quot; title=&quot;ConcurrentHashMap的put()操作过程&quot;&gt;&lt;/a&gt;ConcurrentHashMap的put()操作过程&lt;/h4&gt;&lt;p&gt;这个问题在上次被问到后，我其实做了一番搜索。还搜索了一些文章，但都本着太长不看的原则跑进收藏夹里吃灰了&lt;/p&gt;
&lt;p&gt;不过这次既然被同一个问题绊倒两次，还是坐下来跟它好好对付对付&lt;/p&gt;</summary>
    
    
    
    <category term="interview" scheme="https://henryinshanghai.github.io/categories/interview/"/>
    
    
    <category term="Algorithm" scheme="https://henryinshanghai.github.io/tags/Algorithm/"/>
    
    <category term="Java stuff" scheme="https://henryinshanghai.github.io/tags/Java-stuff/"/>
    
  </entry>
  
  <entry>
    <title>记一次面试（字节跳动）</title>
    <link href="https://henryinshanghai.github.io/interview/2020/08/26/interview/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%9D%A2%E8%AF%95%EF%BC%88%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%EF%BC%89.html"/>
    <id>https://henryinshanghai.github.io/interview/2020/08/26/interview/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%9D%A2%E8%AF%95%EF%BC%88%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%EF%BC%89.html</id>
    <published>2020-08-25T16:00:00.000Z</published>
    <updated>2020-08-26T11:37:00.340Z</updated>
    
    <content type="html"><![CDATA[<h3 id="字节跳动（视频面试一面）"><a href="#字节跳动（视频面试一面）" class="headerlink" title="字节跳动（视频面试一面）"></a>字节跳动（视频面试一面）</h3><hr><h4 id="关于面试官："><a href="#关于面试官：" class="headerlink" title="关于面试官："></a>关于面试官：</h4><p>​    面试官给我的感觉很好，年龄和我相仿，穿着也很随意。就不会让人产生紧张的情绪，而且问的问题也很有递进性。过程是挺轻松的，结果嘛…</p><a id="more"></a><h4 id="关于项目："><a href="#关于项目：" class="headerlink" title="关于项目："></a>关于项目：</h4><p>   这个主要问了做过项目中的一些难点问题。但实话讲，做过的项目有些头疼的问题，但都算不上技术难点。于是我先说了公司项目的特征：面向政府机构居多，所以不会存在什么高并发访问的情况。（这是真实情况，也算是降低面试官的期望，别一上来就问大流量情况下如何削峰、限流什么的）</p><p>   我说了两点：1 excel表格中大数据导入MySQL数据库的问题；2 后台上传多种格式的资料时的处理；富文本编辑器上传时的格式处理等等</p><p>   因为项目总是和业务强相关，面试官可能也不想纠结于细节问题。于是很快就跳到了Java基础的阶段</p><h4 id="关于Java基础："><a href="#关于Java基础：" class="headerlink" title="关于Java基础："></a>关于Java基础：</h4><p>这个据我推测，面试官面前可能有一个巨大的Xmind脑图，根据你简历上所写的内容。随机抽取一个点来问你，基本是要考察你对知识点了解的深度；具体问的问题如下：</p><h5 id="数据库联合索引与最左匹配原则"><a href="#数据库联合索引与最左匹配原则" class="headerlink" title="数据库联合索引与最左匹配原则"></a>数据库联合索引与最左匹配原则</h5><p>索引：为数据表中的指定字段添加的额外的数据结构；</p><p>作用：在查询时，能够通过某个字段的索引来快速定位到满足条件的记录行；</p><p>原理：</p><ul><li>索引一般使用树一类的结构进行存储，因此查询速度很快。</li><li>通过索引中的字段值，就能快速定位到数据表中对应的数据行；</li></ul><p>用法：在SQL查询语句中，使用添加了索引的字段作为查询条件（where xxx=???）。这样就能命中索引，从而实现快速查询；</p><p><strong>联合索引</strong>：使用数据表中的多个字段所创建的索引；</p><p>作用：在编写SQL语句时，就能够通过多个字段来命中索引——这会使得SQL语句的编写更加灵活；</p><p>规则：<strong>最左匹配原则</strong>；（这个我并没有答对）</p><p>示例：</p><ul><li>在创建联合索引时，选择了字段a、b、c；</li><li>在编写查询SQL时，<ul><li>如果查询的字段以a开头（a、a-b、a-b-c），则能够命中联合索引，从而加速查询；</li><li>如果查询的字段不是以a开头（准确的说，是不包含a字段），则无法命中联合索引，查询操作仍旧是遍历的方式；</li></ul></li></ul><p>（讲真，我只用Navicat这个可视化工具创建过索引。所以上面的这些东西都是事后找补的   印象分什么的基本就没了）</p><h5 id="volatile关键字："><a href="#volatile关键字：" class="headerlink" title="volatile关键字："></a>volatile关键字：</h5><p>（这个我两周之前很细致的看过，但是忘得永远比记住得要快）</p><p>是：Java提供的一个关键字；</p><p>作用：修饰一个变量，以保证多线程情况下，变量的可见性与有序性；</p><p>特征：</p><ul><li>volatile就只能修饰变量，不能修饰方法啥的；</li><li>volatile不能保证多线程操作下的原子性（可能线程A执行了一半后，线程B接管CPU时间片）——需要其他手段来保证；</li><li>真正在编码时，这个关键字用得并不多；</li></ul><p>原理：</p><ul><li><p>变量对多个线程的可见性：</p><ul><li><p>JMM（Java 内存模型）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> 每个线程都有自己的工作内存；</span><br><span class="line"><span class="number">2</span> 所有线程共享的变量都在主内存中；</span><br><span class="line"><span class="number">3</span> 线程操作变量时，先从主内存把变量的值拷贝到自己的工作内存中，操作结束后，再把变量的值更新到主内存</span><br><span class="line">中；</span><br></pre></td></tr></table></figure></li><li><p>结合JMM的3条规则，volatile关键字能够保证所有对变量的更新都即时地同步到主内存中；</p></li></ul></li><li><p>变量的有序性：</p><ul><li><p>JVM指令重排</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">为了提高代码执行的效率，CPU或者编译器可能会对程序员编写的代码进行重新排序；</span><br></pre></td></tr></table></figure><ul><li>规则：不管如何重新排序，JVM保证在单线程执行时，得到的结果总是相同的；</li><li>问题来了，多线程时，指令重排就可能导致程序出现非预期的执行结果；</li></ul></li><li><p>结合以上，volatile关键字能够保证变量的赋值过程（非原子操作）不会出现指令重排，aka，指令的有序性。</p></li></ul></li></ul><p>应用：实现双重检查锁的单例模式；</p><h5 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h5><p>是：Java提供的一个关键字；</p><p>作用：为一段代码加锁，从而限制此段代码同一时刻只能被一个线程访问；</p><p>特征：早期它的性能很低，但是JDK8中做了很多优化；</p><p>用法：</p><ul><li>修饰实例方法；<ul><li>作用：线程在执行实例方法之前，必须要获得当前实例的对象锁；</li></ul></li><li>修饰静态方法；（<em>这里面试官着重问了，但是我没能很好的区分实例锁与类锁</em>）<ul><li>作用：线程在执行静态方法之前，必须要获得当前类的对象锁；</li></ul></li><li>修饰代码块；<ul><li>作用：线程在执行代码块之前，必须要获得指定对象的锁；</li><li>特征：这里的对象可以由程序员手动指定；</li></ul></li></ul><p>应用：双重检查校验的单例模式（和volatile配合使用）；</p><p>原理：JVM层面的一些东西，在字节码上添加了一些独特的标识；</p><h5 id="synchronized关键字-与-ReentrantLock类型（这个面试官没问，可能是因为上面答得不好）"><a href="#synchronized关键字-与-ReentrantLock类型（这个面试官没问，可能是因为上面答得不好）" class="headerlink" title="synchronized关键字 与 ReentrantLock类型（这个面试官没问，可能是因为上面答得不好）"></a>synchronized关键字 与 ReentrantLock类型（这个面试官没问，可能是因为上面答得不好）</h5><p>作用：都能够为代码段加锁，从而限制多个线程对代码块的访问；</p><p>相同点：</p><ul><li>两者都是可重入锁（re-entree）;<ul><li>线程可以重复获取到对象的锁——当再次获取对象锁时，计数值+1；</li></ul></li></ul><p>不同点：</p><ul><li>实现层面<ul><li>synchronized关键字的实现是在JVM中，而ReentrantLock的实现在JDK的concurrent包中；</li></ul></li><li>用法层面<ul><li>synchronized是关键字，用法比较单一（无非修饰不同的成份），而ReentrantLock是一个类，用法就非常灵活了；</li></ul></li><li>功能层面<ul><li>ReentrantLock提供了更多的功能：<ul><li>1 使等待中的线程放弃等待（去做别的事情）；</li><li>2 指定锁的类型（是公平锁，还是非公平锁）；公平锁：等待最久的线程会在锁被释放时，优先获取到锁；</li><li>3 实现等待 - 通知机制；</li></ul></li></ul></li></ul><h5 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h5><p>参考：<a href="https://www.jianshu.com/p/f584799f1c77">公平🔒</a></p><p>必须：兔子喝水，黑狗看门；</p><p>结论：</p><ul><li>1、若在释放锁的时候总是没有新的兔子来打扰，则非公平锁等于公平锁；</li><li>2、若释放锁的时候，正好一个兔子来喝水，而此时位于队列头的兔子还没有被唤醒（因为线程上下文切换是需要不少开销的），此时后来的兔子则优先获得锁，成功打破公平，成为非公平锁；</li></ul><h5 id="类加载过程中的双亲委派模型"><a href="#类加载过程中的双亲委派模型" class="headerlink" title="类加载过程中的双亲委派模型"></a>类加载过程中的双亲委派模型</h5><p><strong>类加载过程</strong>：</p><p>是：一个过程；</p><p>作用：把编译器编译生成的class文件，以特定的格式加载到JVM内存中的特定区域；</p><p>特征：分为两类；</p><ul><li>预加载；<ul><li>在虚拟机启动时就会被加载到内存中的class文件；比如lang.*与util.*等；</li></ul></li><li>运行时加载；<ul><li>在运行程序时，虚拟机根据类的全限定名来去查找并加载对应的class文件；</li></ul></li></ul><p>SOP:</p><ul><li>通过类的全限定名获取到<em>类的二进制字节流</em>；</li><li>把<em>字节流所代表的静态存储结构</em>转化为<em>方法区的运行时数据结构</em>；</li><li>在JVM内存中生成<em>表示这个类的Class对象</em>——它包含类的一切信息，是反射机制的基础；</li></ul><p><strong>双亲委派模型</strong>：</p><p>是：一个使用类加载器时，推荐遵守的规则；</p><p>作用：保证核心类型都能够被安全地加载到内存中；防止不法分子写的String类型被JVM错误加载…</p><p>特征：</p><p>​    1 这不是一个强制遵守的规则；</p><p>​    2 每一层加载器都有自己能够加载的类型范围；</p><p>规则描述：</p><ul><li>当类加载器需要把一个类加载到内存中的时候，先尝试把加载的工作交给更高层的类加载器完成；</li><li>然后再转交给更高级的类加载器，so on and so forth,直到到达最高层的类加载器（Bootstrap）；</li><li>只有顶层类加载器无法加载的类型（每一层加载器都有自己所能加载的类型范围），才会交给底层的类加载器去加载；</li></ul><h5 id="Spring-IoC容器"><a href="#Spring-IoC容器" class="headerlink" title="Spring IoC容器"></a>Spring IoC容器</h5><p>是：一个管理对象 以及 对象之间依赖关系的第三方；</p><p><em>如何解决循环依赖的问题呢？</em></p><p><strong>循环依赖</strong>：</p><p>IoC容器中注入了实例a与实例b，实例a依赖于实例b，同时实例b也依赖于实例a；</p><p>issue：IoC容器在创建实例a时，需要先创建实例b。但是创建实例b时，又需要先创建实例a，狗咬尾巴</p><p>参考：<a href="https://segmentfault.com/a/1190000015221968">Spring对循环依赖的解决</a></p><p>解决方案：</p><p>1 尝试创建实例a，发现实例a依赖于实例b；</p><p>2 尝试创建实例b，发现实例b依赖于实例a；</p><p>3 获取到实例a的一个<strong>早期引用</strong>（属性未进行初始化的引用）；</p><p>4 把这个早期引用注入到实例b中，使得实例b完成初始化；</p><p>5 然后实例a再去获取到实例b的引用，得到实例a的<strong>完全引用</strong>；</p><h5 id="AOP（面向切面编程）"><a href="#AOP（面向切面编程）" class="headerlink" title="AOP（面向切面编程）"></a>AOP（面向切面编程）</h5><p>是：一种编程的方式；对标OOP</p><p>作用：能够把应用中一些公共的功能（事务、安全等）抽取出来单独实现，然后以声明的方式编织到需要它们的代码中；</p><p>特征：AOP是一种思想，不同框架对这种思想的实现会各有差异。比如Spring AOP与AspectJ；</p><p>用法：这个步骤比较多，不宜作为面试部分；</p><p>原理：Spring AOP的底层原理是动态代理+反射；</p><ul><li>代理类会封装目标类，并把<em>用于增强的切面类</em>添加到目标类的外围；</li><li>动态代理这种方式绝定了Spring AOP<em>只能对方法做一些增强（因为动态代理使用反射实现目标）</em>，而对字段等无能为力；</li><li>Java中的动态代理：JDK动态代理（要求被代理的类实现接口） 与 CGLib动态代理（不要求…）；</li></ul><h5 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h5><p>注：这是一个多线程安全的类型，我在简历中有写看过它的源码，但其实只看了分析的文章。时隔两周，就只记得“分段锁”这三个字了 😭</p><p>是：一个容器/集合；</p><p>作用：存储键值对；</p><p>特征：多线程安全；</p><p><strong>多线程安全原理</strong>：</p><p>​    JDK1.7的手段：</p><ul><li><p>把容器表示成多个数据段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcurrentHashMap</span></span>&#123;</span><br><span class="line">    <span class="comment">// Segment数组Segment类型本身继承了ReentrantLock，可以当作锁</span></span><br><span class="line">    Segment[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>数据段中存储多个键值对：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Segment</span></span>&#123;</span><br><span class="line">    HashEntry[]; <span class="comment">// HashEntry就是一个封装了键值对的类型；</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li>为每个数据段Segment添加一把锁，这样如果多个线程访问的是不同的数据段，就不会出现并发访问；而如果访问的是同一个数据段，仍旧是获取到锁的执行，没有获取到锁的等待</li></ul><p>​    JDK1.8使用的手段：</p><ul><li>synchronized关键字 + CAS乐观锁【细节需要看源码】</li><li>synchronized关键字只会锁住链表或红黑二叉树的头节点，如果多线程操作没有发生哈希冲突，就不会出现并发访问；如果操作到了同一个哈希位置，仍旧是…;</li></ul><p><strong>底层结构</strong>：</p><p>​    JDK1.7 Segment[] + HashEntry[]；</p><p>​    JDK1.8 Node[] + 链表 + 红黑树；</p><p>用法：</p><p>​    put()方法，前后有8步。</p><p>​    get()方法，就是按图索骥的过程，与多线程关系不大（毕竟它只是一个访问操作）；</p><blockquote><p>in case I don’t see u again, good morning, good afternoon, and good evening!😄</p></blockquote><p>​    </p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;字节跳动（视频面试一面）&quot;&gt;&lt;a href=&quot;#字节跳动（视频面试一面）&quot; class=&quot;headerlink&quot; title=&quot;字节跳动（视频面试一面）&quot;&gt;&lt;/a&gt;字节跳动（视频面试一面）&lt;/h3&gt;&lt;hr&gt;
&lt;h4 id=&quot;关于面试官：&quot;&gt;&lt;a href=&quot;#关于面试官：&quot; class=&quot;headerlink&quot; title=&quot;关于面试官：&quot;&gt;&lt;/a&gt;关于面试官：&lt;/h4&gt;&lt;p&gt;​    面试官给我的感觉很好，年龄和我相仿，穿着也很随意。就不会让人产生紧张的情绪，而且问的问题也很有递进性。过程是挺轻松的，结果嘛…&lt;/p&gt;</summary>
    
    
    
    <category term="interview" scheme="https://henryinshanghai.github.io/categories/interview/"/>
    
    
    <category term="Algorithm" scheme="https://henryinshanghai.github.io/tags/Algorithm/"/>
    
    <category term="Java stuff" scheme="https://henryinshanghai.github.io/tags/Java-stuff/"/>
    
  </entry>
  
  <entry>
    <title>奇偶链表_10</title>
    <link href="https://henryinshanghai.github.io/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8%EF%BC%88%E6%8A%8A%E5%A5%87%E6%95%B0%E4%BD%8D%E7%BD%AE%E4%B8%8E%E5%81%B6%E6%95%B0%E4%BD%8D%E7%BD%AE%E4%B8%8A%E7%9A%84%E8%8A%82%E7%82%B9%E8%BF%9E%E5%9C%A8%E4%B8%80%E8%B5%B7%EF%BC%89_10.html"/>
    <id>https://henryinshanghai.github.io/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8%EF%BC%88%E6%8A%8A%E5%A5%87%E6%95%B0%E4%BD%8D%E7%BD%AE%E4%B8%8E%E5%81%B6%E6%95%B0%E4%BD%8D%E7%BD%AE%E4%B8%8A%E7%9A%84%E8%8A%82%E7%82%B9%E8%BF%9E%E5%9C%A8%E4%B8%80%E8%B5%B7%EF%BC%89_10.html</id>
    <published>2020-08-16T12:46:25.000Z</published>
    <updated>2020-08-17T08:40:31.179Z</updated>
    
    <content type="html"><![CDATA[<h4 id="把链表中的奇数位置节点与偶数位置节点放在一起"><a href="#把链表中的奇数位置节点与偶数位置节点放在一起" class="headerlink" title="把链表中的奇数位置节点与偶数位置节点放在一起"></a>把链表中的奇数位置节点与偶数位置节点放在一起</h4><h4 id="题设-与-要求"><a href="#题设-与-要求" class="headerlink" title="题设 与 要求"></a>题设 与 要求</h4><p><img src="https://s1.ax1x.com/2020/08/15/dklpjK.md.png" alt="题设与要求"></p><a id="more"></a><h4 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h4><p><img src="https://s1.ax1x.com/2020/08/15/dkldDU.md.png" alt="测试用例"></p><h4 id="附加说明"><a href="#附加说明" class="headerlink" title="附加说明"></a>附加说明</h4><p><img src="https://s1.ax1x.com/2020/08/15/dklLKf.md.png" alt="提示信息"></p><h4 id="分析（问题的难点）"><a href="#分析（问题的难点）" class="headerlink" title="分析（问题的难点）"></a>分析（问题的难点）</h4><ul><li>如何把奇数/偶数位置的节点都连接起来？</li><li>如何把奇数位置节点的集合 与 偶数位置节点的集合连接起来？</li></ul><h4 id="思路（难点的解决方案）"><a href="#思路（难点的解决方案）" class="headerlink" title="思路（难点的解决方案）"></a>思路（难点的解决方案）</h4><ul><li>如何把奇数位置/偶数位置的节点都连接起来？<ul><li>答：使用两个指针odd、even，初始化指向第一个节点与第二个节点。然后去创建奇数位置节点链表与偶数位置节点链表；</li></ul></li><li>如何把奇数位置节点集合与偶数位置节点集合连接起来？<ul><li>答：只要把odd链表的尾节点连接到even链表的头节点就可以了</li></ul></li></ul><h4 id="根据思路进行编码（细节处理）"><a href="#根据思路进行编码（细节处理）" class="headerlink" title="根据思路进行编码（细节处理）"></a>根据思路进行编码（细节处理）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">oddEvenList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 鲁棒性代码</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1 定义需要的实例变量</span></span><br><span class="line">        ListNode odd = head; <span class="comment">// 奇数位置节点的指针作用：连接奇数位置的节点</span></span><br><span class="line">        ListNode even = head.next; <span class="comment">// 偶数位置节点的指针作用：连接偶数位置的节点</span></span><br><span class="line">        ListNode evenHead = even; <span class="comment">// 作用：记录偶数节点链表的头节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 遍历当前链表在循环中：1 创建奇数位置节点链表； 2 创建偶数位置节点链表</span></span><br><span class="line">        <span class="keyword">while</span>(even != <span class="keyword">null</span> &amp;&amp; even.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 创建链表SOP： 1 建立连接； 2 更新指针；</span></span><br><span class="line">            odd.next = even.next;</span><br><span class="line">            odd = odd.next;</span><br><span class="line"></span><br><span class="line">            even.next = odd.next;</span><br><span class="line">            even = even.next; <span class="comment">// even会率先达到链表的尾部</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 把偶数链表连接到奇数链表的尾节点上</span></span><br><span class="line">        odd.next = evenHead;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 返回新链表的头节点（作图可知）</span></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代码分解SOP"><a href="#代码分解SOP" class="headerlink" title="代码分解SOP"></a>代码分解SOP</h4><ul><li>定义需要的实例变量</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ListNode odd = head; <span class="comment">// 用于指向奇数位置的节点</span></span><br><span class="line">ListNode even = head.next; <span class="comment">// 用于指向偶数位置的节点</span></span><br></pre></td></tr></table></figure><ul><li>遍历当前链表中的所有节点    在循环中：1 创建奇数节点的链表； 2 创建偶数节点的链表</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(ture)&#123; <span class="comment">// 参考：画图</span></span><br><span class="line">    <span class="comment">// 创建连接</span></span><br><span class="line">    odd.next = even.next;</span><br><span class="line">    <span class="comment">// 更新指针</span></span><br><span class="line">    odd = odd.next;</span><br><span class="line">    </span><br><span class="line">    even.next = odd.next;</span><br><span class="line">    even = even.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2020/08/15/dkteIO.md.jpg" alt="遇事不决画个图"></p><ul><li>确定循环执行表达式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据链表中的节点数的不同，循环终结会有两种情况</span></span><br><span class="line"><span class="comment">// 1 链表中的节点数目为偶数个even.next == null</span></span><br><span class="line"><span class="comment">// 2 链表中的节点数目为奇数个even == null</span></span><br><span class="line"><span class="comment">// 当这两种情况之一发生时，就要终止循环 所以</span></span><br><span class="line"><span class="keyword">while</span>(even == <span class="keyword">null</span> &amp;&amp; even.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>把偶数链表连接到奇数链表上</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">odd.next = evenHead; <span class="comment">// 连接到记录的最初的偶数链表的头节点</span></span><br></pre></td></tr></table></figure><blockquote><p>Bingo! good morning,good afternoon,and good night 🌙</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;把链表中的奇数位置节点与偶数位置节点放在一起&quot;&gt;&lt;a href=&quot;#把链表中的奇数位置节点与偶数位置节点放在一起&quot; class=&quot;headerlink&quot; title=&quot;把链表中的奇数位置节点与偶数位置节点放在一起&quot;&gt;&lt;/a&gt;把链表中的奇数位置节点与偶数位置节点放在一起&lt;/h4&gt;&lt;h4 id=&quot;题设-与-要求&quot;&gt;&lt;a href=&quot;#题设-与-要求&quot; class=&quot;headerlink&quot; title=&quot;题设 与 要求&quot;&gt;&lt;/a&gt;题设 与 要求&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/08/15/dklpjK.md.png&quot; alt=&quot;题设与要求&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="ListNode" scheme="https://henryinshanghai.github.io/categories/ListNode/"/>
    
    
    <category term="Algorithm" scheme="https://henryinshanghai.github.io/tags/Algorithm/"/>
    
    <category term="LinkedList" scheme="https://henryinshanghai.github.io/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>分隔链表得到子链表_09</title>
    <link href="https://henryinshanghai.github.io/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E6%8A%8A%E9%93%BE%E8%A1%A8%E5%88%86%E9%9A%94%E6%88%90k%E4%B8%AA%E5%AD%90%E9%93%BE%E8%A1%A8_09.html"/>
    <id>https://henryinshanghai.github.io/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E6%8A%8A%E9%93%BE%E8%A1%A8%E5%88%86%E9%9A%94%E6%88%90k%E4%B8%AA%E5%AD%90%E9%93%BE%E8%A1%A8_09.html</id>
    <published>2020-08-16T11:00:00.000Z</published>
    <updated>2020-08-17T04:30:44.384Z</updated>
    
    <content type="html"><![CDATA[<h4 id="把链表分隔成k个子链表"><a href="#把链表分隔成k个子链表" class="headerlink" title="把链表分隔成k个子链表"></a>把链表分隔成k个子链表</h4><hr><h4 id="题设与要求"><a href="#题设与要求" class="headerlink" title="题设与要求"></a>题设与要求</h4><p><img src="https://s1.ax1x.com/2020/08/15/dFWppn.md.png" alt="题设与要求"></p><a id="more"></a><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p><img src="https://s1.ax1x.com/2020/08/15/dFICeP.md.png" alt="测试用例"></p><h4 id="提示信息"><a href="#提示信息" class="headerlink" title="提示信息"></a>提示信息</h4><p><img src="https://s1.ax1x.com/2020/08/15/dFoZtO.png" alt="提示信息"></p><h4 id="分析（题目中的难点）"><a href="#分析（题目中的难点）" class="headerlink" title="分析（题目中的难点）"></a>分析（题目中的难点）</h4><ul><li>根据题设，就是要把链表中的节点均分为k份；<ul><li>要如何处理(length % k)余下的这些个节点？</li></ul></li><li>k个连续的部分，每个部分相差不超过1；<ul><li>说明每个子链表中的节点数会有不一样。可以顺序的让靠前的子链表中多出一个节点，来消耗余下的节点</li><li>如何确定到哪一个子链表时，余下的节点已经被消耗完了呢？</li></ul></li><li>如果k &gt; length，缺少的部分补充null作为元素；</li></ul><h4 id="思路（对难点的解决方案）"><a href="#思路（对难点的解决方案）" class="headerlink" title="思路（对难点的解决方案）"></a>思路（对难点的解决方案）</h4><ul><li>定义一个大小为k数组，数组中的第i个元素表示：第i个子链表中应该包含的节点数目；</li><li>定义一个循环，每次循环都为数组中的一个元素绑定值<ul><li>先求出余数；</li><li>每次绑定值时，判断余数是否还大于0.如果是，就把要绑定的值+1； 同时余数-1</li><li>每个子节点要绑定的基础数值为：(length / k)</li></ul></li><li>定义一个子链表列表，用于存储分割后的子链表；</li><li>定义一个循环，每次循环<ul><li>从数组中取出当前子链表应该包含的节点数；</li><li>根据上面的节点数目来创建一个子链表，并把子链表绑定到子链表列表的一个元素上；</li><li>循环往复，直到链表中的所有节点都被安排了</li></ul></li></ul><h4 id="把思路翻译成代码（🙏）"><a href="#把思路翻译成代码（🙏）" class="headerlink" title="把思路翻译成代码（🙏）"></a>把思路翻译成代码（🙏）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode[] splitListToParts(ListNode root, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="comment">// 定义一个指针 作用：作为游标，计算链表的节点长度</span></span><br><span class="line">        ListNode cursor = root;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义一个链表列表 作用：存储分割后的多个子链表；</span></span><br><span class="line">        ListNode[] res = <span class="keyword">new</span> ListNode[k]; <span class="comment">// 默认每个元素绑定的都是一个null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 鲁棒性代码</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算链表长度</span></span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cursor != <span class="keyword">null</span>)&#123;</span><br><span class="line">            length++;</span><br><span class="line">            cursor = cursor.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 比较链表长度length 与 预期分割得到的子链表数目k</span></span><br><span class="line">        <span class="keyword">if</span>(k &gt;= length)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;length; i++)&#123; <span class="comment">// 使用root链表中的节点对res数组的元素进行重新初始化</span></span><br><span class="line">                res[i] = <span class="keyword">new</span> ListNode(root.val);</span><br><span class="line">                root = root.next;</span><br><span class="line">            &#125; <span class="comment">// 只初始化了length个元素。剩下的元素仍旧是null</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 计算出第N个子链表应该包含多少个节点</span></span><br><span class="line">            <span class="keyword">int</span> remainder = length % k;</span><br><span class="line">            <span class="keyword">int</span> part = length / k;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">                counts[i] = remainder &gt; <span class="number">0</span> ? part + <span class="number">1</span> : part;</span><br><span class="line">                remainder--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从原始链表中截取出k个子链表，并添加到链表数组中</span></span><br><span class="line">            ListNode p = root;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;k; i++)&#123;</span><br><span class="line"></span><br><span class="line">                res[i] = p;</span><br><span class="line">                <span class="comment">// 当前子链接中应该包含多少个节点</span></span><br><span class="line">                <span class="keyword">int</span> count = counts[i];</span><br><span class="line">                <span class="keyword">while</span>(--count &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    p = p.next;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 记录下一个节点</span></span><br><span class="line">                ListNode temp = p.next;</span><br><span class="line">                <span class="comment">// 为当前节点绑定null</span></span><br><span class="line">                p.next = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 更新当前节点</span></span><br><span class="line">                p = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回得到的子链表列表</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代码分解步骤"><a href="#代码分解步骤" class="headerlink" title="代码分解步骤"></a>代码分解步骤</h4><ul><li>定义需要的实例变量</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ListNode cursor = head; <span class="comment">// 用于在链表的节点上遍历</span></span><br><span class="line">ListNode[] res = <span class="keyword">new</span> ListNode[k]; <span class="comment">// 一个大小为k的ListNode类型的数组用于存储分割后的子链表</span></span><br></pre></td></tr></table></figure><ul><li>求出链表的长度</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(cursor != <span class="keyword">null</span>)&#123;</span><br><span class="line">length++;</span><br><span class="line">    cursor = cursor.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>比较链表长度length与预期分隔得到的子链表数目k</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(k &gt; length)&#123;</span><br><span class="line"><span class="comment">// 子链表数目比链表本身的节点还要多手段：不足的部分补上null</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 子链表数目小于等于链表本身的节点数目手段：平均分配，盈余的话可能要多分一个</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当子链表数目k比起链表本身的节点length还要多时</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化res数组中前面length个元素</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;length; i++)&#123;</span><br><span class="line">    <span class="comment">// 创建一个新的链表，并绑定到子链表中为什么要新建链表？</span></span><br><span class="line">    res[i] = <span class="keyword">new</span> ListNode(root.val);</span><br><span class="line">    root = root.next;</span><br><span class="line">&#125; <span class="comment">// 没有绑定子链表的节点，值默认是null 符合题目要求</span></span><br></pre></td></tr></table></figure><ul><li>当子链表数目小于等于链表本身的节点length时<ul><li>Ⅰ 计算出每个子链表应该包含的节点数量，并存储到一个数组中；</li><li>Ⅱ 遍历原始链表：<ul><li>从中取出正确数量的节点添加到子链表中；</li><li>当前子链接添加完成后，截断子链表。并把指针移动到下一个子链表的起始处</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Ⅰ计算出每个子链表应该包含的节点数量，并存储到一个数组中；</span></span><br><span class="line"><span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> perPart = length / k; <span class="comment">// 每个子链表的基础节点数目</span></span><br><span class="line"><span class="keyword">int</span> remainder = (length % k); <span class="comment">// 均分k份之后，余下的节点数量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;k; i++)&#123;</span><br><span class="line">    <span class="comment">// 使用三目运算符来替代一个if/else逻辑</span></span><br><span class="line">    counts[i] = (remainder &gt; <span class="number">0</span>) : perPart + <span class="number">1</span> : perPart;</span><br><span class="line">    remainder--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Ⅱ 遍历原始链表,把原始列表分割成k个子链表</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; k; i++)&#123;</span><br><span class="line"><span class="comment">/* ① 从原始链表中取出正确数量的节点添加到子链表中 */</span></span><br><span class="line">    <span class="comment">// 创建一个新的指针指向头节点</span></span><br><span class="line">    ListNode p = root; </span><br><span class="line">    <span class="comment">// 把当前子链表的头节点绑定到res[]的元素上</span></span><br><span class="line">    res[i] = p;</span><br><span class="line">    <span class="comment">// 获取到当前子链接中应该包含的节点数</span></span><br><span class="line">    <span class="keyword">int</span> count = counts[i];</span><br><span class="line">    <span class="comment">// 获取到指定数量的节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;count; j++)&#123; <span class="comment">// 应该向后遍历(count - 1)次</span></span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 当前子链接添加完成后，截断子链表。并把指针移动到下一个子链表的起始处 */</span></span><br><span class="line">    <span class="comment">// 记录下一个节点</span></span><br><span class="line">    ListNode temp = p.next; </span><br><span class="line">    <span class="comment">// 截断当前链表</span></span><br><span class="line">    p.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 更新当前节点</span></span><br><span class="line">    p = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>返回添加了子链表元素的res数组</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure><h4 id="启示"><a href="#启示" class="headerlink" title="启示"></a>启示</h4><p>对于循环次数已知的情况，推荐使用for循环。因为它的表达式非常容易写</p><p>while循环语法适用于那些循环次数不确定的场合</p><blockquote><p>until next time 😄</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;把链表分隔成k个子链表&quot;&gt;&lt;a href=&quot;#把链表分隔成k个子链表&quot; class=&quot;headerlink&quot; title=&quot;把链表分隔成k个子链表&quot;&gt;&lt;/a&gt;把链表分隔成k个子链表&lt;/h4&gt;&lt;hr&gt;
&lt;h4 id=&quot;题设与要求&quot;&gt;&lt;a href=&quot;#题设与要求&quot; class=&quot;headerlink&quot; title=&quot;题设与要求&quot;&gt;&lt;/a&gt;题设与要求&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/08/15/dFWppn.md.png&quot; alt=&quot;题设与要求&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="ListNode" scheme="https://henryinshanghai.github.io/categories/ListNode/"/>
    
    
    <category term="Algorithm" scheme="https://henryinshanghai.github.io/tags/Algorithm/"/>
    
    <category term="LinkedList" scheme="https://henryinshanghai.github.io/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>回文链表(迭代)_08_2</title>
    <link href="https://henryinshanghai.github.io/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E9%93%BE%E8%A1%A8%E6%98%AF%E4%B8%8D%E6%98%AF%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8%EF%BC%88%E8%BF%AD%E4%BB%A3%E6%96%B9%E5%BC%8F%EF%BC%89_08_2.html"/>
    <id>https://henryinshanghai.github.io/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E9%93%BE%E8%A1%A8%E6%98%AF%E4%B8%8D%E6%98%AF%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8%EF%BC%88%E8%BF%AD%E4%BB%A3%E6%96%B9%E5%BC%8F%EF%BC%89_08_2.html</id>
    <published>2020-08-16T10:30:00.000Z</published>
    <updated>2020-08-17T04:28:26.255Z</updated>
    
    <content type="html"><![CDATA[<h3 id="判断一个链表是不是回文链表（迭代方式）"><a href="#判断一个链表是不是回文链表（迭代方式）" class="headerlink" title="判断一个链表是不是回文链表（迭代方式）"></a>判断一个链表是不是回文链表（迭代方式）</h3><h4 id="题设与要求"><a href="#题设与要求" class="headerlink" title="题设与要求"></a>题设与要求</h4><p><img src="https://s1.ax1x.com/2020/08/15/diX5I1.png" alt="题设与要求"></p><a id="more"></a><h4 id="分析（问题的难点）"><a href="#分析（问题的难点）" class="headerlink" title="分析（问题的难点）"></a>分析（问题的难点）</h4><ul><li><p>这里不再考虑使用递归的方式，因为上一篇中已经实现了递归的代码；</p></li><li><p>为了判断链表是不是回文链表，肯定要对其左半边与右半边的节点进行比较；</p><p><strong>难点1</strong>：如何确定链表的左半边与右半边？aka 链表的中间节点位置</p></li><li><p>假设现在已经找到了中间节点的位置，接下来要怎么逐个比较各个节点呢？</p><p>方式1 从两边到中间，逐个比较节点的值；</p><p>方式2 从中间到两边，逐个比较节点的值；</p><p>说明：不管哪一种方式，都会面临一个问题——指针无法逆着链表节点移动；</p><p><strong>难点2</strong>：如何能让指针逆着链表的方向移动？</p></li><li><p>如果上面两个难点都得到解决，接下来就只需要逐个比较节点的值，分分钟无障碍</p></li></ul><h4 id="思路（难点的解决手段）"><a href="#思路（难点的解决手段）" class="headerlink" title="思路（难点的解决手段）"></a>思路（难点的解决手段）</h4><ul><li><p>难点1 如何确定链表的中间节点位置？</p><p>手段：快慢指针。</p><p>具体方法：从head节点开始（具体需要画图确认最佳方案），快指针一次走两个节点，慢指针一次走一个节点。</p><p>原理：当快指针指向链表尾节点时，慢指针应该刚好指向链表的中间节点。（或者前面一个节点）</p></li><li><p>难点2 如何能让指针逆着链表方向移动？</p><p>说明：实现这个目标其实有多个手段，比如借助额外空间整一个新链表。但是题目要求O(1)的空间复杂度，so pass this</p><p>手段：对链表的左半部分/右半部分进行翻转；</p><p>具体方法：翻转链表所需要的3个指针——prev、curr、temp；</p><p>原理：如果翻转左半部分，从中间节点到两边的节点进行比较；如果翻转右半部分，则是从两边的节点向中间节点进行比较；</p><p>这里我们选择翻转左半部分</p></li></ul><h4 id="把思路翻译成代码"><a href="#把思路翻译成代码" class="headerlink" title="把思路翻译成代码"></a>把思路翻译成代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1 作用：判断一个链表是不是回文链表，并返回布尔值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 迭代方式</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 防止NPE的指针</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用于翻转链表的指针</span></span><br><span class="line">        ListNode prev = dummy;</span><br><span class="line">        ListNode curr = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用于定位到中点的指针</span></span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一边定位，一边创建新的链表   翻转三部曲：1 记录当前节点的下一个节点； 2 改变当前节点的连接   3 更新指针prev与curr</span></span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123; <span class="comment">// slow与curr的位置关系还需要考察</span></span><br><span class="line">            <span class="comment">// 注： 当前节点的下一个节点总是slow,所以第1步省略</span></span><br><span class="line">            curr = slow; <span class="comment">// 3-2 更新指针curr</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新快慢指针</span></span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 翻转链表</span></span><br><span class="line">            curr.next = prev; <span class="comment">// 2 改变连接</span></span><br><span class="line">            prev = curr; <span class="comment">// 3-1 更新指针prev</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据fast的特征判断slow的位置</span></span><br><span class="line">        <span class="keyword">if</span>(fast != <span class="keyword">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过逐个比较两个链表的节点来判断是否为回文链表</span></span><br><span class="line">        <span class="keyword">while</span>(slow != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(curr.val != slow.val)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            curr = curr.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代码步骤分解"><a href="#代码步骤分解" class="headerlink" title="代码步骤分解"></a>代码步骤分解</h4><ul><li>定义需要的实例变量（包括指针变量）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方便定位链表头节点的指针</span></span><br><span class="line">      ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">      dummy.next = head;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 用于翻转链表的指针</span></span><br><span class="line">      ListNode prev = dummy;</span><br><span class="line">      ListNode curr = head;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 用于定位到中点的指针</span></span><br><span class="line">      ListNode slow = head;</span><br><span class="line">      ListNode fast = head;</span><br></pre></td></tr></table></figure><ul><li>循环中需要做的事情：Ⅰ 定位链表的中间节点；    </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123; <span class="comment">// 2 直到快指针指向链表的尾节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 手段SOP：1 不断更新快慢指针</span></span><br><span class="line">    slow = slow.next;</span><br><span class="line">    fast = fast.next.next;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Ⅱ 对左半部分链表进行翻转；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    翻转三步曲</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    // 1 记录当前节点的下一个节点；</span></span><br><span class="line"><span class="comment">    ListNode temp = curr.next;</span></span><br><span class="line"><span class="comment">    // 2 改变当前节点的连接</span></span><br><span class="line"><span class="comment">    curr.next = prev;</span></span><br><span class="line"><span class="comment">    // 3 更新指针prev与curr把prev更新到curr，把curr更新到temp</span></span><br><span class="line"><span class="comment">    prev = curr;</span></span><br><span class="line"><span class="comment">    curr = temp;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 问题来了：1 当前节点的下一个节点是什么呢？</span></span><br><span class="line">    <span class="comment">// 问题2：左半边的链表应该结束于哪一个节点呢？</span></span><br><span class="line">    <span class="comment">// 解决手段：为了准确定位左半部分链表的边界，把“当前节点的下一个节点”设置为slow指向的节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 知道了“当前节点的下一个节点为slow”后，套用上面的翻转三步曲 */</span></span><br><span class="line">    <span class="comment">// 1 记录当前节点的下一个节点 手段：直接获取slow就可以了</span></span><br><span class="line">    <span class="comment">// 2 更新当前节点的连接为前一个节点</span></span><br><span class="line">    curr.next = prev; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3 更新指针</span></span><br><span class="line">    prev = curr; </span><br><span class="line">    curr = slow; <span class="comment">// 更新当前指针</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2020/08/15/dFei4K.md.jpg" alt="翻转图示"></p><ul><li>确保curr总是落后于slow一个节点</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 手段：把更新curr的语句放在更新快慢指针的语句之前</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    curr = slow; <span class="comment">// 更新当前节点为temp</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更新快慢指针</span></span><br><span class="line">    slow = slow.next;</span><br><span class="line">    fast = fast.next.next;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 翻转链表中的节点</span></span><br><span class="line">    curr.next = prev;</span><br><span class="line">    prev = curr;</span><br><span class="line">    <span class="comment">// 更新curr指针的代码在第一行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>确定循环执行表达式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参考图示可知，fast应该停留在尾节点 或者 null节点上</span></span><br><span class="line"><span class="comment">// 原则：刚好形成可以一一对比其节点的左半部分链表（已翻转）</span></span><br><span class="line"><span class="keyword">while</span>(fast != <span class="keyword">null</span> || fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>根据情况来移动slow指针——因为这时候左右链表的节点数可能不一样</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参考图示可知：当链表节点数为奇数个时，slow指在最中间节点的位置。这时候右半部分链表的节点多了一个</span></span><br><span class="line"><span class="keyword">if</span>(fast != <span class="keyword">null</span>)&#123; <span class="comment">// fast!=null是这种情况下的特征</span></span><br><span class="line">    slow = slow.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>逐个比较左右两个链表的节点，来判断总链表是不是回文链表</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(curr.val != slow.val)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    curr = curr.next;</span><br><span class="line">    slow = slow.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>确定循环执行表达式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由于左右两个链表的节点长度是一样的，所以只要任一一个链表到头，循环就结束</span></span><br><span class="line"><span class="keyword">while</span>(slow != <span class="keyword">null</span>)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>鲁棒性代码</li><li>测试用例</li></ul><h4 id="代码重现（拆解之后的组合）"><a href="#代码重现（拆解之后的组合）" class="headerlink" title="代码重现（拆解之后的组合）"></a>代码重现（拆解之后的组合）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 定义需要的指针</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 翻转所需要用到的指针</span></span><br><span class="line">        ListNode prev = dummy;</span><br><span class="line">        ListNode curr = head;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 寻找中间节点所需要用到的指针</span></span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123; <span class="comment">// 只要有一个为false，循环就会结束</span></span><br><span class="line">            <span class="comment">// 翻转节点 - 2 </span></span><br><span class="line">            curr = slow;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 更新快慢指针</span></span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 翻转节点 - 1</span></span><br><span class="line">            curr.next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果需要，更新slow指针的位置</span></span><br><span class="line">        <span class="keyword">if</span>(fast != <span class="keyword">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历左右链表的每个节点，逐一比较</span></span><br><span class="line">        <span class="keyword">while</span>(slow != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(curr.val != slow.val)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            curr = curr.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>this is loads of code. until next time 😓</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;判断一个链表是不是回文链表（迭代方式）&quot;&gt;&lt;a href=&quot;#判断一个链表是不是回文链表（迭代方式）&quot; class=&quot;headerlink&quot; title=&quot;判断一个链表是不是回文链表（迭代方式）&quot;&gt;&lt;/a&gt;判断一个链表是不是回文链表（迭代方式）&lt;/h3&gt;&lt;h4 id=&quot;题设与要求&quot;&gt;&lt;a href=&quot;#题设与要求&quot; class=&quot;headerlink&quot; title=&quot;题设与要求&quot;&gt;&lt;/a&gt;题设与要求&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/08/15/diX5I1.png&quot; alt=&quot;题设与要求&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="ListNode" scheme="https://henryinshanghai.github.io/categories/ListNode/"/>
    
    
    <category term="Algorithm" scheme="https://henryinshanghai.github.io/tags/Algorithm/"/>
    
    <category term="LinkedList" scheme="https://henryinshanghai.github.io/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>回文链表_08</title>
    <link href="https://henryinshanghai.github.io/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E4%B8%BA%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8(%E9%80%92%E5%BD%92%E6%96%B9%E5%BC%8F)_08.html"/>
    <id>https://henryinshanghai.github.io/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E4%B8%BA%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8(%E9%80%92%E5%BD%92%E6%96%B9%E5%BC%8F)_08.html</id>
    <published>2020-08-16T10:00:00.000Z</published>
    <updated>2020-08-16T10:28:28.340Z</updated>
    
    <content type="html"><![CDATA[<h3 id="判断一个链表是否为回文链表"><a href="#判断一个链表是否为回文链表" class="headerlink" title="判断一个链表是否为回文链表"></a>判断一个链表是否为回文链表</h3><h4 id="题设与要求"><a href="#题设与要求" class="headerlink" title="题设与要求"></a>题设与要求</h4><p><img src="https://s1.ax1x.com/2020/08/15/diX5I1.png" alt="题设与要求"></p><a id="more"></a><h4 id="分析（问题的难点）"><a href="#分析（问题的难点）" class="headerlink" title="分析（问题的难点）"></a>分析（问题的难点）</h4><p>1 回文链表的定义:左半边与右半边完全对称——这样从左边读起与从右边读起来，读到的内容是相同的。</p><p>2 如果使用迭代的方式，比较直观的想法是：头尾节点各一个指针，然后指针向里走。指针每走一次，就要比较一次节点的值。</p><ul><li>难点：但是由于是单向链表，尾节点的指针没有办法直接向前走。所以在此之前需要把右半边的链表翻转，然后再进行迭代与比较操作。可以预见，需要确定诸多的细节：右半边链表的终点、循环终止条件等</li></ul><p>3 能不能使用递归的方式呢？</p><ul><li>把问题转换为更小规模的问题：head头节点 + 中间节点组成的链表 + tail尾节点；<ul><li>中间节点组成的链表是不是回文链表，这就是一个更小规模的问题；</li></ul></li><li>更小规模问题的处理结果，能用来解决问题本身吗？<ul><li>如果中间节点组成的链表middle是一个回文链表，就只需要判断head.val == tail.val。如果相等，则整个链表就是一个回文链表</li></ul></li></ul><h4 id="思路（优先使用递归）"><a href="#思路（优先使用递归）" class="headerlink" title="思路（优先使用递归）"></a>思路（优先使用递归）</h4><p>1 把方法定义为一个递归方法，确定方法的作用与返回值；</p><ul><li>方法作用：判断一个链表是否为回文链表；    返回值：true/false；</li></ul><p>2 确定递归的终止条件；</p><ul><li>链表为null/链表中只有一个节点；    这时候可以认为链表是一个回文链表</li></ul><p>3 确定本级递归要完成的事情；</p><ul><li>编码时再具体说明</li></ul><h4 id="把思路翻译成代码"><a href="#把思路翻译成代码" class="headerlink" title="把思路翻译成代码"></a>把思路翻译成代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ListNode类型的定义省略</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1 方法作用：判断一个链表是否为回文链表；返回值：true/false；</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 2 递归终结条件</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3 本级递归要做的事情</span></span><br><span class="line">        <span class="comment">// ① 把链表视为：链表头节点head + 中间节点组成的链表middle + 尾节点tail</span></span><br><span class="line">        <span class="comment">// ② 获取到head与tail，判断头节点与尾节点的值是否相等。如果不相等，返回false</span></span><br><span class="line">        <span class="comment">// ③ 如果相等，并且middle也是一个回文链表。则返回true，否则返回false</span></span><br><span class="line">        ListNode cursor = head;</span><br><span class="line">        <span class="keyword">while</span>(cursor.next != <span class="keyword">null</span>)&#123; <span class="comment">// 循环终止时，希望cursor指向尾节点，而不是null</span></span><br><span class="line">            cursor = cursor.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断头节点与尾节点的值是否相等</span></span><br><span class="line">        <span class="keyword">if</span>(head.val != cursor.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 获取到中间节点组成的链表middle</span></span><br><span class="line">            cursor = head.next;</span><br><span class="line">            ListNode middle = cursor;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 删除尾节点：这样其实破坏了原始的链表结构，需要和面试官确认</span></span><br><span class="line">            <span class="keyword">while</span>(cursor != <span class="keyword">null</span> &amp;&amp; cursor.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(cursor.next.next = <span class="keyword">null</span>)&#123;</span><br><span class="line">                    cursor.next = <span class="keyword">null</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cursor = cursor.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 判断middle是不是一个回文链表</span></span><br><span class="line">            <span class="keyword">return</span> isPalindrome(middle);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：这里获取到middle的过程还是差了点意思。</p><h4 id="添加鲁棒性的代码"><a href="#添加鲁棒性的代码" class="headerlink" title="添加鲁棒性的代码"></a>添加鲁棒性的代码</h4><h4 id="使用不同的测试用例测试"><a href="#使用不同的测试用例测试" class="headerlink" title="使用不同的测试用例测试"></a>使用不同的测试用例测试</h4><ul><li>功能性测试（各种极端情况下的有效输入）</li><li>非法输入测试（对各种非法输入是否进行了合适的处理）</li></ul><blockquote><p>until next time😄</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;判断一个链表是否为回文链表&quot;&gt;&lt;a href=&quot;#判断一个链表是否为回文链表&quot; class=&quot;headerlink&quot; title=&quot;判断一个链表是否为回文链表&quot;&gt;&lt;/a&gt;判断一个链表是否为回文链表&lt;/h3&gt;&lt;h4 id=&quot;题设与要求&quot;&gt;&lt;a href=&quot;#题设与要求&quot; class=&quot;headerlink&quot; title=&quot;题设与要求&quot;&gt;&lt;/a&gt;题设与要求&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/08/15/diX5I1.png&quot; alt=&quot;题设与要求&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="ListNode" scheme="https://henryinshanghai.github.io/categories/ListNode/"/>
    
    
    <category term="Algorithm" scheme="https://henryinshanghai.github.io/tags/Algorithm/"/>
    
    <category term="LinkedList" scheme="https://henryinshanghai.github.io/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>链表数相加_07</title>
    <link href="https://henryinshanghai.github.io/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E9%93%BE%E8%A1%A8%E8%A1%A8%E7%A4%BA%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%9B%B8%E5%8A%A0(%E8%BF%AD%E4%BB%A3%E6%96%B9%E5%BC%8F)_07.html"/>
    <id>https://henryinshanghai.github.io/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E9%93%BE%E8%A1%A8%E8%A1%A8%E7%A4%BA%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%9B%B8%E5%8A%A0(%E8%BF%AD%E4%BB%A3%E6%96%B9%E5%BC%8F)_07.html</id>
    <published>2020-08-16T09:30:00.000Z</published>
    <updated>2020-08-17T04:30:00.319Z</updated>
    
    <content type="html"><![CDATA[<h3 id="链表表示的两个数相加"><a href="#链表表示的两个数相加" class="headerlink" title="链表表示的两个数相加"></a>链表表示的两个数相加</h3><h4 id="题设与要求"><a href="#题设与要求" class="headerlink" title="题设与要求"></a>题设与要求</h4><p><img src="https://s1.ax1x.com/2020/08/14/diKVtx.md.png" alt="题目条件与要求"></p><a id="more"></a><h4 id="分析（面临的核心问题）"><a href="#分析（面临的核心问题）" class="headerlink" title="分析（面临的核心问题）"></a>分析（面临的核心问题）</h4><p>两个数的加法算法，主要的特征：</p><ul><li>从低位到高位计算（个十百千…）;</li><li>计算除了个位以外的位数上的数字时，都需要加上来自后一位的进位（如果没有进位数，默认为0）</li><li>位数上的数字 = （第一个数 + 第二个数 + 进位数）% 10；</li><li>当前位向高位数提供的进位数 = (第一个数 + 第二个数 + 进位数) / 10；</li><li>如果最高位计算时，有进位数。则直接把这个进位数作为加和结果的最高位；</li></ul><p>问题1：我们需要从低位向高位计算，对于链表来说，就是从链表尾节点到头节点计算。BUT，访问链表中的节点只能从头节点到尾节点。</p><p>怎么办？</p><p>解决手段：使用栈来存储链表各个节点中的值；</p><p>原理：链表这种数据容器的存储特征是“先进后出”——这样在从栈中取出数值时，获取到的其实就是链表尾部节点中的数值；</p><p>问题2：两个链表的长度可能不一样，如果在同一个循环中通过pop()来取值的话，肯定会有一个栈调用pop()时会抛出”栈为空”的异常；</p><p>解决手段：在调用isEmpty()结果为true时（表示栈已经空了），手动为操作数绑定0；</p><p>问题3：如果使用循环，在短链表中的节点用完后，如何保证循环继续进行（继续计算加和）？</p><p>手段：循环条件 = （链表A节点 != null || 链表B节点 != null);</p><p>问题4：即便使用长链表的节点数来控制循环次数（循环中执行操作数的计算），但是最高位在得到进位后，可能会再产生一个进位。这个进位要怎么处理？</p><p>手段：把进位carry !=0 添加到循环执行表达式中。这样上述情况下，循环会再执行一次(0 + 0 + 进位1) 的计算。计算后carry==0，循环退出，进位数也被作为最高位添加到链表中</p><h4 id="思路SOP"><a href="#思路SOP" class="headerlink" title="思路SOP"></a>思路SOP</h4><p>1 使用两个栈分别存储两个链表中的所有节点；</p><p>2 定义一个循环：</p><ul><li>从栈中弹出值进行计算。得到数位上的数与进位数；</li><li>把位数上的数封装到一个节点，并添加到链表中(使用头插法，即最新的节点总是头节点)； head - xxx - null</li></ul><p>3 循环结束后，循环中创建的链表就是加和结果；</p><h4 id="根据思路SOP来进行编码"><a href="#根据思路SOP来进行编码" class="headerlink" title="根据思路SOP来进行编码"></a>根据思路SOP来进行编码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ListNode类型的定义省略</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 鲁棒性代码</span></span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(l2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 定义两个栈</span></span><br><span class="line">        Stack&lt;Integer&gt; stack_l1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Stack&lt;Integer&gt; stack_l2 = <span class="keyword">new</span> Stack&lt;&gt;(); <span class="comment">// 作用：用于分别存储各个链表中的节点</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用栈来存储对应链表中的节点</span></span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack_l1.push(l1.val);</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack_l2.push(l2.val);</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 定义一个循环 循环中：1 得到位数上的数字； 2 使用1中的数字创建节点，并添加到新链表中</span></span><br><span class="line">        ListNode first = <span class="keyword">null</span>; </span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!stack_l1.isEmpty() || !stack_l2.isEmpty() || carry != <span class="number">0</span>)&#123; <span class="comment">// 循环执行条件:</span></span><br><span class="line">            <span class="comment">// 1 获取到操作数</span></span><br><span class="line">            <span class="keyword">int</span> num1 = stack_l1.isEmpty() ? <span class="number">0</span> : stack_l1.pop();</span><br><span class="line">            <span class="keyword">int</span> num2 = stack_l2.isEmpty() ? <span class="number">0</span> : stack_l2.pop();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 2 进行计算，得到数位上的数值remainder 与 进位数字carry</span></span><br><span class="line">            <span class="keyword">int</span> remainder = (num1 + num2 + carry) % <span class="number">10</span>;</span><br><span class="line">            carry = (num1 + num2 + carry) / <span class="number">10</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 3 使用数位上的数值来创建一个新的节点，并添加到first链表中</span></span><br><span class="line">            ListNode curr = <span class="keyword">new</span> ListNode(remainder);</span><br><span class="line">            curr.next = first;</span><br><span class="line">            first = curr;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回创建的新链表的头节点first</span></span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编码步骤分解"><a href="#编码步骤分解" class="headerlink" title="编码步骤分解"></a>编码步骤分解</h4><ul><li>定义两个栈，并把链表中节点的值添加到对应的栈中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;Integer&gt; stack_l1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">Stack&lt;Integer&gt; stack_l2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把链表节点中的值添加到栈中</span></span><br><span class="line"><span class="keyword">while</span>(l1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">    stack_l1.push(l1.val);</span><br><span class="line">    l1 = l1.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">    stack_l2.push(l2.val);</span><br><span class="line">    l2 = l2.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>定义一个循环 循环中：1 得到位数上的数字；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> carry = <span class="number">0</span>; <span class="comment">// 初始化进位数为0作用：用于个位数的计算</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    <span class="comment">// 1 从栈中获取到当前的操作数</span></span><br><span class="line">    <span class="keyword">int</span> num1 = stack_l1.isEmpty() ? <span class="number">0</span> : stack_l1.pop();</span><br><span class="line">    <span class="keyword">int</span> num2 = stack_l2.isEmpty() ? <span class="number">0</span> : stack_l2.pop();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2 计算操作数，得到位数上的数字</span></span><br><span class="line">    <span class="keyword">int</span> remainder = (num1 + num2 + carry) % <span class="number">10</span>;</span><br><span class="line">    carry = (num1 + num2 + carry) / <span class="number">10</span>; <span class="comment">// 这里需要计算出新的进位数，这样下次遍历时计算结果才能正确</span></span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>2 使用1中的数字创建节点，并添加到新链表中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">ListNode first = <span class="keyword">null</span>; <span class="comment">// 一个头节点作用：作为计算结果的链表容器；特征：头插法</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 头插法</span></span><br><span class="line">    <span class="comment">// 1 创建新节点</span></span><br><span class="line">    ListNode curr = <span class="keyword">new</span> ListNode(remainder);</span><br><span class="line">    <span class="comment">// 2 连接到first指针所指向的节点</span></span><br><span class="line">    curr.next = first;</span><br><span class="line">    <span class="comment">// 3 更新first指针</span></span><br><span class="line">    first = curr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>确定循环执行的表达式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由于栈中的每个数字都需要参与计算，所以最终两个栈要都为空</span></span><br><span class="line"><span class="comment">// 对应于表达式: !satck_l1.isEmpty() || !stack_l2.isEmpty()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最高位计算后，可能会有一个进位————这就要求循环体再执行一次，以便把新的进位添加到链表中。</span></span><br><span class="line"><span class="comment">// 进位添加到链表中后，需要对进位进行更新，以便终止循环</span></span><br><span class="line"><span class="comment">// 更新手段：现有代码 carry = (num1 + num2 + carry) / 10; // 这里需要计算出新的进位数，这样下次遍历时计算结果才能正确</span></span><br><span class="line"><span class="comment">// 此时，由于栈都已经空了。所以num1 = 0、num2 = 0、carry = 1（最高位的进位只会为1）</span></span><br><span class="line"><span class="comment">// 更新后carry的值 = 1 / 10; carry = 0</span></span><br><span class="line"><span class="comment">// 从而应该添加新的条件：carry != 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 综上有：循环执行表达式(!stack_l1.isEmpty() || !stack_l2.isEmpty() || carry != 0)</span></span><br><span class="line"><span class="keyword">while</span>(!stack_l1.isEmpty() || !stack_l2.isEmpty() || carry != <span class="number">0</span>)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>返回循环中创建的链表的头节点</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> first;</span><br></pre></td></tr></table></figure><ul><li>添加鲁棒性代码（或者叫防御性编程代码）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 鲁棒性代码</span></span><br><span class="line"><span class="keyword">if</span>(l1 == <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> l2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(l2 == <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> l1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用设计的测试用例进行功能测试 &amp; 非法输出测试</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 作用：</span></span><br><span class="line"><span class="comment">// 1 保证代码涵对所有可能的合法输入都有效；</span></span><br><span class="line"><span class="comment">// 2 保证对那些个非法输入，代码都做了合适的处理————不会导致程序崩溃；</span></span><br></pre></td></tr></table></figure><blockquote><p> this is whole loads of thing. until next time 😄</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;链表表示的两个数相加&quot;&gt;&lt;a href=&quot;#链表表示的两个数相加&quot; class=&quot;headerlink&quot; title=&quot;链表表示的两个数相加&quot;&gt;&lt;/a&gt;链表表示的两个数相加&lt;/h3&gt;&lt;h4 id=&quot;题设与要求&quot;&gt;&lt;a href=&quot;#题设与要求&quot; class=&quot;headerlink&quot; title=&quot;题设与要求&quot;&gt;&lt;/a&gt;题设与要求&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/08/14/diKVtx.md.png&quot; alt=&quot;题目条件与要求&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="ListNode" scheme="https://henryinshanghai.github.io/categories/ListNode/"/>
    
    
    <category term="Algorithm" scheme="https://henryinshanghai.github.io/tags/Algorithm/"/>
    
    <category term="LinkedList" scheme="https://henryinshanghai.github.io/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>交换链表节点_06_2</title>
    <link href="https://henryinshanghai.github.io/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9%EF%BC%88%E9%80%92%E5%BD%92%E6%96%B9%E5%BC%8F%EF%BC%89_06_2.html"/>
    <id>https://henryinshanghai.github.io/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9%EF%BC%88%E9%80%92%E5%BD%92%E6%96%B9%E5%BC%8F%EF%BC%89_06_2.html</id>
    <published>2020-08-16T09:00:00.000Z</published>
    <updated>2020-08-17T04:32:29.123Z</updated>
    
    <content type="html"><![CDATA[<h4 id="两两交换链表中的节点（递归方式）"><a href="#两两交换链表中的节点（递归方式）" class="headerlink" title="两两交换链表中的节点（递归方式）"></a>两两交换链表中的节点（递归方式）</h4><hr><h4 id="题设与要求"><a href="#题设与要求" class="headerlink" title="题设与要求"></a>题设与要求</h4><p><img src="https://s1.ax1x.com/2020/08/14/dPzGHH.md.png" alt="题设与要求"></p><a id="more"></a><h4 id="分析（递归的可行性）"><a href="#分析（递归的可行性）" class="headerlink" title="分析（递归的可行性）"></a>分析（递归的可行性）</h4><ul><li>问题能够拆解成更小的同类问题吗？<ul><li>答：对链表来说，总是可以把链表拆分成: 头节点head + 剩余节点组成的rest链表（这个链表还可以根据情况再去拆分）</li></ul></li><li>更小同类问题的返回值能够用来帮助解决大问题本身吗？<ul><li>答：对rest执行swapParis操作后，返回的是一个节点已经两两交换后的新链表。它可以和剩余的节点连接起来，从而得到一个所有节点都已经两两交换的新链表——大问题；</li></ul></li></ul><p>结论：这个问题可以使用递归进行解决；</p><h4 id="使用递归实现的SOP"><a href="#使用递归实现的SOP" class="headerlink" title="使用递归实现的SOP"></a>使用递归实现的SOP</h4><ul><li>1 明确方法的作用与返回值；</li><li>2 明确递归的终结条件（根据方法的作用推理）；</li><li>3 描述本次递归需要完成的工作</li></ul><h4 id="按照SOP进行编码"><a href="#按照SOP进行编码" class="headerlink" title="按照SOP进行编码"></a>按照SOP进行编码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 方法作用：把链表中的节点两两进行交换，并返回节点交换后的新链表参考：示例</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">swapParis</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 2 递归的终结条件 链表为null、链表中就只有一个节点</span></span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3 本级递归需要完成的事情</span></span><br><span class="line">    <span class="comment">// ① 把链表拆分为：头节点head + 第二个节点second + 剩余节点组成的链表rest</span></span><br><span class="line">    <span class="comment">// 原因：交换节点需要至少两个节点参与，而且我们不能改变swapPair(rest)的返回值</span></span><br><span class="line">    <span class="comment">// ② 对rest执行swapParis()的操作，并获取到返回值swapedRest</span></span><br><span class="line">    <span class="comment">// ③ 对head、second以及swapedRest进行必要的操作，以得到所有节点都已经两两交换的链表</span></span><br><span class="line">    ListNode second = head.next;</span><br><span class="line">    ListNode swapedRest = swapPairs(second.next);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 交换head与second节点</span></span><br><span class="line">    head.next = swapedRest;</span><br><span class="line">    second.next = head;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>启示</p></blockquote><p>递归大法好，不像递归那样。循环终止条件就能让人💫</p><blockquote><p>until next time😄</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;两两交换链表中的节点（递归方式）&quot;&gt;&lt;a href=&quot;#两两交换链表中的节点（递归方式）&quot; class=&quot;headerlink&quot; title=&quot;两两交换链表中的节点（递归方式）&quot;&gt;&lt;/a&gt;两两交换链表中的节点（递归方式）&lt;/h4&gt;&lt;hr&gt;
&lt;h4 id=&quot;题设与要求&quot;&gt;&lt;a href=&quot;#题设与要求&quot; class=&quot;headerlink&quot; title=&quot;题设与要求&quot;&gt;&lt;/a&gt;题设与要求&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/08/14/dPzGHH.md.png&quot; alt=&quot;题设与要求&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="ListNode" scheme="https://henryinshanghai.github.io/categories/ListNode/"/>
    
    
    <category term="Algorithm" scheme="https://henryinshanghai.github.io/tags/Algorithm/"/>
    
    <category term="LinkedList" scheme="https://henryinshanghai.github.io/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>倒数第k个节点_05_2</title>
    <link href="https://henryinshanghai.github.io/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E8%8A%82%E7%82%B9%EF%BC%88%E4%B8%80%E6%AC%A1%E9%81%8D%E5%8E%86%EF%BC%89_05_2.html"/>
    <id>https://henryinshanghai.github.io/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E8%8A%82%E7%82%B9%EF%BC%88%E4%B8%80%E6%AC%A1%E9%81%8D%E5%8E%86%EF%BC%89_05_2.html</id>
    <published>2020-08-16T08:30:00.000Z</published>
    <updated>2020-08-17T09:12:44.211Z</updated>
    
    <content type="html"><![CDATA[<h3 id="删除链表中的倒数第n个节点（一次遍历）"><a href="#删除链表中的倒数第n个节点（一次遍历）" class="headerlink" title="删除链表中的倒数第n个节点（一次遍历）"></a>删除链表中的倒数第n个节点（一次遍历）</h3><h4 id="题设-amp-要求"><a href="#题设-amp-要求" class="headerlink" title="题设 &amp; 要求"></a>题设 &amp; 要求</h4><p><img src="https://s1.ax1x.com/2020/08/14/dCLxyj.png" alt="题设 &amp; 要求"></p><a id="more"></a><h4 id="分析（难点）"><a href="#分析（难点）" class="headerlink" title="分析（难点）"></a>分析（难点）</h4><p>如何能找到倒数第N个节点（预期节点：此节点的上一个节点）？</p><h4 id="思路2（难点的解决方案）"><a href="#思路2（难点的解决方案）" class="headerlink" title="思路2（难点的解决方案）"></a>思路2（难点的解决方案）</h4><ul><li>定义两个指针front与back，设置两个指针之间的初始间距。</li><li>然后把两个指针同时向后移动，直到front指针到达了链表的尾节点。</li><li>这时候back指针就会指在某一个可以计算的位置——通过设置指针间的初始间距，就能确定back指针停下的具体位置。</li></ul><h4 id="实现SOP"><a href="#实现SOP" class="headerlink" title="实现SOP"></a>实现SOP</h4><ul><li>1 定义所需要的指针front与back与dummy（并初始化）；    注：画图分析指针初始化的位置；    原则：方便编码；&amp; 避免NPE；</li><li>2 画图分析，front指针与back指针之间的初始间距span与n的关系（span = n）；</li><li>3 把front与back指针初始化指向dummy节点(这里引入dummy节点只是为了方便计算指针应该移动的距离)；</li><li>4 把front指针向前移动n个节点；</li><li>5 把front与back指针同时向后移动，直到front指针指向链表的尾节点；</li><li>6 back指向预期节点后，对待删除节点进行删除；</li></ul><h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 实践证明：在删除的时候使用栈不是一个好主意</span></span><br><span class="line">        <span class="comment">// 鲁棒性代码</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 需要的实例变量</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line"></span><br><span class="line">        ListNode front = dummy;</span><br><span class="line">        ListNode back = dummy;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 先让front向前走n个节点   如果只有一个节点，然后要删除倒数第一个节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123; <span class="comment">// 注：front的初始化值会决定循环执行的次数</span></span><br><span class="line">            front = front.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 再让front与back一起先前移动，直到front到达尾节点</span></span><br><span class="line">        <span class="keyword">while</span>(front != <span class="keyword">null</span> &amp;&amp; front.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            front = front.next;</span><br><span class="line">            back = back.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 这里得到的back就是预期删除的节点的前一个节点</span></span><br><span class="line">        <span class="comment">// 执行删除</span></span><br><span class="line">        back.next = back.next.next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="启示"><a href="#启示" class="headerlink" title="启示"></a>启示</h4><p>1 代码的鲁棒性编码在实现了基本功能后，再进行添加；</p><p>2 对于循环执行次数已知的情况，使用for语法来实现循环——这样能避免令人纠结的循环执行/终止条件；</p><p>3 编写while循环执行表达式的参考：节点的最终状态； &amp;  避免代码中的NPE；</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;删除链表中的倒数第n个节点（一次遍历）&quot;&gt;&lt;a href=&quot;#删除链表中的倒数第n个节点（一次遍历）&quot; class=&quot;headerlink&quot; title=&quot;删除链表中的倒数第n个节点（一次遍历）&quot;&gt;&lt;/a&gt;删除链表中的倒数第n个节点（一次遍历）&lt;/h3&gt;&lt;h4 id=&quot;题设-amp-要求&quot;&gt;&lt;a href=&quot;#题设-amp-要求&quot; class=&quot;headerlink&quot; title=&quot;题设 &amp;amp; 要求&quot;&gt;&lt;/a&gt;题设 &amp;amp; 要求&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/08/14/dCLxyj.png&quot; alt=&quot;题设 &amp;amp; 要求&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="ListNode" scheme="https://henryinshanghai.github.io/categories/ListNode/"/>
    
    
    <category term="Algorithm" scheme="https://henryinshanghai.github.io/tags/Algorithm/"/>
    
    <category term="LinkedList" scheme="https://henryinshanghai.github.io/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>交换链表节点(迭代)_06</title>
    <link href="https://henryinshanghai.github.io/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9(%E8%BF%AD%E4%BB%A3%E6%96%B9%E5%BC%8F)_06.html"/>
    <id>https://henryinshanghai.github.io/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9(%E8%BF%AD%E4%BB%A3%E6%96%B9%E5%BC%8F)_06.html</id>
    <published>2020-08-16T08:30:00.000Z</published>
    <updated>2020-08-17T09:20:48.898Z</updated>
    
    <content type="html"><![CDATA[<h3 id="两两交换链表中的节点"><a href="#两两交换链表中的节点" class="headerlink" title="两两交换链表中的节点"></a>两两交换链表中的节点</h3><hr><h4 id="题设与要求"><a href="#题设与要求" class="headerlink" title="题设与要求"></a>题设与要求</h4><p><img src="https://s1.ax1x.com/2020/08/14/dP37xf.png" alt="题设与要求"></p><a id="more"></a><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>要求进行节点之间的两两交换。</p><p>如果使用迭代的方式，可以每次处理两个相邻节点之间的连接关系；</p><p>然后在下次迭代时，再去处理下一批的两个节点之间的连接关系；</p><p>还要处理每个区间（2个节点）之间的连接关系，来保证连接的正确性；</p><p>说明：</p><p>1 当通过这种分析无法得到有效的突破点时，就只好画图来找找规律了，对自己的想象力不要太自信；</p><p>2 翻转操作需要3个指针：两个指针用于指向需要交换的节点，一个指针用于迭代链表；</p><blockquote><p>画图大法(画图找规律)</p></blockquote><p><img src="https://s1.ax1x.com/2020/08/14/dPU7kD.md.jpg" alt="节点的交换过程"></p><ul><li>通过画图可以看出,可以通过连续翻转节点来实现题设中的“两两节点交换”；</li><li>节点翻转需要3个指针：curr指向当前节点、temp指向当前节点的下一个节点；prev指向当前节点的前驱节点（用于更新这三个连续的指针）</li><li>可以根据预期的指针情况（图3）与当前的指针情况（图2）来推理出指针更新的手段；prev = curr;</li></ul><h4 id="代码实现的SOP："><a href="#代码实现的SOP：" class="headerlink" title="代码实现的SOP："></a>代码实现的SOP：</h4><p>1 定义所需要的指针，并初始化指针的原始位置；</p><p>2 定义一个循环，在循环中完成以下工作：</p><ul><li>对指针指向的当前节点区间进行翻转；</li><li>更新指针，以便进行下一次的翻转操作；</li></ul><h4 id="代码实现（虽然SOP不复杂，但是代码实现还是挺讲究的）"><a href="#代码实现（虽然SOP不复杂，但是代码实现还是挺讲究的）" class="headerlink" title="代码实现（虽然SOP不复杂，但是代码实现还是挺讲究的）"></a>代码实现（虽然SOP不复杂，但是代码实现还是挺讲究的）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1 定义需要的指针</span></span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>); <span class="comment">// 作用：指向链表的头节点</span></span><br><span class="line">    dummy.next = head;</span><br><span class="line">    </span><br><span class="line">    ListNode prev = dummy; <span class="comment">// </span></span><br><span class="line">    ListNode curr = head;</span><br><span class="line">    <span class="comment">// ListNode temp = curr.next; // 有点不对劲，因为temp都是在遍历过程中临时更新的参考：翻转链表的操作</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2 定义一个循环，在循环中： 1 完成当前区间内节点的翻转； 2 更新到下一个翻转区间</span></span><br><span class="line">    <span class="keyword">while</span>(curr != <span class="keyword">null</span> &amp;&amp; curr.next != <span class="keyword">null</span>)&#123; <span class="comment">// 循环终止条件：curr == null(对应于奇数个节点) OR curr.next == null (对应于偶数个节点)</span></span><br><span class="line">        <span class="comment">// 1 获取到当前节点的下一个节点 [curr-temp]</span></span><br><span class="line">        ListNode temp = curr.next;</span><br><span class="line">        </span><br><span class="line">         <span class="comment">// 2 完成当前区间内节点的翻转(需要借助temp节点才能实现)</span></span><br><span class="line">        prev.next = temp;</span><br><span class="line">        curr.next = temp.next;</span><br><span class="line">        temp.next = curr;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3 更新到下一个翻转区间[prev-curr]</span></span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = prev.next;</span><br><span class="line">        <span class="comment">// temp = curr.next;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3 返回链表的头节点</span></span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代码实现过程SOP分解"><a href="#代码实现过程SOP分解" class="headerlink" title="代码实现过程SOP分解"></a>代码实现过程SOP分解</h4><ul><li>定义所需要的指针</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">dummy.next = head;<span class="comment">// 作用：指向链表的头节点</span></span><br><span class="line"></span><br><span class="line">ListNode prev = dummy; <span class="comment">// 作用：翻转区间内的第一个节点</span></span><br><span class="line">ListNode curr = prev.next; <span class="comment">// 作用：翻转区间内的第二个节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 所需要的辅助节点temp（当前节点的下一个节点），在循环中再临时获取</span></span><br></pre></td></tr></table></figure><ul><li>定义一个循环，在循环中完成<ul><li>当前节点区间的节点翻转；</li><li>更新当前节点区间；</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    <span class="comment">// 对当前节点区间中的节点进行翻转</span></span><br><span class="line">    <span class="comment">// ① 获取到当前节点的下一个节点作用：防止链表断裂</span></span><br><span class="line">    ListNode temp = curr.next;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ② 按照下图流程来实现节点的翻转参考：👇图</span></span><br><span class="line">    prev.next = temp; </span><br><span class="line">    curr.next = temp.next;</span><br><span class="line">    temp.next = curr;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更新当前的区间节点</span></span><br><span class="line">    prev = curr; <span class="comment">// 更新后的翻转区间第一个节点 参考：“分析”部分</span></span><br><span class="line">    curr = prev.next; <span class="comment">// 更新后的翻转区间第二个节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2020/08/14/dPLV7q.md.jpg" alt="节点翻转流程"></p><ul><li><p>确定循环执行的条件</p><ul><li>循环终止条件（直接根据代码不能NPE来反推）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ListNode temp = curr.next;<span class="comment">// 因此curr != null</span></span><br><span class="line">...</span><br><span class="line">curr.next = temp.next; <span class="comment">// 因此temp != null aka curr.next != null</span></span><br></pre></td></tr></table></figure><p>r u kidding me?</p><ul><li>循环终止条件（极端情况）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 极端情况：prev为倒数第二个节点、curr为尾节点 此时需要翻转prev与curr之间的指向</span></span><br><span class="line"><span class="comment">// 特征:curr.next == null aka 循环执行条件 curr.next != null</span></span><br><span class="line"><span class="comment">// 为了避免循环中的更新操作导致curr为null SO</span></span><br><span class="line"><span class="keyword">while</span>(curr != <span class="keyword">null</span> &amp;&amp; curr.next != <span class="keyword">null</span>)</span><br></pre></td></tr></table></figure><p>不很满意这种说法😳</p></li><li><p>返回新链表的头节点</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由于每个节点都只有一个next指针，所以dummy其实连接到了新的链表头部</span></span><br><span class="line"><span class="keyword">return</span> dummy.next;</span><br></pre></td></tr></table></figure><ul><li>添加鲁棒性代码</li><li>编写各种测试用例，测试代码：1 功能是否可用； 2 对于各种非法输出是否有合理的输出/提示信息；</li></ul><h4 id="代码默写-重现"><a href="#代码默写-重现" class="headerlink" title="代码默写/重现"></a>代码默写/重现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1 定义需要用到的指针</span></span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    dummy.next = head; <span class="comment">// 指向链表的头节点</span></span><br><span class="line">    </span><br><span class="line">    ListNode prev = dummy; <span class="comment">// 翻转区间的第一个节点</span></span><br><span class="line">    ListNode curr = prev.next; <span class="comment">// 翻转区间的第二个节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(curr != <span class="keyword">null</span> &amp;&amp; curr.next != <span class="keyword">null</span>)&#123; <span class="comment">// 烦人的循环执行条件</span></span><br><span class="line">        <span class="comment">// 翻转区间中节点的指向</span></span><br><span class="line">        ListNode temp = curr.next;</span><br><span class="line">        </span><br><span class="line">        prev.next = temp;</span><br><span class="line">        curr.next = temp.next;</span><br><span class="line">        temp.next = curr;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 更新翻转区间</span></span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = curr.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>until next time 😄</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;两两交换链表中的节点&quot;&gt;&lt;a href=&quot;#两两交换链表中的节点&quot; class=&quot;headerlink&quot; title=&quot;两两交换链表中的节点&quot;&gt;&lt;/a&gt;两两交换链表中的节点&lt;/h3&gt;&lt;hr&gt;
&lt;h4 id=&quot;题设与要求&quot;&gt;&lt;a href=&quot;#题设与要求&quot; class=&quot;headerlink&quot; title=&quot;题设与要求&quot;&gt;&lt;/a&gt;题设与要求&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/08/14/dP37xf.png&quot; alt=&quot;题设与要求&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="ListNode" scheme="https://henryinshanghai.github.io/categories/ListNode/"/>
    
    
    <category term="Algorithm" scheme="https://henryinshanghai.github.io/tags/Algorithm/"/>
    
    <category term="LinkedList" scheme="https://henryinshanghai.github.io/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>倒数第k个节点_05</title>
    <link href="https://henryinshanghai.github.io/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9(%E4%B8%A4%E6%AC%A1%E9%81%8D%E5%8E%86)_05.html"/>
    <id>https://henryinshanghai.github.io/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9(%E4%B8%A4%E6%AC%A1%E9%81%8D%E5%8E%86)_05.html</id>
    <published>2020-08-16T08:00:00.000Z</published>
    <updated>2020-08-17T09:13:15.746Z</updated>
    
    <content type="html"><![CDATA[<h3 id="删除链表中的倒数第N个节点"><a href="#删除链表中的倒数第N个节点" class="headerlink" title="删除链表中的倒数第N个节点"></a>删除链表中的倒数第N个节点</h3><h4 id="分析（找到问题的难点）："><a href="#分析（找到问题的难点）：" class="headerlink" title="分析（找到问题的难点）："></a>分析（找到问题的难点）：</h4><ul><li>对于单向链表，只能从前往后地查找节点；</li><li>删除链表节点的常用手段: curr.next = curr.next.next; // 这样就能把curr后面的一个节点从链表中删除掉</li></ul><a id="more"></a><h4 id="思路（解决问题难点）："><a href="#思路（解决问题难点）：" class="headerlink" title="思路（解决问题难点）："></a>思路（解决问题难点）：</h4><p>如果链表的长度已知，就能通过公式（length - N）来求出待删除节点的正向位置。这样就可以执行删除操作了</p><p>可能犯错的地方：找错了节点；</p><p>根据分析的第二点，我们应该找到的是待删除节点的上一个节点（预期节点）；</p><h4 id="实现SOP"><a href="#实现SOP" class="headerlink" title="实现SOP:"></a>实现SOP:</h4><ul><li>1 先计算出链表中的节点的总长度；</li><li>2 根据公式(length - N)计算出待删除节点的正向位置索引；</li><li>3 找到预期节点，然后删除“待删除的节点”；</li></ul><h4 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ListNode类型的定义省略</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 0 鲁棒性代码</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1 定义需要的指针</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>); <span class="comment">// 备用</span></span><br><span class="line">        dummy.next = head;</span><br><span class="line">        </span><br><span class="line">        ListNode cursor = head;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2 计算链表中节点的总长度</span></span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cursor != <span class="keyword">null</span>)&#123;</span><br><span class="line">            length++;</span><br><span class="line">            cursor = cursor.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3 计算预期节点的位置</span></span><br><span class="line">        <span class="keyword">int</span> expect_postion = length - n;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4 通过迭代的方式找到预期节点</span></span><br><span class="line">        cursor = head; <span class="comment">// 把游标拨回链表头节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i &lt; expect_position; i++)&#123;</span><br><span class="line">            cursor = cursor.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 5 找到预取节点后，对待删除节点执行删除操作</span></span><br><span class="line">        cursor.next = cursor.next.next; <span class="comment">// 由于题设已经保证n是有效的，所以这里不会出现NPE</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 6 返回删除节点后的链表</span></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="添加鲁棒性代码"><a href="#添加鲁棒性代码" class="headerlink" title="添加鲁棒性代码"></a>添加鲁棒性代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">参考 <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><h4 id="算法特征"><a href="#算法特征" class="headerlink" title="算法特征"></a>算法特征</h4><p>1 需要两次遍历：第一次遍历用来计算链表中的节点总长度；第二次遍历用来找到“预期的节点”，以便执行删除</p><h4 id="优化（只需要进行一次遍历）"><a href="#优化（只需要进行一次遍历）" class="headerlink" title="优化（只需要进行一次遍历）"></a>优化（只需要进行一次遍历）</h4><p>原理：通过前后指针来找到预期位置，而不是用（length - N）的方式。</p><blockquote><p>until NEXT time 😄</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;删除链表中的倒数第N个节点&quot;&gt;&lt;a href=&quot;#删除链表中的倒数第N个节点&quot; class=&quot;headerlink&quot; title=&quot;删除链表中的倒数第N个节点&quot;&gt;&lt;/a&gt;删除链表中的倒数第N个节点&lt;/h3&gt;&lt;h4 id=&quot;分析（找到问题的难点）：&quot;&gt;&lt;a href=&quot;#分析（找到问题的难点）：&quot; class=&quot;headerlink&quot; title=&quot;分析（找到问题的难点）：&quot;&gt;&lt;/a&gt;分析（找到问题的难点）：&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;对于单向链表，只能从前往后地查找节点；&lt;/li&gt;
&lt;li&gt;删除链表节点的常用手段: curr.next = curr.next.next; // 这样就能把curr后面的一个节点从链表中删除掉&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="ListNode" scheme="https://henryinshanghai.github.io/categories/ListNode/"/>
    
    
    <category term="Algorithm" scheme="https://henryinshanghai.github.io/tags/Algorithm/"/>
    
    <category term="LinkedList" scheme="https://henryinshanghai.github.io/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>链表去重_04_2</title>
    <link href="https://henryinshanghai.github.io/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%EF%BC%88%E9%80%92%E5%BD%92%E6%96%B9%E5%BC%8F%EF%BC%89_04_2.html"/>
    <id>https://henryinshanghai.github.io/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%EF%BC%88%E9%80%92%E5%BD%92%E6%96%B9%E5%BC%8F%EF%BC%89_04_2.html</id>
    <published>2020-08-16T07:30:00.000Z</published>
    <updated>2020-08-17T09:14:16.178Z</updated>
    
    <content type="html"><![CDATA[<h3 id="删除有序链表中的重复元素（递归方式）"><a href="#删除有序链表中的重复元素（递归方式）" class="headerlink" title="删除有序链表中的重复元素（递归方式）"></a>删除有序链表中的重复元素（递归方式）</h3><h4 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h4><p><img src="https://s1.ax1x.com/2020/08/14/dCTVln.png" alt="题设与要求"></p><a id="more"></a><h4 id="分析（确定思路）"><a href="#分析（确定思路）" class="headerlink" title="分析（确定思路）"></a>分析（确定思路）</h4><ul><li><p>使用递归的可行性；</p><ul><li>问题能够被分解为规模更小的问题吗？</li></ul><p>答：可以。手段：把链表视为：头节点head + 剩余节点组成的链表rest;</p><ul><li>可以在更小的问题上应用当前操作，并用它的返回值来帮助解决大问题吗？</li></ul><p>答：可以。对递归调用的返回值做一些额外的处理，就能得到整个链表删除重复元素之后的结果。</p></li></ul><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> val)&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1 递归方法的作用：删除链表中的重复元素并返回更新后的链表/头节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 2 递归终结条件 链表为空 OR 链表中就只有一个节点</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3 本级递归需要做的事情</span></span><br><span class="line">        <span class="comment">// ① 把链表视为：头节点head + 剩余节点构成的链表rest；</span></span><br><span class="line">        <span class="comment">// ② 对rest链表执行删除重复节点的操作（假设已经有一个功能可用的API）；</span></span><br><span class="line">        <span class="comment">// ③ 对返回值进行必要的处理</span></span><br><span class="line">        ListNode rest = deleteDuplicates(head.next); <span class="comment">// ② </span></span><br><span class="line">        <span class="keyword">if</span>(head.val == rest.val)&#123; <span class="comment">// 头节点的值与rest头节点的值相等... 重复了</span></span><br><span class="line">             <span class="comment">// 更新head指针</span></span><br><span class="line">             head = rest;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 把rest连接到head上</span></span><br><span class="line">            head.next = rest;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回新链表的头节点</span></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代码实现步骤SOP分解"><a href="#代码实现步骤SOP分解" class="headerlink" title="代码实现步骤SOP分解"></a>代码实现步骤SOP分解</h4><ul><li>确定递归的可行性</li><li>确定递归方法的作用与返回值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 递归方法的作用：删除链表中的重复元素并返回更新后的链表/头节点</span></span><br></pre></td></tr></table></figure><ul><li>确定递归方法的终结条件</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2 递归终结条件 链表为空 OR 链表中就只有一个节点</span></span><br><span class="line"><span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br></pre></td></tr></table></figure><ul><li>确定本级递归需要完成的事情</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3 本级递归需要做的事情</span></span><br><span class="line"><span class="comment">// ① 把链表视为：头节点head + 剩余节点构成的链表rest；</span></span><br><span class="line"><span class="comment">// ② 对rest链表执行删除重复节点的操作（假设已经有一个功能可用的API）；</span></span><br><span class="line"><span class="comment">// ③ 对返回值进行必要的处理</span></span><br><span class="line">ListNode rest = deleteDuplicates(head.next); <span class="comment">// ② </span></span><br><span class="line"><span class="keyword">if</span>(head.val == rest.val)&#123; <span class="comment">// 头节点的值与rest头节点的值相等... 重复了</span></span><br><span class="line">    <span class="comment">// 更新head指针</span></span><br><span class="line">    head = rest;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 把rest连接到head上</span></span><br><span class="line">    head.next = rest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>返回正确链表的头指针（最好画图确认）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回新链表的头节点</span></span><br><span class="line"><span class="keyword">return</span> head;</span><br></pre></td></tr></table></figure><h4 id="启示"><a href="#启示" class="headerlink" title="启示"></a>启示</h4><p>在分析递归可行的情况下，对递归调用的返回值还需要进一步处理。</p><p>基本的原则是：使用递归调用的返回值来解决本级递归所需要解决的问题；</p><blockquote><p>until next time 😄</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;删除有序链表中的重复元素（递归方式）&quot;&gt;&lt;a href=&quot;#删除有序链表中的重复元素（递归方式）&quot; class=&quot;headerlink&quot; title=&quot;删除有序链表中的重复元素（递归方式）&quot;&gt;&lt;/a&gt;删除有序链表中的重复元素（递归方式）&lt;/h3&gt;&lt;h4 id=&quot;题目要求&quot;&gt;&lt;a href=&quot;#题目要求&quot; class=&quot;headerlink&quot; title=&quot;题目要求&quot;&gt;&lt;/a&gt;题目要求&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/08/14/dCTVln.png&quot; alt=&quot;题设与要求&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="ListNode" scheme="https://henryinshanghai.github.io/categories/ListNode/"/>
    
    
    <category term="Algorithm" scheme="https://henryinshanghai.github.io/tags/Algorithm/"/>
    
    <category term="LinkedList" scheme="https://henryinshanghai.github.io/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>链表去重_04</title>
    <link href="https://henryinshanghai.github.io/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0(%E8%BF%AD%E4%BB%A3%E6%96%B9%E5%BC%8F)_04.html"/>
    <id>https://henryinshanghai.github.io/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0(%E8%BF%AD%E4%BB%A3%E6%96%B9%E5%BC%8F)_04.html</id>
    <published>2020-08-16T07:00:00.000Z</published>
    <updated>2020-08-17T09:15:13.257Z</updated>
    
    <content type="html"><![CDATA[<h3 id="删除排序链表中的重复元素"><a href="#删除排序链表中的重复元素" class="headerlink" title="删除排序链表中的重复元素"></a>删除排序链表中的重复元素</h3><hr><h4 id="题目要求："><a href="#题目要求：" class="headerlink" title="题目要求："></a>题目要求：</h4><p><img src="https://s1.ax1x.com/2020/08/14/dCy9C8.png" alt="题目要求"></p><p><img src="https://s1.ax1x.com/2020/08/14/dCguPP.png" alt="测试用例示例"></p><a id="more"></a><h4 id="题设分析："><a href="#题设分析：" class="headerlink" title="题设分析："></a>题设分析：</h4><ul><li>1 链表已经是有序的了，aka，重复的元素会相邻在一起；</li><li>2 删除元素时，只需要删除重复多次的部分，使元素只会出现一次；</li></ul><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>最直观的方式：</p><ul><li>遍历整个链表，逐个比较当前节点curr与当前节点的下一个节点next的值。</li><li>如果curr.val == next.val,就想办法删除掉当前节点；</li><li>如果不相等，就更新curr指针，以便迭代下一个节点；</li></ul><h4 id="代码实现的SOP"><a href="#代码实现的SOP" class="headerlink" title="代码实现的SOP"></a>代码实现的SOP</h4><ul><li>创建一个指针curr，初始化为链表的头节点head；    作用：用于迭代链表；</li><li>创建一个指针dummy,初始化为null； 作用：用于指向链表的头节点，方便返回更新后的链表；</li><li>循环链表中的每一个节点，判断节点是否是重复节点；<ul><li>如果是，删除此节点；</li><li>如果不是，继续执行循环，直到所有节点都已经被遍历了</li></ul></li></ul><h4 id="完整的代码实现"><a href="#完整的代码实现" class="headerlink" title="完整的代码实现"></a>完整的代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    </span><br><span class="line">    ListNode(<span class="keyword">int</span> val)&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 1 定义需要的指针</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        </span><br><span class="line">        ListNode curr = head;</span><br><span class="line">        <span class="comment">// 2 遍历链表中的每一个节点，判断是否为重复节点，并执行相应的操作</span></span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="keyword">null</span> &amp;&amp; curr.next != <span class="keyword">null</span>)&#123; <span class="comment">// 循环执行条件：当前节点与当前节点的下一个节点都不为null根据画图的边界条件推导 并使用代码中可能的NPE来验证</span></span><br><span class="line">            <span class="keyword">if</span>(curr.val == curr.next.val)&#123;</span><br><span class="line">                curr.next = curr.next.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                curr = curr.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3 遍历完成后，返回新链表的头节点</span></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="实现过程SOP"><a href="#实现过程SOP" class="headerlink" title="实现过程SOP"></a>实现过程SOP</h4><ul><li><p>定义需要的指针</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 定义需要的指针</span></span><br><span class="line">ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">dummy.next = head; <span class="comment">// dummy指针作用：指向链表的头节点，方便无脑地返回链表的头节点</span></span><br><span class="line"></span><br><span class="line">ListNode curr = head; <span class="comment">// 作用：在链表中遍历所有节点（结合循环）</span></span><br></pre></td></tr></table></figure></li><li><p>定义一个循环，在循环中执行判重与删除操作 &amp; 迭代链表的操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(curr.val == curr.next.val)&#123; <span class="comment">// 判重</span></span><br><span class="line">        <span class="comment">// 删除</span></span><br><span class="line">        curr.next = curr.next.next; <span class="comment">// 把当前节点连接到下下个节点上</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        curr = curr.next; <span class="comment">// 更新指针作用：实现遍历链表</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>确定循环()表达式的内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 临界情况：比较倒数第一与倒数第二个节点，判断倒数第一个节点是否需要删除</span></span><br><span class="line"><span class="comment">// curr为倒数第二个节点，curr.next为倒数第一个节点</span></span><br><span class="line"><span class="comment">// 为了循环能够正常执行，要求两个节点均不为null</span></span><br><span class="line"><span class="keyword">while</span>(curr != <span class="keyword">null</span> &amp;&amp; curr.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>确定方法的返回值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由于定义了指向原始链表头节点的指针dummy,而且没有改变链表中的连接方向，SO</span></span><br><span class="line"><span class="keyword">return</span> dummy.next; <span class="comment">// 直接返回dummy的下一个节点 aka 链表的头节点</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="代码重现"><a href="#代码重现" class="headerlink" title="代码重现"></a>代码重现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicats</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1 定义所需要的指针</span></span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    dummy.next = head;</span><br><span class="line">    </span><br><span class="line">    ListNode curr = dummy;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2 迭代链表中的节点，并完成必要的操作</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(curr.val == curr.next.val)&#123;</span><br><span class="line">            curr.next = curr.next.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 这里必须要有else字句，因为链表中可能出现连续重复的节点</span></span><br><span class="line">            <span class="comment">// 更新指针指向下一个节点</span></span><br><span class="line">            curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3 返回更新后的节点</span></span><br><span class="line">    <span class="keyword">return</span> dummy.next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>until next time 😄</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;删除排序链表中的重复元素&quot;&gt;&lt;a href=&quot;#删除排序链表中的重复元素&quot; class=&quot;headerlink&quot; title=&quot;删除排序链表中的重复元素&quot;&gt;&lt;/a&gt;删除排序链表中的重复元素&lt;/h3&gt;&lt;hr&gt;
&lt;h4 id=&quot;题目要求：&quot;&gt;&lt;a href=&quot;#题目要求：&quot; class=&quot;headerlink&quot; title=&quot;题目要求：&quot;&gt;&lt;/a&gt;题目要求：&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/08/14/dCy9C8.png&quot; alt=&quot;题目要求&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/08/14/dCguPP.png&quot; alt=&quot;测试用例示例&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="ListNode" scheme="https://henryinshanghai.github.io/categories/ListNode/"/>
    
    
    <category term="Algorithm" scheme="https://henryinshanghai.github.io/tags/Algorithm/"/>
    
    <category term="LinkedList" scheme="https://henryinshanghai.github.io/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>合并链表_03_2</title>
    <link href="https://henryinshanghai.github.io/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%EF%BC%88%E9%80%92%E5%BD%92%E6%96%B9%E5%BC%8F%EF%BC%89_03_2.html"/>
    <id>https://henryinshanghai.github.io/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%EF%BC%88%E9%80%92%E5%BD%92%E6%96%B9%E5%BC%8F%EF%BC%89_03_2.html</id>
    <published>2020-08-16T06:30:00.000Z</published>
    <updated>2020-08-17T09:15:59.075Z</updated>
    
    <content type="html"><![CDATA[<h3 id="合并两个有序链表（递归方式）"><a href="#合并两个有序链表（递归方式）" class="headerlink" title="合并两个有序链表（递归方式）"></a>合并两个有序链表（递归方式）</h3><hr><p><img src="https://s1.ax1x.com/2020/08/11/aOHNlD.png" alt="题目要求"></p><a id="more"></a><h4 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h4><ul><li><p>使用递归的可行性；</p><p>把第一个链表叫做l1，第二个链表叫做l2。可以把 l1 分解为（head + rest）,然后拿rest与l2进行合并操作，合并得到的结果再连接到head；</p><p>结论：可行</p></li><li><p>递归三部曲回顾：</p><p>1 方法的作用与返回值；</p><p>2 递归的终结条件（根据方法的作用推演）；</p><p>3 本级递归需要完成的工作（假设已经有了一个功能完整实现的API）；</p></li></ul><hr><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>一旦确定是可以递归的，这种方式需要关注的细节其实很少</p><hr><h4 id="完整实现"><a href="#完整实现" class="headerlink" title="完整实现"></a>完整实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ListNode定义的代码省略（参考其他文章）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1 作用：合并两个有序的列表，并返回合并后的列表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 2 递归终结条件</span></span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(l2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3 本级递归需要做的事情</span></span><br><span class="line">        <span class="comment">// ① 比较两个原始链表的头节点谁更小，对更小的那个链表进行拆分；</span></span><br><span class="line">        <span class="comment">// ② 把拆分后的rest链表与原始链表中的另一个进行合并操作，得到新的链表tempMerge</span></span><br><span class="line">        <span class="comment">// ③ 再对head头节点与tempMerge进行合并</span></span><br><span class="line">        <span class="keyword">if</span>(l1.val &lt; l2.val)&#123;</span><br><span class="line">            l1.next = mergeTwoLists(l1.next, l2); <span class="comment">// 把得到的新链表直接连接到头节点上</span></span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l2.next = mergeTwoLists(l2.next, l1);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h4><p>参考代码中的1、2、3</p><hr><h4 id="启示"><a href="#启示" class="headerlink" title="启示"></a>启示</h4><p>递归的代码真的非常简洁（不需要考虑很多的边界细节），而且只要确定可行性，代码一般不会太复杂</p><blockquote><p>until next time😄</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;合并两个有序链表（递归方式）&quot;&gt;&lt;a href=&quot;#合并两个有序链表（递归方式）&quot; class=&quot;headerlink&quot; title=&quot;合并两个有序链表（递归方式）&quot;&gt;&lt;/a&gt;合并两个有序链表（递归方式）&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/08/11/aOHNlD.png&quot; alt=&quot;题目要求&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="ListNode" scheme="https://henryinshanghai.github.io/categories/ListNode/"/>
    
    
    <category term="Algorithm" scheme="https://henryinshanghai.github.io/tags/Algorithm/"/>
    
    <category term="LinkedList" scheme="https://henryinshanghai.github.io/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>合并链表_03</title>
    <link href="https://henryinshanghai.github.io/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8-%E5%BE%97%E5%88%B0%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%EF%BC%88%E8%BF%AD%E4%BB%A3%E6%96%B9%E5%BC%8F%EF%BC%89_03.html"/>
    <id>https://henryinshanghai.github.io/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8-%E5%BE%97%E5%88%B0%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%EF%BC%88%E8%BF%AD%E4%BB%A3%E6%96%B9%E5%BC%8F%EF%BC%89_03.html</id>
    <published>2020-08-16T06:00:00.000Z</published>
    <updated>2020-08-17T09:21:47.190Z</updated>
    
    <content type="html"><![CDATA[<h3 id="合并两个有序链表，得到一个新的有序链表（迭代方式）"><a href="#合并两个有序链表，得到一个新的有序链表（迭代方式）" class="headerlink" title="合并两个有序链表，得到一个新的有序链表（迭代方式）"></a>合并两个有序链表，得到一个新的有序链表（迭代方式）</h3><a id="more"></a><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>1 创建一个链表就只需要想某个节点上不断连接其他节点就行了；</p><p>2 对两个链表对应位置节点的值进行比较，把较小的节点先连接到链表中；</p><p>3 如果出现某一个链表中的节点比较多（另一个链表中的节点已经用完了），直接把链表剩余的节点连接到正在创建的链表上就行了（因为剩余的这些节点都已经是有序的了，并且值也更大）</p><hr><h4 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h4><p>1 创建链表就只需要一个指针就可以；    </p><p>创建链表的SOP:</p><ul><li>1 连接到下一个节点；</li><li>2 更新当前指针到下一个节点；以便重复步骤1</li></ul><p>2 为了方便比较两个链表对应位置上的节点，这里需要添加一个假节点dummy；它总是指向链表的头节点</p><hr><h4 id="根据上面的分析尝试写代码"><a href="#根据上面的分析尝试写代码" class="headerlink" title="根据上面的分析尝试写代码"></a>根据上面的分析尝试写代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> val)&#123; <span class="keyword">this</span>.val = val;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 准备指针，用于生成链表</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>); <span class="comment">// 指向链表的头节点</span></span><br><span class="line">        ListNode cursor = dummy; <span class="comment">// 用于不管更新链表的指针</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 迭代并比较两个链表中节点的大小，并根据比较结果把节点连接到链表中</span></span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>)&#123; <span class="comment">// 循环执行条件：haed to describe</span></span><br><span class="line">            <span class="keyword">if</span>(l1.val &lt; l2.val)&#123;</span><br><span class="line">                <span class="comment">// 创建链表step1：连接到下一个节点</span></span><br><span class="line">                cursor.next = l1;</span><br><span class="line">                <span class="comment">// 更新l1链表的指针到下一个位置作用：实现迭代</span></span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 作用同上</span></span><br><span class="line">                cursor.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 创建链表step2：更新链表的指针作用：方便连接到下一个节点</span></span><br><span class="line">            cursor = cursor.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// always safe to use this to refer the ListNode, cus it always point to the first node of the ListNode</span></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h4><p>step1 定义需要的指针</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>); <span class="comment">// 方便新链表的创建</span></span><br><span class="line">ListNode cursor = dummy; <span class="comment">// cursor的意思是游标，我感觉比起指针更形象一些用于创建新链表</span></span><br></pre></td></tr></table></figure><p>step2 通过迭代的方式，遍历两个子链表中的指针，并连接到新链表中；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(l1.val &lt; l2.val)&#123;</span><br><span class="line"><span class="comment">// 为新链表连接到下一个节点扩展新链表</span></span><br><span class="line">cursor.next = l1;</span><br><span class="line"><span class="comment">// 找到原始链表中的下一个节点 用于比较两个原始链表之间的节点</span></span><br><span class="line">l1 = l1.next;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">cursor.next = l2;</span><br><span class="line">l2 = l2.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新cursor指针用于扩展链表</span></span><br><span class="line">cursor = cursor.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>step3 确定循环执行条件的表达式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 当表达式的值为true时，循环执行；</span></span><br><span class="line"><span class="comment">// 2 循环的作用：为新链表连接一个新节点，并且做一些方便连接下一个节点的操作</span></span><br><span class="line"><span class="comment">// 3 当某个链表的节点用尽时，应该终止循环：因为这时候不再需要进行节点间的比较</span></span><br><span class="line"><span class="comment">// 4 链表节点用尽的情况：l1 == null、l2 == null</span></span><br><span class="line"><span class="comment">// 这两种情况之间的逻辑关系是什么？只要有一个成立，循环就应该终止。对应地，为了让循环执行，应该两者都不为null aka l1 != null &amp;&amp; l2 != null</span></span><br><span class="line"><span class="keyword">while</span>(l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>)&#123; ... &#125;  <span class="comment">// this is truly a piece of work</span></span><br></pre></td></tr></table></figure><p>step4 处理某个原始链表中没有添加进新链表的节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为什么出现节点没有被添加的情况？ 因为另外一个链表中的节点已经用完了，它里面的节点值都比较小</span></span><br><span class="line"><span class="comment">// 如何确定是哪一个链表的节点没有被用完？ 没有被用完的链表指针不为null</span></span><br><span class="line"><span class="comment">// 如何处理没有被添加的节点？ 直接连接到新链表中即可 找对节点</span></span><br><span class="line"><span class="comment">// 这时候最好边看着操作图，边编写代码 因为某些边界条件很容易弄错</span></span><br><span class="line"><span class="keyword">if</span>(l1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">    cursor.next = l2;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span>(l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">    cursor.next = l1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>step5 返回创建的新链表的头节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> dummy.next;</span><br></pre></td></tr></table></figure><p>step6 编写基础测试用例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">main()&#123;</span><br><span class="line"><span class="comment">// 测试用例代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>step7 添加鲁棒性代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 鲁棒性代码一般添加在开始的地方，来对参数进行校验</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>until next time😄</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;合并两个有序链表，得到一个新的有序链表（迭代方式）&quot;&gt;&lt;a href=&quot;#合并两个有序链表，得到一个新的有序链表（迭代方式）&quot; class=&quot;headerlink&quot; title=&quot;合并两个有序链表，得到一个新的有序链表（迭代方式）&quot;&gt;&lt;/a&gt;合并两个有序链表，得到一个新的有序链表（迭代方式）&lt;/h3&gt;</summary>
    
    
    
    <category term="ListNode" scheme="https://henryinshanghai.github.io/categories/ListNode/"/>
    
    
    <category term="Algorithm" scheme="https://henryinshanghai.github.io/tags/Algorithm/"/>
    
    <category term="LinkedList" scheme="https://henryinshanghai.github.io/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>翻转链表_02_2</title>
    <link href="https://henryinshanghai.github.io/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E9%93%BE%E8%A1%A8%E7%BF%BB%E8%BD%AC%E4%B9%8B%E9%80%92%E5%BD%92%E8%A7%A3%E6%B3%95_02_2.html"/>
    <id>https://henryinshanghai.github.io/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E9%93%BE%E8%A1%A8%E7%BF%BB%E8%BD%AC%E4%B9%8B%E9%80%92%E5%BD%92%E8%A7%A3%E6%B3%95_02_2.html</id>
    <published>2020-08-16T06:00:00.000Z</published>
    <updated>2020-08-17T09:22:20.065Z</updated>
    
    <content type="html"><![CDATA[<h3 id="链表翻转之递归解法"><a href="#链表翻转之递归解法" class="headerlink" title="链表翻转之递归解法"></a>链表翻转之递归解法</h3><a id="more"></a><hr><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>并不是所有的情况都能使用递归解决，能用递归解决的问题需要有两个特征：</p><ul><li>1 能够通过某种方式把问题的规模变小；</li><li>2 对于1中更小规模的问题，可以使用同样的操作去处理它；</li></ul><p>现在先看看“翻转链表”这样的操作是不是符合上面的两个特征：</p><h5 id="能够通过某种方式把问题的规模变小"><a href="#能够通过某种方式把问题的规模变小" class="headerlink" title="能够通过某种方式把问题的规模变小"></a>能够通过某种方式把问题的规模变小</h5><p>由于链表本身就是递归的结构，所以总是可以把链表分为：头节点head + 剩余节点所组成的链表rest；</p><h5 id="对于更小规模的问题，可以使用同样的操作去处理它"><a href="#对于更小规模的问题，可以使用同样的操作去处理它" class="headerlink" title="对于更小规模的问题，可以使用同样的操作去处理它"></a>对于更小规模的问题，可以使用同样的操作去处理它</h5><p>在对rest做翻转操作后，我们就能得到一个已经翻转了的链表。接下来就只要想办法把头节点head连接进来即可</p><hr><h4 id="使用递归的三部曲"><a href="#使用递归的三部曲" class="headerlink" title="使用递归的三部曲"></a>使用递归的三部曲</h4><ul><li><p>1 明确方法的作用与返回值；</p></li><li><p>2 找到递归的终结条件——这个条件会停止递归，并开始弹出调用栈；</p></li><li><p>3 确定本级递归需要完成的工作；（这时候要假设已经有了功能可用的API给自己调用）</p></li></ul><p>注：一般而言，递归方法可以按照这3步来编写。但不尽然，有些递归方法的实现可能会surprise us</p><hr><h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 0 作用：翻转指定的链表，并返回链表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1 递归的终结条件</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 本级递归需要做的事情</span></span><br><span class="line">        <span class="comment">// ① 把链表视为：头节点 + 剩下节点组成的链表rest</span></span><br><span class="line">        <span class="comment">// ② 对rest中的节点执行翻转操作————翻转后，rest指向新链表的头节点</span></span><br><span class="line">        ListNode rest = reverseList(head.next);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ③ 把原始的头节点连接到新链表的尾节点</span></span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rest;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><h4 id="代码重现"><a href="#代码重现" class="headerlink" title="代码重现"></a>代码重现</h4><blockquote><p>step0 画个图，理清思路；需要什么东西，应该做怎样的操作；</p></blockquote><p><img src="https://s1.ax1x.com/2020/08/11/aOaGT0.md.jpg" alt="递归下的链表"></p><blockquote><p>step1 确定方法的作用与返回值；</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法作用：翻转链表，并返回翻转后的链表；</span></span><br></pre></td></tr></table></figure><blockquote><p>step2 编写递归终结条件；</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现翻转链表的最简情况是什么？ 答：空链表或者只有一个节点的链表</span></span><br><span class="line"><span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head; <span class="comment">// 这两种情况可以分开写，一起写只是为了让代码简洁一些</span></span><br></pre></td></tr></table></figure><blockquote><p>step3 本级递归需要做的事情；</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">① 把链表拆分为：头节点head + 剩下的节点所组成的链表rest;</span></span><br><span class="line"><span class="comment">② 对rest链表执行“翻转”操作————翻转后的链表头节点为旧链表的尾节点；</span></span><br><span class="line"><span class="comment">③ 处理head节点与rest链表，使得整个链表中的所有节点都被翻转；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 对rest链表执行“翻转”操作</span></span><br><span class="line">ListNode rest = reverseList(head.next);</span><br><span class="line"><span class="comment">// 把head节点添加到rest链表的末尾</span></span><br><span class="line">head.next.next = head;</span><br><span class="line"><span class="comment">// 为head连接一个null——表示链表结束</span></span><br><span class="line">head.next = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><h4 id="测试用例（检查代码功能与代码的健壮性）"><a href="#测试用例（检查代码功能与代码的健壮性）" class="headerlink" title="测试用例（检查代码功能与代码的健壮性）"></a>测试用例（检查代码功能与代码的健壮性）</h4><ul><li>极端情况下，功能是否正常工作； 传入的链表为空/只有一个节点</li></ul><h4 id="启示"><a href="#启示" class="headerlink" title="启示"></a>启示</h4><p>链表节点之间的关系，最好画张图比较容易弄清楚。</p><p>比如“把head连接到rest链表的末尾”这一步，刚开始我是想沿着链表找到rest的尾节点，然后再连接到head</p><p>但如果画图就能看出来，获取rest链表尾节点可以用head.next；</p><p>拆解一下head.next.next = head;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取到rest的尾节点</span></span><br><span class="line">ListNode lastOfRest = head.next;</span><br><span class="line"><span class="comment">// 把获取到的尾节点连接到head上</span></span><br><span class="line">lastOfRest.next = head;</span><br><span class="line"><span class="comment">// 把head连接到一个null这一步必须有，否则head与lastOfRest节点之间就会有环出现 这会导致报错</span></span><br><span class="line">head.next = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><blockquote><p>until next time 😄</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;链表翻转之递归解法&quot;&gt;&lt;a href=&quot;#链表翻转之递归解法&quot; class=&quot;headerlink&quot; title=&quot;链表翻转之递归解法&quot;&gt;&lt;/a&gt;链表翻转之递归解法&lt;/h3&gt;</summary>
    
    
    
    <category term="ListNode" scheme="https://henryinshanghai.github.io/categories/ListNode/"/>
    
    
    <category term="Algorithm" scheme="https://henryinshanghai.github.io/tags/Algorithm/"/>
    
    <category term="LinkedList" scheme="https://henryinshanghai.github.io/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>交换链表节点_02_1</title>
    <link href="https://henryinshanghai.github.io/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E5%AF%B9%E9%93%BE%E8%A1%A8%E8%BF%9B%E8%A1%8C%E7%BF%BB%E8%BD%AC(%E8%BF%AD%E4%BB%A3%E6%96%B9%E5%BC%8F)_02_1.html"/>
    <id>https://henryinshanghai.github.io/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E5%AF%B9%E9%93%BE%E8%A1%A8%E8%BF%9B%E8%A1%8C%E7%BF%BB%E8%BD%AC(%E8%BF%AD%E4%BB%A3%E6%96%B9%E5%BC%8F)_02_1.html</id>
    <published>2020-08-16T05:30:00.000Z</published>
    <updated>2020-08-17T09:22:49.088Z</updated>
    
    <content type="html"><![CDATA[<h3 id="对链表进行翻转（使用迭代的方式）"><a href="#对链表进行翻转（使用迭代的方式）" class="headerlink" title="对链表进行翻转（使用迭代的方式）"></a>对链表进行翻转（使用迭代的方式）</h3><hr><p><img src="https://s1.ax1x.com/2020/08/11/aLKOne.png" alt="翻转链表"></p><a id="more"></a><hr><h3 id="分析-👇👇👇"><a href="#分析-👇👇👇" class="headerlink" title="分析:👇👇👇"></a>分析:👇👇👇</h3><h4 id="节点翻转示意图"><a href="#节点翻转示意图" class="headerlink" title="节点翻转示意图"></a>节点翻转示意图</h4><p><img src="https://s1.ax1x.com/2020/08/11/aL1MgP.md.jpg" alt="节点翻转示意图"></p><p>1 既然是要翻转链表，那每个节点的连接方向都会发生变化；</p><p>2 每个节点都只能有一个连接。当它指向自己的前一个节点时，它就不能再指向自己的下一个节点；</p><p>3 需要处理链表中的每一个节点，但是根据2可知，节点连接方向改变后，无法再沿着链表获取到下一个节点；</p><p>解决手段：在改变节点的连接方向之前，使用一个临时变量保存当前节点的下一个节点；</p><blockquote><p>实现SOP</p></blockquote><p>1 为了能够遍历链表，我们需要一个指针；</p><p>2 为了能够改变节点的连接方向，我们需要另一个指针来指向当前节点的前一个节点；</p><blockquote><p>完整代码(不包含测试用例，可以自己编写main()函数作为测试用例)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 链表/节点的类定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val; <span class="comment">// 节点中存储的值</span></span><br><span class="line">    ListNode next; <span class="comment">// 节点连接到的下一个节点</span></span><br><span class="line">    ListNode(<span class="keyword">int</span> x) &#123;val = x;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 0 作用：翻转指定的链表，并返回链表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 迭代的方式</span></span><br><span class="line">        ListNode prev = <span class="keyword">null</span>; </span><br><span class="line">        ListNode curr = head; <span class="comment">// 翻转链表需要前后两个指针：一个用于更新头节点，一个用于创建链表的连接</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 记录原始的下一个节点 防止链表断掉</span></span><br><span class="line">            ListNode temp = curr.next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 建立链表的连接</span></span><br><span class="line">            curr.next = prev;</span><br><span class="line">            <span class="comment">// 更新两个指针</span></span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="实现过程☕☕☕"><a href="#实现过程☕☕☕" class="headerlink" title="实现过程☕☕☕"></a>实现过程☕☕☕</h3><h4 id="step1-定义两个指针，用来遍历和翻转链表；"><a href="#step1-定义两个指针，用来遍历和翻转链表；" class="headerlink" title="step1 定义两个指针，用来遍历和翻转链表；"></a>step1 定义两个指针，用来遍历和翻转链表；</h4><p>问题：如何初始化这两个指针？/这两个指针最开始应该指向什么位置？</p><p>答：参考上面的 [链表翻转示意图](#### 节点翻转示意图)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ListNode prev = <span class="keyword">null</span>; <span class="comment">// 初始化指向一个null节点</span></span><br><span class="line">ListNode curr = head; <span class="comment">// 初始化指向链表的头节点（head与curr一样，都是头节点的一个指针）</span></span><br></pre></td></tr></table></figure><h4 id="step2-遍历链表中的节点，并进行节点间的翻转；（每次翻转两个节点的连接）"><a href="#step2-遍历链表中的节点，并进行节点间的翻转；（每次翻转两个节点的连接）" class="headerlink" title="step2 遍历链表中的节点，并进行节点间的翻转；（每次翻转两个节点的连接）"></a>step2 遍历链表中的节点，并进行节点间的翻转；（每次翻转两个节点的连接）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123; <span class="comment">// 循环终止条件一般是比较容易出错的地方，所以放在最后再完成</span></span><br><span class="line"><span class="comment">// 1 保存当前节点的下一个节点作用：这样在遍历时才能直到下一个节点是哪一个</span></span><br><span class="line">    Node temp = curr.next;</span><br><span class="line">    <span class="comment">// 2 把当前节点连接到当前节点的前一个节点说明：这个相邻节点的关系需要手动维护</span></span><br><span class="line">    curr.next = prev;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3 维护相邻节点的关系作用：支持2</span></span><br><span class="line">    prev = curr;</span><br><span class="line">    <span class="comment">// 4 更新当前节点为当前节点的下一个节点作用：实现遍历链表操作</span></span><br><span class="line">    curr = curr.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="step3-确定循环终止条件"><a href="#step3-确定循环终止条件" class="headerlink" title="step3 确定循环终止条件"></a>step3 确定循环终止条件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">分析极端情况：</span></span><br><span class="line"><span class="comment">1 当前节点指针指向链表的尾节点（非null）时，还需要一次循环来翻转last与其上一个节点之间的连接方向；</span></span><br><span class="line"><span class="comment">2 当前节点指针指向null时，所有翻转都已经完成，循环结束；</span></span><br><span class="line"><span class="comment">所以循环终止条件为：curr == null;相应地，(表达式)就应该为curr != null</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">while</span>(curr != <span class="keyword">null</span>)&#123;...&#125;</span><br></pre></td></tr></table></figure><h4 id="step4-确定返回值"><a href="#step4-确定返回值" class="headerlink" title="step4 确定返回值"></a>step4 确定返回值</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原则：总是应该返回预期链表的头节点</span></span><br><span class="line"><span class="comment">// 手段：查看循环终止时，各个指针的指向情况翻转后链表的头节点应该是prev</span></span><br><span class="line"><span class="keyword">return</span> prev;</span><br></pre></td></tr></table></figure><hr><h3 id="代码重现-🦇🦇🦇"><a href="#代码重现-🦇🦇🦇" class="headerlink" title="代码重现 🦇🦇🦇"></a>代码重现 🦇🦇🦇</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    </span><br><span class="line">    ListNode(<span class="keyword">int</span> x)&#123; <span class="keyword">this</span>.val = x&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> <span class="title">Solution</span>(<span class="title">ListNode</span> <span class="title">head</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 定义两个指针并初始化作用：用于连接与遍历</span></span><br><span class="line">    ListNode prev = <span class="keyword">null</span>;</span><br><span class="line">    ListNode curr = head;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 开始遍历，并在遍历的过程中进行节点连接的翻转</span></span><br><span class="line">    <span class="keyword">while</span>(curr != <span class="keyword">null</span>)&#123; <span class="comment">// 循环执行条件</span></span><br><span class="line">        <span class="comment">// 记录当前节点（开始时是头节点）的下一个节点作用：实现遍历</span></span><br><span class="line">        ListNode temp = curr.next;</span><br><span class="line">        <span class="comment">// 更新当前节点的连接</span></span><br><span class="line">        curr.next = prev; <span class="comment">// 连接到前一个节点说明：需要维护这种节点的相邻关系</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 维护节点的相邻关系 &amp; 实现遍历</span></span><br><span class="line">        prev = curr; <span class="comment">// 1 把prev指向curr所指向的节点</span></span><br><span class="line">        curr = temp; <span class="comment">// 2 更新curr到链表的下一个节点由于节点的连接方向已经变化，所以不能使用curr.next 使用预先存储的节点temp</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回链表的头节点</span></span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="启示"><a href="#启示" class="headerlink" title="启示"></a>启示</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">知道为什么这么写后，才能把思路翻译成代码。不然就是在背代码了</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;对链表进行翻转（使用迭代的方式）&quot;&gt;&lt;a href=&quot;#对链表进行翻转（使用迭代的方式）&quot; class=&quot;headerlink&quot; title=&quot;对链表进行翻转（使用迭代的方式）&quot;&gt;&lt;/a&gt;对链表进行翻转（使用迭代的方式）&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/08/11/aLKOne.png&quot; alt=&quot;翻转链表&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="ListNode" scheme="https://henryinshanghai.github.io/categories/ListNode/"/>
    
    
    <category term="Algorithm" scheme="https://henryinshanghai.github.io/tags/Algorithm/"/>
    
    <category term="LinkedList" scheme="https://henryinshanghai.github.io/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>两个链表的交点_01</title>
    <link href="https://henryinshanghai.github.io/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E6%B1%82%E4%B8%A4%E4%B8%AA%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E4%BA%A4%E7%82%B9_01.html"/>
    <id>https://henryinshanghai.github.io/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E6%B1%82%E4%B8%A4%E4%B8%AA%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E4%BA%A4%E7%82%B9_01.html</id>
    <published>2020-08-16T05:00:00.000Z</published>
    <updated>2020-08-17T09:23:51.185Z</updated>
    
    <content type="html"><![CDATA[<h3 id="求两个相交链表的交点"><a href="#求两个相交链表的交点" class="headerlink" title="求两个相交链表的交点"></a>求两个相交链表的交点</h3><hr><p><img src="https://s1.ax1x.com/2020/08/11/aLZ7UP.png" alt="图片无法显示"></p><a id="more"></a><p><strong>要求</strong></p><ul><li>如果两个链表没有交点，返回null</li><li>返回结果后，两个链表必须仍保持原有的结构；</li><li>默认链表中不存在环；</li><li>尽量满足O(n)的时间复杂度与O(1)的空间复杂度。</li></ul><hr><p>思路：</p><p>既然两个链表有长度差异，计算出差出来的长度，想办法消除这个多余长度的影响。就可以一一比较节点了</p><p>手段SOP：</p><p>1 为两个链表的头节点分别添加一个指针；</p><p>2 计算出链表之间的长度差异，然后让较长的那个链表的游标向后移动等长的节点；</p><p>3.再让两个游标同步移动，并比较所指向节点是否相等。直到找到相等/相交的节点或者到达链表的末端</p><hr><p>把上述SOP翻译成代码：</p><ol><li>先定义表示链表的类型；</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以直接作为一个内部类与Solution类定义在同一个文件中</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x)&#123;</span><br><span class="line">        val = x;</span><br><span class="line">        next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>实现上述SOP（完整实现 + 分解动作）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123; <span class="comment">// 两个链表结构</span></span><br><span class="line">        <span class="comment">// 最优解法（目前）：1 先计算出两个链表直接的长度差距； 2 再使用两个前后指针解决问题</span></span><br><span class="line">        <span class="comment">// 原理：1 起点相同的两个人，沿同一个方向以相同的速度移动。每时每刻，两个人都在同一个位置上；</span></span><br><span class="line">        <span class="comment">// 2 当两个链表相遇时，节点就重合了</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 鲁棒性代码</span></span><br><span class="line">        <span class="keyword">if</span>(headA == <span class="keyword">null</span> || headB == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode cursorA = headA;</span><br><span class="line">        ListNode cursorB = headB;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算headA与headB的长度</span></span><br><span class="line">        <span class="keyword">int</span> lengthA = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cursorA!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            lengthA++;</span><br><span class="line">            cursorA = cursorA.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> lengthB = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cursorB!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            lengthB++;</span><br><span class="line">            cursorB = cursorB.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算出两个链表之间的距离差————这个就是哨兵指针需要前进的节点数</span></span><br><span class="line">        <span class="keyword">int</span> diff = lengthA - lengthB; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里问题来了，我们需要确定一个信息：哪个链表更长？（这样才能正确地设置指针）</span></span><br><span class="line">        <span class="comment">// 手段：先假设A更长，然后根据真实情况进行更新</span></span><br><span class="line">        ListNode fronter = headA;</span><br><span class="line">        ListNode follower = headB;</span><br><span class="line">        <span class="keyword">if</span>(diff &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            fronter = headB;</span><br><span class="line">            follower = headA;</span><br><span class="line"></span><br><span class="line">            diff = lengthB - lengthA;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 让fronter指针先向前走diff个节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; diff; i++)&#123;</span><br><span class="line">            fronter = fronter.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 让fronter和follwer同时沿着节点先前移动，并比较节点是否为同一个节点</span></span><br><span class="line">        ListNode firstCommon = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(follower != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fronter == follower)&#123;</span><br><span class="line">                firstCommon = fronter;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fronter = fronter.next;</span><br><span class="line">            follower = follower.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> firstCommon;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>分解实现过程</li></ol><p>step1 定义两个指针，分别指向两个链表的头节点；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ListNode cursorA = headA;</span><br><span class="line">ListNode cursorB = headB;</span><br></pre></td></tr></table></figure><p>step2 计算headA链表与headB链表的长度；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> lengthA = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(cursorA != <span class="keyword">null</span>)&#123;</span><br><span class="line">lengthA++;</span><br><span class="line">cursorA = cursorA.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> lengthB = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(cursorB != <span class="keyword">null</span>)&#123;</span><br><span class="line">lengthB++;</span><br><span class="line">cursorB = cursorB.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>step3 计算两个链表之间的节点数量差;这个值就是长链表的指针需要前进的距离</p><blockquote><p>问题来了，怎么知道哪个链表更长呢？为了向前移动指针，一定需要一个正数；</p><p>手段：先绑定值，再通过判断来更新值；（其实就是if/else）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> diff = lengthA - lengthB;</span><br><span class="line"></span><br><span class="line">ListNode fronter = headA;</span><br><span class="line">ListNode follower = headB;</span><br><span class="line"><span class="keyword">if</span>(diff &lt; <span class="number">0</span>)&#123;</span><br><span class="line">fronter = headB;</span><br><span class="line">follower = headA;</span><br><span class="line"></span><br><span class="line">diff = lengthB - lengthA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>step4 把长链表的指针沿着链表向前移动diff个节点；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 让fronter指针先向前走diff个节点</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; diff; i++)&#123;</span><br><span class="line">   fronter = fronter.next;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>step5 同时移动长链表的指针fronter与短链表的指针follower，并比较指针指向的节点是否是同一个节点；</p><p>直到（这个循环终止的条件）：1 找到了两个链表的第一个交点； 2 迭代到了链表的尾部，没有任何交点；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ListNode firstCommon = <span class="keyword">null</span>; <span class="comment">// 用于存储找到的第一个节点</span></span><br><span class="line"><span class="keyword">while</span>(fronter != <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(fronter == follower)&#123;</span><br><span class="line">firstCommon = fronter;</span><br><span class="line"><span class="keyword">break</span>; <span class="comment">// 找到了第一个交点</span></span><br><span class="line">&#125;</span><br><span class="line">fronter = fronter.next;</span><br><span class="line">follower = follower.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>step6 把找到的交点节点返回；（如果没有交点，firstCommon的值不会被更新，也就是为null）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> firstCommon;</span><br></pre></td></tr></table></figure><p>step7 检查所有的变量名拼写；（在编辑器没有智能提示的情况下，拼写很容易出错）</p><p>step8 添加鲁棒性代码，增强代码的健壮性；最常见的就是参数判空</p><blockquote><p>启示：虽然把所有的成员变量写在一起看上去很规整，但是看代码的时候却不能重现写代码时的思路；</p><p>所以最好在需要变量的时候才添加这些变量，并且写在需要的地方。这会增加可读性</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;求两个相交链表的交点&quot;&gt;&lt;a href=&quot;#求两个相交链表的交点&quot; class=&quot;headerlink&quot; title=&quot;求两个相交链表的交点&quot;&gt;&lt;/a&gt;求两个相交链表的交点&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/08/11/aLZ7UP.png&quot; alt=&quot;图片无法显示&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="ListNode" scheme="https://henryinshanghai.github.io/categories/ListNode/"/>
    
    
    <category term="Algorithm" scheme="https://henryinshanghai.github.io/tags/Algorithm/"/>
    
    <category term="LinkedList" scheme="https://henryinshanghai.github.io/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>Spring Web应用第一谈（请求处理的中枢DispatcherServlet）</title>
    <link href="https://henryinshanghai.github.io/uncategorized/2020/05/17/Spring%20Web%E5%BA%94%E7%94%A8%E7%AC%AC%E4%B8%80%E8%B0%88%EF%BC%88%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E7%9A%84%E4%B8%AD%E6%9E%A2DispatcherServlet%EF%BC%89.html"/>
    <id>https://henryinshanghai.github.io/uncategorized/2020/05/17/Spring%20Web%E5%BA%94%E7%94%A8%E7%AC%AC%E4%B8%80%E8%B0%88%EF%BC%88%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E7%9A%84%E4%B8%AD%E6%9E%A2DispatcherServlet%EF%BC%89.html</id>
    <published>2020-05-17T15:29:34.973Z</published>
    <updated>2020-05-17T16:12:14.607Z</updated>
    
    <content type="html"><![CDATA[<p>Spring Web应用第一谈（请求处理的中枢DispatcherServlet）</p><hr><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Web应用？</span><br><span class="line">是：一个能够提供CURD功能的程序；</span><br><span class="line">作用：为用户提供服务；</span><br><span class="line">特征：</span><br><span class="line"><span class="number">1</span> 用户通过浏览器来访问应用中的功能；</span><br><span class="line"><span class="number">2</span> 程序需要运行在一个Web容器中（这样它才能被用户访问到）；</span><br><span class="line"><span class="number">3</span> 用户不需要安装任何东西，他只需要一个能够访问网络的浏览器；</span><br></pre></td></tr></table></figure><h4 id="1-SpringMVC框架对一个URL请求的处理流程"><a href="#1-SpringMVC框架对一个URL请求的处理流程" class="headerlink" title="1.SpringMVC框架对一个URL请求的处理流程"></a>1.SpringMVC框架对一个URL请求的处理流程</h4><hr><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SpringMVC处理URL请求的流程：</span><br><span class="line">1 请求发送给DispatcherServlet；</span><br><span class="line">作用：DS作为一个前端控制器，把请求委托给应用程序的其他组件</span><br><span class="line">2 DispatcherServlet查询处理器映射（<span class="keyword">Handler</span> <span class="keyword">Mapping</span>）来确定把请求发送给哪一个映射器(Hanlder)进行处理；</span><br><span class="line"></span><br><span class="line"><span class="number">3</span> 根据查询的结果，DS把请求发送给指定的映射器(<span class="keyword">Handler</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">4</span> 控制器把处理后的<span class="keyword">model</span>数据与视图名称(<span class="keyword">View</span>)发送给DS；</span><br><span class="line"></span><br><span class="line"><span class="number">5</span> DispatcherServlet使用视图解析器（ViewResolver）来通过视图名称找到对应的视图文件；</span><br><span class="line"></span><br><span class="line"><span class="number">6</span> DS把<span class="keyword">model</span>渲染到视图文件中，并最终返回到用户浏览器上;</span><br></pre></td></tr></table></figure><h5 id="Q1-不就是处理个请求吗？不应该最多两步吗？SpringMVC怎么一下搞了这么多有的没的，设计者是咋想的？-○´･д･-ﾉ"><a href="#Q1-不就是处理个请求吗？不应该最多两步吗？SpringMVC怎么一下搞了这么多有的没的，设计者是咋想的？-○´･д･-ﾉ" class="headerlink" title="#Q1 不就是处理个请求吗？不应该最多两步吗？SpringMVC怎么一下搞了这么多有的没的，设计者是咋想的？(○´･д･)ﾉ"></a>#Q1 不就是处理个请求吗？不应该最多两步吗？SpringMVC怎么一下搞了这么多有的没的，设计者是咋想的？(○´･д･)ﾉ</h5><h5 id="A1-DS其实在这个过程中，相当于是一个前端控制器。作用就是委托请求，有点子想Nginx"><a href="#A1-DS其实在这个过程中，相当于是一个前端控制器。作用就是委托请求，有点子想Nginx" class="headerlink" title="#A1 DS其实在这个过程中，相当于是一个前端控制器。作用就是委托请求，有点子想Nginx"></a>#A1 DS其实在这个过程中，相当于是一个前端控制器。作用就是委托请求，有点子想Nginx</h5><p>配张图，描述整个过程：</p><p>​    Web 请求 —&gt; DispatcherServlet - (!@#$%^)</p><hr><h4 id="2-创建SpringMVC的请求处理系统"><a href="#2-创建SpringMVC的请求处理系统" class="headerlink" title="2.创建SpringMVC的请求处理系统"></a>2.创建SpringMVC的请求处理系统</h4><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">--</span><br><span class="line"><span class="number">1</span> 配置DispatcherServlet；</span><br><span class="line">作用：把URL请求路由到具体的Spring组件中；</span><br><span class="line">手段<span class="number">1</span>：在web.xml中对DS进行配置</span><br><span class="line">手段<span class="number">2</span>：使用java类对DS进行配置（aka 在Servlet容器中声明前端控制器）</span><br><span class="line">参考：HelloWorldInitializer.java</span><br><span class="line"></span><br><span class="line">--</span><br><span class="line"><span class="number">2</span> 启用SpringMVC,并添加视图解析器的配置</span><br><span class="line">手段：添加注解@EnableWebMvc</span><br><span class="line">参考：WebConfig.java</span><br><span class="line"></span><br><span class="line"><span class="number">3</span> 创建管理其他非Web组件的上下文contextLoaderListener</span><br><span class="line">参考：RootConfig.java</span><br><span class="line"></span><br><span class="line">注：RootConfig先于WebConfig执行，所以：</span><br><span class="line"><span class="number">1</span> 预期交给WebConfig管理的组件需要在RootConfig中过滤掉；</span><br><span class="line"><span class="number">2</span> WebConfig中的Bean所依赖的组件可以在RootConfig中先行声明；</span><br></pre></td></tr></table></figure><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">说明：直接导入书上的源码到IDEA中运行会各种报错（百度无果的报错）；</span><br><span class="line">最终按照外网上的一个教程，搭建Web项目运行成功。</span><br><span class="line">参考链接：<span class="keyword">http</span>://websystique.com/springmvc/spring<span class="number">-4</span>-mvc-helloworld-tutorial-annotation-javaconfig-full-example/</span><br><span class="line"></span><br><span class="line">然后按照Spring实战书上的代码对项目进行更新，发现书上的代码是可以工作的。</span><br><span class="line">踩坑报错：xxx</span><br><span class="line">原因：一般测试某种手段是否可行时，我都会把原有文件拷贝一份，命名为xxx_backup.java。这样才测试方案不可行时能够快速恢复到初始状态。</span><br><span class="line">但是对Controller类来说，这种做法会导致<span class="built_in">URL</span>的歧义性</span><br><span class="line">参考:Servlet规范<span class="title">_05</span>(本地文件 如何引用？)</span><br><span class="line">引用：既然应用的上下文路径决定了Web应用中内容的<span class="built_in">URL</span>命名空间，Web容器必须要拒绝web应用定义一个在此<span class="built_in">URL</span>命名空间中可能导致冲突的上下文路径</span><br></pre></td></tr></table></figure><hr><h5 id="2-1-按照控制器的方式来对控制器进行测试"><a href="#2-1-按照控制器的方式来对控制器进行测试" class="headerlink" title="2.1 按照控制器的方式来对控制器进行测试"></a>2.1 按照控制器的方式来对控制器进行测试</h5><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">需求：按照控制器的方式来测试控制器：</span><br><span class="line">SOP：</span><br><span class="line">    <span class="number">1</span> 创建控制器对象；</span><br><span class="line">    手段：<span class="built_in">new</span></span><br><span class="line">    <span class="number">2</span> 创建SpringMvc mock对象；</span><br><span class="line">    手段：standaloneSetup(xxx).build()这是Spring框架test模块中的一个静态方法</span><br><span class="line">    <span class="number">3</span> 使用mock对象发起请求并验证响应结果；</span><br><span class="line">    手段：<span class="keyword">perform</span>()方法[执行] + andExcept()方法[断言预期结果]同样是test框架提供的方法</span><br><span class="line">特征：不需要启动Tomcat就能能够对控制器进行测试；</span><br><span class="line">参考：HomeControllerTest.java</span><br><span class="line">结果：报错“java.lang.NoSuchMethodError: org.springframework.util.StreamUtils.emptyInput()Ljava/io/InputStream;”</span><br><span class="line">解决参考：https://blog.csdn.net/weixin_30487317/article/details/<span class="number">95601425</span></span><br><span class="line">原因：test的版本与spring-mvc版本不一致</span><br><span class="line">解决手段：test的版本参考spring-mvc的版本</span><br></pre></td></tr></table></figure><hr><h5 id="2-2-把模型数据传递到视图中"><a href="#2-2-把模型数据传递到视图中" class="headerlink" title="2.2 把模型数据传递到视图中"></a>2.2 把模型数据传递到视图中</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">需求：把模型数据传递到视图中</span></span><br><span class="line"><span class="attr">SOP</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">1</span> <span class="string">定义用来与数据库交互的接口SpittleRepository；</span></span><br><span class="line">    <span class="attr">2</span> <span class="string">定义域数据表对应的实体类Spittle；</span></span><br><span class="line">    <span class="attr">3</span> <span class="string">编写针对于新的Controller控制器的测试类；</span></span><br><span class="line">    <span class="attr">参考：SpittleControllerTest.java</span></span><br><span class="line">    <span class="attr">4</span> <span class="string">编写新的控制器Controller</span></span><br><span class="line"><span class="attr">为什么先编写测试类，后编写控制器？？？😳</span></span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">编写完成后，重启Tomcat时，项目启动失败；</span><br><span class="line">报错：找不到指定的bean；</span><br><span class="line">原因：</span><br><span class="line">    原理：</span><br><span class="line">    Spring对不同类型的组件，创建的时机会不一样；</span><br><span class="line">        <span class="number">1</span> 对于Web相关的组件（aka 控制器对象），由DispatcherServlet所创建的上下文(WebConfig)管理；</span><br><span class="line">        <span class="number">2</span> 其他类型的组件（比如dao层的对象），由ContextLoaderListener所创建的上下文（RootConfig）进行管理；</span><br><span class="line">        <span class="number">3</span> RootConfig先于WebConfig执行，它服务于整个项目；</span><br><span class="line">    具体原因：</span><br><span class="line">        在RootConfig扫描的时候就扫描到controller中的类：</span><br><span class="line">            <span class="number">1</span> bean初始化就要找自动装填的 实现SpitterRepository接口的对象(A)，</span><br><span class="line">            <span class="number">2</span> 但我把A放在WebConfig里了，环境中找不到这个Bean，于是报错。</span><br><span class="line">        所以我在RootConfig中的ComponentScan里添加了过滤，不扫描spittr.web，这样controller中的bean就不会在NoSuchBean的情况下提前初始化了，启动成功。</span><br><span class="line">    同样的原因，SpittleRepository的声明应该放在RootConfig中，否则控制器初始化时也会找不到依赖Bean而报错</span><br><span class="line">参考：https:<span class="comment">//blog.csdn.net/q5738415/article/details/78197508</span></span><br></pre></td></tr></table></figure><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这里虽然有dao层的执行方法，但是却并没有配置数据库。它是怎么实现的呢？</span><br><span class="line"><span class="params">...</span> <span class="keyword">to</span> be continue <span class="params">...</span></span><br></pre></td></tr></table></figure><hr><h5 id="2-3-向控制器方法发送请求时携带参数"><a href="#2-3-向控制器方法发送请求时携带参数" class="headerlink" title="2.3 向控制器方法发送请求时携带参数"></a>2.3 向控制器方法发送请求时携带参数</h5><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">需求：向控制器发送请求时携带参数；</span><br><span class="line">参数类型（按功能分类）：</span><br><span class="line">    <span class="number">1</span> 查询参数；</span><br><span class="line">    <span class="number">2</span> 表单参数；</span><br><span class="line">    <span class="number">3</span> 路径变量；</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--</span></span><br><span class="line">1 控制器接收查询参数： /spittles/<span class="keyword">show</span>?spittle_id=<span class="number">12345</span></span><br><span class="line">需求：分页列表展示xxx</span><br><span class="line">手段：调用控制器方法时，传入两个参数————页面中第一个xxx的<span class="keyword">ID</span> + 页面中xxx的总条数；</span><br><span class="line">    <span class="keyword">before</span>参数：当前页面xxx列表的左边界；</span><br><span class="line">    <span class="keyword">count</span>参数：当前页面中要包含的xxx数量</span><br><span class="line">实现方法： com.websystique.springmvc.controller.SpittleController.spittles()方法</span><br><span class="line">测试:shouldShowPagedSpittles()</span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">--</span><br><span class="line"><span class="number">2</span> 控制器接收路径参数：/spittles/<span class="number">12345</span></span><br><span class="line">特征：</span><br><span class="line">    <span class="number">1</span> 这种描述方式更加面向资源：<span class="number">12345</span>就是要查询的资源</span><br><span class="line">    <span class="number">2</span> 查询参数的描述方式表示：这是一个带有参数的操作；（通过HTTP发起的RPC）</span><br><span class="line">-</span><br><span class="line">先编写测试方法：</span><br><span class="line">参考：testSpittle()</span><br><span class="line">测试方法fail？？？</span><br><span class="line"></span><br><span class="line">项目访问URL：失败<span class="number">400</span></span><br><span class="line">这都是因为热部署延迟 😳</span><br><span class="line"></span><br><span class="line">-</span><br><span class="line">进入方法后，跳转视图页面时。报错<span class="number">404.</span>..</span><br><span class="line">/spring_mvc/spittles/WEB-INF/views/spittle.jsp</span><br><span class="line">在其他的控制器方法中都可以正常跳转，为什么这个方法就不行？</span><br><span class="line">原因：在配置视图解析器时，没有添加前缀/</span><br><span class="line">参考：https:<span class="comment">//blog.csdn.net/xujin_chen/article/details/53557463</span></span><br><span class="line">原理：不晓得😵[又是半夜无眠]</span><br></pre></td></tr></table></figure><hr><h5 id="2-4-向控制器方法发送请求时携带表单参数"><a href="#2-4-向控制器方法发送请求时携带表单参数" class="headerlink" title="2.4 向控制器方法发送请求时携带表单参数"></a>2.4 向控制器方法发送请求时携带表单参数</h5><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">需求：向控制器发送请求时携带表单数据；</span><br><span class="line">实现手段：</span><br><span class="line">    <span class="number">1</span> 处理用户通过表单提交的数据；</span><br><span class="line">    参考：show<span class="constructor">RegistrationForm()</span>方法</span><br><span class="line">    完整流程SOP:</span><br><span class="line">        <span class="number">1</span> 编写控制器方法的测试方法：<span class="module-access"><span class="module"><span class="identifier">SpitterController</span>.</span></span>show<span class="constructor">RegistrationForm()</span></span><br><span class="line">        <span class="number">2</span> 编写视图文件；registerForm.jsp</span><br><span class="line">        <span class="number">3</span> 编写表单提交到的控制器方法 aka 保存表单的控制器方法；<span class="module-access"><span class="module"><span class="identifier">SpitterController</span>.</span></span>processRegistration</span><br><span class="line">        <span class="number">4</span> 编写保存表单的方法的测试方法：should<span class="constructor">ProcessRegistration()</span></span><br><span class="line">        <span class="number">5</span> 编写保存表单后所跳转到的控制器方法；  show<span class="constructor">SpitterProfile()</span></span><br><span class="line">        <span class="number">6</span> 编写控制器方法跳转到的对应页面：profile.jsp</span><br><span class="line">访问链接：http:<span class="comment">//localhost:8088/spring_mvc/spitter/jbauer</span></span><br></pre></td></tr></table></figure><hr><h5 id="2-5-对表单中的字段值进行校验"><a href="#2-5-对表单中的字段值进行校验" class="headerlink" title="2.5 对表单中的字段值进行校验"></a>2.5 对表单中的字段值进行校验</h5><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">需求：对表单中的字段值进行校验；</span><br><span class="line">校验类型：</span><br><span class="line">    <span class="number">1</span> 字段值不能为空；</span><br><span class="line">    <span class="number">2</span> 字段值的长度不能超过指定边界；</span><br><span class="line">手段<span class="number">1</span>：在控制方法中对用户提交的表单字段进行逐一验证；</span><br><span class="line">手段<span class="number">2</span>：java校验API接口（SpringMVC框架支持此接口）；</span><br><span class="line">具体方法SOP：</span><br><span class="line">    <span class="number">1</span> 在类路径下包含Java校验API接口的具体实现（比如Hibernate Validator）：</span><br><span class="line">        手段：引用jar包</span><br><span class="line">    <span class="number">2</span> 在java类的属性上添加所需要的注解；</span><br><span class="line">        手段：@NotNull、@Size</span><br><span class="line">    <span class="number">3</span> 在控制器方法中启用校验功能；</span><br><span class="line">        手段：为方法的POJO类型参数添加 @Valid 注解————通知Spring对此参数进行校验；</span><br><span class="line">    <span class="number">4</span> 在控制器方法中处理校验未通过的错误</span><br><span class="line">        手段：使用Errors对象来获取到校验失败的具体信息；</span><br><span class="line">特征：</span><br><span class="line">    <span class="number">1</span> 即便校验没有通过，用户仍旧能够提交表单。aka 控制器方法仍旧会被调用</span><br><span class="line">    <span class="number">2</span> 为了使Errors对象能够获取到校验失败的信息，需要让Errors参数紧跟在@Valid注解的参数后面</span><br><span class="line">    <span class="number">3</span> 在控制器方法中，第一步就应该查看是否出现校验错误————如果校验有错，后面的逻辑就不用再执行了</span><br><span class="line">参考：SpitterController.processRegistration()</span><br></pre></td></tr></table></figure><hr><h5 id="2-6-java校验API"><a href="#2-6-java校验API" class="headerlink" title="2.6 java校验API"></a>2.6 java校验API</h5><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Java校验API：</span><br><span class="line">作用：对Java类的属性进行校验；</span><br><span class="line">手段：提供多个用于特定校验规则的注解；</span><br><span class="line">用法：把特定的注解放到属性上，就能够限制属性的值。</span><br><span class="line">特征：所有的这些个注解都在javax.validation.constraints包中提供；</span><br><span class="line">常用的校验注解：</span><br><span class="line">    <span class="symbol">@NotNull</span>：限制被注解的属性的值不能为<span class="literal">null</span></span><br><span class="line">    <span class="symbol">@Size</span>：限制被注解的属性的值必须是<span class="built_in">String</span>、数组或者集合，并且长度要符合给定的范围；</span><br><span class="line">参考：Spitter类 （这是Spittr应用的用户）</span><br></pre></td></tr></table></figure><hr><h4 id="3-额外收获"><a href="#3-额外收获" class="headerlink" title="3.额外收获"></a>3.额外收获</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">有趣的点：</span></span><br><span class="line">    <span class="number">1</span> <span class="string">SpitterRepository接口的实现类是在WebConfig中配置Bean的时候实现的：</span></span><br><span class="line">        <span class="string">如果没提供这个实现类。创建Controller时注入依赖就会失败</span></span><br><span class="line">    <span class="number">2</span> <span class="string">这里的save()方法并没有把值存储到数据库中，而是添加到一个map对象中。</span></span><br><span class="line">        <span class="string">尽管对象会在每次重启JVM时消失，但是作为一个容器，它是可以当成临时数据库来使用的</span></span><br></pre></td></tr></table></figure><hr><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">小结：</span><br><span class="line">大需求：编写应用程序的Web部分；</span><br><span class="line">手段：使用SpringMVC框架（这是Spring框架的一个模块）；</span><br><span class="line">特征：</span><br><span class="line">    <span class="number">1</span> 这种开发方式几乎就是在写POJO类；</span><br><span class="line">    <span class="number">2</span> 编写控制器方法与编写普通java方法无异，唯一的区别在于————你要想办法让方法能够接收到页面发来的参数</span><br><span class="line">    <span class="number">3</span> SpringMVC编写的控制器非常容易测试；</span><br><span class="line">    手段：Mockito框架 + Spring test模块</span><br><span class="line">NexT？</span><br><span class="line">Spring视图相关的一堆东西</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Spring Web应用第一谈（请求处理的中枢DispatcherServlet）&lt;/p&gt;
&lt;hr&gt;
&lt;figure class=&quot;highlight angelscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;</summary>
      
    
    
    
    
  </entry>
  
</feed>
