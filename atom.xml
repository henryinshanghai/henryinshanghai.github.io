<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Henry&#39;s blog</title>
  
  <subtitle>focus works better than curiosity</subtitle>
  <link href="https://henryinshanghai.github.io/atom.xml" rel="self"/>
  
  <link href="https://henryinshanghai.github.io/"/>
  <updated>2020-09-17T12:57:09.943Z</updated>
  <id>https://henryinshanghai.github.io/</id>
  
  <author>
    <name>henryInSH</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>验证一棵二叉树是否是二叉搜索树</title>
    <link href="https://henryinshanghai.github.io/Binary-Search-Tree/2020/09/17/%E7%AE%97%E6%B3%95/%E6%A0%91/20200917-%E9%AA%8C%E8%AF%81%E4%B8%80%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%A0%91%E6%98%AF%E5%90%A6%E6%98%AF%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html"/>
    <id>https://henryinshanghai.github.io/Binary-Search-Tree/2020/09/17/%E7%AE%97%E6%B3%95/%E6%A0%91/20200917-%E9%AA%8C%E8%AF%81%E4%B8%80%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%A0%91%E6%98%AF%E5%90%A6%E6%98%AF%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html</id>
    <published>2020-09-17T06:30:00.000Z</published>
    <updated>2020-09-17T12:57:09.943Z</updated>
    
    <content type="html"><![CDATA[<h4 id="LeetCode-98-验证一棵树是否是二叉搜索树"><a href="#LeetCode-98-验证一棵树是否是二叉搜索树" class="headerlink" title="LeetCode#98 验证一棵树是否是二叉搜索树"></a>LeetCode#98 验证一棵树是否是二叉搜索树</h4><h5 id="题设与要求"><a href="#题设与要求" class="headerlink" title="题设与要求"></a>题设与要求</h5><a id="more"></a><p><img src="https://s1.ax1x.com/2020/09/17/wfibon.png" alt="题设与要求"></p><h5 id="分析题目难点-amp-提出解决手段"><a href="#分析题目难点-amp-提出解决手段" class="headerlink" title="分析题目难点 &amp; 提出解决手段"></a>分析题目难点 &amp; 提出解决手段</h5><blockquote><p>什么是有效的二叉搜索树？</p><p>特征：</p><ul><li>1 左子树中的节点小于当前节点；</li><li>2 右子树中的节点大于当前节点；</li><li>3 左右子树都是BST；</li></ul></blockquote><blockquote><p>怎么能判断一棵树是不是同时满足这3条性质？</p><ul><li>左右子树都是BST；<ul><li>手段：在左右子树上递归调用用来判断的方法；</li></ul></li><li>左子树中的节点小于当前节点； &amp;&amp; 右子树中的节点大于当前节点；<ul><li>手段：对二叉树进行中序遍历（左 - 根 - 右），中序遍历时，判断当前节点是不是总大于上一个节点即可；</li></ul></li></ul></blockquote><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><ul><li>1 准备一个变量，记录<strong>中序遍历序列中的上一个节点的值</strong>；</li><li>2 定义一个递归方法isValidBST(),方法作用：判断指定的二叉树是否为BST；<ul><li>2-1 定义递归终结条件；</li><li>2-2 定义本级递归需要做的事情；<ul><li>实现中序遍历，通过比较当前节点与<strong>序列中的前一个节点</strong>的值来判断是否满足特性1、2；</li><li>在左右子树上递归调用isValidBST(),以此来判断是否满足特性3；</li></ul></li></ul></li></ul><h5 id="把思路翻译成代码"><a href="#把思路翻译成代码" class="headerlink" title="把思路翻译成代码"></a>把思路翻译成代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 准备一个变量用于绑定“中序序列中前一个节点的值”</span></span><br><span class="line"><span class="comment">// 之所以使用long类型，是因为测试用例中使用了一些对应类型的数据</span></span><br><span class="line"><span class="keyword">long</span> pre = Long.MIN_VALUE; <span class="comment">// -2的63次方</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归方法作用：判断给定的二叉树是不是BST，并返回布尔值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1 递归终结条件</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2 本级递归需要做的事情</span></span><br><span class="line">    <span class="comment">// 2-1 实现中序遍历：左节点 - 根节点 - 右节点</span></span><br><span class="line">    <span class="comment">// 左节点root.left;对于左节点，判断左节点是否是一个BST</span></span><br><span class="line">   <span class="keyword">if</span>(!isValidBST(root.left))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根节点（当前节点）对于当前节点，比较它与序列中的上一个节点的值，以判断二叉树是不是一个BST</span></span><br><span class="line">    <span class="keyword">if</span>(root.val &lt;= pre)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用当前节点来更新pre：中序序列中的前一个节点的值</span></span><br><span class="line">    pre = root.val;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> isValidBST(root.right); <span class="comment">// 三个特性都已经被判断，完满完成任务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="代码拆解SOP"><a href="#代码拆解SOP" class="headerlink" title="代码拆解SOP"></a>代码拆解SOP</h5><blockquote><p>1 以中序遍历规则遍历二叉树中的节点</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中序遍历规则: 左节点 - 根节点 - 右节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 左节点</span></span><br><span class="line">something(root.left);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根节点/当前节点</span></span><br><span class="line">    somethingElse(root);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 右节点</span></span><br><span class="line">    somethingOtherElse(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：<strong>以前序遍历的规则来执行遍历</strong>更像是一个执行框架；</p><blockquote><p>2 判断左右子树是否为BST；</p><p>手段：在左右子树上调用isValidBST()进行判断；</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 左子树</span></span><br><span class="line"><span class="keyword">if</span>(!isValidBST(root.left))&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 右子树</span></span><br><span class="line"><span class="keyword">if</span>(!isValidBST(root.right))&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="comment">// 这里其实可以简化为: return isValidBST(root.right);因为代码的判断已经结束了</span></span><br></pre></td></tr></table></figure><blockquote><p>3 比较当前节点与序列中的前一个节点值的大小（判断是否为升序）；</p><p>手段：使用一个变量pre来记录“前一个节点的值”；</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> pre = Long.MIN_VALUE; <span class="comment">// 使用long类型是因为测试用例中有这种类型的数据这里取long类型的最小值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 当前节点</span></span><br><span class="line"><span class="keyword">if</span>(root.val &lt; pre)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用当前节点的值来更新pre的值作用：使pre变量一直绑定“上一个被处理的节点的值（aka 序列中上一个节点的值）”</span></span><br><span class="line">    pre = root.val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="代码重现"><a href="#代码重现" class="headerlink" title="代码重现"></a>代码重现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> pre = Long.MIN_VALUE;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 递归终结条件 &amp; 鲁棒性代码</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 本级递归需要做的事情</span></span><br><span class="line"><span class="comment">// 1 按照中序遍历的规则处理二叉树中的节点</span></span><br><span class="line">    <span class="comment">// root.left;</span></span><br><span class="line">    <span class="keyword">if</span>(!isValidBST(root.left))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// root;</span></span><br><span class="line">    <span class="keyword">if</span>(root.val &lt;= pre)&#123; <span class="comment">// 注：根据BST的规则，这里要包含等号</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pre = root.val;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// root.right;</span></span><br><span class="line">    <span class="keyword">return</span> isValidBST(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="启示-技巧"><a href="#启示-技巧" class="headerlink" title="启示/技巧"></a>启示/技巧</h5><p>对于<strong>多个条件同时成立</strong>时才能得出的判断结果（boolean类型），这里的<strong>多个条件</strong>都是<strong>必要条件</strong>。</p><p>在进行判断逻辑时，<strong>应该逐一判断违反规则导致false的情况</strong>。</p><p>当所有违反规则的情况都被排除后，就可以放心地返回true了；</p><blockquote><p>alright, this is henry. until next time 😄</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;LeetCode-98-验证一棵树是否是二叉搜索树&quot;&gt;&lt;a href=&quot;#LeetCode-98-验证一棵树是否是二叉搜索树&quot; class=&quot;headerlink&quot; title=&quot;LeetCode#98 验证一棵树是否是二叉搜索树&quot;&gt;&lt;/a&gt;LeetCode#98 验证一棵树是否是二叉搜索树&lt;/h4&gt;&lt;h5 id=&quot;题设与要求&quot;&gt;&lt;a href=&quot;#题设与要求&quot; class=&quot;headerlink&quot; title=&quot;题设与要求&quot;&gt;&lt;/a&gt;题设与要求&lt;/h5&gt;</summary>
    
    
    
    <category term="Binary Search Tree" scheme="https://henryinshanghai.github.io/categories/Binary-Search-Tree/"/>
    
    
    <category term="Algorithm" scheme="https://henryinshanghai.github.io/tags/Algorithm/"/>
    
    <category term="Binary Search Tree" scheme="https://henryinshanghai.github.io/tags/Binary-Search-Tree/"/>
    
  </entry>
  
  <entry>
    <title>计算二叉树的最大深度（递归写法）</title>
    <link href="https://henryinshanghai.github.io/Binary-Tree/2020/09/17/%E7%AE%97%E6%B3%95/%E6%A0%91/20200917-%E8%AE%A1%E7%AE%97%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6%EF%BC%88%E9%80%92%E5%BD%92%E5%86%99%E6%B3%95%EF%BC%89.html"/>
    <id>https://henryinshanghai.github.io/Binary-Tree/2020/09/17/%E7%AE%97%E6%B3%95/%E6%A0%91/20200917-%E8%AE%A1%E7%AE%97%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6%EF%BC%88%E9%80%92%E5%BD%92%E5%86%99%E6%B3%95%EF%BC%89.html</id>
    <published>2020-09-17T02:30:00.000Z</published>
    <updated>2020-09-17T12:49:18.393Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Leetcode-104-计算二叉树的最大深度"><a href="#Leetcode-104-计算二叉树的最大深度" class="headerlink" title="Leetcode#104 计算二叉树的最大深度"></a>Leetcode#104 计算二叉树的最大深度</h4><a id="more"></a><h5 id="题设与要求"><a href="#题设与要求" class="headerlink" title="题设与要求"></a>题设与要求</h5><p><img src="https://s1.ax1x.com/2020/09/17/wRTu0H.png" alt="题设与要求"></p><h5 id="分析难点-amp-提出解决手段"><a href="#分析难点-amp-提出解决手段" class="headerlink" title="分析难点 &amp; 提出解决手段"></a>分析难点 &amp; 提出解决手段</h5><blockquote><p>二叉树的深度到底是啥意思？</p><ul><li>1 从根节点到子节点会构成一条路径；</li><li>2 深度指的就是路径中节点的个数；</li><li>3 二叉树的最大深度：二叉树中存在的所有路径中，最长路径的节点个数；</li></ul></blockquote><blockquote><p>如何得到二叉树中的一条路径？</p><p>答：使用深度优先遍历，一头扎到底，直到遇到叶子节点时，就得到了一条完整的路径；</p></blockquote><blockquote><p>如何能从多个路径中找到最长路径？</p><p>手段1：在一个循环的过程中，不断更新最长路径maxLength；</p><p>手段2：利用二叉树结构本身的递归性，递归地处理左、右子树。然后加和出maxLength；</p></blockquote><h5 id="思路（递归）"><a href="#思路（递归）" class="headerlink" title="思路（递归）"></a>思路（递归）</h5><ul><li>1 定义一个方法，方法作用：计算给定的二叉树的最大深度并返回；</li><li>2 准备递归方法的递归终结条件 aka 递归调用触底返回的条件；</li><li>3 准备本级递归需要做的事情；<ul><li>1 在更小规模的二叉树中执行递归方法提供的操作；</li><li>2 利用1中的返回值来得到本级递归需要的返回值；</li></ul></li></ul><h5 id="把思路翻译成代码"><a href="#把思路翻译成代码" class="headerlink" title="把思路翻译成代码"></a>把思路翻译成代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 递归方法；作用：返回指定二叉树的最大深度</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line"><span class="comment">// 2 递归终结条件：当前节点为nil</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3 本级递归需要做的事情：</span></span><br><span class="line">    <span class="comment">// 3-1 对当前节点的左右子树求最大深度</span></span><br><span class="line">    <span class="keyword">int</span> leftDepth = maxDepth(root.left);</span><br><span class="line">    <span class="keyword">int</span> rightDepth = maxDepth(root.right);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3-2 使用子问题的结果来得到本级递归需要返回的值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + Math.max(leftDepth, rightDepth);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="几点疑问"><a href="#几点疑问" class="headerlink" title="几点疑问"></a>几点疑问</h5><ul><li><p>1 既然递归操作的终点是叶子节点（左右节点为nil），那么递归终结条件能不能改成:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><ul><li>这样写会导致空指针异常，因为传入的参数root可以为null；相当于代码不够鲁棒</li></ul></li><li><p>2 if(root == null) return 0; 具体表示什么含义？</p><ul><li>1 作为递归终结条件，aka，在当前节点为nil节点时，递归调用开始返回（<strong>这不是最外层调用的返回，而只是上一级调用开始返回</strong>）</li><li>2 作为鲁棒性代码，aka，处理方法参数为null的情况；</li></ul></li></ul><h5 id="代码重现"><a href="#代码重现" class="headerlink" title="代码重现"></a>代码重现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归方法作用：计算给定二叉树的最大深度并返回</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 递归终止条件/鲁棒性代码</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 本级递归要完成的事情</span></span><br><span class="line">    <span class="keyword">int</span> leftDepth = maxDepth(root.left);</span><br><span class="line">    <span class="keyword">int</span> rightDepth = maxDepth(root.right);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + Math.max(leftDepth, rightDepth);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>until next time,mate 😄</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;Leetcode-104-计算二叉树的最大深度&quot;&gt;&lt;a href=&quot;#Leetcode-104-计算二叉树的最大深度&quot; class=&quot;headerlink&quot; title=&quot;Leetcode#104 计算二叉树的最大深度&quot;&gt;&lt;/a&gt;Leetcode#104 计算二叉树的最大深度&lt;/h4&gt;</summary>
    
    
    
    <category term="Binary Tree" scheme="https://henryinshanghai.github.io/categories/Binary-Tree/"/>
    
    
    <category term="Algorithm" scheme="https://henryinshanghai.github.io/tags/Algorithm/"/>
    
    <category term="Binary Tree" scheme="https://henryinshanghai.github.io/tags/Binary-Tree/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的前序遍历（迭代方式）</title>
    <link href="https://henryinshanghai.github.io/Binary-Node/2020/09/16/%E7%AE%97%E6%B3%95/%E6%A0%91/20200916-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E8%BF%AD%E4%BB%A3%E6%96%B9%E5%BC%8F%EF%BC%89.html"/>
    <id>https://henryinshanghai.github.io/Binary-Node/2020/09/16/%E7%AE%97%E6%B3%95/%E6%A0%91/20200916-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E8%BF%AD%E4%BB%A3%E6%96%B9%E5%BC%8F%EF%BC%89.html</id>
    <published>2020-09-16T14:30:00.000Z</published>
    <updated>2020-09-16T16:13:39.484Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Leetcode-144-二叉树的前序遍历（迭代方式）"><a href="#Leetcode-144-二叉树的前序遍历（迭代方式）" class="headerlink" title="Leetcode#144 二叉树的前序遍历（迭代方式）"></a>Leetcode#144 二叉树的前序遍历（迭代方式）</h4><h5 id="题设与要求"><a href="#题设与要求" class="headerlink" title="题设与要求"></a>题设与要求</h5><a id="more"></a><p><img src="https://s1.ax1x.com/2020/09/16/w2qXjK.png" alt="题设与要求"></p><h5 id="分析问题难点-amp-提出解决手段"><a href="#分析问题难点-amp-提出解决手段" class="headerlink" title="分析问题难点 &amp; 提出解决手段"></a>分析问题难点 &amp; 提出解决手段</h5><blockquote><p>提出解决手段，有时候会需要giant leap😱</p></blockquote><blockquote><p>1 什么是二叉树的前序遍历？</p><p>答：以前序遍历的规则对二叉树这种非线性结构中的节点进行遍历；</p><p>前序遍历规则：对二叉树中的任意一棵子树，遍历的顺序总是—根节点、左节点、右节点；</p></blockquote><blockquote><p>2 如何才能按照这样的顺序来遍历树中的节点呢？</p><p>分析：因为遍历树中节点时，会有往回走的动作（aka 回溯），所以用栈结构应该可以实现</p><p>答：</p><ul><li>1 把当前节点存入一个栈中；</li><li>2 出栈当前节点，并按照特定顺序来入栈当前节点的子节点；</li><li>3 出栈预期的节点，并处理该节点的子节点（放到一个循环中进行）；</li></ul></blockquote><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><ul><li>0 准备一个列表，用于存储当前遍历的节点；</li><li>1 准备一个栈，用于安排遍历二叉树节点的顺序；</li><li>2 把当前节点先入栈；</li><li>3 准备一个循环（栈不为空时执行循环体 aka 仍旧有未被处理的节点），在循环体中：<ul><li>1 弹出栈顶元素；</li><li>2 把栈顶元素的值添加到列表中；</li><li>3 把当前节点的子节点按照特定顺序添加到栈中（以便在遍历节点时，满足<strong>前序遍历所要求的顺序</strong>）</li><li>4 重复1-2-3，直到所有的节点都处理完成</li></ul></li></ul><h5 id="把思路翻译成代码"><a href="#把思路翻译成代码" class="headerlink" title="把思路翻译成代码"></a>把思路翻译成代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123; <span class="comment">// 树节点</span></span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">    </span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">        root = stack.pop();</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 先入栈右节点，以便出栈时得到的是左节点</span></span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="keyword">null</span>)&#123; <span class="comment">// 这里一定要进行判空，否则可能会NPE</span></span><br><span class="line">            stack.push(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(root.left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注：其实就是N叉树前序遍历的一个变体啦</p></blockquote><blockquote><p>until next time 😄</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;Leetcode-144-二叉树的前序遍历（迭代方式）&quot;&gt;&lt;a href=&quot;#Leetcode-144-二叉树的前序遍历（迭代方式）&quot; class=&quot;headerlink&quot; title=&quot;Leetcode#144 二叉树的前序遍历（迭代方式）&quot;&gt;&lt;/a&gt;Leetcode#144 二叉树的前序遍历（迭代方式）&lt;/h4&gt;&lt;h5 id=&quot;题设与要求&quot;&gt;&lt;a href=&quot;#题设与要求&quot; class=&quot;headerlink&quot; title=&quot;题设与要求&quot;&gt;&lt;/a&gt;题设与要求&lt;/h5&gt;</summary>
    
    
    
    <category term="Binary Node" scheme="https://henryinshanghai.github.io/categories/Binary-Node/"/>
    
    
    <category term="Algorithm" scheme="https://henryinshanghai.github.io/tags/Algorithm/"/>
    
    <category term="Binary Node" scheme="https://henryinshanghai.github.io/tags/Binary-Node/"/>
    
  </entry>
  
  <entry>
    <title>N叉树的前序遍历（迭代方式）</title>
    <link href="https://henryinshanghai.github.io/Node/2020/09/16/%E7%AE%97%E6%B3%95/%E6%A0%91/20200916-N%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E8%BF%AD%E4%BB%A3%E6%96%B9%E5%BC%8F%EF%BC%89.html"/>
    <id>https://henryinshanghai.github.io/Node/2020/09/16/%E7%AE%97%E6%B3%95/%E6%A0%91/20200916-N%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E8%BF%AD%E4%BB%A3%E6%96%B9%E5%BC%8F%EF%BC%89.html</id>
    <published>2020-09-16T12:30:00.000Z</published>
    <updated>2020-09-16T16:13:49.497Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Leetcode-589-N叉树的前序遍历（迭代方式）"><a href="#Leetcode-589-N叉树的前序遍历（迭代方式）" class="headerlink" title="Leetcode#589    N叉树的前序遍历（迭代方式）"></a>Leetcode#589    N叉树的前序遍历（迭代方式）</h4><h5 id="题设与要求"><a href="#题设与要求" class="headerlink" title="题设与要求"></a>题设与要求</h5><a id="more"></a><p><img src="https://s1.ax1x.com/2020/09/16/w2T2LQ.png" alt="题设与要求"></p><h5 id="分析难点-amp-提出解决手段"><a href="#分析难点-amp-提出解决手段" class="headerlink" title="分析难点&amp;提出解决手段"></a>分析难点&amp;提出解决手段</h5><blockquote><p>1 什么是N叉树的前序遍历？</p><p>答： 根节点 - 左子节点 - 中间节点（从左往右） - 右子节点</p></blockquote><blockquote><p>2 如何能够<strong>按照前序遍历的规则</strong>来遍历这样一个<strong>非线性数据结构</strong>中的节点呢？</p><ul><li>前序遍历的规则：根节点 - 左节点-…-右节点；</li><li>非线性数据结构：数据结构中有分叉的情况，因此如果使用不同的遍历规则，就会得到不同的结果（这些结果都是合理存在的）</li></ul><p>答：</p><ul><li>1 把当前节点存入一个栈中；</li><li>2 出栈当前节点，并按照特定顺序来入栈当前节点的子节点；</li><li>3 出栈预期的节点，并处理该节点的子节点（放到一个循环中进行）；</li></ul></blockquote><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><ul><li><p>0 准备一个列表，用于在合适的位置存储节点；</p></li><li><p>1 准备一个栈，用于以特定顺序处理<strong>树结构中的节点</strong>；</p></li><li><p>2 把当前节点root入栈；</p></li><li><p>3 准备一个循环（栈不为空时执行循环体），在循环体中：</p><ul><li>1 出栈当前元素；</li><li>2 把当前元素的子节点以特定顺序入栈；</li><li>重复步骤12，以便按照预期的顺序来处理节点；</li></ul></li></ul><h5 id="把思路翻译成代码"><a href="#把思路翻译成代码" class="headerlink" title="把思路翻译成代码"></a>把思路翻译成代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Node类型的定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Node&gt; children;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> _val)</span> </span>&#123;</span><br><span class="line">        val = _val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> _val, List&lt;Node&gt; _children)</span> </span>&#123;</span><br><span class="line">        val = _val;</span><br><span class="line">        children = _children;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preOrder</span><span class="params">(Node root)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 准备一个列表</span></span><br><span class="line">List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 鲁棒性代码</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 准备一个栈</span></span><br><span class="line">    Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 准备一个循环</span></span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">        root = stack.pop(); <span class="comment">// 注：此处出栈的元素必须绑定到root变量上，否则会超时</span></span><br><span class="line">        </span><br><span class="line">        res.add(root.val);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 把当前节点的子节点按照特定顺序入栈</span></span><br><span class="line">        <span class="comment">// 先入栈右边的节点，最后入栈左节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=root.children.size()-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123; <span class="comment">// 从右往左遍历</span></span><br><span class="line">            stack.push(root.children.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="代码重现"><a href="#代码重现" class="headerlink" title="代码重现"></a>代码重现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preOrder</span><span class="params">(Node root)</span></span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">    </span><br><span class="line">    Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">        <span class="comment">// 当前节点</span></span><br><span class="line">        root = stack.pop();</span><br><span class="line">        <span class="comment">// 以特定顺序入栈当前节点的子节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = root.children.size()-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">         stack.push(root.children.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>alright here, until next time 😄</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;Leetcode-589-N叉树的前序遍历（迭代方式）&quot;&gt;&lt;a href=&quot;#Leetcode-589-N叉树的前序遍历（迭代方式）&quot; class=&quot;headerlink&quot; title=&quot;Leetcode#589    N叉树的前序遍历（迭代方式）&quot;&gt;&lt;/a&gt;Leetcode#589    N叉树的前序遍历（迭代方式）&lt;/h4&gt;&lt;h5 id=&quot;题设与要求&quot;&gt;&lt;a href=&quot;#题设与要求&quot; class=&quot;headerlink&quot; title=&quot;题设与要求&quot;&gt;&lt;/a&gt;题设与要求&lt;/h5&gt;</summary>
    
    
    
    <category term="Node" scheme="https://henryinshanghai.github.io/categories/Node/"/>
    
    
    <category term="Algorithm" scheme="https://henryinshanghai.github.io/tags/Algorithm/"/>
    
    <category term="Node" scheme="https://henryinshanghai.github.io/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>N叉树的前序遍历</title>
    <link href="https://henryinshanghai.github.io/Node/2020/09/16/%E7%AE%97%E6%B3%95/%E6%A0%91/20200916-N%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86(%E9%80%92%E5%BD%92%E6%96%B9%E5%BC%8F).html"/>
    <id>https://henryinshanghai.github.io/Node/2020/09/16/%E7%AE%97%E6%B3%95/%E6%A0%91/20200916-N%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86(%E9%80%92%E5%BD%92%E6%96%B9%E5%BC%8F).html</id>
    <published>2020-09-16T10:30:00.000Z</published>
    <updated>2020-09-16T16:14:05.124Z</updated>
    
    <content type="html"><![CDATA[<h4 id="对N叉树进行前序遍历（递归方式）"><a href="#对N叉树进行前序遍历（递归方式）" class="headerlink" title="对N叉树进行前序遍历（递归方式）"></a>对N叉树进行前序遍历（递归方式）</h4><h5 id="题设与要求"><a href="#题设与要求" class="headerlink" title="题设与要求"></a>题设与要求</h5><a id="more"></a><p><img src="C:%5CUsers%5CHenryInSH%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200916215515549.png" alt="题设与要求"></p><h5 id="分析题目的难点"><a href="#分析题目的难点" class="headerlink" title="分析题目的难点"></a>分析题目的难点</h5><blockquote><p>1 N叉树的前序遍历是到底是什么？</p><p>根据上面的题目示例，前序遍历 = 根节点 + 左节点 - … - 右节点；</p></blockquote><blockquote><p>2 要怎样才能以前序遍历的顺序遍历N叉树中的节点？</p><p>手段：深度优先遍历(DFS) + 递归调用（因为是在重复进行规模更小的问题）；</p></blockquote><blockquote><p>3 如何能够存储<strong>当前正在被遍历的节点</strong>？</p><p>手段：准备一个列表，在遍历时，把当前节点添加进去；</p></blockquote><h5 id="递归思路"><a href="#递归思路" class="headerlink" title="递归思路"></a>递归思路</h5><ul><li>1 先处理<strong>当前节点对应的子树</strong>；</li><li>2 然后依次遍历<strong>当前节点的子节点所对应的子树</strong>，并使用相同的方式来处理<strong>该子树中的节点</strong>；</li></ul><h5 id="把思路翻译成代码"><a href="#把思路翻译成代码" class="headerlink" title="把思路翻译成代码"></a>把思路翻译成代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// N叉树的定义（题目已给出）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Node&gt; children; <span class="comment">// 有一堆的孩子节点</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> _val)</span> </span>&#123;</span><br><span class="line">        val = _val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> _val, List&lt;Node&gt; _children)</span> </span>&#123;</span><br><span class="line">        val = _val;</span><br><span class="line">        children = _children;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编写的代码</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="comment">// 准备一个数组，用于存储当前正在被遍历的节点</span></span><br><span class="line">List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定义前序遍历函数</span></span><br><span class="line">    <span class="comment">// 作用：以前序遍历的规则对N叉树中的节点进行遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 递归终结条件; / 递归调用触底返回的条件</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根节点（当前节点）</span></span><br><span class="line">        res.add(root.val);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按照顺序来遍历根节点的孩子节点</span></span><br><span class="line">        <span class="keyword">for</span>(Node child:root.children)&#123;</span><br><span class="line">            <span class="comment">// 对当前子节点进行递归调用（以在更小的规模上做同样的事情）</span></span><br><span class="line">            preorder(child);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="代码拆解SOP"><a href="#代码拆解SOP" class="headerlink" title="代码拆解SOP"></a>代码拆解SOP</h5><blockquote><p>1 准备一个列表，用来存储当前正在被遍历的节点；</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure><blockquote><p>2 使用递归的方式实现preOrder()方法；</p><ul><li>作用：按照前序遍历的规则把N叉树中的节点添加到列表中，并返回列表；</li><li>递归的手段：<ul><li>1 递归终结条件（递归调用触底返回条件）/ 鲁棒性代码；</li><li>2 定义本级递归需要完成的工作；<ul><li>1 缩小问题的规模，并对小规模的问题进行同样的处理；</li><li>2 使用小规模问题的处理结果来解决大问题；</li></ul></li></ul></li></ul></blockquote><blockquote><p>01 递归终止条件；</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归终结条件/递归调用触底返回的条件</span></span><br><span class="line"><span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure><blockquote><p>02 本级递归要做的事情；</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历当前节点的所有子节点</span></span><br><span class="line"><span class="keyword">for</span>(Node child : root.children)&#123;</span><br><span class="line">    <span class="comment">// 对子节点所表示的N叉树执行前序遍历操作</span></span><br><span class="line">    preOrder(child);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>3 在本级递归结束后，返回res列表</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure><h5 id="代码重现"><a href="#代码重现" class="headerlink" title="代码重现"></a>代码重现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preOrder</span><span class="params">(Node root)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 递归终止条件</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 本级递归的工作</span></span><br><span class="line">    <span class="keyword">for</span>(Node child:root.children)&#123;</span><br><span class="line">        preOrder(child);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 本级递归调用结束后的返回值</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>until next time😄</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;对N叉树进行前序遍历（递归方式）&quot;&gt;&lt;a href=&quot;#对N叉树进行前序遍历（递归方式）&quot; class=&quot;headerlink&quot; title=&quot;对N叉树进行前序遍历（递归方式）&quot;&gt;&lt;/a&gt;对N叉树进行前序遍历（递归方式）&lt;/h4&gt;&lt;h5 id=&quot;题设与要求&quot;&gt;&lt;a href=&quot;#题设与要求&quot; class=&quot;headerlink&quot; title=&quot;题设与要求&quot;&gt;&lt;/a&gt;题设与要求&lt;/h5&gt;</summary>
    
    
    
    <category term="Node" scheme="https://henryinshanghai.github.io/categories/Node/"/>
    
    
    <category term="Algorithm" scheme="https://henryinshanghai.github.io/tags/Algorithm/"/>
    
    <category term="Node" scheme="https://henryinshanghai.github.io/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>盛水最多的容器</title>
    <link href="https://henryinshanghai.github.io/Array/2020/09/15/%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84/20200915-%E7%9B%9B%E6%B0%B4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AE%B9%E5%99%A8.html"/>
    <id>https://henryinshanghai.github.io/Array/2020/09/15/%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84/20200915-%E7%9B%9B%E6%B0%B4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AE%B9%E5%99%A8.html</id>
    <published>2020-09-15T10:30:00.000Z</published>
    <updated>2020-09-16T13:42:33.106Z</updated>
    
    <content type="html"><![CDATA[<h4 id="使用数组构造盛水最多的容器"><a href="#使用数组构造盛水最多的容器" class="headerlink" title="使用数组构造盛水最多的容器"></a>使用数组构造盛水最多的容器</h4><h5 id="题设与要求"><a href="#题设与要求" class="headerlink" title="题设与要求"></a>题设与要求</h5><a id="more"></a><p><img src="https://s1.ax1x.com/2020/09/15/w6GfeK.png" alt="题设与要求"></p><h5 id="分析要求（得到难点）"><a href="#分析要求（得到难点）" class="headerlink" title="分析要求（得到难点）"></a>分析要求（得到难点）</h5><blockquote><p>如何才能让容器盛放尽可能多的水呢？</p><p>分析：V = S * D;    S = length * height;</p><ul><li><p>获取到length；</p><p>手段：使用数组中两个指针来求取指针间距length；</p></li><li><p>获取到height；</p><p>手段：两个指针指向的元素值的较小者（因为面积是由短板决定的）</p></li></ul></blockquote><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><ul><li><p>1 准备两个指针i、j，分别指向数组的头元素&amp;尾元素；</p></li><li><p>2 计算当前数组元素所围成的界面面积，并作为当前Smax；</p></li><li><p>3 准备一个循环，在循环中：</p><ul><li>1 按照<strong>特定规则</strong>来更新指针i/指针j，以使得面积S尽可能变大；</li><li>2 使用新的界面面积与旧的截面面积比较，从而更新Smax；</li></ul><hr><p>循环结束时得到的Smax就是数组元素可能围成的界面面积的最大值；</p></li><li><p>4 返回这个最大值即可；</p></li></ul><h5 id="把思路翻译成代码"><a href="#把思路翻译成代码" class="headerlink" title="把思路翻译成代码"></a>把思路翻译成代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span></span>&#123; <span class="comment">// 参数：一个由挡板高度作为元素所组成的数组</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 准备两个指针作用：指向数组的头元素与尾元素</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = height.length - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 准备一个循环作用：计算面积的最大值</span></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)&#123; <span class="comment">// 循环次数不可预期，使用while循环</span></span><br><span class="line">        <span class="comment">// 用旧的res 与 新的res中的较大者来更新res</span></span><br><span class="line">        res = Math.max(res, (j - i) * Math.min(height[i], height[j]));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 更新指针</span></span><br><span class="line">        <span class="keyword">if</span>(height[i] &lt; height[j])&#123; <span class="comment">// 如果指针指向的是一个短板，移动另一个指针肯定不会让Smax更大</span></span><br><span class="line">            i++; <span class="comment">// 所以这里移动表示短板的指针</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>until next time 😄</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;使用数组构造盛水最多的容器&quot;&gt;&lt;a href=&quot;#使用数组构造盛水最多的容器&quot; class=&quot;headerlink&quot; title=&quot;使用数组构造盛水最多的容器&quot;&gt;&lt;/a&gt;使用数组构造盛水最多的容器&lt;/h4&gt;&lt;h5 id=&quot;题设与要求&quot;&gt;&lt;a href=&quot;#题设与要求&quot; class=&quot;headerlink&quot; title=&quot;题设与要求&quot;&gt;&lt;/a&gt;题设与要求&lt;/h5&gt;</summary>
    
    
    
    <category term="Array" scheme="https://henryinshanghai.github.io/categories/Array/"/>
    
    
    <category term="Algorithm" scheme="https://henryinshanghai.github.io/tags/Algorithm/"/>
    
    <category term="Array" scheme="https://henryinshanghai.github.io/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>删除数组中的重复项</title>
    <link href="https://henryinshanghai.github.io/Array/2020/09/15/%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84/20200915-%E5%88%A0%E9%99%A4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9.html"/>
    <id>https://henryinshanghai.github.io/Array/2020/09/15/%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84/20200915-%E5%88%A0%E9%99%A4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9.html</id>
    <published>2020-09-15T07:30:00.000Z</published>
    <updated>2020-09-16T16:15:30.500Z</updated>
    
    <content type="html"><![CDATA[<h4 id="删除数组中的重复项"><a href="#删除数组中的重复项" class="headerlink" title="删除数组中的重复项"></a>删除数组中的重复项</h4><h5 id="题设与要求"><a href="#题设与要求" class="headerlink" title="题设与要求"></a>题设与要求</h5><a id="more"></a><p><font size=2>没有找到截长图的好用工具，所以先用图片拼接吧</font></p><p><img src="https://s1.ax1x.com/2020/09/15/w6uQyD.png" alt="题设与要求"></p><p><img src="https://s1.ax1x.com/2020/09/15/w6uhXF.png" alt="示例2"></p><p><img src="https://s1.ax1x.com/2020/09/15/w6Km7j.png" alt="备注说明"></p><h5 id="分析（约束-与-难点）"><a href="#分析（约束-与-难点）" class="headerlink" title="分析（约束 与 难点）"></a>分析（约束 与 难点）</h5><ul><li>如何找到排序数组中的重复项？   <ul><li>在排序数组中，重复的项一定是相邻的。所以只需要比较相邻的两个元素是否相等即可</li></ul></li><li>找到重复的元素后，如何把元素删除掉？   <ul><li>数组中删除元素的方式就只有覆盖元素了</li></ul></li></ul><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><ul><li>1 先找到数组中的重复元素；<ul><li>手段：比较两个指针指向的元素是否相等（因为可能同一个元素多次重复出现）</li></ul></li><li>2 然后删除掉重复多余的元素；<ul><li>手段：当出现新的元素/不重复元素时，把新元素覆盖到正确的位置上；</li></ul></li><li>3 处理数组中剩余的元素；<ul><li>既然我们只是要返回不重复的有序元素，后面的元素保留即可（如果需要可以填充为null）</li></ul></li></ul><h5 id="把思路翻译成代码"><a href="#把思路翻译成代码" class="headerlink" title="把思路翻译成代码"></a>把思路翻译成代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 准备两个指针，这样能够对数组元素进行预期的比较</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指针j作为数组的遍历指针即可</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;nums.length; j++)&#123;</span><br><span class="line">        <span class="comment">// 比较两个元素是否相等</span></span><br><span class="line">        <span class="comment">// 如果相等，说明出现了重复元素，则...移动后指针即可：j++</span></span><br><span class="line">        <span class="keyword">if</span>(nums[i] == nums[j])&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果不相等,说明出现了新元素，则...把新元素绑定到/覆盖到正确的位置上</span></span><br><span class="line">            <span class="comment">// 手段：把后指针指向的元素覆盖到前指针位置的下一个位置</span></span><br><span class="line">            <span class="comment">// 把前指针后移一位</span></span><br><span class="line">            i++; </span><br><span class="line">            <span class="comment">// 把新元素绑定到正确的位置</span></span><br><span class="line">            nums[i] = nums[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回nums[]数组的前N个元素（不重复）组成的子数组的长度</span></span><br><span class="line">    <span class="keyword">return</span> i+<span class="number">1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="代码分解"><a href="#代码分解" class="headerlink" title="代码分解"></a>代码分解</h5><blockquote><p>1 找到重复的元素；</p><p>手段：使用两个指针，比较数组中相邻的元素；</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>; <span class="comment">// like an anchor</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; nums.length; j++)&#123;</span><br><span class="line">        <span class="comment">// 比较相邻的两个元素作用：找到重复的元素</span></span><br><span class="line">        <span class="keyword">if</span>(nums[i] == nums[j])&#123;</span><br><span class="line">            <span class="comment">// 找到重复元素之后，要怎么处理？</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>2 处理找到的重复元素；</p><p>手段：把重复元素后面的新元素覆盖到/绑定到正确的位置上；</p><p>特征：这并没有删除多余的重复元素，只是构造出了一个不重复元素的子数组；</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j &lt; nums.length; j++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums[j] == nums[i])&#123;</span><br><span class="line">        <span class="comment">// 只移动后指针即可 j++</span></span><br><span class="line">        <span class="comment">// 手段：跳过本次循环的其他代码</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 找到新的元素时...</span></span><br><span class="line">        <span class="comment">// 把新元素绑定到正确的位置</span></span><br><span class="line">        i++;</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// 循环结束后，会得到一个无重复元素的子数组</span></span><br></pre></td></tr></table></figure><blockquote><p>3 返回有序子数组的长度；</p><p>手段：使用指针i的值凑出子数组的长度len；</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> i+<span class="number">1</span>;</span><br></pre></td></tr></table></figure><h5 id="代码重现"><a href="#代码重现" class="headerlink" title="代码重现"></a>代码重现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 这个鲁棒性代码和 if(nums == null) return 0;有差别吗</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; nums.length; j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[j] == nums[i])&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i++;</span><br><span class="line">            nums[i] = nums[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> i+<span class="number">1</span>; <span class="comment">// 返回有序子数组的长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>until next time 😄</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;删除数组中的重复项&quot;&gt;&lt;a href=&quot;#删除数组中的重复项&quot; class=&quot;headerlink&quot; title=&quot;删除数组中的重复项&quot;&gt;&lt;/a&gt;删除数组中的重复项&lt;/h4&gt;&lt;h5 id=&quot;题设与要求&quot;&gt;&lt;a href=&quot;#题设与要求&quot; class=&quot;headerlink&quot; title=&quot;题设与要求&quot;&gt;&lt;/a&gt;题设与要求&lt;/h5&gt;</summary>
    
    
    
    <category term="Array" scheme="https://henryinshanghai.github.io/categories/Array/"/>
    
    
    <category term="Algorithm" scheme="https://henryinshanghai.github.io/tags/Algorithm/"/>
    
    <category term="Array" scheme="https://henryinshanghai.github.io/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>移动数组中的零到特定位置（双指针 + 交换操作）</title>
    <link href="https://henryinshanghai.github.io/Array/2020/09/15/%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84/20200915-%E7%A7%BB%E5%8A%A8%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%9B%B6%E5%88%B0%E7%89%B9%E5%AE%9A%E4%BD%8D%E7%BD%AE%EF%BC%88%E5%8F%8C%E6%8C%87%E9%92%88-+-%E4%BA%A4%E6%8D%A2%E6%93%8D%E4%BD%9C%EF%BC%89.html"/>
    <id>https://henryinshanghai.github.io/Array/2020/09/15/%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84/20200915-%E7%A7%BB%E5%8A%A8%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%9B%B6%E5%88%B0%E7%89%B9%E5%AE%9A%E4%BD%8D%E7%BD%AE%EF%BC%88%E5%8F%8C%E6%8C%87%E9%92%88-+-%E4%BA%A4%E6%8D%A2%E6%93%8D%E4%BD%9C%EF%BC%89.html</id>
    <published>2020-09-15T07:30:00.000Z</published>
    <updated>2020-09-15T11:13:06.848Z</updated>
    
    <content type="html"><![CDATA[<h4 id="把数组中所有的零元素移动到数组末尾"><a href="#把数组中所有的零元素移动到数组末尾" class="headerlink" title="把数组中所有的零元素移动到数组末尾"></a>把数组中所有的零元素移动到数组末尾</h4><h5 id="题设与要求"><a href="#题设与要求" class="headerlink" title="题设与要求"></a>题设与要求</h5><a id="more"></a><p><img src="https://s1.ax1x.com/2020/09/15/wyITmt.png" alt="题设与要求"></p><h5 id="分析（约束-amp-难点）"><a href="#分析（约束-amp-难点）" class="headerlink" title="分析（约束 &amp; 难点）"></a>分析（约束 &amp; 难点）</h5><ul><li><p>约束；</p><blockquote><p> 如何把0移动到数组末尾？</p></blockquote><blockquote><p>如何保持非零元素的相对顺序？</p></blockquote></li><li><p>难点；</p><blockquote><p>有可能用一个操作同时满足两个约束吗？</p><p>这时候需要使用具体考察一个测试用例[0, 1, 0, 3, 12]，否则操作的过程非常不清晰（除非你可以图形化的调试）</p></blockquote></li><li><p>手段；</p><ul><li>把非零元素与<strong>指针指向的元素</strong>进行交换；<ul><li>如果<strong>指针指向的元素</strong>为0，则：<ul><li>交换后，0元素就会被交换到数组的后面（它还可能被继续交换到数组更靠后的位置）；</li></ul></li><li>如果指针指向的元素不为0，则：<ul><li>交换操作等同于什么都没有做。</li></ul></li></ul></li><li>执行完成交换后，需要把两个指针都向后移动一个位置；</li></ul></li></ul><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><ul><li>1 准备两个指针：一个用于保持元素的相对顺序（anchor），一个用于遍历数组中的元素（explorer）；</li><li>2 对数组元素进行遍历，如果当前元素为非零元素，则：<ul><li>1 把当前元素与anchor指向的元素进行交换；<ul><li>作用：1 把非零元素绑定到了预期位置； 2 把0元素移动到了数组靠后的位置（这个0还可能继续向后移动）</li></ul></li><li>2 交换操作后，把anchor指针指向下一个位置；<ul><li>作用：使anchor指针指向<strong>非零元素预期被交换到的位置</strong>；</li></ul></li></ul></li></ul><blockquote><p>这个思路并不流畅，一点子都不流畅😳</p></blockquote><h5 id="把思路翻译成代码"><a href="#把思路翻译成代码" class="headerlink" title="把思路翻译成代码"></a>把思路翻译成代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeros</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 准备一个anchor指针；作用：指向非零元素预期被交换到的位置；</span></span><br><span class="line">    <span class="keyword">int</span> anchor = <span class="number">0</span>; <span class="comment">// 初始化指向数组的头元素；</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> explorer=<span class="number">0</span>; explorer &lt; nums.length; explorer++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[explorer] != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[anchor];</span><br><span class="line">            nums[anchor] = nums[explorer];</span><br><span class="line">            nums[explorer] = temp;</span><br><span class="line">            </span><br><span class="line">            anchor++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="添加鲁棒性代码"><a href="#添加鲁棒性代码" class="headerlink" title="添加鲁棒性代码"></a>添加鲁棒性代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(nums == <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="代码分解SOP"><a href="#代码分解SOP" class="headerlink" title="代码分解SOP"></a>代码分解SOP</h5><ul><li><p>1 准备anchor指针；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> anchor = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li><li><p>2 遍历数组元素，找到非零元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> explorer=<span class="number">0</span>; explorer &lt; nums.length; explorer++)&#123;</span><br><span class="line">    <span class="comment">// 找到非零元素...</span></span><br><span class="line">    <span class="keyword">if</span>(nums[explorer] != <span class="number">0</span>)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>找到非零元素后…</p><ul><li><p>1 把非零元素交换到预期的位置；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> temp = nums[explorer];</span><br><span class="line">nums[explorer] = nums[anchor];</span><br><span class="line">nums[anchor] = temp;</span><br></pre></td></tr></table></figure></li><li><p>2 把anchor指针移动到下一个位置；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">anchor++;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>遍历结束后，所有的非零元素都已经被交换到了预期位置，所有的0元素都已经被交换到了数组末尾；</p></li></ul><h5 id="代码重现"><a href="#代码重现" class="headerlink" title="代码重现"></a>代码重现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeros</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> anchor = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> explorer=<span class="number">0</span>; explorer &lt; nums.length; explorer++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[explorer] != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[explorer];</span><br><span class="line">            nums[explorer] = nums[anchor];</span><br><span class="line">            nums[anchor] = temp;</span><br><span class="line">            </span><br><span class="line">            anchor++;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>一个老年人可能对她的孙子有着令人讨厌的耐心，甚至各种苦口婆心也变成了叨叨叨 不听不听 和尚念经🐢</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;把数组中所有的零元素移动到数组末尾&quot;&gt;&lt;a href=&quot;#把数组中所有的零元素移动到数组末尾&quot; class=&quot;headerlink&quot; title=&quot;把数组中所有的零元素移动到数组末尾&quot;&gt;&lt;/a&gt;把数组中所有的零元素移动到数组末尾&lt;/h4&gt;&lt;h5 id=&quot;题设与要求&quot;&gt;&lt;a href=&quot;#题设与要求&quot; class=&quot;headerlink&quot; title=&quot;题设与要求&quot;&gt;&lt;/a&gt;题设与要求&lt;/h5&gt;</summary>
    
    
    
    <category term="Array" scheme="https://henryinshanghai.github.io/categories/Array/"/>
    
    
    <category term="Algorithm" scheme="https://henryinshanghai.github.io/tags/Algorithm/"/>
    
    <category term="Array" scheme="https://henryinshanghai.github.io/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>移动数组中的零到特定位置</title>
    <link href="https://henryinshanghai.github.io/Array/2020/09/15/%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84/20200915-%E7%A7%BB%E5%8A%A8%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%9B%B6%E5%88%B0%E7%89%B9%E5%AE%9A%E4%BD%8D%E7%BD%AE(%E5%8F%8C%E6%8C%87%E9%92%88+%E8%A6%86%E7%9B%96).html"/>
    <id>https://henryinshanghai.github.io/Array/2020/09/15/%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84/20200915-%E7%A7%BB%E5%8A%A8%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%9B%B6%E5%88%B0%E7%89%B9%E5%AE%9A%E4%BD%8D%E7%BD%AE(%E5%8F%8C%E6%8C%87%E9%92%88+%E8%A6%86%E7%9B%96).html</id>
    <published>2020-09-15T06:30:00.000Z</published>
    <updated>2020-09-15T09:49:07.518Z</updated>
    
    <content type="html"><![CDATA[<h4 id="把数组中所有的零都移动到数组尾部"><a href="#把数组中所有的零都移动到数组尾部" class="headerlink" title="把数组中所有的零都移动到数组尾部"></a>把数组中所有的零都移动到数组尾部</h4><h5 id="题设与要求"><a href="#题设与要求" class="headerlink" title="题设与要求"></a>题设与要求</h5><a id="more"></a><p><img src="https://s1.ax1x.com/2020/09/15/wyITmt.png" alt="题目与示例"></p><h5 id="分析出问题的难点"><a href="#分析出问题的难点" class="headerlink" title="分析出问题的难点"></a>分析出问题的难点</h5><blockquote><p>如何把0都移到数组的末尾？</p></blockquote><blockquote><p>如何能保持非零元素的相对顺序呢？</p></blockquote><blockquote><p>bear in mind:</p><p>对于一维数组这种数据结构，能够执行的操作有：</p><ul><li>遍历（需要一个指针）；</li><li>比较两个元素（需要两个指针）<ul><li>相邻元素；</li><li>指针指向的元素；</li></ul></li><li>交换两个位置上的元素</li></ul></blockquote><ul><li>手段1：<ul><li>1 依次找到所有的非零元素，然后<strong>向前覆盖</strong>到特定的位置（以<strong>保持非零元素的相对顺序</strong>）；</li><li>2 把数组中那些没有被覆盖的位置填充上0；</li></ul></li></ul><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><ul><li><p>1 定义一个循环，顺序遍历数组中的每一个元素（遍历数组需要提供一个指针cursor）；</p></li><li><p>2 准备另一个指针expect_cover，用于指向<strong>当前非零元素预期覆盖的位置</strong>；</p><ul><li>初始化指向<strong>数组的头元素</strong>；</li></ul></li><li><p>3 当遇到非零元素时，则：</p><ul><li>1 把非零元素覆盖到<strong>expect_cover指针指向的位置</strong>；</li><li>2 把expect_cover指向向后移动一个位置；</li></ul><hr><p>遍历/循环结束后，所有的非零元素就已经按照相对顺序被绑定到了预期的位置；</p></li><li><p>4 把expect_cover指针指向的位置（&amp;后面的所有位置）上的元素都绑定0；</p></li></ul><h5 id="把思路翻译成代码"><a href="#把思路翻译成代码" class="headerlink" title="把思路翻译成代码"></a>把思路翻译成代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 准备一个指针 expect_cover初始化指向数组的头元素  作用：指向非零元素要绑定到的位置</span></span><br><span class="line">    <span class="keyword">int</span> expect_cover = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 准备一个循环作用：遍历数组，找到其中的非零元素以执行需要的操作</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> cursor = <span class="number">0</span>; cursor &lt; nums.length; cursor++) &#123;</span><br><span class="line">        <span class="comment">// 如果当前元素是非零元素,则：</span></span><br><span class="line">        <span class="keyword">if</span>(nums[cursor] != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 把元素覆盖到指定的位置</span></span><br><span class="line">            nums[expect_cover++] = nums[cursor]; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">/* 循环结束后，指针j指向最后一个非零元素的下一个位置 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把从expect_cover指针到数组末尾的所有位置都绑定0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> cursor = expect_cover; cursor &lt; nums.length; cursor++) &#123;</span><br><span class="line">        nums[expect_cover++] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="添加鲁棒性代码"><a href="#添加鲁棒性代码" class="headerlink" title="添加鲁棒性代码"></a>添加鲁棒性代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 鲁棒性代码</span></span><br><span class="line"><span class="keyword">if</span>(nums==<span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="使用不同的测试用例检查代码的正确性-amp-健壮性"><a href="#使用不同的测试用例检查代码的正确性-amp-健壮性" class="headerlink" title="使用不同的测试用例检查代码的正确性&amp;健壮性"></a>使用不同的测试用例检查代码的正确性&amp;健壮性</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">现在好像没有特别好的方式（只能在leetcode编辑器的控制台上修改测试用例）</span><br><span class="line"><span class="comment">// 修改测试用例的建议</span></span><br><span class="line">    <span class="number">1</span> 为空的情况；</span><br><span class="line">    <span class="number">2</span> 元素重复的情况；</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><h5 id="代码重现"><a href="#代码重现" class="headerlink" title="代码重现"></a>代码重现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeros</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 鲁棒性代码</span></span><br><span class="line">    <span class="keyword">if</span>(nums == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 不用做任何操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 准备一个指针expect_cover作用：指向预期被当前非零元素覆盖的位置；</span></span><br><span class="line">    <span class="keyword">int</span> expect_cover = <span class="number">0</span>; <span class="comment">// 初始化指向数组的头元素</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 准备一个循环作用：找到非零元素，并把它们按顺序绑定到预期的位置</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> cursor=<span class="number">0</span>; cursor &lt; nums.length; cursor++)&#123;</span><br><span class="line">        <span class="comment">// 如果当前元素为非零元素，则...</span></span><br><span class="line">        <span class="keyword">if</span>(nums[cursor] != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 把该元素绑定到预期的位置：如果一开始就是非零元素，这里其实就做了自己绑定到自己的操作</span></span><br><span class="line">            nums[expect_cover++] = nums[cursor];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 把expect_cover指针开始的所有位置都绑定0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> cursor=expect_cover; cursor &lt; nums.length; cursor++)&#123;</span><br><span class="line">        nums[cursor] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;把数组中所有的零都移动到数组尾部&quot;&gt;&lt;a href=&quot;#把数组中所有的零都移动到数组尾部&quot; class=&quot;headerlink&quot; title=&quot;把数组中所有的零都移动到数组尾部&quot;&gt;&lt;/a&gt;把数组中所有的零都移动到数组尾部&lt;/h4&gt;&lt;h5 id=&quot;题设与要求&quot;&gt;&lt;a href=&quot;#题设与要求&quot; class=&quot;headerlink&quot; title=&quot;题设与要求&quot;&gt;&lt;/a&gt;题设与要求&lt;/h5&gt;</summary>
    
    
    
    <category term="Array" scheme="https://henryinshanghai.github.io/categories/Array/"/>
    
    
    <category term="Algorithm" scheme="https://henryinshanghai.github.io/tags/Algorithm/"/>
    
    <category term="Array" scheme="https://henryinshanghai.github.io/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>计算机基础（1）</title>
    <link href="https://henryinshanghai.github.io/Computer-Basic/2020/09/14/interview/20200914-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%EF%BC%881%EF%BC%89.html"/>
    <id>https://henryinshanghai.github.io/Computer-Basic/2020/09/14/interview/20200914-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%EF%BC%881%EF%BC%89.html</id>
    <published>2020-09-14T14:30:00.000Z</published>
    <updated>2020-09-14T14:58:20.770Z</updated>
    
    <content type="html"><![CDATA[<h5 id="计算机中数据的表示方式"><a href="#计算机中数据的表示方式" class="headerlink" title="计算机中数据的表示方式"></a>计算机中数据的表示方式</h5><a id="more"></a><blockquote><p>知识卡：在计算机中，数据是使用二进制进行表示的；</p><p>原因：</p><ul><li>1 计算机内部是由IC（集成电路）构成的；</li><li>2 IC的每个引脚，只能表示两种状态——二进制与IC的特性非常吻合😄；</li></ul><p>手段：IC的一个引脚表示二进制数中的一位bit（<strong>计算机中信息的最小单位</strong>）；</p><p>特征：</p><ul><li>1 二进制数字的位数一般是8的倍数；<ul><li>原因：计算机处理信息的基本单元是8位二进制数（一个字节）；</li><li>应用：内存和磁盘使用<strong>字节单位</strong>来读写数据；</li><li>用法：<ul><li>1 如果被处理的数字小于存储它所使用的字节空间，则：在数字的高位上补0；</li></ul></li></ul></li><li>2 不同的处理器的引脚数量不相同，因此一次能够处理的二进制数据的位数也就不同（比如奔腾32位处理器，一次就可以处理32位的二进制数信息 🚩 不太懂）</li></ul><p>结论：计算机中，使用二进制数来表示一切信息；</p></blockquote><blockquote><p>知识卡：数字的位权；</p><ul><li>是：特定<strong>位数上的数字</strong>所表示的实际权重； </li><li>作用：描述<strong>当前位数上的数字</strong>所表示的实际数值大小；</li><li>特征：<ul><li>1 数字所在的位数不同，数字的权重也就不同；</li><li>2 不同的进制下，特定位数的权重是不一样的；</li></ul></li><li>应用：<ul><li>计算<strong>特定进制下</strong>，某个<strong>数据表示方式</strong>所表示的<strong>实际数值大小</strong><ul><li>十进制下123的实际大小 = 1 × 100（数字1的位权） + 2 × 10（数字2的位权） + 3 × 1（数字3的位权）；</li></ul></li></ul></li></ul></blockquote><blockquote><p>知识卡：N进制；</p><ul><li>是：一种记录大数值的技术；</li><li>作用：表示大的数值；</li><li>特征：<ul><li>1 N进制的基数为N aka 如果一个位数上的数字达到了N，就会发生进位操作；</li><li>2 数值 = SUM(位上的数字 × 当前位数的权重)；</li></ul></li></ul></blockquote><h6 id="二进制中的运算规则"><a href="#二进制中的运算规则" class="headerlink" title="二进制中的运算规则"></a>二进制中的运算规则</h6><ul><li><p>常见的四则运算：加、减、乘除？？？</p></li><li><p>二进制中特有的运算：</p><ul><li><p>1 移位运算；</p><ul><li><p>作用：把二进制数值的各个数位进行移动（shift）；</p></li><li><p>特征：</p><ul><li><p>1 移动时有两个方向：向高位移动 + 向低位移动；</p></li><li><p>2 移位操作可以一次性移动多个数位；</p></li><li><p>3 可以直接对10进制数字进行移位操作，因为它的底层表示仍旧是二进制数；</p><hr></li><li><p>移动操作会导致一些位上的数字位空，怎么办？</p><ul><li>1 如果是向左移动，说明低权重的位会空出来，而高权重的位会溢出边界。则：<ul><li>给低权重的位数上补0；</li><li>把高权位的位数丢弃； </li></ul></li><li>2 如果是向右移动，说明高权重的位会空出来。则：<font size=2>有点子复杂，单独认识🚩<a href="#rightMove">跳转</a></font></li></ul></li></ul></li><li><p>用法/语法：待操作的数字 &lt;&lt; 预期移动的位数量；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">39</span>;</span><br><span class="line"><span class="keyword">int</span> b = a &lt;&lt; <span class="number">2</span>; <span class="comment">// 把39的二进制数值向左移动两个位置，然后把移位之后的结果绑定到变量b上</span></span><br></pre></td></tr></table></figure></li><li><p>应用：使用移位运算来代替乘法/除法；</p><ul><li>二进制数字左移一位，则其对应的十进制表示会变成原来的2倍；</li><li>二进制数字右移一位，则其对应的十进制表示会变成原来的1/2倍；</li></ul><p>由于CPU能够直接对二进制数字进行运算，所以移位运算的效率要比乘除法要高（CPU也不会计算乘除法😳）</p></li></ul></li></ul></li></ul><h6 id="二进制中，如何表示负数？"><a href="#二进制中，如何表示负数？" class="headerlink" title="二进制中，如何表示负数？"></a>二进制中，如何表示负数？</h6><ul><li><p>手段：把<strong>二进制数字的最高位</strong>作为<strong>符号位</strong>使用；</p></li><li><p>规则：</p><ul><li>1 符号位的数字是0时，表示正数；</li><li>2 符号位的数字是1时，表示负数；</li></ul></li><li><p>用法：</p><ul><li><p>任务：使用8位二进制数字来表示（-1）DEC;</p><ul><li><p>错误手段：</p><ul><li>1 把(1)DEC转化为其二进制表示(0000 0001)BIN;</li><li>2 为1中得到的二进制表示添加符号位，得到(1000 0001)BIN;</li></ul><p>原因：在表示负数时，需要使用<strong>二进制数字的补数</strong>；而不是单纯地添加一个符号位🌚</p><blockquote><p>知识卡：补数；</p><p>是：二进制中的一种性质；</p><p>作用：表示负数；</p><p>特征：</p><ul><li>它会使用正数来表示一个负数；（因为计算机只会做加法）；</li></ul><p>用法SOP：计算一个<strong>二进制数字的补数（用来表示负数）</strong>；</p><ul><li>1 把二进制数的各个数位上的数值全部取反；</li><li>2 把1中得到的结果+1；</li></ul><p>应用：<strong>求一个二进制数字的负数</strong>等价于<strong>求这个二进制数字的补数</strong>；</p></blockquote></li><li><p>正确手段：</p><ul><li><p>1 计算(-1)DEC的绝对值，得到(1)DEC；</p></li><li><p>2 求(1)DEC的补数，从而得到(-1)DEC的二进制表示；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把十进制的正数转化为二进制</span></span><br><span class="line">(<span class="number">1</span>)DEC = (<span class="number">0000</span> <span class="number">0001</span>)BIN</span><br><span class="line"><span class="comment">// 求二进制数字的补数</span></span><br><span class="line">Ⅰ 取反；</span><br><span class="line">(<span class="number">0000</span> <span class="number">0001</span>)BIN =&gt; (<span class="number">1111</span> <span class="number">1110</span>)BIN</span><br><span class="line">Ⅱ +<span class="number">1</span>；</span><br><span class="line">(<span class="number">1111</span> <span class="number">1110</span>)BIN + <span class="number">1</span> =&gt; (<span class="number">1111</span> <span class="number">1111</span>)BIN</span><br></pre></td></tr></table></figure><p>所以(-1)正确的二进制表示为(1111 1111)BIN;</p></li></ul></li></ul></li></ul></li><li><p>原理/证明其正确性：</p><ul><li><p>(1)DEC的二进制表示 与 (-1)DEC的二进制表示，相加的结果是否为0；</p><p>结论：当<strong>使用补数的方式来表示负数</strong>时，A + (-A) = 0这个表达式才是成立的；</p></li></ul></li></ul><blockquote><p>二进制数字的运算法则：</p><p>把二进制数字<strong>取反后加1</strong>（得到其补数）的结果，与原来的值相加，结果为0；</p><p>简言之，一个二进制数的负数形式其实就是它的补数；</p></blockquote><h6 id="在任何运算场景中，总是可以使用补数来表示一个负数吗？"><a href="#在任何运算场景中，总是可以使用补数来表示一个负数吗？" class="headerlink" title="在任何运算场景中，总是可以使用补数来表示一个负数吗？"></a>在任何运算场景中，总是可以使用补数来表示一个负数吗？</h6><ul><li><p>结论：是的；</p></li><li><p>特征：</p><ul><li>如果计算结果是负数，那么计算结果的值<strong>也是用补数形式来表示的</strong>；</li></ul></li><li><p>计算示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">任务：求(<span class="number">3</span> - <span class="number">5</span>)的二进制表示；</span><br><span class="line"><span class="number">1</span>. 把减法转化为加法；</span><br><span class="line">    （<span class="number">3</span> - <span class="number">5</span>） =&gt; (<span class="number">3</span> + (-<span class="number">5</span>))</span><br><span class="line"><span class="number">2</span>. 把十进制数转化为二进制数；</span><br><span class="line">    <span class="number">3</span>的二进制数字：<span class="number">0000</span> <span class="number">0011</span></span><br><span class="line">    (-<span class="number">5</span>)的二进制数字：</span><br><span class="line">    <span class="number">5</span>的二进制数字：<span class="number">0000</span> <span class="number">0101</span></span><br><span class="line">    (-<span class="number">5</span>)的二进制数字：<span class="number">1111</span> <span class="number">1011</span></span><br><span class="line"><span class="number">3</span> 对转化后的二进制数字执行加法运算；</span><br><span class="line">    (<span class="number">3</span> + (-<span class="number">5</span>)) &lt;=&gt; <span class="number">0000</span> <span class="number">0011</span> + <span class="number">1111</span> <span class="number">1011</span></span><br></pre></td></tr></table></figure></li></ul><h6 id="补数在编程语言中的应用？"><a href="#补数在编程语言中的应用？" class="headerlink" title="补数在编程语言中的应用？"></a>补数在编程语言中的应用？</h6><blockquote><p>知识卡：一个以1开头的二进制数总是负数吗？</p><p>答：No.只有在<strong>规定把第一个数位视为符号位</strong>时，以1开头的二进制数才会是一个负数；</p></blockquote><p>C语言中的整数数据类型：</p><ul><li><p>unsigned short类型；</p><ul><li>特征：<ul><li>1 不能够处理负数；</li><li>2 占用两个字节的内存空间；</li><li>3 所能够表示整数的数据范围：0~65535；</li></ul></li></ul></li><li><p>short类型；</p><ul><li>特征：<ul><li>1 能够处理负数；</li><li>2 占用两个字节的内存空间；</li><li>3 所能够表示的整数数据范围：-32768~32767；</li></ul></li></ul></li><li><p>原理：为什么特征上会有这些差异（① 能否表示负数？ ② 所能表示的整数的数据范围）</p><ul><li>1 是否把二进制数字的第一位作为符号位；<ul><li>unsigned short没有这么做，因此它只能够表示正整数；</li><li>short类型<strong>规定了二进制数字的第一位是符号位</strong>，所以它能够表示正整数 &amp; 负整数；</li></ul></li><li>2 数据类型占用的内存空间，决定了该数据类型能够表示多少种结果；<ul><li>两者都占据2个字节（16个bit），所以能够表示2的16次方个结果（65536）；</li></ul></li><li>3 short类型规定了符号位的存在，所以可以用补数来表示负数；<ul><li>1 最高位为0时（表示这是一个正数），可以使用剩下的15bit来表示数值。所以正数的范围为0~32767（共32768个结果 = 2的15次方）；</li><li>2 最高位为1时（表示这是一个负数），仍旧可以用剩下的15bit来表示数值。但是数值范围不需要包括0，所以负数的范围是-1~-32768(共32768个结果，不包含0)</li></ul></li></ul><h6 id="二进制数字的右移操作"><a href="#二进制数字的右移操作" class="headerlink" title="二进制数字的右移操作"></a>二进制数字的右移操作</h6></li></ul><p>二进制数字的应用：</p><ul><li><p>表示<strong>图形模式</strong>；</p><ul><li><p>这种情况下，进行右移操作时，就：只需要在移动后空出的高权重位上补0；</p></li><li><p>这种情况下的右移操作也叫做<strong>逻辑右移</strong>；</p><p><img src="https://s1.ax1x.com/2020/09/14/wr4Q7F.png" alt="逻辑右移，高位补零"></p></li></ul></li><li><p>表示<strong>带符号的数值</strong>；</p><ul><li><p>这种情况下，进行右移操作时，就：需要在移动后空出来的高权重位上补<strong>原始二进制数字符号位的值</strong>；</p><ul><li>如果原始的二进制数字为正数，则：在高权重位上补0；</li><li>如果原始的二进制数字为负数（补数表示），则：在高权重位上补1；</li></ul></li><li><p>这种情况下的右移操作也叫做<strong>算术移位</strong>；</p></li><li><p>应用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">任务：对(-<span class="number">4</span>)DEC执行算术右移，计算右移两位后的结果；</span><br><span class="line">预期：(-<span class="number">4</span>)右移两位后，得到的结果 = (-<span class="number">4</span>) * (<span class="number">1</span>/<span class="number">2</span>) * (<span class="number">1</span>/<span class="number">2</span>) = (-<span class="number">1</span>)DEC</span><br><span class="line">手段：按照算术移位的规则进行移位操作；</span><br><span class="line">SOP:</span><br><span class="line"><span class="number">1</span> 把(-<span class="number">4</span>)DEC转化为二进制数字；</span><br><span class="line">        <span class="number">4</span> =&gt; <span class="number">0000</span> <span class="number">0100</span></span><br><span class="line">        (-<span class="number">4</span>) =&gt; <span class="number">1111</span> <span class="number">1100</span></span><br><span class="line"><span class="number">2</span> 对<span class="number">1</span>中得到的二进制数字执行算术右移，移动<span class="number">2</span>位；</span><br><span class="line">        规则：在空出的高权重位上补<span class="string">"原始二进制数字符号位的值"</span>；</span><br><span class="line">        <span class="number">1111</span> <span class="number">1100</span> =&gt; (右移两位) xx11 <span class="number">1111</span> =&gt;(高权重位补“👆”) <span class="number">1111</span> <span class="number">1111</span></span><br><span class="line"><span class="number">3</span> 验证得到的二进制结果是否符合预期；</span><br><span class="line">        手段：把二进制数字转化为DEC进制数字；</span><br><span class="line">        注：这个二进制数字是规定了符号位的二进制数字；</span><br><span class="line">        具体方法（尝试）：求出补数的原始数值；</span><br><span class="line">        SOP:</span><br><span class="line"><span class="number">1</span> 减<span class="number">1</span>； <span class="number">1111</span> <span class="number">1111</span> - <span class="number">0000</span> <span class="number">0001</span> = <span class="number">1111</span> <span class="number">1110</span></span><br><span class="line"><span class="number">2</span> 取反；<span class="number">1111</span> <span class="number">1110</span> =&gt;(取反后) <span class="number">0000</span> <span class="number">0001</span></span><br><span class="line"><span class="number">3</span> 把计算结果转化为DEC进制；(<span class="number">0000</span> <span class="number">0001</span>)BIN = (<span class="number">1</span>)DEC</span><br><span class="line">SO:</span><br><span class="line">补数对应的原始数字为<span class="number">1</span>，说明补数表示的DEC数字为(-<span class="number">1</span>);</span><br><span class="line">结论：符合预期 😄；</span><br></pre></td></tr></table></figure><p>参考图示:<img src="https://s1.ax1x.com/2020/09/14/wrTAbV.png" alt="逻辑右移 VS 算术右移"></p></li></ul></li></ul><blockquote><p>只有在右移操作时，才需要考虑<strong>逻辑移位</strong>与<strong>算术移位</strong>的差别；</p><p>左移操作（图形模式下表示单纯地移动，数值模式下表示乘法）时，就：在空位补零即可；</p></blockquote><h6 id="把一个8位二进制数字表示成8-N位二进制数字？"><a href="#把一个8位二进制数字表示成8-N位二进制数字？" class="headerlink" title="把一个8位二进制数字表示成8*N位二进制数字？"></a>把一个8位二进制数字表示成8*N位二进制数字？</h6><ul><li>手段：符号位扩充；</li><li>作用：把二进制数字的位数转化为其他8的倍数；</li><li>用法：<ul><li>1 如果二进制数字是正数，则：用符号位0填充高权重的位即可；</li><li>2 如果二进制数字是负数（用补数表示），则：用符号位1填充高权重的位即可；</li></ul></li></ul><h6 id="计算机可以执行的运算"><a href="#计算机可以执行的运算" class="headerlink" title="计算机可以执行的运算"></a>计算机可以执行的运算</h6><ul><li>算术运算；<ul><li>是：加减乘除四则运算；</li><li>作用：按照特定的规则，操作得到预期的结果；</li><li>特征：<ul><li>与十进制数的加减乘除一样，也涉及到进位问题；</li></ul></li></ul></li><li>逻辑运算；<ul><li>是：一种操作；</li><li>作用：按照特定的规则，操作得到预期的结果；</li><li>特征：<ul><li>1 对二进制数各数字位的0或1会分别进行处理；</li><li>2 不存在进位的问题；</li><li>3 有4种具体的运算；<ul><li>1 逻辑非(NOT运算)；<ul><li>规则：0变1，1变0；</li></ul></li><li>2 逻辑与(AND运算)；<ul><li>规则：全1为1，否则为0；</li></ul></li><li>3 逻辑或(OR运算)；<ul><li>规则：有1为1，否则为0；</li></ul></li><li>4 逻辑异或(XOR运算 exclusive-or 独家的/不同的)；<ul><li>规则：不同为1，相同为0；</li></ul></li></ul></li></ul></li><li>技巧：<ul><li>1 逻辑运算中，<strong>二进制数表示的不是数值，而是一组ON/OFF开关</strong>；</li><li>2 逻辑运算真值表的规律；</li></ul></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h5 id=&quot;计算机中数据的表示方式&quot;&gt;&lt;a href=&quot;#计算机中数据的表示方式&quot; class=&quot;headerlink&quot; title=&quot;计算机中数据的表示方式&quot;&gt;&lt;/a&gt;计算机中数据的表示方式&lt;/h5&gt;</summary>
    
    
    
    <category term="Computer Basic" scheme="https://henryinshanghai.github.io/categories/Computer-Basic/"/>
    
    
    <category term="Computer stuff" scheme="https://henryinshanghai.github.io/tags/Computer-stuff/"/>
    
  </entry>
  
  <entry>
    <title>java基础之快速复习（5）</title>
    <link href="https://henryinshanghai.github.io/Java-Basic/2020/09/13/interview/20200913-java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BF%AB%E9%80%9F%E5%A4%8D%E4%B9%A0%EF%BC%885%EF%BC%89.html"/>
    <id>https://henryinshanghai.github.io/Java-Basic/2020/09/13/interview/20200913-java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BF%AB%E9%80%9F%E5%A4%8D%E4%B9%A0%EF%BC%885%EF%BC%89.html</id>
    <published>2020-09-13T14:30:00.000Z</published>
    <updated>2020-09-14T14:57:56.993Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Java基础速查"><a href="#Java基础速查" class="headerlink" title="Java基础速查"></a>Java基础速查</h4><h5 id="JDK中哈希操作"><a href="#JDK中哈希操作" class="headerlink" title="JDK中哈希操作"></a>JDK中哈希操作</h5><p>参考：<a href="https://juejin.im/post/6844903583255642120#heading-7">JDK中的哈希应用</a></p><a id="more"></a><blockquote><p>知识卡：哈希；</p><ul><li><p>是：一种技术；</p></li><li><p>作用：把任意长度的输入转化为固定长度的输出（哈希值）；</p></li><li><p>特征：</p><ul><li>1 相同的输入总是得到相同的输出；</li><li>2 不同的输入总是得到不同的输出（真实实现时无法保证 aka 碰撞）；</li></ul></li><li><p>手段：哈希函数；</p><ul><li>直接定址法：直接以<strong>关键字k或者k加上某个常数（k+c）</strong>作为哈希地址。</li><li>数字分析法：提取<strong>关键字中取值比较均匀的数字</strong>作为哈希地址。</li><li>除留余数法：用<strong>关键字k除以某个不大于哈希表长度m的数p</strong>，将所得余数作为哈希表地址。</li></ul><p>衡量哈希函数质量好坏的指标：1 发生碰撞的概率； 2 发生碰撞时的解决方案；</p><ul><li>哈希函数发生碰撞时，常用的解决手段：<ul><li>1 开放定址法；<ul><li>如果发生了冲突，就去寻找下一个空的散列地址；</li></ul></li><li>2 链地址法；<ul><li>如果发生冲突，就把新的键值对作为链表节点链接在已有的键值对后面；</li></ul></li></ul></li></ul></li></ul></blockquote><h6 id="HashMap存储键值对的过程"><a href="#HashMap存储键值对的过程" class="headerlink" title="HashMap存储键值对的过程"></a>HashMap存储键值对的过程</h6><ul><li>1 根据key-value中的key，找到键值对预期插入的哈希桶数组中的位置；</li><li>2 根据具体情况，把键值对插入到底层数据结构中；</li></ul><h6 id="根据key-value中的key来计算预期插入到的桶位置（Java8）"><a href="#根据key-value中的key来计算预期插入到的桶位置（Java8）" class="headerlink" title="根据key-value中的key来计算预期插入到的桶位置（Java8）"></a>根据key-value中的key来计算预期插入到的桶位置（Java8）</h6><p>SOP:</p><ul><li><p>1 根据key计算出一个哈希值；</p></li><li><p>2 根据哈希值与哈希桶数组的长度，计算得到预期插入的桶位置；</p><ul><li>代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>代码说明</p><ul><li><p>1 先使用key的hashCode()方法，得到一个最初版本的hash值（一个32位的数字）；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h = key.hashCode() <span class="comment">// hashCode()是Object类型的实例方法</span></span><br></pre></td></tr></table></figure></li><li><p>2 对1中得到的hash值执行无符号右移16位的操作；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h &gt;&gt;&gt; <span class="number">16</span> <span class="comment">// &gt;&gt;&gt;是无符号右移的操作符：忽略符号位，空位都用0补齐</span></span><br></pre></td></tr></table></figure></li><li><p>3 把1中计算得到的hash值与右移16位之后的结果，进行异或操作；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>)</span><br></pre></td></tr></table></figure><blockquote><p>作用(2+3)：最终减少哈希碰撞;</p><p>手段：把最初hash值的高16位与低16位异或，使得每一位的数字都能参与到<strong>桶位置的计算</strong>中；</p><p>原理：避免了<strong>虽然哈希值不同，但由于哈希值低位上的数字相同，而计算得到了相同的桶位置</strong>这种碰撞情况；</p></blockquote></li></ul></li></ul></li></ul><h5 id="Java中的基本数据类型（8种）"><a href="#Java中的基本数据类型（8种）" class="headerlink" title="Java中的基本数据类型（8种）"></a>Java中的基本数据类型（8种）</h5><h6 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h6><ul><li>1 整数类型；<ul><li><code>byte</code> - 8 位。<ul><li>数值范围：-128~127；</li></ul></li><li><code>short</code> - 16 位。</li><li><code>int</code> - 32 位。</li><li><code>long</code> - 64 位，赋值时一般在数字后加上 <code>l</code> 或 <code>L</code>。</li></ul></li><li>2 浮点型；<ul><li><code>float</code> - 32 位，直接赋值时必须在数字后加上 <code>f</code> 或 <code>F</code>。</li><li><code>double</code> - 64 位，赋值时一般在数字后加 <code>d</code> 或 <code>D</code> 。</li></ul></li><li>3 字符型；<ul><li><code>char</code> - 16 位，存储 Unicode 码，用单引号赋值。</li><li>数值范围：0~65535；</li></ul></li><li>4 布尔型；<ul><li><code>boolean</code> - 只有 true 和 false 两个取值。</li></ul></li></ul><h6 id="为什么long类型与double类型都是使用8字节内存，但是所能表示的数据范围却差别那么大呢？"><a href="#为什么long类型与double类型都是使用8字节内存，但是所能表示的数据范围却差别那么大呢？" class="headerlink" title="为什么long类型与double类型都是使用8字节内存，但是所能表示的数据范围却差别那么大呢？"></a>为什么long类型与double类型都是使用8字节内存，但是所能表示的数据范围却差别那么大呢？</h6><p>答：因为整数类型与浮点数类型在计算机中的底层表示是不一样的；</p><ul><li>整数类型long的底层存储方式；<ul><li>符号位（一个bit） + 数值位（63个bit）；</li></ul></li><li>浮点类型double的底层表示方式；<ul><li>符号位 + 指数位 + 尾数位；</li></ul></li></ul><h5 id="Base64编码"><a href="#Base64编码" class="headerlink" title="Base64编码"></a>Base64编码</h5><p>参考：<a href="https://www.cnblogs.com/linguanh/p/11205256.html">Base64编码过程</a></p><blockquote><p> 知识卡：编码</p><p>是：一种技术/一个过程；</p><p>作用：把信息转换成另一种形式，方便计算机进行处理；</p><p>手段：Basexxx编码；</p><p>原理：</p><ul><li>1 编码算法；</li><li>2 编码对照表格；</li></ul><p>特征：</p><ul><li>不同编码方式的基本原理都是相同的，主要差异在于：<ul><li>1 具体使用<strong>几位二进制数字</strong>来作为<strong>编码对照表的查找索引</strong>;</li><li>2 不同编码方式<strong>使用的编码对照表格</strong>各有不同；</li></ul></li></ul></blockquote><h6 id="流程SOP"><a href="#流程SOP" class="headerlink" title="流程SOP:"></a>流程SOP:</h6><ul><li>0 准备预期要被编码的字符串；</li><li>1 把字符串中的字符转化成Ascii编码表的数值；</li><li>2 把1中得到的数值转化为二进制数字（要求为8位的整数倍）；</li><li>3 根据BaseX编码算法中的<strong>获取查找索引的规则</strong>，把2中得到的二进制数字划分成一个个单元；</li><li>4 把3中得到的一个个单元转化为10进制数字；</li><li>5 使用4中得到的10进制数字作为<strong>编码对照表的查找索引</strong>，得到编码后的字符集合；</li></ul><h6 id="应用示例："><a href="#应用示例：" class="headerlink" title="应用示例："></a>应用示例：</h6><ul><li><p>任务：对原始字符串“ILU”按照Base16算法进行编码；</p></li><li><p>流程：</p><ul><li><p>1 把字符串中的字符转化成Ascii编码表的数值；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I = <span class="number">73</span>, L = <span class="number">76</span>, U = <span class="number">85</span></span><br></pre></td></tr></table></figure></li><li><p>2 把1中得到的数值转化为二进制数字（要求为8位的整数倍）；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">73</span> = <span class="number">01001001</span></span><br><span class="line"></span><br><span class="line"><span class="number">76</span> = <span class="number">01001100</span></span><br><span class="line"></span><br><span class="line"><span class="number">85</span> = <span class="number">01010101</span></span><br></pre></td></tr></table></figure></li><li><p>3 根据BaseX编码算法中的<strong>计算查找索引的规则</strong>，把2中得到的二进制数字划分成一个个单元；</p><blockquote><p>说明：Base16规定-使用4位二进制数字来计算查找索引</p></blockquote></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;Java基础速查&quot;&gt;&lt;a href=&quot;#Java基础速查&quot; class=&quot;headerlink&quot; title=&quot;Java基础速查&quot;&gt;&lt;/a&gt;Java基础速查&lt;/h4&gt;&lt;h5 id=&quot;JDK中哈希操作&quot;&gt;&lt;a href=&quot;#JDK中哈希操作&quot; class=&quot;headerlink&quot; title=&quot;JDK中哈希操作&quot;&gt;&lt;/a&gt;JDK中哈希操作&lt;/h5&gt;&lt;p&gt;参考：&lt;a href=&quot;https://juejin.im/post/6844903583255642120#heading-7&quot;&gt;JDK中的哈希应用&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Java Basic" scheme="https://henryinshanghai.github.io/categories/Java-Basic/"/>
    
    
    <category term="Java stuff" scheme="https://henryinshanghai.github.io/tags/Java-stuff/"/>
    
  </entry>
  
  <entry>
    <title>java基础之快速复习（4）</title>
    <link href="https://henryinshanghai.github.io/Java-Basic/2020/09/12/interview/20200912-java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BF%AB%E9%80%9F%E5%A4%8D%E4%B9%A0%EF%BC%884%EF%BC%89.html"/>
    <id>https://henryinshanghai.github.io/Java-Basic/2020/09/12/interview/20200912-java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BF%AB%E9%80%9F%E5%A4%8D%E4%B9%A0%EF%BC%884%EF%BC%89.html</id>
    <published>2020-09-12T02:30:00.000Z</published>
    <updated>2020-09-13T10:44:53.411Z</updated>
    
    <content type="html"><![CDATA[<h5 id="HashMap类型的resize-过程"><a href="#HashMap类型的resize-过程" class="headerlink" title="HashMap类型的resize()过程"></a>HashMap类型的resize()过程</h5><blockquote><p>这个其实在上次分析的时候就学了一遍，但是不够熟悉 所以没有答上来。再复习一波~</p></blockquote><p>参考：<a href="http://www.tianxiaobo.com/2018/01/18/HashMap-%E6%BA%90%E7%A0%81%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90-JDK1-8/#342-%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6">HashMap详解-田小波</a></p><a id="more"></a><h6 id="resize-方法SOP："><a href="#resize-方法SOP：" class="headerlink" title="resize()方法SOP："></a>resize()方法SOP：</h6><ul><li>1 计算新的<strong>哈希桶数组的容量newCap</strong>和<strong>新阈值newThr</strong>；<a href="#step1">跳转</a></li><li>2 根据1中计算出的newCap来<strong>创建新的哈希桶数组</strong>/<strong>对桶数组table进行初始化</strong>；<a href="#step2">跳转</a></li><li>3 把键值对重新映射到新的桶数组中（<strong>比较复杂</strong>）；<a href="#step3">跳转</a><ul><li>1 如果节点是树节点，则需要对红黑树进行拆分；【红黑树对象的split()方法】</li><li>2 如果节点是链表节点，则将节点按照原始顺序进行分组；【循环 + 重新映射】</li></ul></li></ul><h6 id="源码-SOP框架-："><a href="#源码-SOP框架-：" class="headerlink" title="源码(SOP框架)："></a>源码(SOP框架)：</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line"><span class="comment">/* Step1: 计算新的桶数组的容量newCap与阈值newThr */</span></span><br><span class="line">...</span><br><span class="line">threshold = newThr;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* step2: 根据计算出的newCap来得到新的桶数组newTab,并绑定到table引用上 */</span></span><br><span class="line">...</span><br><span class="line">table = newTab;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* step3:把旧的哈希桶数组中的键值对重新映射到新的哈希桶数组中 */</span></span><br><span class="line"><span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="源码拆解："><a href="#源码拆解：" class="headerlink" title="源码拆解："></a>源码拆解：</h6><ul><li><span id="step1">step1</span>：计算新哈希桶数组的容量newCap与新阈值newThr；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记录旧桶数组的容量与阈值</span></span><br><span class="line">Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">   <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">   <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">   <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">   <span class="comment">// 如果 table 不为空，表明已经初始化过了</span></span><br><span class="line">   <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="comment">// 当 table 容量超过容量最大值，则不再扩容</span></span><br><span class="line">       <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">           threshold = Integer.MAX_VALUE;</span><br><span class="line">           <span class="keyword">return</span> oldTab;</span><br><span class="line">       &#125; </span><br><span class="line">       <span class="comment">// 如果旧容量并没有超过最大容量，则:按旧容量和阈值的2倍计算新容量和阈值的大小</span></span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">           newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// 🚩注：这里计算newThr，可能会导致newThr的值为零（因为数值溢出）</span></span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// 如果旧的阈值大于0，说明“程序员在调用构造方法时指定了初始容量”，则：</span></span><br><span class="line">       <span class="comment">// 把“程序员指定的初始化容量”作为“新桶数组的容量”</span></span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 手段：把 threshold 的值绑定到 newCap（以作为新桶数组的容量）</span></span><br><span class="line"><span class="comment">        * 原理：HashMap()构造方法中，使用了threshold变量来暂时保 initialCapacity参数的值（🚩 参考id="helper" 😳）</span></span><br><span class="line"><span class="comment">        */</span> </span><br><span class="line">       newCap = oldThr;</span><br><span class="line">   <span class="keyword">else</span> &#123;  <span class="comment">// 如果旧的阈值为0，说明“程序员调用了默认的构造方法”，则:</span></span><br><span class="line">       <span class="comment">// 为newCap、newThr变量绑定默认值（默认容量、默认阈值）</span></span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 调用无参构造方法时，桶数组容量为默认容量，</span></span><br><span class="line"><span class="comment">        * 阈值为默认容量与默认负载因子乘积</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">       newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 如果newThr 为 0，说明：1 上面的if&#123;&#125;中没有更新newThr的值； 或者2在计算newThr发生了溢出，导致newThr的值为0。则</span></span><br><span class="line"><span class="comment">// 按“阈值计算公式”进行计算；公式：阈值 = 容量 * 负载因子</span></span><br><span class="line">   <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">       <span class="comment">// 从两个值中取一个绑定到newThr</span></span><br><span class="line">       newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                 (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把计算得到的newThr绑定到全局变量threshold上</span></span><br><span class="line">   threshold = newThr;</span><br></pre></td></tr></table></figure><blockquote><p>🚩 程序员调用了有初始容量的构造方法时…</p><p><span id="helper">辅助代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 参数判空</span></span><br><span class="line">    ...</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// 把程序员指定的初始容量调整后绑定到了threshold变量上（暂存initialCapacity）</span></span><br><span class="line">        <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>计算新容量与新阈值的代码说明：</p></blockquote><ul><li><p>如果旧哈希桶的容量大于0，说明“哈希桶已经初始化过了”。则：</p><ul><li>尝试使用旧容量&amp;旧阈值的2倍来更新newCap&newThr;<ul><li>1 判断容量是否已经到达最大容量MAXIMUM_CAPACITY，如果是，直接返回旧的哈希桶数组；</li><li>2 如果旧容量没有到达最大容量MAXIMUM_CAPACITY，则：<ul><li>尝试按照扩容两倍的方式来更新newCap与newThr；</li><li>注：如果扩容两倍导致容量超限，则语句不会被执行（newCap与newThr仍旧为0）</li></ul></li></ul></li></ul></li><li><p>如果旧哈希桶的容量等于0，说明“哈希桶还没有被初始化”（aka 程序员通过默认构造器创建的hashMap对象），则：</p><ul><li>如果旧的阈值大于0，说明“程序员在调用构造方法时指定了初始容量”，则：<ul><li>使用”程序员指定的初始容量调整后的值”来更新newCap；</li></ul></li><li>如果旧的阈值等于0，说明”程序员调用了默认的构造方法”，则:<ul><li>使用“默认的值”来更新newCap&amp;newThr；</li></ul></li></ul><hr></li><li><p>处理上面流程中可能没有被更新的newThr；</p><ul><li>如果newThr仍旧等于0，说明：要么newThr的值没有被更新过，要么在更新newThr时发生了溢出。则：<ul><li>使用“阈值 = 容量 * 扩容因子”的公式来计算阈值，并使用计算结果来更新newThr；</li></ul></li></ul></li></ul><p><strong>Period</strong></p><ul><li><p><span id="step2">step2: </span> 根据1中计算出的newCap来<strong>创建新的哈希桶数组</strong>;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建新的桶数组，桶数组的初始化也是在这里完成的</span></span><br><span class="line">Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">table = newTab; <span class="comment">// 把新创建的数组绑定到table全局变量上</span></span><br></pre></td></tr></table></figure></li><li><p><span id="step3">step3: </span>把键值对重新映射到新的桶数组中;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果旧的桶数组不为空，则遍历桶数组，并将键值对映射到新的桶数组中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="comment">// 重新映射时，需要对红黑树进行拆分</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="comment">// 遍历链表，并将链表节点按原顺序进行分组</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 将分组后的链表映射到新桶中</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>重新映射键值对的代码说明</p></blockquote><ul><li><p>分类1：对桶中的链表进行分组映射；</p><blockquote><p>知识卡1：向HashMap中插入键值对的流程；</p><ul><li>1 计算键值对应该插入到的哈希桶的位置；</li><li>2 尝试把键值对插入到桶中（作为链表节点/红黑树节点）；</li></ul><p>说明：JDK1.8中，对第一步做了优化以减少哈希冲突；</p></blockquote><blockquote><p>知识卡2：JDK1.8中，计算键值对预期插入的桶位置的流程；</p><ul><li>1 根据键值对的key，调用key的hashCode()方法计算得到其哈希值hash_key；</li><li>2 根据公式(n - 1) &amp; hash_key来计算出它预期插入的桶位置；</li></ul></blockquote><blockquote><p>知识卡3：默认情况下，扩容操作会被桶数组的容量扩大为旧容量的2倍；</p></blockquote><ul><li><p>手段：把链表中的键值对重新映射到<strong>扩容后新的哈希桶数组</strong>中；</p></li><li><p>特征：</p><ul><li>1 先前被映射到同一个桶中的键值对，在重新映射时，会被映射到不同的桶中；</li><li>2 <strong>不同的桶</strong>分为两个桶：旧位置的桶 + （旧位置 + 扩容长度）位置的桶；</li><li>3 这种手段不需要重新计算哈希值，只要查看高一位bit的值是0还是1，就能够得到<strong>键值对应该被映射到的哈希桶位置</strong>；</li></ul></li><li><p>原理：</p><ul><li>1 重新映射时， (n - 1) &amp; hash_key表达式中hash_key的值是不变的；</li><li>2 表达式中的n变成了先前的2倍，具体到二进制表示上——最高位1的前一个bit的值从0变成1；</li><li>3 由于按位与&amp;的特征（全1为1，否则为0），所以，根据hash_key的对应bit的值就能得到表达式(n - 1) &amp; hash_key的结果（aka 桶的位置）</li></ul></li><li><p>具体代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 如果旧的桶数组不为空，则遍历桶数组，并将键值对映射到新的桶数组中</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">Node&lt;K,V&gt; e;</span><br><span class="line"><span class="comment">// 获取当前桶位置的节点e，如果节点e不为null...</span></span><br><span class="line"><span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 处理其他的情况</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line"><span class="comment">/* 准备需要的指针 注：根据原理，链表的键值对会被映射到两个桶中 */</span></span><br><span class="line">Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>; <span class="comment">// “原始桶位置上的链表分组”的头尾指针 </span></span><br><span class="line">Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>; <span class="comment">// “新的桶位置上的链表分组”的头尾指针</span></span><br><span class="line">Node&lt;K,V&gt; next; <span class="comment">// 记录当前节点的下一个节点</span></span><br><span class="line"><span class="comment">// 遍历链表，并将链表节点按原顺序进行分组</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">next = e.next;</span><br><span class="line">                    <span class="comment">// 判断当前节点应该添加到的“链表分组”</span></span><br><span class="line">                    <span class="comment">// 手段：判断节点的哈希值 &amp; 桶数组的旧容量 的结果是否为0【WHY？】</span></span><br><span class="line"><span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 构建链表loHead</span></span><br><span class="line"><span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">loHead = e;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">loTail.next = e;</span><br><span class="line">loTail = e;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 构建链表hiHead</span></span><br><span class="line"><span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">hiHead = e;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">hiTail.next = e;</span><br><span class="line">hiTail = e;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">// 将分组后的链表（loHead、hiHead）添加到新桶中</span></span><br><span class="line"><span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">loTail.next = <span class="keyword">null</span>;</span><br><span class="line">newTab[j] = loHead;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">newTab[j + oldCap] = hiHead;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>链表中的键值对重新映射过程的SOP：</p><ul><li><p>原始桶数组；</p><p><img src="https://s1.ax1x.com/2020/09/13/w0dbnK.png" alt="原始桶数组"></p></li><li><p>桶数组扩容后，对链表中的键值对重新映射；</p><ul><li><p>1 依次遍历链表，并计算节点 <code>hash &amp; oldCap</code> 的值【为什么是这个公式？🚩】；</p><p><img src="https://s1.ax1x.com/2020/09/13/w0wFHS.png" alt="遍历桶中链表的节点"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    next = e.next;</span><br><span class="line">    <span class="comment">// 判断当前节点应该添加到的“链表分组”</span></span><br><span class="line">    <span class="comment">// 手段：判断节点的哈希值 &amp; 桶数组的旧容量 的结果是否为0【WHY？】</span></span><br><span class="line">    <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 构建链表loHead</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 构建链表hiHead</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul></li></ul></li></ul><pre><code>- 2 根据计算结果，对节点进行分组并创建分组后的链表（&lt;font size=2&gt;分组依据：键值对应该存放在原始桶位置or新的桶位置&lt;/font&gt;）；  手段：创建链表的一般步骤（两个指针head + tail）；  ![分组节点并创建分组链表](https://s1.ax1x.com/2020/09/13/w0ws4H.png)  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建loHead链表</span></span><br><span class="line"><span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">    loHead = e;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    loTail.next = e;</span><br><span class="line">loTail = e;</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 创建hiHead链表</span></span><br><span class="line"><span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">    hiHead = e;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    hiTail.next = e;</span><br><span class="line">hiTail = e;</span><br></pre></td></tr></table></figure>- 3 把创建的分组链表添加到新桶数组中预期位置；  手段：把分组后链表的头节点绑定到桶数组的预期位置上；  ![把链表绑定到桶数组的预期位置](https://s1.ax1x.com/2020/09/13/w00dRs.png)  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将分组后的链表（loHead、hiHead）添加到新桶中</span></span><br><span class="line"><span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">    loTail.next = <span class="keyword">null</span>;</span><br><span class="line">    newTab[j] = loHead; <span class="comment">// 旧的桶位置</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">    hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">    newTab[j + oldCap] = hiHead; <span class="comment">// 新的桶位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><hr><h6 id="哈希桶扩容后，红黑树中节点的重新映射过程"><a href="#哈希桶扩容后，红黑树中节点的重新映射过程" class="headerlink" title="哈希桶扩容后，红黑树中节点的重新映射过程"></a>哈希桶扩容后，红黑树中节点的重新映射过程</h6><blockquote><p>这个过程又会有很多细节，所以这里就简单捋一下</p></blockquote><p>参考：<a href="http://www.tianxiaobo.com/2018/01/18/HashMap-%E6%BA%90%E7%A0%81%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90-JDK1-8/#342-%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6">红黑树的拆分</a></p><ul><li><p>手段：按照映射链表节点的方式来重新映射红黑树中的节点；</p></li><li><p>原理：在<strong>将普通链表转成红黑树treeifyBin()方法</strong>时，HashMap 通过两个额外的引用 next 和 prev <strong>保留了原链表的节点顺序</strong>；</p></li><li><p>特征：不需要先把红黑树转化成链表，然后再映射到新的桶数组（效率更高）；</p></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 红黑树转链表阈值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index, <span class="keyword">int</span> bit)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; b = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// Relink into lo and hi lists, preserving order</span></span><br><span class="line">    TreeNode&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">    TreeNode&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * 红黑树节点仍然保留了 next 引用，故仍可以按链表方式遍历红黑树。</span></span><br><span class="line"><span class="comment">     * 下面的循环是对红黑树节点进行分组，与“对链表分组”类似</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; e = b, next; e != <span class="keyword">null</span>; e = next) &#123;</span><br><span class="line">        next = (TreeNode&lt;K,V&gt;)e.next;</span><br><span class="line">        e.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> ((e.hash &amp; bit) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                loHead = e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                loTail.next = e;</span><br><span class="line">            loTail = e;</span><br><span class="line">            ++lc;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                hiHead = e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                hiTail.next = e;</span><br><span class="line">            hiTail = e;</span><br><span class="line">            ++hc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断分组后的树是否需要反树化为链表</span></span><br><span class="line">    <span class="keyword">if</span> (loHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果 loHead 不为空，且链表长度小于等于 6，则将红黑树转成链表</span></span><br><span class="line">        <span class="keyword">if</span> (lc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">            tab[index] = loHead.untreeify(map);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tab[index] = loHead;</span><br><span class="line">            <span class="comment">/* </span></span><br><span class="line"><span class="comment">             * hiHead == null 时，表明扩容后，</span></span><br><span class="line"><span class="comment">             * 所有节点仍在原位置，树结构不变，无需重新树化</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) </span><br><span class="line">                loHead.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 把分组后的红黑树绑定到预期的桶中</span></span><br><span class="line">    <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">            tab[index + bit] = hiHead.untreeify(map);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tab[index + bit] = hiHead;</span><br><span class="line">            <span class="keyword">if</span> (loHead != <span class="keyword">null</span>)</span><br><span class="line">                hiHead.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h6 id="其他参考文章"><a href="#其他参考文章" class="headerlink" title="其他参考文章"></a>其他参考文章</h6><p><a href="https://www.toocruel.net/java8de-hashmapxiang-jie-cun-chu-jie-gou-gong-neng-shi-xian-kuo-rong-you-hua-xian-cheng-an-quan-bian-li-fang-fa/">JDK1.8中HashMap扩容机制简介</a></p><p><a href="https://mp.weixin.qq.com/s/qVoebks_Ba17ZtKMlzcbgw">JDK1.7中HashMap扩容机制简介</a></p><blockquote><p>it’s been a day, until next time 😄</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h5 id=&quot;HashMap类型的resize-过程&quot;&gt;&lt;a href=&quot;#HashMap类型的resize-过程&quot; class=&quot;headerlink&quot; title=&quot;HashMap类型的resize()过程&quot;&gt;&lt;/a&gt;HashMap类型的resize()过程&lt;/h5&gt;&lt;blockquote&gt;
&lt;p&gt;这个其实在上次分析的时候就学了一遍，但是不够熟悉 所以没有答上来。再复习一波~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;参考：&lt;a href=&quot;http://www.tianxiaobo.com/2018/01/18/HashMap-%E6%BA%90%E7%A0%81%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90-JDK1-8/#342-%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6&quot;&gt;HashMap详解-田小波&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Java Basic" scheme="https://henryinshanghai.github.io/categories/Java-Basic/"/>
    
    
    <category term="Java stuff" scheme="https://henryinshanghai.github.io/tags/Java-stuff/"/>
    
  </entry>
  
  <entry>
    <title>java基础之快速复习（3）</title>
    <link href="https://henryinshanghai.github.io/Java-Basic/2020/09/12/interview/20200912-java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BF%AB%E9%80%9F%E5%A4%8D%E4%B9%A0%EF%BC%883%EF%BC%89.html"/>
    <id>https://henryinshanghai.github.io/Java-Basic/2020/09/12/interview/20200912-java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BF%AB%E9%80%9F%E5%A4%8D%E4%B9%A0%EF%BC%883%EF%BC%89.html</id>
    <published>2020-09-12T02:30:00.000Z</published>
    <updated>2020-09-12T17:53:50.210Z</updated>
    
    <content type="html"><![CDATA[<h5 id="自定义注解相关知识"><a href="#自定义注解相关知识" class="headerlink" title="自定义注解相关知识"></a>自定义注解相关知识</h5><a id="more"></a><p>参考：<a href="https://mp.weixin.qq.com/s/gdYysBB3aD_HmPyvEThFXw">只会用注解，不会自己写？</a></p><blockquote><p>注解</p><p>是：Java中提供的一项技术；</p><p>作用：</p><ul><li>1 声明被标记的部分有/支持特殊的功能；</li><li>2 为被标记的部分添加额外的信息（以便在后面的代码中方便地使用这些信息）</li></ul><p>特征：</p><ul><li>1 在代码中可以用注进行解标注的部分：<ul><li>类/接口；</li><li>字段变量；</li><li>方法；</li></ul></li><li>2 特殊的功能：<ul><li>代码生成；</li><li>数据校验；</li><li>资源整合（🚩？？？）</li></ul></li></ul><p>用法：</p><ul><li>1 使用注解来标注需要的代码；</li><li>2 使用反射机制，在运行时动态地获取到注解中的标注信息，从而实现注解预期的功能；</li></ul></blockquote><h6 id="手动编写一个注解-Length-amp-验证注解的作用"><a href="#手动编写一个注解-Length-amp-验证注解的作用" class="headerlink" title="手动编写一个注解@Length&amp;验证注解的作用"></a>手动编写一个注解@Length&amp;验证注解的作用</h6><blockquote><p>说明：Spring框架其实提供了很多注解来对类的字段进行校验； 比如@NotNull、@NotEmpty、@Min、@Max、@Length</p></blockquote><ul><li><p>1 定义注解；</p><ul><li><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.FIELD&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Length &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">()</span></span>;  <span class="comment">// 字符串所允许的最小值</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">()</span></span>; <span class="comment">// 字符串所允许的最大值</span></span><br><span class="line">    <span class="function">String <span class="title">errorMsg</span><span class="params">()</span></span>; <span class="comment">// 自定义的错误提示信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>手段：</p><ul><li><p>1 关键字：@interface；</p></li><li><p>2 指定自定义注解的一些特性（注解可以添加到的位置、注解的声明周期）：</p><ul><li><p>手段：Java提供的元注解（BIA）；</p></li><li><p>分类：</p><ul><li><p>@Target(xxx)，用于指定该自定义注解可以用在什么位置【字段 - 方法 - 类（and more）】</p><ul><li><code>ElementType.FIELD</code>：说明自定义的注解可以用于类的变量</li><li><code>ElementType.METHOD</code>：说明自定义的注解可以用于类的方法</li><li><code>ElementType.TYPE</code>：说明自定义的注解可以用于类本身、接口或 <code>enum</code>类型</li></ul></li><li><p>@Retention(xxx)，用于指定自定义注解的生命周期【运行时 - 编译时 - 源码时】</p><ul><li><code>@Retention(RetentionPolicy.RUNTIME)</code>：表示注解可以一直保留到运行时（因此可以通过反射获取注解信息）</li><li><code>@Retention(RetentionPolicy.CLASS)</code>：表示注解被编译器编译进 <code>class</code>文件，但运行时会忽略</li><li><code>@Retention(RetentionPolicy.SOURCE)</code>：表示注解仅在源文件中有效，编译时就会被忽略</li></ul><p>一般选择的生命周期为：@Retention(RetentionPolicy.RUNTIME). Retention,延续</p></li></ul></li></ul></li></ul></li></ul></li><li><p>2 定义一个工具类，在类中添加静态方法——用于动态获取当前实例的字段值，并于程序员指定的字段值边界进行比较；</p><ul><li><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">validate</span><span class="params">(Object object)</span> <span class="keyword">throws</span> IllegalAccessException </span>&#123;</span><br><span class="line">        <span class="comment">// Ⅰ 获取类的所有字段</span></span><br><span class="line">        Field[] fields = object.getClass().getDeclaredFields();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Ⅱ 遍历这些个字段对象</span></span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">            <span class="comment">// Ⅲ 如果字段上存在“自定义的注解”...</span></span><br><span class="line">            <span class="keyword">if</span> (field.isAnnotationPresent(Length<span class="class">.<span class="keyword">class</span>)) </span>&#123; </span><br><span class="line">                <span class="comment">// Ⅳ 获取到字段上的注解类实例</span></span><br><span class="line">                MyPattern myPattern = field.getAnnotation(MyPattern<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">                field.setAccessible(<span class="keyword">true</span>); <span class="comment">// 允许通过反射访问到私有变量</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// Ⅴ 通过反射，获取到程序员给对象的该字段绑定的值     诡异地反转：对象的某个字段的值 - 字段.get(对象)</span></span><br><span class="line">                String myRex = (String)field.get(object); <span class="comment">// 获取到字段的值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="comment">// Ⅵ 对字段绑定的值进行判断，如果不在指定的区间内。就返回自定义的异常信息</span></span><br><span class="line">                Pattern p = Pattern.compile(myPattern.regularExpression());</span><br><span class="line">                Matcher m = p.matcher(myRex);</span><br><span class="line">                <span class="keyword">if</span> (!m.matches()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> myPattern.errorMag();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// 否则返回null</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>3 在自定义类型的字段上，使用自定义的注解；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.annotationDemo2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在字段上标记自定义的注解</span></span><br><span class="line">    <span class="meta">@Length</span>(min=<span class="number">11</span>, max=<span class="number">11</span>, errorMsg = <span class="string">"电话号码的长度必须为11位"</span>)</span><br><span class="line">    <span class="keyword">private</span> String mobile;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>4 验证注解是否发挥作用；</p><ul><li>手段：<ul><li>1 写一段代码，尝试给实例的mobile绑定一个6位数字的号码；</li><li>2 然后调用工具类中的静态方法对实例进行校验，如果失败，就返回errorMsg；</li></ul></li></ul></li></ul><h5 id="Spring中常用的注解"><a href="#Spring中常用的注解" class="headerlink" title="Spring中常用的注解"></a>Spring中常用的注解</h5><p>参考：<a href="http://cmsblogs.com/?p=4040">Spring中常用的20+注解</a></p><blockquote><p>知识卡</p><p>Spring注解</p><ul><li>是：Spring框架所提供的一种技术；</li><li>作用：<ul><li>声明式地描述Spring框架的指定功能；</li><li>部分替代Spring的XML配置文件的工作（比如描述<strong>被Spring所管理的Bean</strong>、<strong>装配Bean之间的关系</strong>等）</li></ul></li><li>特征：<ul><li>1 对于Spring的不同功能，Spring都提供了实现该功能的注解手段；</li><li>2 注解能够声明式地使用，不需要像OOP编程一样指定很多的细节（只需要给出关键信息即可）</li></ul></li><li>用法/分类：<ul><li>参考：👇👇👇</li></ul></li></ul></blockquote><h6 id="1-用于描述组件的注解"><a href="#1-用于描述组件的注解" class="headerlink" title="1.用于描述组件的注解"></a>1.用于描述组件的注解</h6><ul><li><p>作用：为Java类添加一个标识，声明此Java类接受Spring容器的管理（这部分替代了Spring配置文件的作用）。</p></li><li><p>具体注解：</p><ul><li><strong>@Component</strong>：声明当前类型接受Spring容器的管理（aka 可以视为Spring容器中的一个组件）；</li><li>@Repository、@Service、@Controller：作用与@Component完全相同，但是能让程序员直接了解到组件所在的层次；<ul><li>@Controller标注的类型：表示此类型为controller层的组件(页面交互层)；</li><li>@Service标注的类型：表示此类型为service层的组件（业务逻辑处理层）；</li><li>@Repository标注的类型：表示此类型为dao层的组件（数据库操作层）；【<font size=2>引申：开发应用时采用的三层架构</font>】</li></ul></li><li>原理（这些注解的作用相同）：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;) <span class="comment">// 此注解可以使用的位置</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME) <span class="comment">// 此注解有效的范围</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Component</span> <span class="comment">// 🚩所有其他的三个注解都被@Component注解所标注</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Controller &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>特征</p><ul><li><p>1 Java类型被声明为Spring容器中的Bean（不管是注解手段还是…）后，bean实例的名称默认为：<strong>首字母变成小写</strong>后Bean类型的名称;</p></li><li><p>2 实际开发时，尽量使用三层架构对应的注解；</p></li><li><p>3 为Java类型添加注解后，还需要些其他操作才能<strong>由Spring容器来完全管理Java类型的实例</strong>；</p><blockquote><p>知识卡：</p><p>任务：把一个Java类型交给Spring容器管理；</p><p>手段：</p><ul><li><p>1 为Java类型标注Spring提供的注解@Component;</p></li><li><p>2 在Spring的配置文件中添加<strong>预期执行注解扫描的路径</strong>这个配置信息；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 自动扫描指定包及其子包下的所有Bean类 --&gt;</span><br><span class="line">&lt;context:component-scan base-<span class="keyword">package</span>=<span class="string">"org.springframework.*"</span>/&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote></li></ul></li></ul><h6 id="2-用于进行装配Bean的注解"><a href="#2-用于进行装配Bean的注解" class="headerlink" title="2.用于进行装配Bean的注解"></a>2.用于进行装配Bean的注解</h6><ul><li>作用：<ul><li>1 描述Spring容器中不同Bean之间的依赖关系；</li><li>2 在Spring容器中建立这种依赖关系（把B类型的bean实例绑定到/注入到/装配到A类型的属性上）；</li></ul></li><li>具体注解：<ul><li><strong>@Autowired</strong>：Spring内置注解；</li><li>@Inject：由JSR-330规范提供;</li><li>@Resource：由JSR-250规范提供;【非嫡系】</li></ul></li><li>用法：都可以标注在set方法和属性上，<strong>推荐直接标注在属性上</strong>（一目了然，少写代码）</li></ul><h6 id="3-用于声明“这是一个用于配置的类型”的注解"><a href="#3-用于声明“这是一个用于配置的类型”的注解" class="headerlink" title="3.用于声明“这是一个用于配置的类型”的注解"></a>3.用于声明“这是一个用于配置的类型”的注解</h6><ul><li>作用：声明这是一个用于配置Bean之间依赖关系的Java类型；</li><li>具体注解：<ul><li>@Configuration <ul><li>作用：声明当前类为配置类，相当于配置文件中的xxx标签；</li><li>用法：标注在类上</li></ul></li><li>@Bean <ul><li>作用：产生一个Bean对象，然后这个Bean对象交给Spring管理；</li><li>用法：标注在方法上；</li></ul></li><li>@ComponentScan <ul><li>作用：用于对Component进行自动扫描（相当于配置文件中的xxx标签）；</li><li>用法：标注在类上；</li></ul></li></ul></li></ul><h6 id="4-用于支持AOP的注解"><a href="#4-用于支持AOP的注解" class="headerlink" title="4.用于支持AOP的注解"></a>4.用于支持AOP的注解</h6><ul><li><p>作用：支持AOP编程中的技术细节（where、when&amp;how）；</p></li><li><p>具体注解：</p><ul><li><p>@Aspect（how）：</p><ul><li>作用：把一个类声明为切面类（aka 用于对其他类型进行增强的类）；</li><li>用法：<ul><li>1 标注在Java类上；</li><li>2 直接把<strong>拦截规则（where）</strong>作为@Aspect注解的参数；</li></ul></li></ul></li><li><p>@After（when）：</p><ul><li>作用：声明<strong>当前用于增强的方法</strong>在<strong>切点方法</strong>执行之后再去执行；</li><li>用法：标注在用于增强的方法上；</li></ul><blockquote><p>@Before注解作用与用法和@After都类似；</p></blockquote></li><li><p>@Around（when）</p><ul><li>作用：声明<strong>当前用于增强的方法</strong>在 <strong>切点方法执行之前</strong> 与 <strong>切点方法执行之后</strong>都会执行；</li><li>用法：标注在用于增强的方法上；</li></ul></li><li><p>@PointCut（where）</p><ul><li>作用：声明预期会被增强的方法/代码；</li><li>用法：<ul><li>0 开启Spring对AspectJ代理的支持；<ul><li>手段：在Java配置类上标注@EnableAspectJAutoProxy注解；</li></ul></li><li>1 把@PointCur注解标注在方法上；</li><li>2 编写预期的切点表达式作为@PointCut注解的参数；</li></ul></li></ul></li></ul></li></ul><h6 id="5-用于声明bean实例相关属性的注解"><a href="#5-用于声明bean实例相关属性的注解" class="headerlink" title="5.用于声明bean实例相关属性的注解"></a>5.用于声明bean实例相关属性的注解</h6><ul><li><p>作用：对bean实例进行更细致的管理（声明bean实例在容器中的作用域）；</p></li><li><p>具体注解;</p><ul><li><p>@Scope；</p><blockquote><p>知识卡—Spring容器中bean实例的作用域分类：</p><p>作用域的作用：声明容器中当前Bean的特性；</p><ul><li>Singleton作用域；<ul><li>当前Bean的特性：整个容器中有且只有一个当前Bean的实例；</li></ul></li><li>Prototype作用域；<ul><li>当前Bean的特性：代码每次从容器中获取bean实例时，容器都会为这个get操作创建一个新的实例；</li></ul></li><li>Request作用域；<ul><li>当前Bean的特性：web项目中，给每个http request（请求与获取bean实例没有必然关系呀？🚩）新建一个bean</li><li>特征：创建出的实例只在本次HTTP请求期间有效；</li></ul></li><li>Session作用域；<ul><li>当前Bean的特性：同上；</li><li>特征：创建出的bean实例只在本次会话期间有效（时间范围比起以此请求更长）；</li></ul></li></ul></blockquote><ul><li>作用：声明bean实例在Spring容器中的<strong>作用域属性</strong>；</li><li>用法：标注在<strong>用于创建bean实例的方法</strong>上；</li></ul></li><li><p>@PostConstruct </p><ul><li><p>作用：声明方法会在<strong>在构造函数执行完之后（bean的生命周期的一个阶段）</strong>执行；</p></li><li><p>特征：</p><ul><li>1 由JSR-250规范提供；</li><li>2 等价于xml配置文件中xxx标签的ooo属性；</li></ul></li><li><p>用法：标注在<strong>预期在依赖注入操作执行完成后会被调用</strong>的方法上；</p></li><li><p>原理：</p><ul><li><p>bean的生命周期中执行注解的顺序；</p><p><img src="https://s1.ax1x.com/2020/09/12/walSC4.png" alt="生命周期中顺序执行的注解"></p></li></ul></li></ul></li><li><p>@PreDestory </p><ul><li>作用：声明方法会<strong>在Bean销毁之前（bean生命周期的另一个阶段）</strong>执行;</li><li>特征：<ul><li>1 由JSR-250规范提供；</li><li>2 等价于xml配置文件中xxx标签的ooo属性；</li></ul></li><li>用法：标注在<strong>预期在bean实例被销毁之后会被调用</strong>的方法上；</li></ul></li></ul></li></ul><h6 id="6-用于为属性绑定值的注解"><a href="#6-用于为属性绑定值的注解" class="headerlink" title="6.用于为属性绑定值的注解"></a>6.用于为属性绑定值的注解</h6><ul><li><p>作用：为Bean类型的属性绑定/注入值；</p></li><li><p>用法：从配置文件中加载值，并绑定到成员属性上；</p><ul><li><p>1 在配置文件<em>test.properties</em>中定义一堆的<strong>属性 - 值</strong>对；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">book.name=《三体》</span><br></pre></td></tr></table></figure></li><li><p>2 在<strong>当前类</strong>中加载配置文件；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PropertySource(<span class="string">"classpath:com/hgs/hello/test/test.propertie"</span>) <span class="comment">// 在类上标注PropertySource注解</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span>&#123; ... &#125;</span><br></pre></td></tr></table></figure></li><li><p>3 在配置类中添加一个用于填充占位符的bean实例；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">🚩</span><br></pre></td></tr></table></figure></li><li><p>4 在<strong>属性上</strong>标注@Value注解；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value</span>(<span class="string">"$&#123;user.age:11&#125;"</span>) <span class="comment">// 引用配置文件中的键值对，然后把得到的值绑定到age属性上</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h6 id="7-用于切换代码运行环境的注解"><a href="#7-用于切换代码运行环境的注解" class="headerlink" title="7.用于切换代码运行环境的注解"></a>7.用于切换代码运行环境的注解</h6><ul><li><p>作用：指定代码运行的当前环境；</p><blockquote><p>知识卡1——代码的不同阶段</p><ul><li>1 对于一个项目来说，相同的代码需要先后经历<strong>开发环境 - 测试环境 - 生产环境</strong>的阶段；</li><li>2 每一种环境，配置使用的数据库肯定是不同的（还有一些其他的配置信息也会不同）；</li></ul><p>知识卡2——代码部署</p><p>手段1：</p><ul><li><p>1 当把代码部署到一个新的环境时，修改配置文件中<strong>与代码运行环境相关的信息</strong>；</p></li><li><p>2 修改正确后，把代码+编辑后的配置文件<strong>放到/部署到新的工作环境中</strong>；</p><p>特征：每次部署工作都需要重新修改配置文件，很容易出错；</p></li></ul><p>手段2：</p><ul><li><p>1 准备好每一种工作环境所对象的配置文件(file_dev、file_test、file_prod);</p></li><li><p>2 在代码中，通过@Profile注解来指定当前代码所使用的运行环境配置；</p><p>特征： 这样每次部署时，就只需要修改一行代码即可（🚩 Not for sure）</p></li></ul></blockquote></li><li><p>具体注解：</p><ul><li><p>@Profile；</p><ul><li><p>作用：指定<strong>代码运行的当前环境</strong>（aka <em>当前context</em>所需要使用的配置环境）；</p></li><li><p>手段：设定<em>Environment的ActiveProfiles</em>；</p></li><li><p>用法：</p><ul><li><p>1 在<strong>预期使用xxx环境配置信息的方法上</strong>标注@Profile(‘xxx’)注解；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Profile</span>(<span class="string">"dev"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">devDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 具体配置信息</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> basicDataSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>2 激活<strong>预期使用的xxx环境配置</strong>;</p><ul><li><p>手段：在类上标注<code>@ActiveProfiles</code>注解；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Not going into the details now</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul></li><li><p>@Conditional；</p><ul><li>作用：声明那些个<strong>在特定条件下才会被实例化</strong>的bean；</li><li>用法：<ul><li>1 自定义类型实现Condition接口，并重写matches()方法；</li><li>2 根据matches()方法的返回结果来确定<strong>Bean类型是否会被实例化</strong>；</li></ul></li></ul></li></ul></li></ul><h6 id="8-用于支持异步操作的注解"><a href="#8-用于支持异步操作的注解" class="headerlink" title="8.用于支持异步操作的注解"></a>8.用于支持异步操作的注解</h6><ul><li>作用：支持异步操作并指定具体的操作细节；</li><li>具体注解：<ul><li>@EnableAsync；<ul><li>作用：开启Spring对异步任务的支持；</li><li>用法：标注在配置类上；</li></ul></li><li>@Async；<ul><li>作用：声明<strong>bean方法是一个异步任务</strong>（啥意思🚩）；</li><li>用法：标注在<strong>预期声明其为异步任务</strong>的方法上；</li></ul></li></ul></li></ul><h6 id="9-用于支持定时任务的注解"><a href="#9-用于支持定时任务的注解" class="headerlink" title="9.用于支持定时任务的注解"></a>9.用于支持定时任务的注解</h6><ul><li><p>具体注解：</p><ul><li><p>@EnableScheduling：</p><ul><li>作用：开启Spring对定时任务的支持；</li><li>用法：标注在配置类上；</li></ul></li><li><p>@Scheduled：</p><ul><li><p>作用：声明<strong>bean方法是一个待执行的任务(比如爬取新闻)</strong>；</p></li><li><p>用法：</p><ul><li><p>1 标注在<strong>预期按照指定规则运行的方法</strong>上；</p></li><li><p>2 通过注解的参数来指定<strong>任务的运行规则</strong>；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scheduled</span>(cron = <span class="string">"0 0 0 1 Jan ?"</span>) <span class="comment">//每年的1月的1日的0时0分0秒执行</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><p>参考:<a href="https://juejin.im/post/6844903470793752584">@Schedule注解的用法</a></p></li></ul><h6 id="10-形如-Enable-的注解说明"><a href="#10-形如-Enable-的注解说明" class="headerlink" title="10.形如@Enable*的注解说明"></a>10.形如@Enable*的注解说明</h6><ul><li>作用：用于开启Spring对*所表示的功能的支持；</li><li>常用注解：<ul><li>@EnableAsync 开启对<strong>异步方法</strong>的支持</li><li>@EnableScheduling 开启对<strong>计划任务</strong>的支持</li><li>@EnableWebMvc 开启对<strong>Web MVC</strong>的支持</li><li>@EnableCaching 开启<strong>注解式的缓存</strong>支持</li></ul></li></ul><h6 id="11-用于支持代码测试的注解"><a href="#11-用于支持代码测试的注解" class="headerlink" title="11.用于支持代码测试的注解"></a>11.用于支持代码测试的注解</h6><ul><li><p>@RunWith</p><ul><li><p>作用：指定<strong>当前代码上下文</strong>所使用的<strong>运行器</strong>（aka 运行当前代码的工具）；</p></li><li><p>用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RunWith(SpringJUnit4ClassRunner<span class="class">.<span class="keyword">class</span>) // 为参数绑定具体运行器的<span class="title">class</span>对象</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>@ContextConfiguration【上下文配置】</p><ul><li><p>作用：指定<strong>当前代码上下文</strong>所使用的<strong>Spring容器配置</strong>（aka 具体实例与实例之间的装配关系）；</p></li><li><p>用法（通过Java配置类来指定Spring容器配置）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ContextConfiguration</span>(classes=&#123;TestConfig<span class="class">.<span class="keyword">class</span>&#125;) // 为<span class="title">classes</span>参数绑定配置类的<span class="title">class</span>对象</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h6 id="12-SpringMVC框架所使用的注解"><a href="#12-SpringMVC框架所使用的注解" class="headerlink" title="12.SpringMVC框架所使用的注解"></a>12.SpringMVC框架所使用的注解</h6><ul><li><p>作用：开启SpringMVC框架，并指定MVC框架处理请求的细节；</p></li><li><p>具体注解；</p><ul><li><p>@EnableWebMvc；</p><ul><li>作用：开启Spring<strong>对Web MVC配置的支持</strong>；</li><li>用法：标注在配置类上；</li></ul></li><li><p>@Controller;</p><ul><li>作用：声明当前类为<strong>MVC模型中的控制器</strong>；</li><li>用法：标注在当前类型上；</li></ul></li><li><p>@RequestMapping：</p><ul><li>作用：映射Web请求到特定的Controller方法上；</li><li>特征：<ul><li>1 映射内容除了路径外，还包括请求参数；</li><li>2 请求参数到controller方法参数的绑定会有很多种手段；</li></ul></li></ul></li><li><p>@ResponseBody；</p><ul><li>作用：声明方法的返回值会<strong>存入response内</strong>，而不是需要<strong>作为一个视图名</strong>;</li><li>用法：标注在controller方法上；</li></ul></li><li><p>@RequestBody；</p><ul><li>作用：把请求的参数封装到请求体中，而不是跟在请求地址后面；</li><li>用法：标注在controller方法参数的前面；</li></ul></li><li><p>@PathVariable；</p><ul><li>作用：接受Web请求中的路径参数，并把参数值绑定到controller方法参数上；</li><li>用法：<ul><li>1 编写@RequestMapping注解时，使用<strong>路径参数</strong>来接收Web请求中的参数；</li><li>2 把@PathVariable注解标注在controller方法参数的前面即可;（more details）</li></ul></li></ul></li><li><p>@RestController;</p><ul><li>作用：@Controller+@ResponseBody；</li><li>特征：组合注解；</li></ul></li><li><p>@InitBinder；</p><ul><li>作用：设置从web请求到controller方法参数的数据绑定；</li><li>原理：<ul><li>1 使用WebDataBinder来自动绑定前台请求参数到Model中；</li><li>2 通过InitBinder注解能够设置WebDataBinder的细节；</li></ul></li></ul><blockquote><p>OMG, so much details you may want to puke(⚡吼)</p></blockquote></li></ul></li></ul><h5 id="多线程中常用的方法说明"><a href="#多线程中常用的方法说明" class="headerlink" title="多线程中常用的方法说明"></a>多线程中常用的方法说明</h5><blockquote><p>多线程的应用场景：</p><ul><li>1 流程中的耗时任务（比如发通知时，需要给每一个参会人员发送短信）；</li><li>2 创建需要在后台一直执行的线程（比如定时任务，像备份数据库等）；</li><li>3 处理并发请求（Tomcat）/处理多个任务（多任务场景？🚩）；</li><li>4 多次独立的循环；</li></ul></blockquote><p>参考：<a href="https://mp.weixin.qq.com/s/FHyqxHcfzOtKvA1_PFtnXw">田小齐-多线程</a></p><h6 id="线程的生命周期-6种状态"><a href="#线程的生命周期-6种状态" class="headerlink" title="线程的生命周期(6种状态)"></a>线程的生命周期(6种状态)</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> State &#123;</span><br><span class="line">  NEW,</span><br><span class="line">  RUNNABLE,</span><br><span class="line">  BLOCKED,</span><br><span class="line">  WAITTING,</span><br><span class="line">  TIMED_WAITTING,</span><br><span class="line">  TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>线程6种状态之间的转移图</li></ul><p><img src="https://s1.ax1x.com/2020/09/12/wd4gP0.png" alt="状态转移图"></p><ul><li><p>New;</p><ul><li><p>状态：A thread that has not yet started is in this state.</p><blockquote><p>一个还没有启动的线程就处在这种状态；</p></blockquote></li><li><p>手段：创建线程；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyThread myThread = <span class="keyword">new</span> MyThread();</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Runnable;</p><ul><li><p>状态：A thread is executing in the Java virtual machine but it may be waiting for other resources from the operating system such as processor.</p><blockquote><p>线程在Java虚拟机中执行，但它可能在等待从操作系统中得到其他需要的资源（比如CPU资源）</p></blockquote></li><li><p>手段：启动线程；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myThread.start();</span><br></pre></td></tr></table></figure></li><li><p>特征：</p><ul><li>1 线程启动后就会进入Runnable状态；</li><li>2 Runnable状态的线程都会被添加到一个等待队列中，等待CPU的调度（皇帝临幸）；</li><li>3 线程得到CPU资源后，就会执行。如果没得到，继续等待</li></ul></li></ul></li><li><p>Blocked;</p><ul><li><p>状态：Thread state for a thread blocked waiting for a monitor lock.<br>A thread in the blocked state is <strong>waiting for a monitor lock to enter a synchronized block/method</strong> or reenter a synchronized block/method after calling <code>wait()</code> Object.</p><blockquote><p>描述线程的一种状态：线程阻塞以等待一个监视器的锁；</p><p>阻塞状态下的线程会等待监视器的锁来：</p><ul><li>1 进入一个synchronized修饰的代码块/方法；</li><li>2 或者在调用wait()方法后重新进入synchronized修饰的代码块/方法；</li></ul></blockquote></li><li><p>特征：</p><ul><li>1 阻塞状态下的线程是在<strong>等待锁资源</strong>;</li><li>2 线程是否能够等待到锁<strong>不是很可控</strong>（起码程序员没有办法指定某个线程获得锁）；</li></ul></li></ul></li><li><p>Waiting;</p><ul><li><p>状态：A thread in the waiting state is waiting for another thread to perform a particular action.</p><blockquote><p>等待状态下的线程，正在等待另一个线程执行特定的动作；</p></blockquote></li><li><p>手段</p><p>A thread is in the waiting state due to calling one of the following methods:</p><ul><li><p>Object.wait with no timeout</p></li><li><p>Thread.join with no timeout</p></li><li><p>LockSupport.park</p><blockquote><p>以下原因会导致线程进入到等待状态：</p><ul><li>调用了wait()方法；</li><li>调用了join()方法；</li><li>调用了park()方法；</li></ul></blockquote></li></ul></li><li><p>特征：</p><ul><li>1 等待状态没有时间限制（无限期等待），所以需要某些方式来唤醒线程；</li><li>2 由于使线程进入睡眠状态的手段是可控的，所以唤醒线程的手段也是可控的；<ul><li>如果使用wait()方法使线程A进入等待状态，则<ul><li>需要使用notify()/notifyall()方法来唤醒；</li></ul></li><li>如果使用join()方法使线程A进入等待状态，则<ul><li>需要<strong>等待目标线程运行结束</strong></li></ul></li></ul></li></ul></li><li><p>应用：生产者-消费者模型中，当没有产品时，就需要</p><ul><li>1 让消费者等待；    手段：在消费者线程上调用wait()方法；</li><li>2 在生产者生产完毕后，唤醒消费者(去消费)； 手段：在消费者线程上调用notify()方法；</li></ul></li></ul></li><li><p>Timed_waiting;</p><ul><li><p>状态：有时长限制的等待状态（太久的话我就不等你了）</p></li><li><p>手段：</p><blockquote><ul><li>Thread.sleep</li><li>Object.wait with timeout</li><li>Thread.join with timeout</li><li>LockSupport.parkNanos</li><li>LockSupport.parkUntil</li></ul></blockquote></li><li><p>特征：</p><ul><li>1 其实就是在等待状态上添加了<strong>等待时长限制</strong>；</li><li>2 在时长超限后，线程就不再等待（可以做其他事情）；</li></ul></li></ul></li><li><p>Terminated;</p><ul><li><p>状态：A thread that has exited is in this state.</p><blockquote><p>一个已经退出的线程就处在这种状态；</p></blockquote></li><li><p>手段：</p><ul><li>1 执行完所有代码，线程正常结束；</li><li>2 线程被强制结束；【手段：stop()方法；   注：此手段已弃用】</li><li>3 线程执行时，抛出了未处理的异常；</li></ul></li><li><p>特征：</p><ul><li>1 线程一旦终结/死亡，就无法再复活了（不像超人）；</li><li>2 如果在已经终结的线程上调用start()方法，则程序会抛出<strong>非法线程状态异常</strong>；</li></ul></li></ul></li></ul><h6 id="线程实例常用的APIs"><a href="#线程实例常用的APIs" class="headerlink" title="线程实例常用的APIs"></a>线程实例常用的APIs</h6><ul><li><p>join()方法；</p><ul><li><p>作用：</p><blockquote><p>Waits for this thread to die. 等待当前线程死亡</p></blockquote></li><li><p>手段：<strong>强制让该线程执行</strong>，并且一直会让它执行完；</p></li><li><p>用法：</p><ul><li><p>1 实现一个线程类；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123; <span class="comment">// 手段2</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 线程执行时的工作：打印100次特定字符串</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Henry666："</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在类中直接定义主线程</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>2 在主线程中：</p><ul><li>创建线程实例；</li><li>启动线程；</li><li>强制线程执行完成；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123; <span class="comment">// 定义main()函数aka 开启一个主线程</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建一个新线程</span></span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable());</span><br><span class="line">    <span class="comment">// 开启新线程</span></span><br><span class="line">        t.start();</span><br><span class="line">    <span class="comment">// 等待，直到新线程执行结束</span></span><br><span class="line">        t.join();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程的工作</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"主线程"</span> + i + <span class="string">"：齐姐666"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">// 注：通过控制台的打印结果可以得到：主线程与新创建线程之间的执行顺序</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>应用：使某个线程优先执行，直到线程执行结束（然后才会回到公平竞争的情况）；</p></li><li><p>原理：join()方法其实是使用wait()方法实现的；</p></li></ul></li><li><p>wait()方法 &amp; notify()方法；</p><ul><li>作用：使得当前线程实例<strong>进入等待状态</strong>；</li><li>特征：<ul><li>1 wait()方法并不是线程类的方法，而是Object类的方法；</li><li>2 可以为wait()方法设置时长参数（这样就不需要别的线程唤醒了）</li></ul></li><li>用法【🚩 不够清晰】：<ul><li>1 在当前线程实例上调用wait()方法，使之进入<strong>无限期等待的状态</strong>；</li><li>2 直到某个线程调用了notify()/notifyall()方法，唤醒<strong>等待状态下的当前线程</strong>；</li></ul></li><li>代码：xxx</li></ul></li><li><p>yield()方法；</p><ul><li>作用：强制当前线程让出CPU资源，使得线程从<strong>执行中</strong>切换到<strong>可执行</strong>（都是Runnable状态）；</li><li>特征：让出CPU资源后，线程会回到等待队列中，重新等待CPU资源；</li></ul></li><li><p>sleep()方法；</p><ul><li><p>作用：使当前线程睡一会；</p></li><li><p>特征：</p><ul><li><p>1 线程并不会让出CPU资源（它只是占着CPU不做事罢了）；</p></li><li><p>2 sleep()方法的方法签名中抛出了异常，所以调用时需要使用try/catch捕获可能的异常进行检查；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myThread.sleep(<span class="number">1000</span>); <span class="comment">// 睡眠 1 秒钟</span></span><br></pre></td></tr></table></figure></li></ul><hr></li><li><p>currentThread()方法；</p><ul><li><p>作用：Returns a reference to the currently executing thread object.</p><blockquote><p>返回一个当前正在执行的线程对象的引用；</p></blockquote></li><li><p>特征：</p><ul><li>1 它是Thread类型的一个static方法；</li><li>2 方法的返回值类型是Thread类型；</li></ul></li><li><p>应用：打印当前线程实例；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Thread.currentThread());</span><br></pre></td></tr></table></figure></li></ul></li><li><p>getName()方法；</p><ul><li><p>作用：获取当前线程的名称；</p></li><li><p>特征：当前线程实例的名称可以由程序员手动设置；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable(), <span class="string">"壹齐学"</span>); <span class="comment">// 手段：Thread类的构造方法</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>getId()方法；</p><ul><li>作用：获取当前线程的id；</li></ul></li><li><p>getPriority()方法；</p><ul><li><p>作用：获取当前线程的优先级；</p></li><li><p>特征：</p><ul><li><p>1 优先级高的线程更有可能被CPU率先执行；</p></li><li><p>2 优先级的可选级别为1-10；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The minimum priority that a thread can have.最低优先级</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MIN_PRIORITY = <span class="number">1</span>;</span><br><span class="line">      </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The default priority that is assigned to a thread. 默认优先级</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> NORM_PRIORITY = <span class="number">5</span>;</span><br><span class="line">      </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The maximum priority that a thread can have. 最高优先级</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_PRIORITY = <span class="number">10</span>;</span><br></pre></td></tr></table></figure></li><li><p>3 如果设置的优先级别不在{1, 5, 10}中，则JDK会抛出非法参数异常；</p></li></ul></li></ul></li><li><p>setPriority()方法；</p><ul><li>作用：设置线程的优先级；</li></ul></li><li><p>stop()方法；</p><ul><li>作用：强制停止线程；</li><li>特征：已弃用（因为可能会导致一些线程安全方面的问题<strong>留坑了</strong>）</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h5 id=&quot;自定义注解相关知识&quot;&gt;&lt;a href=&quot;#自定义注解相关知识&quot; class=&quot;headerlink&quot; title=&quot;自定义注解相关知识&quot;&gt;&lt;/a&gt;自定义注解相关知识&lt;/h5&gt;</summary>
    
    
    
    <category term="Java Basic" scheme="https://henryinshanghai.github.io/categories/Java-Basic/"/>
    
    
    <category term="Java stuff" scheme="https://henryinshanghai.github.io/tags/Java-stuff/"/>
    
  </entry>
  
  <entry>
    <title>java基础之快速复习（2）</title>
    <link href="https://henryinshanghai.github.io/Java-Basic/2020/09/11/interview/20200911-java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BF%AB%E9%80%9F%E5%A4%8D%E4%B9%A0%EF%BC%882%EF%BC%89.html"/>
    <id>https://henryinshanghai.github.io/Java-Basic/2020/09/11/interview/20200911-java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BF%AB%E9%80%9F%E5%A4%8D%E4%B9%A0%EF%BC%882%EF%BC%89.html</id>
    <published>2020-09-11T02:30:00.000Z</published>
    <updated>2020-09-13T10:47:07.476Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Java基础-2"><a href="#Java基础-2" class="headerlink" title="Java基础(2)"></a>Java基础(2)</h4><h5 id="Java中的接口相关的内容"><a href="#Java中的接口相关的内容" class="headerlink" title="Java中的接口相关的内容"></a>Java中的接口相关的内容</h5><a id="more"></a><p>参考：<a href="https://juejin.im/post/6844903734053437448">接口的最少必要内容</a></p><ul><li><p>是：一个技术名称；</p></li><li><p>作用：定义一组抽象的行为规范；</p></li><li><p>创建接口的手段：interface接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> 接口名称</span>&#123;</span><br><span class="line">    <span class="comment">// 全局常量；</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 多个抽象方法；</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>用法：</p><ul><li><p>1 定义接口类型（<strong>只能定义这两个部分</strong>）；</p><ul><li><p>1 定义接口中的静态常量；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String name = <span class="string">"张三"</span>; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">String name = <span class="string">"张三"</span>; <span class="comment">// 2 接口中的成员变量一般都是常量(静态不可变)</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><pre><code>- 2 定义接口中的静态方法；  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> List&lt;String&gt; <span class="title">getUserNames</span><span class="params">(Long companyId)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">List&lt;String&gt; <span class="title">getUserNames</span><span class="params">(Long companyId)</span></span>; <span class="comment">// 接口中的抽象方法都是：公开抽象的</span></span><br></pre></td></tr></table></figure></code></pre><ul><li>2 定义具体类型来实现接口；</li></ul><ul><li><p>特征：</p><ul><li><p>1 接口类型<strong>不能直接实例化</strong>（从而得到实例）；</p><ul><li>手段：接口类型中<strong>不允许定义构造方法</strong>，会直接编译报错；</li></ul></li><li><p>2 定义类型时，可以同时实现多个不同类型的接口；</p><ul><li>超人既能Fly,还能Fight；</li></ul></li><li><p>3 接口类型不能继承自<strong>普通类型/抽象类型</strong>；</p><ul><li>原因：普通类型/抽象类型对方法与变量都没有任何限制，而接口对方法与变量有限制。所以不能直接继承它们</li></ul></li><li><p>4 如果：</p><ul><li><p>Ⅰ 类型A，继承自类型B，并实现了接口C；</p><blockquote><p>知识卡</p><ul><li>继承自类型B，则：<ul><li>A继承了类型B中的所有用 <strong>public 和 protected 关键字</strong>修饰的方法和属性（啥意思？😕）</li></ul></li><li>实现了接口C，则：<ul><li>A必须要实现接口C中规定的所有抽象方法；</li></ul></li></ul></blockquote></li><li><p>Ⅱ 类型B与接口C中有相同的方法f()…</p><ul><li>方法名相同的情况下，讨论<strong>方法的参数&amp;返回值类型</strong>:<ul><li>方法签名与返回值类型都相同，则：如果实现类中没有显式实现抽象方法f()，最终会执行父类中的f()方法；</li><li>方法签名相同，但返回值类型不同，则：子类无法成功定义，因为<strong>先继承，后实现</strong>（子类中方法的返回值类型必须与父类中保持一致）；</li><li>参数不同，但是返回值类型相同，则：在子类中需要实现接口中的抽象方法（签名不同，aka 一个新的方法）；</li><li>参数不同，返回值类型不同，则：子类中需要重新实现接口中的抽象方法；</li></ul></li><li>原理：子类会<strong>先继承自父类，然后再去实现接口</strong>；</li></ul></li></ul><hr></li><li><p>可以在一个普通类型中定义接口；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//源码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"><span class="comment">// 定义接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Climb</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>可以在一个接口类型中定义接口；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//源码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Hunt</span> </span>&#123;</span><br><span class="line"><span class="comment">// 定义接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Kill</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>应用（设计模式-wise）：</p><ul><li>工厂模式中：<ul><li>1 在工厂父类中定义一个接口；（用于创建产品对象）</li><li>2 在子类实现中来具体地创建实例；</li></ul></li></ul></li></ul><h5 id="Java中的访问权限修饰符的具体含义"><a href="#Java中的访问权限修饰符的具体含义" class="headerlink" title="Java中的访问权限修饰符的具体含义"></a>Java中的<em>访问权限修饰符</em>的具体含义</h5><p>参考：<a href="https://mp.weixin.qq.com/s/F7Rl64M5aD4UrzxUydPQdw">从HotSpot虚拟机源码认识访问权限修饰符</a></p><ul><li>private：<ul><li>被private修饰的部分，只在<strong>当前类</strong>中可以访问到</li></ul></li><li>package/default:<ul><li>被default修饰的部分，<strong>当前包中的其他类</strong>都能够访问到</li></ul></li><li>protected:<ul><li>被protected修饰的部分，<strong>其他包中的子类（继承自当前类）</strong>都能访问到</li></ul></li><li>public:<ul><li>被public修饰的部分，<strong>其他包中的任意类</strong>访问到</li></ul></li></ul><blockquote><p>访问控制因素：1 访问者是否在当前包； 2 访问者是否是当前类的子类；</p></blockquote><p><img src="https://s1.ax1x.com/2020/09/11/wNiTy9.png" alt="修饰符限定的访问范围"></p><h5 id="Java语言特性多态的具体应用场景"><a href="#Java语言特性多态的具体应用场景" class="headerlink" title="Java语言特性多态的具体应用场景"></a>Java语言特性<em>多态</em>的具体应用场景</h5><blockquote><p>注：这个问题真的把我问住了，对于多态的作用，一个基本的答案是“能够使一套代码根据运行时具体的实例产生不同的执行结果”。但是面试官并不满意，大脑迅速搜索库存中可能接近的答案，但是没能找到特别贴切的例子…😳</p></blockquote><p>其实JDBC就是多态应用的一个很好的例子🐣<font size=2>之前的理解只限于Oracle制定用法标准，具体的数据库厂商负责提供具体实现（像是某种设计模式）</font> 但其实在具体使用时，多态发挥了关键作用</p><p>参考：<a href="https://mp.weixin.qq.com/s/XShFqTkw2wmOd8-VCVNC-w">认识JDBC</a></p><ul><li>是：Oracle（Java语言的发明公司）所制定的<strong>Java程序员应该如何操作数据库</strong>的规范；</li><li>作用：<ul><li>1 规定了Java程序员在编写操作数据库的代码时所使用到的APIs（具体化程序员的工作）；</li><li>2 帮助程序员避开了操作数据库时繁琐的底层协议；</li></ul></li></ul><blockquote><p>说明：</p><ul><li>市场上有很多种类型的数据库（在Java语言之前就已经存在），比如MySQL、Oracle、 DB2等；</li><li>这些个厂商提供给Java程序员操作数据库的接口各不相同（毕竟是竞争关系嘛），这就导致Java程序员在编写代码时，需要根据具体使用的数据库类型来编写对应的代码；</li></ul></blockquote><ul><li><p>原理：</p><ul><li>1 Oracle（Java所属的公司）制定了JDBC规范，统一了Java程序员编写DB操作的编码方式；</li><li>2 Oracle要求/请求/强制/协商所有的数据库厂商，请大家根据我制定的规范，实现一个能够操作你家数据库的工具（这个工具叫做<strong>驱动</strong>）；</li><li>3 各大厂商就真的去根据JDBC规则实现了<strong>操作自家数据库的工具</strong>，然后免费开放出来，给Java程序员下载来用；</li></ul></li><li><p>用法（Java程序员编码过程）：</p><ul><li>1 把数据库厂商提供的jar包工具添加进项目中；（这个工具相当于接口的实现类）</li><li>2 使用JDBC规定的API编写代码来操作数据库；（JDBC规定的API相当于接口中的抽象方法）</li></ul><blockquote><p>Java程序员编写的代码为什么能够成功操作数据库的？</p><p>1 程序员在编写代码时，是在使用接口编程；</p><p>2 程序在运行时，会为接口类型绑定具体实例（厂商jar包中的实现类 <strong>代码中的多态</strong>）。所以代码真正执行时，使用的是<strong>厂商提供的子类的实例</strong>去完成对应数据库的操作；</p><p>3 既然用他们家的工具操作他们家的产品，当然就能正常地操作啦😄</p></blockquote></li></ul><h5 id="如何通过反射机制访问到类中的私有方法？"><a href="#如何通过反射机制访问到类中的私有方法？" class="headerlink" title="如何通过反射机制访问到类中的私有方法？"></a>如何通过反射机制访问到类中的私有方法？</h5><blockquote><p>注：这应该只是某个API，但当时记不得这么多细节了</p></blockquote><p>参考：<a href="https://www.cnblogs.com/mengdd/archive/2013/01/26/2878136.html">利用反射访问私有字段、方法</a></p><blockquote><p>使用反射机制的流程：</p><ul><li>1 获取到类的Class对象；</li><li>2 根据需要，获取到Method对象或者Field对象；<ul><li>任务：获取到Method对象；</li><li>API(参考文档):<ul><li>getMethod()方法，返回的是public的Method对象</li><li>getDeclaredMethod()，返回的Method对象可以是非public的</li></ul></li></ul></li></ul></blockquote><h6 id="访问私有方法的手段-反射用法："><a href="#访问私有方法的手段-反射用法：" class="headerlink" title="访问私有方法的手段/反射用法："></a>访问私有方法的手段/反射用法：</h6><ul><li>Prepare: 准备一个私有方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrivateClass</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 被private访问修饰符修饰的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">sayHello</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello: "</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>0 获取到私有方法的Method对象；</p><ul><li><p>手段：&lt;class对象&gt;.getDeclaredMethod(xxx, ooo);</p></li><li><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Ⅰ 创建实例</span></span><br><span class="line">PrivateClass p = <span class="keyword">new</span> PrivateClass();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ⅱ 使用实例获取到Class对象</span></span><br><span class="line">Class&lt;?&gt; classType = p.getClass();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ⅲ 使用Class对象获取Method对象</span></span><br><span class="line">Method method = classType.getDeclaredMethod(<span class="string">"sayHello"</span>,</span><br><span class="line">                                            <span class="keyword">new</span> Class[] &#123; String<span class="class">.<span class="keyword">class</span> &#125;)</span>;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>1 <strong>抑制Java访问权限的检查</strong>；</p><ul><li><p>手段：通过<strong>AccessibleObject类</strong>（Constructor、 Field和Method类的基类）中的<strong>setAccessible()</strong>方法；</p></li><li><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">method.setAccessible(<span class="keyword">true</span>); <span class="comment">// 抑制Java的访问控制检查</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>2 实现对方法的调用；</p><ul><li><p>手段：Method对象的invoke()方法；</p></li><li><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str = (String) method.invoke(p, <span class="keyword">new</span> Object[] &#123; <span class="string">"zhangsan"</span> &#125;);</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>总结：反射机制破坏了类的封装，private本来是保护方法只有在类的内部才能被访问到。但是现在通过反射机制，在其他类中（类的外部）同样可以访问private修饰的方法；</p><h5 id="项目中多线程具体的应用场景"><a href="#项目中多线程具体的应用场景" class="headerlink" title="项目中多线程具体的应用场景"></a>项目中多线程具体的应用场景</h5><blockquote><p>注：这个如果没有答好会很吃亏，对于项目中没有真正多线程经验的同学尤其如此。很露怯😳</p></blockquote><p>参考：<a href="https://mp.weixin.qq.com/s/hrhyihWRBnLX_ZRNachJmA">多线程的应用案例与具体场景</a></p><h6 id="多线程的使用场景"><a href="#多线程的使用场景" class="headerlink" title="多线程的使用场景"></a>多线程的使用场景</h6><ul><li>1 在一组操作中，有一个<strong>操作比较耗时</strong>（但又没那么重要）。可以开启一个新线程来执行这个操作<ul><li>比如用户注册完成后，赠送积分的操作；</li></ul></li><li>2 由于某些需求，可能<strong>需要某个线程一直在后台运行</strong>（比如定期执行某项任务-更新配置文件、采集特定信息…）；</li><li>3 某一个<strong>非常耗时的操作</strong>（比如备份数据库，这其实也算是后台任务）<ul><li>注：这种情况下，主线程需要轮询开启的线程以便了解备份的进度情况；</li></ul></li><li>4  某个业务逻辑有<strong>很多次的循环，而且每次循环之间没有相互影响</strong>（比如验证1万条url路径是否存在）；<ul><li>手段：开启50个线程，每个线程负责200条URL的验证；</li><li>特征：耗时比较短（砌墙的工人多了）</li></ul></li><li>5 希望获取到某个任务执行的进度（比如电影下载的进度条）；<ul><li>手段：不是很理解（做了Demo后回来补充 🚩）</li></ul></li></ul><h6 id="多线程的应用案例"><a href="#多线程的应用案例" class="headerlink" title="多线程的应用案例"></a>多线程的应用案例</h6><ul><li><p>1 Tomcat这个Web服务器就是采用多线程的方式来<strong>处理并发请求</strong>的;</p><ul><li>原理：<ul><li>1 每次有新的客户端向Web应用发起请求，Tomcat都会创建一个新的线程来处理它；</li><li>2 这个新线程最后会调用到程序员编写的Servlet代码-比如doGet()；</li></ul></li></ul></li><li><p>2 需要<strong>同时执行多个任务</strong>的场景（aka 异步处理）；</p><ul><li>手段：<ul><li>1 手动为每个任务创建一个线程；</li><li>2 通过JVM的线程调度来实现<strong>同时执行多个任务</strong>；</li></ul></li></ul><blockquote><p>单核CPU的电脑是不可能同时执行多个任务的。所以如果电脑只有一个核心，会使用一种技术，让每个线程都能够获取到CPU时间执行（这样看起来像是“<strong>同时执行</strong>”）</p></blockquote></li></ul><p>总结：多线程开发的目的是，<strong>尽量充分利用CPU资源</strong>；</p><p>SO， 如果某个业务逻辑执行非常耗时/效率低，就可以考虑使用多线程处理它。  </p>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;Java基础-2&quot;&gt;&lt;a href=&quot;#Java基础-2&quot; class=&quot;headerlink&quot; title=&quot;Java基础(2)&quot;&gt;&lt;/a&gt;Java基础(2)&lt;/h4&gt;&lt;h5 id=&quot;Java中的接口相关的内容&quot;&gt;&lt;a href=&quot;#Java中的接口相关的内容&quot; class=&quot;headerlink&quot; title=&quot;Java中的接口相关的内容&quot;&gt;&lt;/a&gt;Java中的接口相关的内容&lt;/h5&gt;</summary>
    
    
    
    <category term="Java Basic" scheme="https://henryinshanghai.github.io/categories/Java-Basic/"/>
    
    
    <category term="Java stuff" scheme="https://henryinshanghai.github.io/tags/Java-stuff/"/>
    
  </entry>
  
  <entry>
    <title>java基础之快速复习</title>
    <link href="https://henryinshanghai.github.io/Java-Basic/2020/09/09/interview/20200909-java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BF%AB%E9%80%9F%E5%A4%8D%E4%B9%A0.html"/>
    <id>https://henryinshanghai.github.io/Java-Basic/2020/09/09/interview/20200909-java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BF%AB%E9%80%9F%E5%A4%8D%E4%B9%A0.html</id>
    <published>2020-09-09T02:30:00.000Z</published>
    <updated>2020-09-11T06:58:19.631Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Java常见知识（Common-Sense）"><a href="#Java常见知识（Common-Sense）" class="headerlink" title="Java常见知识（Common Sense）"></a>Java常见知识（Common Sense）</h4><a id="more"></a><h5 id="1-重写-amp-重载"><a href="#1-重写-amp-重载" class="headerlink" title="1 重写&amp;重载"></a>1 重写&amp;重载</h5><ul><li>重写；<ul><li>是：一种编程技术；</li><li>作用：对父类中的方法重新进行实现，以满足子类的具体需求；</li><li>特征：<ul><li>1 发生在子类型/实现类型中；</li><li>2 方法签名与父类中的方法签名相同，方法实现应该会不同；</li><li>3 不能对父类中的private方法进行重写；</li></ul></li></ul></li><li>重载；<ul><li>是：一种编程技术；</li><li>作用：为某一个功能的方法，提供不同的/新的具体实现；</li><li>特征：<ul><li>1 编写的重载方法与原始方法在同一个类中；</li><li>2 重载方法的方法名和原始方法的方法名相同（某一功能），其他的细节不要求相同；</li></ul></li></ul></li></ul><h5 id="String、StringBuffer、StringBuilder的区别"><a href="#String、StringBuffer、StringBuilder的区别" class="headerlink" title="String、StringBuffer、StringBuilder的区别"></a>String、StringBuffer、StringBuilder的区别</h5><ul><li><p><strong>String</strong>:</p><ul><li><p>特征：</p><ul><li>1 String实例是不可变的；</li><li>2 由于实例是不可变的，所以多线程下实例是安全的（只可读）；</li><li>3 由于实例是不可变的，所以每次修改实例时，其实都在内存中新建了一个String实例；</li></ul></li><li><p>原理：String的底层数据结构是一个<em>被final修饰的字符数组</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span>[] value;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>StringBuffer &amp; StringBuilder</strong>:</p><ul><li><p>特征：</p><ul><li><p>1 实例是可变的；</p><ul><li>原理：<ul><li>1 它们都继承自AbstractStringBuilder 类型；</li><li>2 AbstractStringBuilder类型的底层数据结构为<em>一个*</em>没有被final修饰*<em>的字符数组</em>；</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title">Appendable</span>, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] value; <span class="comment">// 底层数据结构：字符数组</span></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></li><li><p>2 StringBuffer是线程安全的，而StringBuilder不是线程安全的；</p><ul><li>原理：<ul><li>StringBuffer对所有操作字符串的方法都加了锁，StringBuilder没有这么做；</li></ul></li></ul></li><li><p>3 单线程情况下，StringBuilder的效率更高；</p></li></ul></li></ul></li><li><p>用法总结：</p><ul><li>操作少量字符串时，可以使用String类型；</li><li>单线程情况下，操作大量字符串数据时，使用StringBuilder类型；</li><li>多线程情况下，操作大量字符串数据时，使用StringBuffer类型；</li></ul></li></ul><h5 id="Java中的自动装箱与自动拆箱"><a href="#Java中的自动装箱与自动拆箱" class="headerlink" title="Java中的自动装箱与自动拆箱"></a>Java中的自动装箱与自动拆箱</h5><ul><li>自动装箱；<ul><li>是：JDK提供的一种技术；</li><li>作用：<ul><li>在需要使用包装类型（Integer等）的场合中，如果程序员使用了基本数据类型（int），自动装箱技术能够把基本类型封装成为其对应的包装类型——从而保证代码编译的正确性；</li></ul></li><li>特征：<ul><li>这项技术会自动发挥作用，而不需要任何显式的语法声明；</li></ul></li></ul></li><li>自动拆箱：<ul><li>作用：在xxx的场合，如果xxx，xxx能够把包装类型自动拆封成为其对应的基本类型——从而xxx；</li></ul></li></ul><h5 id="Java中的-与equals-方法"><a href="#Java中的-与equals-方法" class="headerlink" title="Java中的==与equals()方法"></a>Java中的==与equals()方法</h5><ul><li><p>==</p><ul><li>是：Java提供的操作符；</li><li>作用：<ul><li>当==左右两侧是同类型的操作数时，<ul><li>如果操作数是<strong>基本数据类型</strong>，则：比较<em>操作数的数值</em>是否相等；</li><li>如果操作数是<strong>引用数据类型</strong>，则：比较<em>操作数的内存地址</em>是否相等；</li></ul></li><li>当==左右两侧不是同类型的操作数时，直接编译报错；</li></ul></li><li>特征：<ul><li>不同情况下，==的具体作用会有不同；</li></ul></li></ul></li><li><p>equals()方法</p><ul><li><p>是：Object类的一个方法；</p></li><li><p>作用：</p><ul><li><p>默认实现是：比较当前对象与另外一个对象的<em>内存地址是否相等</em>；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>特征：</p><ul><li>1 程序员在编码时，可能会根据具体的需要在类型中重写equals()方法——指定新的判等规则；</li><li>2 一般重写的判等规则，会根据对象的某个属性值来判断对象是否相等；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String类型的equals()方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">            <span class="comment">// 实现不重要，关键是equals()方法被重写了</span></span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>应用：</p><ul><li><p>1 String类型中的equals()方法被重写了，所以判断两个字符串实例是否相等时，判断依据是<strong>对象的值是否相等（而不是内存地址）</strong></p><blockquote><p>知识卡</p><p>当代码中创建String实例时，JVM会从常量池中查找是不是已经存在<strong>值与预期要创建的字符串实例相同</strong>的实例：</p><ul><li>如果存在，则：不新建String实例，而是直接把实例赋值给新的变量/引用；</li><li>如果不存在，则：会在常量池中新创建一个String实例；</li></ul><p>注：JDK1.8版本中似乎有些变动，具体待考证（Mark🚩）</p></blockquote></li></ul></li></ul><h5 id="关于final关键字"><a href="#关于final关键字" class="headerlink" title="关于final关键字"></a>关于final关键字</h5><ul><li><p>是：Java提供的一个关键字；</p></li><li><p>作用：</p><ul><li>修饰一个成份，标识此成份<strong>不可变</strong>；</li></ul></li><li><p>用法：</p><ul><li>1 修饰一个变量；<ul><li>1 变量为基本数据类型，则：变量的值一旦初始化后，就不能再改变；</li><li>2 变量为引用数据类型，则：变量初始化后，不能再重新绑定到新的对象；</li></ul></li><li>2 修饰一个方法；<ul><li>标识此方法不能被子类重写；</li></ul></li><li>3 修饰一个类；<ul><li>标识此类不能被扩展/继承；</li><li>原理：final类中的所有成员方法都隐式地被final修饰；</li></ul></li></ul><blockquote><p>知识卡：</p><p>关键字是什么？它是怎么发挥作用的？</p><p>是：字符串；</p><p>作用：能够被编译器识别出来，并默认有特定的含义；</p><p>原理：</p><ul><li>在实现编译器时，就对这些关键字的功能进行了内置的定义；</li><li><strong>所以关键字的作用是由Java编译器支持的</strong></li></ul></blockquote></li></ul><h5 id="Object类的常用方法【×7-×5】"><a href="#Object类的常用方法【×7-×5】" class="headerlink" title="Object类的常用方法【×7 + ×5】"></a>Object类的常用方法【×7 + ×5】</h5><p>🐖：在Java中，Object类型是所有其他类型的父类；</p><ul><li>getClass()方法；<ul><li>作用：返回当前运行时对象的Class对象 ；</li><li>特征：<ul><li>1 使用final关键字修饰（不允许子类重写）；</li></ul></li><li>应用：Java反射机制中获取运行时对象的信息；</li></ul></li><li>hashCode()方法；<ul><li>作用：返回对象的hash码；</li><li>应用：JDK中HashMap求key的哈希值；</li></ul></li><li>equals()方法；<ul><li>作用：比较两个对象的内存地址是否相等（aka 是否为同一个对象）；</li><li>用法：在子类型中重写，以重新定义判等规则；</li><li>应用：String类型；</li></ul></li><li>clone()方法；<ul><li>作用：创建并返回当前对象的一个副本；</li><li>用法规则：一般情况下，对于任何对象 x，<ul><li>表达式 x.clone() != x 为true；（副本与原始对象是独立的不同对象）</li><li>x.clone().getClass() == x.getClass() 为true ；（副本的Class对象与原始对象的Class对象是同一个对象）；</li></ul></li></ul></li><li>toString()方法；<ul><li>作用：返回实例的一个字符串标识；</li><li>规则：<em>类的名字</em>@<em>实例的哈希码的16进制表示</em></li></ul></li><li>多线程通知相关的方法【×5】 简单记忆<ul><li>1 notify()方法<ul><li>作用：唤醒正在等待锁的某个线程；</li><li>特征：<ul><li>1 如果有多个线程正在等待<strong>当前线程所持有的锁</strong>，此方法只会随机唤醒一个线程；</li><li>2 此方法不能被重写（被final修饰）；</li><li>3 此方法为native方法（使用C语言实现，无法查看源码）；</li></ul></li><li>用法：<ul><li>在当前线程对象上调用notify()方法，以此释放锁，从而唤醒其他等待这个锁的线程；</li></ul></li></ul></li><li>2 notifyAll()方法<ul><li>作用：唤醒正在等待锁的所有线程；</li><li>特征：<ul><li>等待锁的所有线程都被会被唤醒（😕唤醒也只有一个锁呀，唤醒有啥用？）</li></ul></li></ul></li><li>3 wait(long timeout)方法<ul><li>作用：暂停线程的执行；</li><li>特征：<ul><li>1 线程会释放自己所持有的锁；</li><li>2 timeout参数指定的是线程的释放锁之前的等待时间；</li></ul></li></ul></li><li>4 wait(long timeout, int nanos)<ul><li>作用：更加精确地暂停线程的执行；</li><li>特征：<ul><li>1 添加了nano参数，用于表示超时的额外时间（单位为毫微秒）；</li></ul></li></ul></li></ul></li><li>finalize ()方法；<ul><li>作用：定义<strong>实例被垃圾回收时</strong>所预期执行的操作；</li></ul></li></ul><h5 id="Java中的异常处理机制"><a href="#Java中的异常处理机制" class="headerlink" title="Java中的异常处理机制"></a>Java中的异常处理机制</h5><blockquote><p>知识卡</p><p>异常；</p><ul><li>是：一个名词；</li><li>作用：描述那些程序执行过程中发生的<strong>预期之外的事情</strong>；</li><li>特征：<ul><li>1 异常可以是语句执行引发的，也可以由程序员手动抛出（比如xxx数据类型不支持remove()操作，但是为了API的一致性又需要实现删除的API方法，那么就可以通过抛出一个异常来表示不支持此操作）；</li><li>2 程序中会使用一个异常对象来封装异常，以便使用代码处理它们；</li></ul></li><li>说明：程序中发生异常时，如果不做任何处理，程序就会完全终止；</li><li>处理异常的手段：<ul><li>在语言实现中提供一整套的处理机制（Java采用的手段）；</li></ul></li></ul></blockquote><ul><li><p>作用：</p><ul><li>1 为程序员提供一种编码方式，能够在编码时就对<em>可能出现的异常**</em>进行针对性的处理**；</li><li>2 通过1的处理，使得程序尽可能恢复正常并继续执行；</li></ul></li><li><p>特征：</p><ul><li>1 Throwable类型是Java异常类的顶级父类；</li><li>2 程序的异常分为两类（它们都是Throwable的子类）：<ul><li>Excpetion(异常)；</li><li>Error(错误)；</li></ul></li></ul></li><li><p>原理：当出现异常对象时，JRE就会尝试寻找异常处理程序(程序员手动编写)来处理异常；</p></li><li><p>用法：</p><ul><li>1 当程序运行出现Error时，表示出现了非常严重的错误（一般是虚拟机发生问题，通过编码无法处理这些错误）；<ul><li>Error的具体类型：<ul><li>内存溢出错误、虚拟机运行错误、类定义错误等；</li></ul></li><li>处理手段：JVM终止线程的运行（程序员不需要做任何事情）；</li></ul></li><li>2 当程序运行出现Exception时，表示出现了一些问题，但是可以通过代码处理这些问题；<ul><li>Exception的具体类型：<ul><li>空指针异常、算术运算异常、下标越界异常；</li></ul></li><li>处理手段：程序员在编码时，手动通过try/catch语法来对异常进行处理；</li></ul></li></ul></li><li><p>用法模板（编程语法）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">// 可能出现异常的代码片段</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (预期出现的异常类型)&#123;</span><br><span class="line">    <span class="comment">// 对捕捉到的异常进行处理的代码</span></span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 不管是否发生异常都会被执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>finally代码块的特征：<ul><li>0 正常情况下，finally块中的语句肯定会被执行（除非发生异常，或者被强制退出）；</li><li>1 如果try/catch中有return语句，finally代码块会在return之前被执行；</li></ul></li></ul></li></ul><h5 id="Java中获取键盘输入的手段"><a href="#Java中获取键盘输入的手段" class="headerlink" title="Java中获取键盘输入的手段"></a>Java中获取键盘输入的手段</h5><ul><li><p>手段1：Scanner类型；</p><ul><li><p>用法：</p><ul><li><p>1 使用标准输入(<strong>System.in</strong>)作为参数，创建一个Scanner对象；</p></li><li><p>2 调用Scanner实例的API，来在代码中获取到<em>用户通过键盘输入的内容</em>；</p></li><li><p>3 用完Scanner实例之后，关闭该实例；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">String s = input.nextLine();</span><br><span class="line">input.close();</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>手段2：不常用Mark🚩</p></li></ul><h5 id="Java中接口与抽象类的区别"><a href="#Java中接口与抽象类的区别" class="headerlink" title="Java中接口与抽象类的区别"></a>Java中接口与抽象类的区别</h5><ul><li>本质区别；<ul><li>接口用于定义一组行为规范，而抽象类用于抽象某一个实体类型（是模板设计）；</li></ul></li><li>语法特征上的区别（抽象类 VS 接口）：<ul><li>1 接口中定义的方法一般都是抽象的（Java8之后也允许接口方法有默认实现），而抽象类中可以有具体的方法实现；</li><li>2 接口中的实例变量默认会用final修饰，而抽象类不会；</li><li>3 接口中的方法默认都是public的；</li></ul></li><li>语法特征上的区别（类 VS 接口）<ul><li>1 自定义类型能够实现多个接口，但只能实现/继承一个抽象类；</li><li>2 自定义类型实现接口时，必须实现接口中所有的抽象方法。但实现抽象类时，可以选择性地实现其中的抽象方法；</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;Java常见知识（Common-Sense）&quot;&gt;&lt;a href=&quot;#Java常见知识（Common-Sense）&quot; class=&quot;headerlink&quot; title=&quot;Java常见知识（Common Sense）&quot;&gt;&lt;/a&gt;Java常见知识（Common Sense）&lt;/h4&gt;</summary>
    
    
    
    <category term="Java Basic" scheme="https://henryinshanghai.github.io/categories/Java-Basic/"/>
    
    
    <category term="Java stuff" scheme="https://henryinshanghai.github.io/tags/Java-stuff/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之代理模式</title>
    <link href="https://henryinshanghai.github.io/Design-Model/Proxy-mode/2020/09/08/interview/20200908-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.html"/>
    <id>https://henryinshanghai.github.io/Design-Model/Proxy-mode/2020/09/08/interview/20200908-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.html</id>
    <published>2020-09-08T04:30:00.000Z</published>
    <updated>2020-09-09T03:27:24.282Z</updated>
    
    <content type="html"><![CDATA[<h4 id="代理模式-amp-Java所提供的具体实现手段-Ⅰ"><a href="#代理模式-amp-Java所提供的具体实现手段-Ⅰ" class="headerlink" title="代理模式 &amp; Java所提供的具体实现手段_Ⅰ"></a>代理模式 &amp; Java所提供的具体实现手段_Ⅰ</h4><h5 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h5><a id="more"></a><ul><li><p>作用：</p><ul><li>1 解耦<strong>客户端代码</strong>与<strong>具体实例</strong>之间的依赖关系；</li><li>2 控制<strong>客户端代码</strong>对<strong>具体实例</strong>的访问；</li><li>3 在代理中，对具体实例的功能进行增强（有点子像装饰器模式，figure out this later）；</li></ul></li><li><p>特征：</p><ul><li><p>1 这里的“代理”指的是<strong>具体实例</strong>的代理；</p><blockquote><p>比如我要租房，而我没办法直接找到房东。</p><p>但是我知道链家的经纪人一般能够作为房东（具体实例）的代理;</p><p>所以我只要联系链家经纪人（房东的代理），就能去租房东的房子了；</p></blockquote></li></ul></li><li><p>应用场景：</p><ul><li>1 客户端代码不希望直接访问某个具体实例（这会导致强耦合）；</li><li>2 客户端代码无法直接访问到某个具体实例（WHY?🙋）；</li></ul><p>在以上场景中，客户端代码可以<strong>通过代理对象来访问到具体实例（目标对象）</strong>；</p></li></ul><h6 id="UML图描述各个部分的关系："><a href="#UML图描述各个部分的关系：" class="headerlink" title="UML图描述各个部分的关系："></a>UML图描述各个部分的关系：</h6><p><img src="https://s1.ax1x.com/2020/09/08/wMyxZ6.png" alt="代理模式中各个部分之间的关系"></p><p><font size=2>可能是我不太清楚UML图的规则，我不很喜欢UML描述各部分关系的方式</font></p><h6 id="用法（根据UML类图）"><a href="#用法（根据UML类图）" class="headerlink" title="用法（根据UML类图）"></a>用法（根据UML类图）</h6><ul><li><p>用法（根据UML类图）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 准备一个接口特征：目标类 与 代理类都需要实现这个接口（这样才能在代码中无差别地使用接口类型）</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 定义具体类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"This is real doSomeThing"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3 定义代理类型作用：代理具体的类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxySubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123; <span class="comment">// 特征1：实现具体类型所实现的接口</span></span><br><span class="line"><span class="comment">// 特征2：持有具体类型的实例变量</span></span><br><span class="line">    <span class="keyword">private</span> Subject mSubject;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 特征3：通过构造方法来初始化具体类型的实例变量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxySubject</span><span class="params">(Subject realSubject)</span> </span>&#123;</span><br><span class="line">        mSubject = realSubject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 委托具体实例完成具体的操作</span></span><br><span class="line">        mSubject.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4 客户端代码的编写</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 4-1 创建具体类型</span></span><br><span class="line">        Subject mRealSubject=<span class="keyword">new</span> RealSubject();</span><br><span class="line">        <span class="comment">// 4-2 创建代理类</span></span><br><span class="line">        ProxySubject mProxy = <span class="keyword">new</span> ProxySubject(mRealSubject);</span><br><span class="line">        <span class="comment">// 4-3 客户端代码调用代理对象来实现需要的操作</span></span><br><span class="line">        mProxy.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码有点子多，拆解一下：</p><ul><li>根据UML类图实现代理模式的流程：<ul><li>1 准备一个接口；<ul><li>作用：具体类型 与 代理类型都需要实现这个接口，以便在客户端代码中能够无差别地使用代理对象替代具体实例；</li></ul></li><li>2 编写具体类型；<ul><li>作用：实现具体的方法，作为最终会被执行的方法；</li></ul></li><li>3 编写代理类型；<ul><li>作用：控制客户端代码中对具体实例的访问（虚）；</li></ul></li><li>4 编写客户端代码；<ul><li>作用：使用各个组件编写出的主流程代码（体现代理模式的作用）；</li></ul></li></ul></li></ul></li></ul><h6 id="为什么客户端代码中需要使用代理对象呢？😕"><a href="#为什么客户端代码中需要使用代理对象呢？😕" class="headerlink" title="为什么客户端代码中需要使用代理对象呢？😕"></a>为什么客户端代码中需要使用代理对象呢？😕</h6><ul><li><p>窘境：在第4步中，为了创建出代理对象，还是需要先创建出具体实例。既然已经有了具体实例，为什么还要使用代理对象呢？</p></li><li><p>原因：这里是因为<em>代理类中具体类型的实例变量</em>是通过<em>构造方法的参数</em>进行初始化的——这样不能很好地描述代理模式的工作方式（因为客户端代码中既存在代理对象，又存在具体实例对象）；【uncertain】</p></li><li><p>解决手段：在代理类中，可以在声明实例变量的时候进行初始化操作；</p></li><li><p>特征/issue：</p><ul><li>这样每个代理类就只能代理某一种具体的类型；就像一个链家经纪人只能代理一个房东一样，这种处理方式效率很低；</li></ul><p>追问：</p></li><li><p>追问：</p><ul><li>有没有其他方式能够用代理对象代理多个具体类型呢？</li></ul></li></ul><h5 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h5><ul><li><p>作用：</p><ul><li>创建出目标对象的代理对象，以控制对目标对象的访问；</li></ul></li><li><p>特征：</p><ul><li>1 不需要为每个<em>具体类型</em>都手动创建<em>其对应的代理类型</em>；</li><li>2 使用JDK提供的工具，传入需要的参数即可得到一个代理对象；</li><li>3 代理类并不是在程序编译的时候创建，而是在运行的过程中通过Java的反射机制动态的进行创建；</li></ul></li><li><p>用法：</p><ul><li>1 准备一个接口；</li><li>2 准备一个具体类型；</li><li>3 自定义一个处理器类型，实现InvocationHandler接口，并重写invoke()方法；</li><li>4 在客户端代码中，通过Proxy.newProxyInstance(&lt;类加载器&gt;, &lt;接口数组&gt;, &lt;处理器&gt;)来获取到一个代理对象；</li><li>5 通过4中得到的代理对象来操作具体对象（以获取到一些增强的功能）</li></ul></li><li><p>代码示例</p><blockquote><p>1 定义接口</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代理类和被代理的接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SaleComputer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sale</span><span class="params">(<span class="keyword">double</span> money)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>2 定义具体类型</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by qjq on 2020/2/23 10:53</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lenovo</span> <span class="keyword">implements</span> <span class="title">SaleComputer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sale</span><span class="params">(<span class="keyword">double</span> money)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"卖出一台电脑，价值："</span>+money);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"联想电脑"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"展示电脑"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>3 客户端代码【注：InvocationHandler接口的实现类使用匿名内部类来实现】</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler; <span class="comment">// 全限定名以java开头，说明是JDK提供的类型/接口</span></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by qjq on 2020/2/23 10:55</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 创建真实对象</span></span><br><span class="line">        Lenovo company = <span class="keyword">new</span> Lenovo();</span><br><span class="line">        <span class="comment">//2. 创建动态代理</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        三个参数：</span></span><br><span class="line"><span class="comment">            1. 类加载器：真实对象.getClass().getClassLoader()</span></span><br><span class="line"><span class="comment">            2. 接口数组：真实对象.getClass().getInterfaces()</span></span><br><span class="line"><span class="comment">            3. 处理器：new InvocationHandler()，处理和被代理对象的方法，即方法增强的地方</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        SaleComputer proxy_lenovo = (SaleComputer)            Proxy.newProxyInstance(company.getClass().getClassLoader(), company.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">            <span class="comment">/*代理逻辑编写的方法，代理对象调用的所有方法都会触发该方法的执行</span></span><br><span class="line"><span class="comment">            参数：</span></span><br><span class="line"><span class="comment">                1. proxy：代理对象（一般不用）</span></span><br><span class="line"><span class="comment">                2. method：代理对象调用的方法，被封装为的对象</span></span><br><span class="line"><span class="comment">                3. args：代理对象调用的方法时，传入的实际参数</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                Object obj =<span class="keyword">null</span>;</span><br><span class="line">                System.out.println(<span class="string">"这里是代理。。。。"</span>);</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">"sale"</span>.equals(method.getName()))&#123;</span><br><span class="line">                    <span class="comment">//增强参数</span></span><br><span class="line">                    Double money = (Double) args[<span class="number">0</span>];<span class="comment">//用户买电脑付的钱</span></span><br><span class="line">                    money = money*<span class="number">0.8</span>;<span class="comment">//给电脑厂商的钱</span></span><br><span class="line">                    System.out.println(<span class="string">"你被增强啦"</span>);</span><br><span class="line">                    <span class="comment">//使用compay对象执行此方法，返回值就是真实对象方法的返回值</span></span><br><span class="line">                    obj = method.invoke(company, money);</span><br><span class="line">                    <span class="comment">//增强返回值</span></span><br><span class="line">                    obj = obj+<span class="string">"_鼠标垫"</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    obj = method.invoke(company, args);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> obj;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 客户端代码使用代理对象来编码</span></span><br><span class="line">        String computer = proxy_lenovo.sale(<span class="number">8000</span>);<span class="comment">//用户付钱</span></span><br><span class="line">        System.out.println(computer);<span class="comment">//用户得到的产品</span></span><br><span class="line">        System.out.println(<span class="string">"---------------------"</span>);</span><br><span class="line">        proxy_lenovo.show();<span class="comment">//展示商品</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>疑问：</p><p>如果只是通过代理获取到一些增强的功能，那代理模式就和装饰者模式没有差别呀😮</p></li><li><p>不足：</p><p>获取代理对象时，需要传入代理类型预期实现的接口。所以如果具体类型没有实现任何接口，就不能通过这种方式来生成代理对象😳</p></li><li><p>解决手段：CGLib动态代理</p></li></ul><h5 id="CGLib动态代理"><a href="#CGLib动态代理" class="headerlink" title="CGLib动态代理"></a>CGLib动态代理</h5><ul><li><p>特征：</p><ul><li>1 不要求具体类型实现接口；</li><li>2 具体类型的方法不能被final修饰（因为final修饰的方法无法被重写，所以子类方法的字节码无法正常生成）；</li><li>3 具体类型不能被final修饰（因为被final修饰的类无法被继承，也就无法生成子类字节码）；</li><li>4 依赖于第三方库cglib；</li></ul></li><li><p>原理：</p><ul><li>1 动态生成具体类型(被代理类)的子类字节码;</li><li>2 由于其字节码都是按照jvm编译后的class文件的规范编写的，因而其可以被jvm正常加载并运行;</li></ul></li><li><p>用法：</p><ul><li>1 引入cglib的jar包；</li><li>2 调用jar包所提供的Enhancer类的create()方法，生成代理对象；<ul><li>create()方法的参数：<ul><li>&lt;Class对象&gt;：具体类型的Class对象/字节码；</li><li>&lt;Callback类型实例&gt;: 自定义的代理增强实现；<ul><li>手段：编写一个类，实现Callback接口/子接口的实现类<strong>MethodInterceptor</strong>；</li></ul></li></ul></li></ul></li></ul></li><li><p>代码示例：</p><blockquote><p>具体类型</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 电脑生产商</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lenovo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sale</span><span class="params">(<span class="keyword">double</span> money)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"卖出一台电脑，价值："</span>+money);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"联想电脑"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"展示电脑"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>客户端代码【注：Callback类型参数使用匿名内部类】</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * CGLib动态代理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibProxy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Lenovo factory = <span class="keyword">new</span> Lenovo();</span><br><span class="line">        <span class="comment">// 创建代理对象手段：Enhancer.create(&lt;Class对象&gt;, &lt;Callback对象&gt;)</span></span><br><span class="line">        <span class="comment">// 1 获取具体类型的Class对象手段:实例.getClass()；</span></span><br><span class="line">        <span class="comment">// 2 创建Callback类型的对象(匿名内部类)手段：new MethodInterceptor()&#123; ... &#125; </span></span><br><span class="line">        Lenovo proxy_CGLib = (Lenovo) Enhancer.create(factory.getClass(), <span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 执行被代理对象的任何方法都会经过该方法</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> proxy 代理对象 </span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> method 方法所封装得到的对象</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> args 参数封装得到的对象    注：以上三个参数和基于接口的动态代理中invoke方法的参数是一样的</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> methodProxy ：当前执行方法的代理对象</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@return</span> 调用方法的返回值</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                Object obj = <span class="keyword">null</span>;</span><br><span class="line">                System.out.println(<span class="string">"这里是CGLib动态代理。。。。"</span>);</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">"sale"</span>.equals(method.getName())) &#123;<span class="comment">//当是sale方法时</span></span><br><span class="line">                    <span class="comment">//增强参数</span></span><br><span class="line">                    Double money = (Double) args[<span class="number">0</span>];<span class="comment">//用户买电脑付的钱</span></span><br><span class="line">                    money = money * <span class="number">0.8</span>;<span class="comment">//给电脑厂商的钱</span></span><br><span class="line">                    System.out.println(<span class="string">"你被增强啦"</span>);</span><br><span class="line">                    <span class="comment">//使用factory对象执行此方法，返回值就是真实对象方法的返回值</span></span><br><span class="line">                    obj = method.invoke(factory, money);</span><br><span class="line">                    <span class="comment">//增强返回值</span></span><br><span class="line">                    obj = obj + <span class="string">"_鼠标垫"</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;<span class="comment">//因为这里只有两个方法，所以使用else，也就是指show方法</span></span><br><span class="line">                    obj = method.invoke(factory, args);<span class="comment">//这里执行打印，有无返回值一样</span></span><br><span class="line">                    System.out.println(<span class="string">"小新pro13"</span>);</span><br><span class="line">                    System.out.println(<span class="string">"ThinkPad"</span>);</span><br><span class="line">                    System.out.println(<span class="string">"...."</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> obj;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 客户端代码使用代理对象进行编码</span></span><br><span class="line">        String computer = proxy_CGLib.sale(<span class="number">8000</span>);<span class="comment">//用户付钱</span></span><br><span class="line">        System.out.println(computer);<span class="comment">//用户得到的产品</span></span><br><span class="line">        System.out.println(<span class="string">"---------------------"</span>);</span><br><span class="line">        proxy_CGLib.show();<span class="comment">//展示商品</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ul><li>静态代理：<ul><li>需要手动创建代理类，而且每一个具体类型都需要单独创建一个代理类；</li></ul></li><li>JDK动态代理：<ul><li>1 要求具体类型实现某种接口（可自定义）；</li><li>2 使用JDK提供的Proxy类型的newProxyInstance()方法来动态创建代理类；</li></ul></li><li>CGLib动态代理：<ul><li>1 要求具体类型不能被final修饰；</li><li>2 原理：扩展被代理的类型，隐式得到一个增强后的子类；</li></ul></li></ul><h5 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h5><p><a href="https://segmentfault.com/a/1190000021841185">segmentFault-代理模式总结</a></p><p><a href="https://juejin.im/post/6844903544965857294">掘金-代理模式</a></p><blockquote><p>until next time</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;代理模式-amp-Java所提供的具体实现手段-Ⅰ&quot;&gt;&lt;a href=&quot;#代理模式-amp-Java所提供的具体实现手段-Ⅰ&quot; class=&quot;headerlink&quot; title=&quot;代理模式 &amp;amp; Java所提供的具体实现手段_Ⅰ&quot;&gt;&lt;/a&gt;代理模式 &amp;amp; Java所提供的具体实现手段_Ⅰ&lt;/h4&gt;&lt;h5 id=&quot;代理模式&quot;&gt;&lt;a href=&quot;#代理模式&quot; class=&quot;headerlink&quot; title=&quot;代理模式&quot;&gt;&lt;/a&gt;代理模式&lt;/h5&gt;</summary>
    
    
    
    <category term="Design Model" scheme="https://henryinshanghai.github.io/categories/Design-Model/"/>
    
    <category term="Proxy mode" scheme="https://henryinshanghai.github.io/categories/Design-Model/Proxy-mode/"/>
    
    
    <category term="Fancy Stuff" scheme="https://henryinshanghai.github.io/tags/Fancy-Stuff/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之单例模式</title>
    <link href="https://henryinshanghai.github.io/Design-Model/2020/09/07/interview/20200907-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.html"/>
    <id>https://henryinshanghai.github.io/Design-Model/2020/09/07/interview/20200907-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.html</id>
    <published>2020-09-07T06:30:00.000Z</published>
    <updated>2020-09-09T03:25:58.015Z</updated>
    
    <content type="html"><![CDATA[<h4 id="快速博客（使用双重检查锁来实现多线程下的单例模式）"><a href="#快速博客（使用双重检查锁来实现多线程下的单例模式）" class="headerlink" title="快速博客（使用双重检查锁来实现多线程下的单例模式）"></a>快速博客（使用双重检查锁来实现多线程下的单例模式）</h4><h5 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h5><p>是：一个性质；</p><p>作用：描述特定的类只能存在一个实例对象的性质；</p><a id="more"></a><h5 id="单线程下的单例"><a href="#单线程下的单例" class="headerlink" title="单线程下的单例"></a>单线程下的单例</h5><p>手段：</p><ul><li>1 类中持有静态私有变量uniqueInstance;</li><li>2 把构造方法私有化；</li><li>3 提供一个公开的获取单例对象的方法getInstance()；<ul><li>在方法中，先判空，再new出来单例对象；</li></ul></li></ul><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(uniqueInstance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="多线程下的单例模式（特征：双重检查锁）"><a href="#多线程下的单例模式（特征：双重检查锁）" class="headerlink" title="多线程下的单例模式（特征：双重检查锁）"></a>多线程下的单例模式（特征：双重检查锁）</h5><p>手段：</p><ul><li><p>1 为创建单例对象的if()语句块加锁（类对象的锁）；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(Singleton<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(uniqueInstance == <span class="keyword">null</span>)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>2 避免多线程不必要地抢夺锁（如果实例已经创建了，就没有必要再去抢夺锁了）</p><p>手段：在抢夺锁之前，判断单例是不是已经存在了；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(uniqueInstance == <span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(Singleton<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(xxx)&#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>3 避免多线程下，创建对象操作所引起的非单例情况；</p><p>手段：为实例变量添加volatile修饰符，避免创建对象时发生指令重排；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br></pre></td></tr></table></figure></li></ul><h6 id="完成代码"><a href="#完成代码" class="headerlink" title="完成代码"></a>完成代码</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == instance) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == instance) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();   </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>ok, until next time 😄</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;快速博客（使用双重检查锁来实现多线程下的单例模式）&quot;&gt;&lt;a href=&quot;#快速博客（使用双重检查锁来实现多线程下的单例模式）&quot; class=&quot;headerlink&quot; title=&quot;快速博客（使用双重检查锁来实现多线程下的单例模式）&quot;&gt;&lt;/a&gt;快速博客（使用双重检查锁来实现多线程下的单例模式）&lt;/h4&gt;&lt;h5 id=&quot;单例&quot;&gt;&lt;a href=&quot;#单例&quot; class=&quot;headerlink&quot; title=&quot;单例&quot;&gt;&lt;/a&gt;单例&lt;/h5&gt;&lt;p&gt;是：一个性质；&lt;/p&gt;
&lt;p&gt;作用：描述特定的类只能存在一个实例对象的性质；&lt;/p&gt;</summary>
    
    
    
    <category term="Design Model" scheme="https://henryinshanghai.github.io/categories/Design-Model/"/>
    
    
    <category term="Fancy Stuff" scheme="https://henryinshanghai.github.io/tags/Fancy-Stuff/"/>
    
  </entry>
  
  <entry>
    <title>Java垃圾回收机制</title>
    <link href="https://henryinshanghai.github.io/JVM/2020/09/07/interview/20200907-Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.html"/>
    <id>https://henryinshanghai.github.io/JVM/2020/09/07/interview/20200907-Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.html</id>
    <published>2020-09-07T04:30:00.000Z</published>
    <updated>2020-09-07T05:30:16.016Z</updated>
    
    <content type="html"><![CDATA[<h4 id="JVM之垃圾回收"><a href="#JVM之垃圾回收" class="headerlink" title="JVM之垃圾回收"></a>JVM之垃圾回收</h4><h5 id="为什么要进行垃圾回收？"><a href="#为什么要进行垃圾回收？" class="headerlink" title="为什么要进行垃圾回收？"></a>为什么要进行垃圾回收？</h5><ul><li>1 提高内存资源的利用率；</li><li>2 防止无用的垃圾挤占内存空间，影响程序的正常运行；</li></ul><a id="more"></a><h5 id="如何判断内存中的一个对象是不是垃圾？"><a href="#如何判断内存中的一个对象是不是垃圾？" class="headerlink" title="如何判断内存中的一个对象是不是垃圾？"></a>如何判断内存中的一个对象是不是垃圾？</h5><h6 id="知识卡"><a href="#知识卡" class="headerlink" title="知识卡"></a>知识卡</h6><ul><li>垃圾：不再被使用的资源；</li><li>程序中的垃圾：不再被使用的对象；</li></ul><h6 id="如何判断一个对象已经“不再被使用”（aka-成为垃圾）？"><a href="#如何判断一个对象已经“不再被使用”（aka-成为垃圾）？" class="headerlink" title="如何判断一个对象已经“不再被使用”（aka 成为垃圾）？"></a>如何判断一个对象已经“不再被使用”（aka 成为垃圾）？</h6><p>答：垃圾判定算法；</p><ul><li>手段1：引用计数法；<ul><li>具体方法：<ul><li>1 在内存中创建对象后，即为对象配置一个引用计数器；</li><li>2 如果对象通过某种方式（比如类A持有类B的实例对象）被引用，则引用计数器的值+1；</li><li>3 如果引用关系结束，则引用计数器的值-1（什么叫引用关系结束？😕）；</li></ul></li><li>作用：<ul><li>这样通过对象的引用计数器的值，就可以清楚对象是不是已经变成垃圾，从而决定是否回收此对象占用的空间；</li></ul></li><li>特征：<ul><li>1 执行效率高，对主程序影响小；</li><li>2 如果程序中出现了循环引用（a引用b，而b也引用a），则引用计数法无法处理这种类型的垃圾；</li></ul></li></ul></li><li>手段2：可达性分析算法；<ul><li>具体方法：<ul><li>1 使用<em>有向图中的一个顶点</em>来表示一个对象；</li><li>2 使用<em>有向图中的一条边</em>来表示“<em>一个对象对另一个对象的引用</em>”；</li><li>3 从特定的顶点（GC Root）开始进行搜索指定的对象（待审判的对象defendant），<ul><li>如果搜索到了defendant,则它不是垃圾；</li><li>如果没能搜索到defendant,则它已经变成了垃圾（不可达对象）；</li></ul></li></ul></li><li>作用：<ul><li>通过指定对象defendant在有向图中是否可以到达，就可以清楚对象是不是已经变成垃圾；</li></ul></li><li>特征：<ul><li>1 能够处理“循环引用的垃圾对象”；</li><li>2 这是JVM垃圾回收所选择的手段；</li><li>3 可以被作为GC Root的对象有：虚拟机栈中所引用的对象…</li></ul></li></ul></li></ul><h5 id="找到哪些对象是垃圾后，怎么回收它们占用的内存？"><a href="#找到哪些对象是垃圾后，怎么回收它们占用的内存？" class="headerlink" title="找到哪些对象是垃圾后，怎么回收它们占用的内存？"></a>找到哪些对象是垃圾后，怎么回收它们占用的内存？</h5><p>答：垃圾回收算法；</p><h6 id="知识卡-1"><a href="#知识卡-1" class="headerlink" title="知识卡"></a>知识卡</h6><p>Java中提供了4种垃圾回收的手段：</p><ul><li>标记-清除算法；<ul><li>SOP过程：<ul><li>1 遍历内存中所有的对象；</li><li>2 标记出哪些对象是垃圾（使用垃圾判定算法）；</li><li>3 清理掉所有垃圾对象；</li></ul></li><li>特征：<ul><li>1 这种清除方式会导致<em>清除出来的内存空间</em>不连续地分布在内存中，aka，一堆的<strong>内存碎片</strong>；</li><li>2 过多的内存碎片会导致内存的使用率降低，因为清理出的空间可能<em>不足够创建一个新的对象</em>；</li></ul></li></ul></li><li>复制算法；<ul><li>SOP过程：<ul><li>1 把内存空间划分成两个区域：空闲区域A + 用于存储对象的区域B；</li><li>2 当区域B空间用完的时候，则：<ul><li>1 把区域B中的非垃圾对象复制一份，拷贝/复制到区域A中；</li><li>2 清除区域B中的所有对象（垃圾 + 非垃圾）；</li></ul></li></ul></li><li>特征：<ul><li>1 内存中不会出现内存碎片；</li><li>2 整体内存使用率低，因为只有一半的内存被用来存储对象；</li><li>3 复制对象的过程比较耗时；</li></ul></li><li>应用：<ul><li>回收JVM新生代（<font size=2>注：JVM内存区域的划分需要另一篇博客了</font>）中存活率低的对象；</li></ul></li></ul></li><li>3 标记 - 整理算法；<ul><li>SOP过程：<ul><li>1 找到内存中所有的垃圾对象；</li><li>2 把1中找到的所有垃圾对象移动到一个连续的空间（dumping area）中；</li><li>3 把dumping area中的对象全部清除；</li></ul></li><li>特征：<ul><li>1 不会产生内存碎片；</li><li>2 不会导致内存空间的浪费；</li><li>3 移动垃圾对象是一个耗时的过程；</li></ul></li><li>应用：<ul><li>对象存活率比较高的场合；</li></ul></li></ul></li><li>4 分代收集算法（博采众长，为我所用）<ul><li>SOP过程：<ul><li>1 把JVM内存分成3个区域：新生代、老年代、永久代；</li><li>2 对不同区域中的对象，采用不同的垃圾回收算法：<ul><li>新生代（用于存放生命周期短的对象）：使用复制算法【标记-复制到空闲区-整体删除】；</li><li>老年代（用于存放生命周期长的对象）：使用标记-整理算法【标记-整理-集中删除】；</li></ul></li></ul></li><li>特征：<ul><li>1 对JVM的内存空间进行了逻辑划分；</li><li>2 针对不同区域采用了不同的清除算法；</li></ul></li></ul></li></ul><h5 id="清除垃圾的工作具体是谁来完成的？"><a href="#清除垃圾的工作具体是谁来完成的？" class="headerlink" title="清除垃圾的工作具体是谁来完成的？"></a>清除垃圾的工作具体是谁来完成的？</h5><p>答：垃圾收集器；</p><p>知识卡：</p><p>​    对于JVM中不同的内存区域，具体执行垃圾清除工作的垃圾收集器也是不一样的；</p><p>​    原因：因为不同的<strong>垃圾收集器</strong>实现了不同的<strong>垃圾回收算法</strong>；</p><p>具体分类：</p><ul><li>新生代区域（同一个回收算法的不同实现结果）：<ul><li>1 Serial收集器；</li><li>2 ParNew收集器；</li><li>3 Parallel收集器；</li></ul></li></ul><blockquote><p>虽然不清楚为什么有这么些个收集器，但是它们都是某一个算法的具体实现结果。只是在实现时新增了独特的特性…</p></blockquote><ul><li>老年代区域：<ul><li>1 Serial Old收集器；</li><li>2 ParNew Old收集器；</li><li>3 CMS收集器；</li></ul></li></ul><blockquote><p>好歹记住一个收集器吧，Serial收集器。<strong>单线程串行(Serial)执行</strong>垃圾回收，<strong>(1)</strong>不需要切换线程，<strong>(2)</strong>但是回收时会终止程序的执行；</p></blockquote><blockquote><p>alright, until next time.😄</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;JVM之垃圾回收&quot;&gt;&lt;a href=&quot;#JVM之垃圾回收&quot; class=&quot;headerlink&quot; title=&quot;JVM之垃圾回收&quot;&gt;&lt;/a&gt;JVM之垃圾回收&lt;/h4&gt;&lt;h5 id=&quot;为什么要进行垃圾回收？&quot;&gt;&lt;a href=&quot;#为什么要进行垃圾回收？&quot; class=&quot;headerlink&quot; title=&quot;为什么要进行垃圾回收？&quot;&gt;&lt;/a&gt;为什么要进行垃圾回收？&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;1 提高内存资源的利用率；&lt;/li&gt;
&lt;li&gt;2 防止无用的垃圾挤占内存空间，影响程序的正常运行；&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="JVM" scheme="https://henryinshanghai.github.io/categories/JVM/"/>
    
    
    <category term="Garbage Collection" scheme="https://henryinshanghai.github.io/tags/Garbage-Collection/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之简单工厂模式</title>
    <link href="https://henryinshanghai.github.io/Design-Model/2020/09/07/interview/20200907-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.html"/>
    <id>https://henryinshanghai.github.io/Design-Model/2020/09/07/interview/20200907-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.html</id>
    <published>2020-09-07T04:30:00.000Z</published>
    <updated>2020-09-07T06:58:55.886Z</updated>
    
    <content type="html"><![CDATA[<p>诚实地讲，我看过设计模式的一本书，但是仍旧觉得它是悬浮在大气层外面的东西。现在对设计模式的基本认识是，它能够：</p><ul><li>封装变化，从而以最小的代码改动应对需求变化；</li></ul><a id="more"></a><h4 id="常见的设计模式"><a href="#常见的设计模式" class="headerlink" title="常见的设计模式"></a>常见的设计模式</h4><h5 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h5><ul><li><p>作用：解耦<strong>客户端代码</strong>与<strong>具体实例</strong>之间的依赖；</p></li><li><p>直接依赖导致的问题：</p><ul><li>场景：A对象如果要调用B对象，最简单的做法就是直接new一个B出来【直接依赖】。</li><li>需求改动：系统需要把B类修改成C类（假如C类和B类实现了同一个接口/继承自同一个类）；</li><li>手段：程序员只能改动A类代码（客户端代码）。</li><li>特征：如果程序中有100个地方new了B对象，那么就要修改100处（😫）。</li></ul></li><li><p>简单工厂模式的用法SOP：</p><ul><li>1 定义一个工厂类IFactory(工厂类能够创建各种类型的实例);</li><li>2 编写客户端代码时，使用工厂类来获取到所需要的实例B；</li><li>3 当需求变化为：客户端代码使用实例C时,客户端代码不需要做出任何变化…(really?)</li></ul></li><li><p>示例</p><blockquote><p>水果接口</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Fruit</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 接口中规定的行为集合</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">grow</span><span class="params">()</span></span>;<span class="comment">// 生长</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">harveset</span><span class="params">()</span></span>; <span class="comment">// 收货</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">plant</span><span class="params">()</span></span>;<span class="comment">// 种植</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>两个子类型：苹果和葡萄</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">implements</span> <span class="title">Fruit</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Apple.grow()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">harveset</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Apple.harveset()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">plant</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Apple.plant()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Grape</span> <span class="keyword">implements</span> <span class="title">Fruit</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Grape.grow()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">harveset</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Grape.harveset()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">plant</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Grape.plant()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>园丁（工厂类） 用于生产各种水果</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Gardener</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Fruit <span class="title">getFruit</span><span class="params">(String fruit)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 根据传入的参数，来new出对应类型的实例</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"apple"</span>.equalsIgnoreCase(fruit))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Apple();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"grape"</span>.equalsIgnoreCase(fruit))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Grape();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>客户端代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 需要苹果时，传入APPLE参数</span></span><br><span class="line">    Fruit fruit0 = Gardener.getFruit(<span class="string">"APPLE"</span>);</span><br><span class="line">    <span class="comment">// 消费苹果实例aka 调用apple实例的方法</span></span><br><span class="line">    fruit0.grow();</span><br><span class="line">    <span class="comment">// 需要葡萄时，传入GRAPE参数</span></span><br><span class="line">    Fruit fruit1 = Gardener.getFruit(<span class="string">"GRAPE"</span>);</span><br><span class="line">    fruit1.harveset();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>需求变动时，客户端代码还是需要改动呀？传入工厂类的参数需要变化</p></blockquote></li><li><p>简单工厂模式的作用：</p><ul><li>1 客户端代码不需要直接new具体实例，而是通过工厂类去获取；</li><li>2 把创建实例的部分从客户端代码中分离出去了——<strong>创建代码</strong> 与 <strong>消费代码</strong>分离，职责更清晰</li></ul></li></ul><h5 id="简单工厂模式的改进"><a href="#简单工厂模式的改进" class="headerlink" title="简单工厂模式的改进"></a>简单工厂模式的改进</h5><ul><li><p>issue：每次增加新类型的水果（比如梨子），就必须要改动工厂类（在类代码中添加if/else语句）；</p></li><li><p>手段：在工厂类代码中，使用反射的方式来创建类型的实例对象；</p></li><li><p>特征：</p><ul><li>1 反射方式创建实例时，需要传入<strong>实例所属的类的全限定名</strong>；</li><li>2 反射方式创建实例时，能够<strong>使用同一行代码创建出不同的实例</strong>（根据1中传入参数的不同）；</li></ul></li><li><p>示例</p><blockquote><p>1 在工厂类中使用反射来创建实例对象；</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Gardener</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Fruit <span class="title">getFruit</span><span class="params">(String fruitPath)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 1 获取到类型的Class对象；手段：Class.forName("类的全限定名")</span></span><br><span class="line">        Class&lt;?&gt; c = Class.forName(fruitPath);</span><br><span class="line">        <span class="comment">// 2 调用Class对象的newInstance()方法，并进行强制类型转换。得到需要的实例对象</span></span><br><span class="line">        <span class="keyword">return</span> (Fruit)c.newInstance();       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>2 客户端代码在调用时，传入需要类型的全限定名；</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 需要获取苹果的实例则传入Apple类的全限定名</span></span><br><span class="line">    Fruit fruit0 = Gardener.getFruit(<span class="string">"com.xrq.simplefactory.Apple"</span>);</span><br><span class="line">    fruit0.grow();</span><br><span class="line">    Fruit fruit1 = Gardener.getFruit(<span class="string">"com.xrq.simplefactory.Grape"</span>);</span><br><span class="line">    fruit1.harveset();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>隐藏问题：如果项目进行了重构，则类的全限定名就会发生变化。由于客户端代码使用类的全限定名进行了硬编码，所以客户端代码就无法再找到类的class文件（进而加载到JVM中生成Class对象）</p></li></ul><h5 id="应对项目重构的方式"><a href="#应对项目重构的方式" class="headerlink" title="应对项目重构的方式"></a>应对项目重构的方式</h5><ul><li><p>原则：避免客户端代码中的硬编码；</p></li><li><p>手段：</p><ul><li><p>1 创建一个属性文件(Fruit.properties),在其中定义水果 -&gt; 类路径的关系；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Apple=com.xrq.simplefactory.Apple</span><br><span class="line">Grape=com.xrq.simplefactory.Grape</span><br></pre></td></tr></table></figure></li><li><p>2 在客户端代码中，先加载属性文件。然后解析出参数，传入工厂类方法中</p><p>…</p></li></ul></li><li><p>作用：如果需求发生变动，不需要修改客户端代码，只需要修改配置文件中特定键对应的值即可；</p></li></ul><h5 id="简单工厂模式在JDK中的应用"><a href="#简单工厂模式在JDK中的应用" class="headerlink" title="简单工厂模式在JDK中的应用"></a>简单工厂模式在JDK中的应用</h5><p>答：Java线程池的Executors类；</p><p>作用：把<strong>创建线程池</strong>与<strong>使用线程池</strong>的代码进行分离；</p><p>用法：</p><ul><li>1 获取线程池【这种创建线程池的方式似乎是不推荐使用的】；<ul><li>Executors.newSingleThreadExecutor()；</li></ul></li><li>2 使用线程池；<ul><li>…</li></ul></li></ul><p>特征：</p><p>​    开发者可以不用关心线程池是如何去实现的，直接使用Executors方法提供给开发者的ThreadPoolExecutor就可以了</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>简单工厂模式的作用：</p><ul><li>1 把实例的创建过程从客户端代码中分离/解耦出去；</li><li>2 （aka）把<strong>创建实例</strong> 与 <strong>消费实例</strong>进行分离；</li></ul><h5 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h5><p><a href="https://www.cnblogs.com/xrq730/p/4902597.html">五月的仓颉</a></p><blockquote><p>until next time, Bless！</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;诚实地讲，我看过设计模式的一本书，但是仍旧觉得它是悬浮在大气层外面的东西。现在对设计模式的基本认识是，它能够：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;封装变化，从而以最小的代码改动应对需求变化；&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Design Model" scheme="https://henryinshanghai.github.io/categories/Design-Model/"/>
    
    
    <category term="Fancy Stuff" scheme="https://henryinshanghai.github.io/tags/Fancy-Stuff/"/>
    
  </entry>
  
  <entry>
    <title>岛屿问题</title>
    <link href="https://henryinshanghai.github.io/Algorithm/2020/09/04/interview/20200904-%E5%B2%9B%E5%B1%BF%E9%97%AE%E9%A2%98.html"/>
    <id>https://henryinshanghai.github.io/Algorithm/2020/09/04/interview/20200904-%E5%B2%9B%E5%B1%BF%E9%97%AE%E9%A2%98.html</id>
    <published>2020-09-04T06:30:00.000Z</published>
    <updated>2020-09-04T07:20:35.187Z</updated>
    
    <content type="html"><![CDATA[<h5 id="题设与条件"><a href="#题设与条件" class="headerlink" title="题设与条件"></a>题设与条件</h5><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><blockquote><p>注：这是字节跳动第二次面试时给的题目。当时面试官说求出相互不联通的湖泊的数量</p><p>现在想想，要是相互连通的话，不就是同一个湖泊了吗？😔</p></blockquote><a id="more"></a><p><img src="https://s1.ax1x.com/2020/09/04/wkC3Dg.png" alt="题设示例"></p><h5 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h5><p>一个岛屿可以沿着上下左右方向不断扩展（直到遇到湖泊），扩展得到的是一个大的岛屿；</p><p>这本质上是一个搜索问题，只不过这里是在m×n的网格中搜索；</p><p>在网格中搜索，这是一个典型的DFS应用场景；</p><h6 id="二叉树的DFS"><a href="#二叉树的DFS" class="headerlink" title="二叉树的DFS"></a>二叉树的DFS</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line"><span class="comment">// 递归结束条件</span></span><br><span class="line"><span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="comment">// 递归遍历两个相邻的节点：左孩子、右孩子</span></span><br><span class="line">TreeNode(root.left);</span><br><span class="line">TreeNode(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二叉树DFS的两个要点：</p><ul><li>1 访问相邻节点：二叉树的相邻节点就只有左子节点 + 右子节点；由于二叉树本身是一个递归结构，所以遍历过程就只需要递归地调用左右子树即可</li><li>2 递归终结条件：<ul><li>一般地，二叉树 DFS 的结束条件是 root == null；</li><li>作用：<ul><li>1  root 指向的子树为空，不需要再往下遍历了；</li><li>2 在 root == null 的时候及时返回，让后面的 root.left 和 root.right 不会出现空指针异常；</li></ul></li></ul></li></ul><h6 id="类比出网格的DFS遍历："><a href="#类比出网格的DFS遍历：" class="headerlink" title="类比出网格的DFS遍历："></a>类比出网格的DFS遍历：</h6><ul><li>1 访问相邻节点：在网格（二维数组/矩阵）中，当前节点（r, c）的相邻节点为- (r-1, c)、(r+1, c)、(r, c-1)、(r, c+1)；</li><li>2 递归结束条件：当前网格已经是数组的边界。aka，DFS 的递归结束条件就是网格的四个边界；</li></ul><p>网格DFS遍历的模板：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line"><span class="comment">// 递归结束条件：如果坐标(r, c)超出网格，直接返回</span></span><br><span class="line"><span class="keyword">if</span>(!inArea(grid, r, c))</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">dfs(grid, r - <span class="number">1</span>, c);<span class="comment">// 上</span></span><br><span class="line">dfs(grid, r + <span class="number">1</span>, c);<span class="comment">// 下</span></span><br><span class="line">dfs(grid, r, c - <span class="number">1</span>);<span class="comment">// 左</span></span><br><span class="line">dfs(grid, r, c + <span class="number">1</span>);<span class="comment">// 右</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">inArea</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 合法的网格范围</span></span><br><span class="line"><span class="keyword">return</span> r &gt;= <span class="number">0</span> &amp;&amp; r &lt; grid.length &amp;&amp; c &gt;= <span class="number">0</span> &amp;&amp; c &lt; grid[<span class="number">0</span>].length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="避免搜索时，搜索到重复的网格；"><a href="#避免搜索时，搜索到重复的网格；" class="headerlink" title="避免搜索时，搜索到重复的网格；"></a>避免搜索时，搜索到重复的网格；</h6><p>手段：</p><ul><li>标记搜索过的网格；</li><li>然后在搜索前，先判断网格是不是已经搜索过了（如果是，跳过此网格）；</li></ul><p>具体方法：更新搜索过的网格中的值（不是岛屿的网格不会被搜索到）；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line"><span class="comment">// 递归结束条件：如果坐标(r, c)超出网格，直接返回</span></span><br><span class="line"><span class="keyword">if</span>(!inArea(grid, r, c))</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果这个格子不是岛屿，直接返回</span></span><br><span class="line"><span class="keyword">if</span>(grid[r][c] != <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">grid[r][c] = <span class="number">2</span>;<span class="comment">// 标记已经遍历的格子</span></span><br><span class="line"></span><br><span class="line">dfs(grid, r - <span class="number">1</span>, c);<span class="comment">// 上</span></span><br><span class="line">dfs(grid, r + <span class="number">1</span>, c);<span class="comment">// 下</span></span><br><span class="line">dfs(grid, r, c - <span class="number">1</span>);<span class="comment">// 左</span></span><br><span class="line">dfs(grid, r, c + <span class="number">1</span>);<span class="comment">// 右</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">inArea</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> r &gt;= <span class="number">0</span> &amp;&amp; r &lt; grid.length &amp;&amp; c &gt;= <span class="number">0</span> &amp;&amp; c &lt; grid[<span class="number">0</span>].length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法问题一旦有了模板，接下来就只是填写代码的工作了</p><h6 id="使用模板解决当前问题"><a href="#使用模板解决当前问题" class="headerlink" title="使用模板解决当前问题"></a>使用模板解决当前问题</h6><ul><li>从网格的左上角开始进行 DFS。</li><li>走到一个格子，若该格子不是陆地，则跳过该格子继续搜索；</li><li>若该格子是陆地，就往它的上下左右四个方向进行搜索；<ul><li>直至搜索到边界处或者搜索到已经遍历过的格子，说明一个岛屿成功找出，则把岛屿数量 count + 1。</li></ul></li></ul><h5 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                    dfs(grid, i, j);</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 递归结束条件：如果坐标(r, c)超出网格，直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(!inArea(grid, r, c))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 如果这个格子不是岛屿，直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(grid[r][c] != <span class="string">'1'</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        grid[r][c] = <span class="string">'2'</span>;<span class="comment">// 标记已经遍历的格子</span></span><br><span class="line">        </span><br><span class="line">        dfs(grid, r - <span class="number">1</span>, c);<span class="comment">// 上</span></span><br><span class="line">        dfs(grid, r + <span class="number">1</span>, c);<span class="comment">// 下</span></span><br><span class="line">        dfs(grid, r, c - <span class="number">1</span>);<span class="comment">// 左</span></span><br><span class="line">        dfs(grid, r, c + <span class="number">1</span>);<span class="comment">// 右</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">inArea</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> r &gt;= <span class="number">0</span> &amp;&amp; r &lt; grid.length &amp;&amp; c &gt;= <span class="number">0</span> &amp;&amp; c &lt; grid[<span class="number">0</span>].length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="代码分解步骤"><a href="#代码分解步骤" class="headerlink" title="代码分解步骤"></a>代码分解步骤</h5><blockquote><p>1 从最左上角的网格开始遍历二维数组中的所有网格</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.length; i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">            ...</span><br></pre></td></tr></table></figure><blockquote><p>2 如果当前网格是一个陆地网格，开始在二维数组中进行DFS搜索</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(grid[i][j] == <span class="string">'1'</span>)&#123;</span><br><span class="line">dfs(grid, i, j);</span><br></pre></td></tr></table></figure><blockquote><p>3 搜索结束后，就找到了一个岛屿。对找到的岛屿进行计数</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">...</span><br><span class="line">count++;</span><br></pre></td></tr></table></figure><blockquote><p>4 实现二维数组中网格的DFS遍历算法</p></blockquote><ul><li><p>1 递归终结条件</p><ul><li><p>1 如果坐标(r, c)超出网格，则停止搜索；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!inArea(grid, r, c))</span><br><span class="line"><span class="keyword">return</span>; <span class="comment">// 手段：直接返回</span></span><br></pre></td></tr></table></figure></li><li><p>2 如果遇到非岛屿的网格，则停止搜索；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果这个格子不是岛屿，直接返回</span></span><br><span class="line"><span class="keyword">if</span>(grid[r][c] != <span class="string">'1'</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>2 本级递归需要做的事情</p><ul><li><p>1 标记已经被搜索到的格子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grid[r][c] = <span class="string">'2'</span>;<span class="comment">// 标记已经遍历的格子</span></span><br></pre></td></tr></table></figure></li><li><p>2 向上下左右四个方向继续执行搜索；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dfs(grid, r - <span class="number">1</span>, c);<span class="comment">// 上</span></span><br><span class="line">dfs(grid, r + <span class="number">1</span>, c);<span class="comment">// 下</span></span><br><span class="line">dfs(grid, r, c - <span class="number">1</span>);<span class="comment">// 左</span></span><br><span class="line">dfs(grid, r, c + <span class="number">1</span>);<span class="comment">// 右</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>3 定义方格所允许的合法边界</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">inArea</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> r &gt;= <span class="number">0</span> &amp;&amp; r &lt; grid.length &amp;&amp; c &gt;= <span class="number">0</span> &amp;&amp; c &lt; grid[<span class="number">0</span>].length;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如果使用非法边界表示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(r &lt; <span class="number">0</span> || r &gt;= grid.length || c &lt; <span class="number">0</span> || c &gt;= grid[<span class="number">0</span>].length || grid[r][c] != <span class="string">'1'</span>)&#123;...&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="代码重现"><a href="#代码重现" class="headerlink" title="代码重现"></a>代码重现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取到二维数组中所有的岛屿数量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 从最左上角的网格开始遍历，搜索存在的岛屿</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;grid.length; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;grid[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">            <span class="comment">// 如果当前网格是陆地...</span></span><br><span class="line">            <span class="keyword">if</span>(grid[i][j] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                <span class="comment">// 开始进行DFS搜索，以找到完整的当前岛屿</span></span><br><span class="line">                dfs(grid, i, j);</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二维数组中网格的DFS遍历</span></span><br><span class="line"><span class="comment">// 0 递归方法的作用与返回值作用：</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1递归终结条件</span></span><br><span class="line">    <span class="comment">// 1-1   当前网格超出合法边界</span></span><br><span class="line">    <span class="keyword">if</span>(r&lt;<span class="number">0</span> || c&lt;<span class="number">0</span> || r &gt;= grid.length || c &gt;=grid[<span class="number">0</span>].length)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1-2 当前网格为湖泊网格</span></span><br><span class="line">    <span class="keyword">if</span>(grid[i][j] != <span class="string">'1'</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2 本级递归需要做的事情</span></span><br><span class="line">    <span class="comment">// 标记已经搜索过的网格</span></span><br><span class="line">    grid[r][c] = <span class="string">'2'</span>; <span class="comment">// 注：这里是字符，而不是数字</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 开始搜索当前网格相邻的网格</span></span><br><span class="line">    dfs(grid, r-<span class="number">1</span>, c);</span><br><span class="line">    dfs(grid, r+<span class="number">1</span>, c);</span><br><span class="line">    dfs(grid, r, c-<span class="number">1</span>);</span><br><span class="line">    dfs(grid, r, c+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="参考：二维数组DFS框架"><a href="#参考：二维数组DFS框架" class="headerlink" title="参考：二维数组DFS框架"></a>参考：<a href="https://blog.csdn.net/weixin_45594025/article/details/106095271?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param">二维数组DFS框架</a></h6><blockquote><p> until next time 🐷</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h5 id=&quot;题设与条件&quot;&gt;&lt;a href=&quot;#题设与条件&quot; class=&quot;headerlink&quot; title=&quot;题设与条件&quot;&gt;&lt;/a&gt;题设与条件&lt;/h5&gt;&lt;p&gt;给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。&lt;/p&gt;
&lt;p&gt;岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。&lt;/p&gt;
&lt;p&gt;此外，你可以假设该网格的四条边均被水包围。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注：这是字节跳动第二次面试时给的题目。当时面试官说求出相互不联通的湖泊的数量&lt;/p&gt;
&lt;p&gt;现在想想，要是相互连通的话，不就是同一个湖泊了吗？😔&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Algorithm" scheme="https://henryinshanghai.github.io/categories/Algorithm/"/>
    
    
    <category term="DFS in 2-dimensional-array" scheme="https://henryinshanghai.github.io/tags/DFS-in-2-dimensional-array/"/>
    
  </entry>
  
</feed>
