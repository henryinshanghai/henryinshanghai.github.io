<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Henry&#39;s blog</title>
  
  <subtitle>focus works better than curiosity</subtitle>
  <link href="https://henryinshanghai.github.io/atom.xml" rel="self"/>
  
  <link href="https://henryinshanghai.github.io/"/>
  <updated>2020-09-04T03:06:53.468Z</updated>
  <id>https://henryinshanghai.github.io/</id>
  
  <author>
    <name>henryInSH</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java基础之Redis</title>
    <link href="https://henryinshanghai.github.io/Redis/2020/09/03/interview/20200903-java%E5%9F%BA%E7%A1%80%E4%B9%8BRedis.html"/>
    <id>https://henryinshanghai.github.io/Redis/2020/09/03/interview/20200903-java%E5%9F%BA%E7%A1%80%E4%B9%8BRedis.html</id>
    <published>2020-09-03T02:30:00.000Z</published>
    <updated>2020-09-04T03:06:53.468Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Java应用之Redis（快速记忆）"><a href="#Java应用之Redis（快速记忆）" class="headerlink" title="Java应用之Redis（快速记忆）"></a>Java应用之Redis（快速记忆）</h4><h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><ul><li>是：数据库；</li><li>作用：存储数据；</li></ul><a id="more"></a><ul><li>特征：<ul><li>1 数据存储在内存中（所以读写速度很快）；</li><li>2 支持事务；</li><li>3 支持持久化；</li><li>4 支持LUA脚本（能够方便地定制与扩展功能）；</li><li>5 支持多种集群方案（所以可以在分布式环境下使用）；</li></ul></li><li>应用：<ul><li>1 缓存；</li><li>2 分布式锁；</li></ul></li></ul><h5 id="为什么要用缓存？"><a href="#为什么要用缓存？" class="headerlink" title="为什么要用缓存？"></a>为什么要用缓存？</h5><ul><li>1 能够更快地对查询进行响应；</li><li>2 由于缓存是存在内存中地，因此可以支持更高的并发量；</li></ul><h5 id="Redis比起Map-guava有什么不一样？"><a href="#Redis比起Map-guava有什么不一样？" class="headerlink" title="Redis比起Map/guava有什么不一样？"></a>Redis比起Map/guava有什么不一样？</h5><ul><li>map/guava：<ul><li>是：本地缓存；</li><li>作用：在本地机器上为数据在内存中创建缓存；</li><li>特征：<ul><li>1 轻量快速；</li><li>2 生命周期随着JVM的销毁而结束（aka 无法持久化）；</li><li>3 多态机器之间的缓存数据没有办法保持一致（aka 多实例时，缓存不一致）；</li></ul></li></ul></li><li>Redis/memcached：<ul><li>是：分布式缓存；</li><li>作用：为多台机器提供统一的缓存数据；</li><li>特征：<ul><li>1 当有多台机器/服务器/电脑时，多台机器能够共用一份缓存数据（aka 多实例时，缓存具有一致性）；</li><li>2 为了缓存能够稳定地服务于多台机器，需要做很多其他的准备；</li></ul></li></ul></li></ul><h5 id="Redis-VS-Memcached"><a href="#Redis-VS-Memcached" class="headerlink" title="Redis VS Memcached"></a>Redis VS Memcached</h5><ul><li>支持的数据类型：<ul><li>Redis支持更多的数据类型（String, list, hash, set等），Memcached只支持简单的数据类型；</li></ul></li><li>数据持久化：<ul><li>Redis支持数据持久化（aka 把缓存数据保存到磁盘中，以备后用），Memcached不支持持久化；</li></ul></li><li>对集群的支持：<ul><li>Redis天生支持集群(aka 实现服务器集群非常简单)，但Memcached并不是原生支持集群的；</li></ul></li><li>运行原理：<ul><li>Redis是单线程 + 多路IO复用； Memcached是多线程 + 非阻塞IO复用【😵】</li></ul></li></ul><p>综上，现在Redis的使用率斩杀Memcached（太难读了）</p><h5 id="Redis常见的数据结构-amp-数据结构关联的使用场景"><a href="#Redis常见的数据结构-amp-数据结构关联的使用场景" class="headerlink" title="Redis常见的数据结构 &amp; 数据结构关联的使用场景"></a>Redis常见的数据结构 &amp; 数据结构关联的使用场景</h5><ul><li><p>String类型</p><ul><li>常用命令：set,get,decr（值减一）,incr（值加一）,mget（获取多个指定key的值）等  </li><li>应用场景：<ul><li>key-value中，key就是String类型的；</li><li>常规计数：微博数、粉丝数；</li></ul></li></ul></li><li><p>Hash类型（存储key-value集合）</p><ul><li><p>作用：用于存储对象；</p></li><li><p>常用命令：hget（获取对象指定属性的值）,hset（设置对象指定属性的值）,hgetall （查看对象中所有的属性与其绑定的值）等</p></li><li><p>应用：</p><ul><li>存储用户信息</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">key=JavaUser293847</span><br><span class="line">value=&#123;</span><br><span class="line">“id”: 1,</span><br><span class="line">“name”: “SnailClimb”,</span><br><span class="line">“age”: 22,</span><br><span class="line">“location”: “Wuhan, Hubei”</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>list类型</p><ul><li>是：双向链表；</li><li>作用：存储一堆的String数据类型；</li><li>常用命令：lpush（在链表左端添加元素）,rpush,lpop（移除链表左边的第一个元素）,rpop,lrange （获取链表中指定范围的key-value集合）</li><li>特征：<ul><li>支持反向查找与遍历；</li></ul></li><li>应用：<ul><li>实现分页查询（lrange），aka，从某个元素开始读取指定个数的元素；</li></ul></li></ul></li><li><p>Set类型</p><ul><li><p>是：一个集合类型；</p></li><li><p>作用：存储一堆的String类型数据；</p></li><li><p>特征：</p><ul><li>1 可以自动去重；</li><li>2 能够方便地实现集合操作（交集、差集、并集）</li></ul></li><li><p>用法：sadd,spop,smembers（返回指定key对应的集合中的所有元素）,sunion,sismember(判断指定key中指定value是否存在集合中，返回 0 或 1) 等  </p></li><li><p>应用：</p><ul><li>1 微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合；</li><li>2 实现共同关注、共同粉丝、共同喜好等功能 （求交集）；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sinterstore key1 key2 key3 将交集存在key1内</span><br></pre></td></tr></table></figure></li></ul></li><li><p>SortedSort类型</p><ul><li>作用：同Sort类型；</li><li>特征：集合中的元素能够按score进行有序排列  ；</li><li>原理：sorted set增加了一个权重参数score；</li><li>用法：zadd,zrange,zrem（从排序的集合中删除一个或多个成员）,zcard（获取一个排序的集合中的成员数量）等  </li><li>应用：<ul><li>直播系统中的时时排行榜（用户列表、礼物排行榜、弹幕消息等）</li></ul></li></ul><blockquote><p>this is nuts!</p></blockquote></li></ul><h5 id="Redis中设置数据的过期时间"><a href="#Redis中设置数据的过期时间" class="headerlink" title="Redis中设置数据的过期时间"></a>Redis中设置数据的过期时间</h5><ul><li>作用：保证缓存数据是最新的；</li><li>应用：项目中的 token 或者一些登录信息、短信验证码等</li><li>用法：set key 的时候，指定一个 expire time ；</li><li>原理（过期之后，Redis如何删除过期数据）<ul><li>1 <strong>定期删除</strong><ul><li>redis默认是每隔 100ms 就<strong>随机抽取</strong>一些设置了过期时间的key，检查其是否过期，如果过期就删<br>除 ；（注意这里是随机抽取的，因为数据量很大）</li></ul></li><li>2 *<em>惰性删除 *</em><ul><li>过期key在定期删除时没有被删除掉（还停留在内存里），只有重新查询该过期的key，它才会被redis给删除 ；</li></ul></li><li>遗留问题：过期的key可能会堆积在内存中，影响缓存的正常工作；</li><li>解决方案：Redis内存淘汰机制；</li></ul></li></ul><h5 id="Redis内存淘汰机制"><a href="#Redis内存淘汰机制" class="headerlink" title="Redis内存淘汰机制"></a>Redis内存淘汰机制</h5><ul><li>作用：保证Redis中存储的数据都是热门数据（经常被查询到的数据）；</li><li>数据淘汰策略：<ul><li>从设置了过期时间的数据集中删除：<ul><li>最近最少使用的数据（LRU）；</li><li>即将要过期的数据（TTL）；</li><li>随机的数据（random）；</li></ul></li><li>当内存空间不够用时，在键空间中，移除最近最少使用的key；【最常用】</li><li>从数据集中任意选择数据进行删除；</li><li>不删除旧的缓存数据，如果空间不够用，而又有新的数据要写入缓存，就拒绝新的数据；</li></ul></li></ul><h5 id="Redis的持久化原理"><a href="#Redis的持久化原理" class="headerlink" title="Redis的持久化原理"></a>Redis的持久化原理</h5><ul><li>持久化：把内存中的数据写入硬盘（相当于永久存储）；</li><li>作用：备份数据；</li><li>手段：<ul><li>1 快照（snapshotting/rdb文件）<ul><li>是：一个文件；</li><li>作用：存储内存中某一时刻的数据；</li><li>特征：<ul><li>1 rdb文件可以在多台机器上复制与同步，从而保持备份数据的一致性；</li><li>2 这是Redis默认使用的持久化方式；</li><li>3 快照的细节可以在redis.conf中进行配置；</li></ul></li><li>原理：在某些时刻自动触发创建快照的操作；</li></ul></li><li>2 AOF持久化<ul><li>是：一个文件；</li><li>作用：记录数据的变化过程（被执行的写命令）；</li><li>特征：<ul><li>0 备份数据的实时性更好（所以是主要使用的持久化方案）；</li><li>1 默认情况下，AOF持久化没有开启；</li><li>2 开启AOF后，每次执行写入操作时，写入命令就会被追加到AOF文件中；</li><li>3 AOF存储的细节可以在redis.conf文件中进行配置；</li></ul></li><li>原理：写操作发生后，以一定的规律向AOF文件中追加写操作命令；</li></ul></li></ul></li></ul><h5 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h5><blockquote><p>事务；</p><p>是：一个规范；</p><p>作用：提供了一种将多个命令请求打包，然后一次性、按顺序地执行多个命令的机制  ；</p><p>特征：</p><p>​        1 执行事务期间，服务器不会中断事务而去执行其他客户端的请求；</p><p>​        2 如果事务执行到一半时发生意外情况，服务器会把之前执行的事务部分撤销操作；</p></blockquote><ul><li>是：Redis对事务的具体实现；</li><li>手段：使用MULTI、EXEC、WATCH 等命令来实现事务(transaction)功能 ；</li><li>特征：<ul><li>1 Redis事务总能保证事务的ACI(Atomicity  、Consistency  、Isolation)；</li><li>2 在设置了持久化模式之后，Redis事务也能保证事务的D（Durability ）；</li></ul></li></ul><p>ACID：原子性、连续性、隔离性、持久性；</p><h5 id="缓存雪崩-amp-缓存穿透（及解决方案）"><a href="#缓存雪崩-amp-缓存穿透（及解决方案）" class="headerlink" title="缓存雪崩&amp;缓存穿透（及解决方案）"></a>缓存雪崩&amp;缓存穿透（及解决方案）</h5><p>缓存雪崩</p><ul><li>是：一个现象；</li><li>作用：描述缓存在短时间内大量失效（缓存的数据不再是热点数据了）</li><li>特征：请求都会落在数据库服务器上，数据库压力很大</li><li>解决手段：<ul><li>事前：建立Redis集群，保证缓存机器集群的可用性；</li><li>事中：利用各种手段防止MySQL崩掉（ehcache缓存 + hystrix限流/降级等）；</li><li>事后：使用Redis持久化备份的数据尽快恢复缓存；</li></ul></li></ul><p>缓存穿透</p><ul><li>是：一个现象；</li><li>作用：描述客户端故意请求缓存中不存在的数据，使得请求总是落在数据库服务器上；</li><li>解决手段：<ul><li>1 使用布隆过滤器；<ul><li>原理：如果请求的数据在数据库中一定不存在，布隆过滤器就会拦截掉这个请求；</li></ul></li><li>2 把查询为空的结构也添加到缓存中；<ul><li>原理：这样即便客户端请求不存在的数据，缓存也能发挥作用；</li></ul></li></ul></li></ul><h5 id="Redis并发竞争Key的问题"><a href="#Redis并发竞争Key的问题" class="headerlink" title="Redis并发竞争Key的问题"></a>Redis并发竞争Key的问题</h5><ul><li>是：一种现象；</li><li>作用：描述多个系统同时操作一个key，而执行的顺序不是预期执行的顺序。最终导致了非预期的结果</li><li>解决手段：分布式锁（首选Zookeeper）；<ul><li>是：一种技术；</li><li>作用：解决分布式（多台机器上都有相同的实例）场景下，多台机器同时操作相同资源的并发问题；</li><li>特征：有点子像多线程并发操作资源的情况；</li><li>手段：使用zookeeper的临时有序节点；</li><li>原理：<ul><li>1 当客户端对某个方法加锁时，在zookeeper上的<strong>与该方法对应的指定节点的目录</strong>下，生成一个唯一的瞬时有序节点  ;</li><li>2 当机器要获取资源的锁时，只需要判断有序节点中序号最小的一个  ；【😵】</li><li>3 当机器要释放锁时，只需将这个瞬时节点删除即可 ；</li></ul></li><li>用法：<ul><li>完成业务流程后，删除对应的子节点来释放锁 ；</li></ul></li></ul></li></ul><h5 id="数据写入数据库-amp-缓存时，保证双写一致"><a href="#数据写入数据库-amp-缓存时，保证双写一致" class="headerlink" title="数据写入数据库&amp;缓存时，保证双写一致"></a>数据写入数据库&amp;缓存时，保证双写一致</h5><p>双写一致：</p><ul><li>是：一个要求；</li><li>作用：要求缓存中的数据与数据库中的数据保持一致；</li><li>特征：多数情况下，系统并不必须要保持双写一致（串行化会导致系统处理请求的能力大大降低）；</li><li>手段：把读请求&amp;写请求串行化放到一个队列中；</li><li>原理：请求串行化后，Redis就会同步数据库中新写入的数据。从而保证从缓存中读取的数据总是正确的；</li></ul><p>​    </p><h5 id="参考：JavaGuide《面试突击》"><a href="#参考：JavaGuide《面试突击》" class="headerlink" title="参考：JavaGuide《面试突击》"></a>参考：JavaGuide《面试突击》</h5><blockquote><p>until next time 😳</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;Java应用之Redis（快速记忆）&quot;&gt;&lt;a href=&quot;#Java应用之Redis（快速记忆）&quot; class=&quot;headerlink&quot; title=&quot;Java应用之Redis（快速记忆）&quot;&gt;&lt;/a&gt;Java应用之Redis（快速记忆）&lt;/h4&gt;&lt;h5 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;是：数据库；&lt;/li&gt;
&lt;li&gt;作用：存储数据；&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Redis" scheme="https://henryinshanghai.github.io/categories/Redis/"/>
    
    
    <category term="Java stuff" scheme="https://henryinshanghai.github.io/tags/Java-stuff/"/>
    
  </entry>
  
  <entry>
    <title>java基础之HashMap</title>
    <link href="https://henryinshanghai.github.io/JDK-source-type/2020/09/01/interview/20200901-java%E5%9F%BA%E7%A1%80%E4%B9%8BHashMap.html"/>
    <id>https://henryinshanghai.github.io/JDK-source-type/2020/09/01/interview/20200901-java%E5%9F%BA%E7%A1%80%E4%B9%8BHashMap.html</id>
    <published>2020-09-01T02:30:00.000Z</published>
    <updated>2020-09-03T11:31:20.418Z</updated>
    
    <content type="html"><![CDATA[<h4 id="java集合类型之HashMap"><a href="#java集合类型之HashMap" class="headerlink" title="java集合类型之HashMap"></a>java集合类型之HashMap</h4><p>对于JDK源码来说，它有点像吉他谱中的F和弦。第一道坎，跨过去就会是另一番风景</p><a id="more"></a><blockquote><p>bear in mind</p><p>1 HashMap是用来存储键值对的容器；</p><p>2 HashMap能够实现O(1)时间复杂度的查找（根据key来查找对应的键值对）；</p><p>3 HashMap底层的数据结构为：数组 + 链表 + 红黑树；</p></blockquote><h5 id="前置说明：为了表述的统一-amp-简化表达"><a href="#前置说明：为了表述的统一-amp-简化表达" class="headerlink" title="前置说明：为了表述的统一&amp;简化表达"></a>前置说明：为了表述的统一&amp;简化表达</h5><ul><li>把底层结构中的数组叫做散列数组/桶数组；</li></ul><blockquote><p>鉴于只有文字说明时，写得没劲，看得也没劲。所以这次会配合源码+图解</p></blockquote><h5 id="HashMap的特性"><a href="#HashMap的特性" class="headerlink" title="HashMap的特性"></a>HashMap的特性</h5><p><em>注：刚开始学这些容器类型时，发现它们有着各种不同的特性，多到无从记忆。其实所有这些特性都是容器类型实现的具体结果，所以要记住这些个特性，看一看源码就好了</em></p><ul><li>1 默认的初始容量为16；</li><li>2 默认的装载因子为0.75;</li><li>3 只有在链表中的节点数量 &gt; =8 并且 HashMap中的键值对数量 &gt; 64时，才会对链表进行树化；</li><li>4 当树化与扩容冲突时，应该优先扩容。这样能够从更高层面解决问题；</li></ul><h5 id="原理（存储键值对的过程）"><a href="#原理（存储键值对的过程）" class="headerlink" title="原理（存储键值对的过程）"></a>原理（存储键值对的过程）</h5><ul><li>1 计算key-value中key的散列值；</li><li>2 使用散列值来计算得到key-value应该插入到散列数组的哪个桶中；</li><li>3 判断桶是不是空的，如果是，直接插入key-value；</li><li>4 如果桶不是空的，说明不同的键值对被映射到了散列数组相同的桶中（aka 发生了散列冲突）。</li><li>5 发生散列冲突后，先判断桶中的key-value与预期插入的key-value的key是否相等，如果相等，直接更新桶中的key-value的value值；</li><li>6 如果不相等，把新的key-value以链表节点的形式连接到桶中已有的节点上；【Mark：一般面试时，回答到这里就已经足够了】</li><li>7 当链表中的节点数量大于8时，把链表转化成红黑树（以提升查询效率）；【具体手段比较复杂】</li><li>8 当哈希数组中的key-value数量大于阈值（阈值 = 容量 * 加载因子）时，需要对散列数组进行扩容，并对桶中的链表/红黑树上的key-value进行重新布局；【具体手段比较复杂】</li></ul><p>HashMap的key-value存储结果图：<a href="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15161231547335.jpg">田小波</a></p><p><img src="https://s1.ax1x.com/2020/09/02/wSwlKe.png" alt="HashMap存储节点的效果"></p><h5 id="HashMap源码分析"><a href="#HashMap源码分析" class="headerlink" title="HashMap源码分析"></a>HashMap源码分析</h5><h6 id="1-HashMap的特性"><a href="#1-HashMap的特性" class="headerlink" title="1 HashMap的特性"></a>1 HashMap的特性</h6><p><img src="https://s1.ax1x.com/2020/09/02/wSPg9e.png" alt="HashMap特性说明"></p><p>这些大段大段的介绍的确很吓人，这时候就需要点子耐心了。其实这只是你想象出来的无法跨越的人行道罢了 </p><p>上面的图片引用自<a href="https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&mid=2247484139&idx=1&sn=bb73ac07081edabeaa199d973c3cc2b0&chksm=ebd743eadca0cafc532f298b6ab98b08205e87e37af6a6a2d33f5f2acaae245057fa01bd93f4&scene=21#wechat_redirect">Java3y</a></p><p><font size="3">使用有道词典翻译了源码上的注释 &amp; 翻译了JDK提供的HashMap的接口文档。两者内容基本一致，建议参考接口文档（毕竟它就是用源码生成的）</font></p><blockquote><p>特性总结</p></blockquote><ul><li>允许空键与空值；</li><li>存储时，不保证key-value的顺序就是插入时的顺序；</li><li>装载因子对迭代key-value对的性能有很大影响；</li><li>当key-value对的数量 &gt; 散列数组的容量 * 装载因子时，会创建新的散列数组（大小是旧数组的两倍），并对key-value进行重哈希；</li><li>默认装载因子0.75是在时间与空间上妥协的结果，装载因子越大，越节省空间，但是访问key-value的时间就会随之增长。反之亦然</li><li>HashMap没有实现多线程同步的逻辑，所以多线程操作是不安全的；</li><li>遍历HashMap的迭代器时，如果有其他线程在修改哈希表，就会马上抛出并发修改的异常；</li></ul><blockquote><p>HashMap的类继承结构</p></blockquote><p><img src="https://s1.ax1x.com/2020/09/02/wSw93T.png" alt="HashMap类继承结构"></p><p><font size=3>为什么要看它的类继承结构呢？</font></p><p>这样能够直观地知道HashMap预期会有哪些功能，然后可以在看源码的时候有的放矢地查看源码是如何实现这些功能的。</p><h6 id="2-HashMap的实例变量（包含底层数据结构）"><a href="#2-HashMap的实例变量（包含底层数据结构）" class="headerlink" title="2 HashMap的实例变量（包含底层数据结构）"></a>2 HashMap的实例变量（包含底层数据结构）</h6><p><font size=2>这里不想再借别人的图，但是却没有好用的截长图与截图标注工具。饶了些狗尾巴圈子😳</font></p><p>注：接口文档中没有关于成员属性的说明，因为接口文档是教会用户如何使用的，并不想把底层实现呈现出来；</p><ul><li><p>成员常量；</p><p>​    <img src="https://s1.ax1x.com/2020/09/02/wSDOzV.png" alt="成员常量"></p><ul><li>作用：各种场景下对应的默认值（通过常量的名称基本能了解其使用场合）</li></ul></li><li><p>成员变量；</p><p>​    <img src="https://s1.ax1x.com/2020/09/02/wSryOU.png" alt="成员变量"></p><ul><li>作用：作为底层的数据结构，以支持各种API的操作；<ul><li>table    作用：作为散列数组；</li><li>loadFacotr   作用：哈希表的加载因子（用于计算扩容时的门槛）；</li><li></li></ul></li></ul></li><li><p>成员内部类；</p><p><img src="https://s1.ax1x.com/2020/09/02/wSsanO.png" alt="HashMap成员内部类"></p><ul><li><p>作用：作为底层数据结构，支持各种API操作；</p><blockquote><p> 核心内部类说明；</p></blockquote><ul><li>Node    作用：封装key-value映射关系，表示哈希表中的一个节点；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key; <span class="comment">// 键值对中的key</span></span><br><span class="line">        V value; <span class="comment">// 键值对中的value</span></span><br><span class="line">        Node&lt;K,V&gt; next; <span class="comment">// 链表结构中下一个节点的指针</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><ul><li>TreeNode 作用：表示红黑树中的一个节点；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links指向父节点的指针</span></span><br><span class="line">        TreeNode&lt;K,V&gt; left; <span class="comment">// 指向左子节点的指针</span></span><br><span class="line">        TreeNode&lt;K,V&gt; right; <span class="comment">// 指向右子节点的指针</span></span><br><span class="line">        TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion（删除后需要取消链接） </span></span><br><span class="line">        <span class="keyword">boolean</span> red; <span class="comment">// 是否为红色节点</span></span><br><span class="line">        ...</span><br></pre></td></tr></table></figure></li></ul></li></ul><h6 id="3-HashMap的构造方法"><a href="#3-HashMap的构造方法" class="headerlink" title="3 HashMap的构造方法"></a>3 HashMap的构造方法</h6><p>作用：</p><ul><li>规定程序员使用HashMap的语法；</li><li>创建出HashMap的实例对象；</li><li>强制程序员为某些成员属性绑定值；</li></ul><p>分析底层原理时，构造方法似乎并不重要。不管用户决定用哪种构造方法，核心API的逻辑不会受到任何影响。所以这里只分析最常用的构造方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里只是为loadFactor属性进行了初始化（绑定了值）；而哈希表都还没有创建与初始化——因为这个操作是在第一次插入key-value的时候实现的。</p><h6 id="4-常用常量分析"><a href="#4-常用常量分析" class="headerlink" title="4 常用常量分析"></a>4 常用常量分析</h6><ul><li>初始容量initialCapacity;<ul><li>作用：指定散列数组的初始容量大小；</li></ul></li><li>负载因子loadFactor；<ul><li>作用：计算散列（桶）数组的扩容门槛；</li></ul></li><li>扩容门槛threshold；<ul><li>作用：声明当前HashMap所能存储key-value对的最大数量；如果继续插入key-value，会引发散列数组的扩容操作；</li></ul></li></ul><p>三者之间的关系：threshold = initialCapacity * loadFactor;</p><h5 id="核心APIs"><a href="#核心APIs" class="headerlink" title="核心APIs"></a>核心APIs</h5><h6 id="从键值对集合中查询；（get-方法）"><a href="#从键值对集合中查询；（get-方法）" class="headerlink" title="从键值对集合中查询；（get()方法）"></a>从键值对集合中查询；（get()方法）</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">// 计算key的hash值，并作为参数传入getNode()方法中</span></span><br><span class="line">        <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 准备需要的局部变量：tab-散列数组； first、e-节点、n-散列数组的长度、k-键的类型；</span></span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="comment">// 如果散列数组不为空 &amp;&amp; key映射到的桶不为空...</span></span><br><span class="line">    <span class="comment">// 任务：求出key所映射到的桶；手段1：hash % n手段2：(n-1) &amp; hash</span></span><br><span class="line">    <span class="comment">// 说明：只有在n等于2的乘方时，才会有： hash % n &lt;=&gt; (n-1) &amp; hash</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 判断桶中的第一个节点是不是待查找的键值对</span></span><br><span class="line">            <span class="comment">// 手段：1 判断节点的hash值与key的hash值是否相等； 2 判断节点的key与key是否相等</span></span><br><span class="line">            <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">                ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="keyword">return</span> first;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 否则，从桶中继续查找</span></span><br><span class="line">            <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 判断桶中的节点是不是树节点...</span></span><br><span class="line">                <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">                <span class="comment">// 否则，桶中一定是一个链表</span></span><br><span class="line">                <span class="comment">// 遍历链表进行查找</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">return</span> e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 都没能找到，则返回null</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>流程</p></blockquote><ul><li>1 找到key所映射到的散列数组中桶的位置（桶就是散列数组中的一个位置）；</li><li>2 从桶中的链表/红黑树来查找是否存在键为key的节点；</li></ul><blockquote><p>关键操作</p></blockquote><ul><li>1 计算key会映射到的桶的位置；<ul><li>手段：(n - 1) &amp; hash；    </li><li>特征：1 高效的位运算； 2 n的值必须是2的乘方；3 等价于(hash % n);</li></ul></li><li>2 计算key的哈希值；<ul><li>手段: 内置的hash(Object key)方法；</li><li>SOP：1 调用key的hashCode()方法，初次获取到hash值；2 把h无符号右移16位得到一个新的二进制数字； 3 把1与2的值进行^（异或运算）；</li><li>原因（HashMap为什么这样计算哈希值）：<ul><li>移位操作-1：通过这种方式，让高位数据与低位数据进行异或，以此加大低位信息的随机性，变相的让高位数据参与到计算中；</li><li>移位操作-2：在 Java 中，hashCode 方法产生的 hash 是 int 类型，32 位宽。前16位为高位，后16位为低位，所以要右移16位;</li><li>异或操作：通过移位和异或运算，可以让 hash 变得更复杂，进而影响 hash 的分布性；</li></ul></li></ul></li></ul><h6 id="遍历HashMap中所有的key-value-（keySet-方法）"><a href="#遍历HashMap中所有的key-value-（keySet-方法）" class="headerlink" title="遍历HashMap中所有的key-value （keySet()方法）"></a>遍历HashMap中所有的key-value （keySet()方法）</h6><p><font size=3>注:遍历的操作分为两步——1 获取到键集合 / 键值对Entry集合； 2 使用迭代器模式来遍历键值对；</font></p><blockquote><p>用法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用法1-获取到所有的键组成的集合然后使用迭代器模式进行遍历</span></span><br><span class="line"><span class="keyword">for</span>(Object key : map.keySet()) &#123;</span><br><span class="line">    <span class="comment">// 通过map.get(key)方法获取到关联的value</span></span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用法2-获取到所有的键值对组成的集合然后使用迭代器模式进行遍历</span></span><br><span class="line"><span class="keyword">for</span>(HashMap.Entry entry : map.entrySet()) &#123;</span><br><span class="line">    <span class="comment">// Entry对象就是封装好的key-value</span></span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代器模式是一种遍历集合的统一方式，aka，程序员可以使用确定的API来编写迭代的代码；</p><blockquote><p>流程（遍历键集合）</p></blockquote><ul><li>1 首先要获取键集合<code>KeySet</code>对象；</li><li>2 再通过 KeySet 的迭代器<code>KeyIterator</code>（继承自HashIterator）进行遍历；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 键集合的类型</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 迭代器模式要求：返回一个迭代器对象；    </span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;K&gt; <span class="title">iterator</span><span class="params">()</span>     </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> KeyIterator(); &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 键-迭代器类型</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextNode().key; &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类迭代器类型</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HashIterator</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; next;        <span class="comment">// next entry to return</span></span><br><span class="line">        Node&lt;K,V&gt; current;     <span class="comment">// current entry</span></span><br><span class="line">        <span class="keyword">int</span> expectedModCount;  <span class="comment">// for fast-fail</span></span><br><span class="line">        <span class="keyword">int</span> index;             <span class="comment">// current slot</span></span><br><span class="line"></span><br><span class="line">        HashIterator() &#123;</span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">            Node&lt;K,V&gt;[] t = table;</span><br><span class="line">            current = next = <span class="keyword">null</span>;</span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123; <span class="comment">// advance to first entry</span></span><br><span class="line">                <span class="comment">// 寻找第一个包含链表节点引用的桶</span></span><br><span class="line">                <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ...</span><br><span class="line">        <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">nextNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">if</span> ((next = (current = e).next) == <span class="keyword">null</span> &amp;&amp; (t = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 寻找下一个包含链表节点引用的桶</span></span><br><span class="line">                <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><blockquote><p> 关键操作(在HashIterator中完成)</p></blockquote><ul><li>1 从桶数组中找到包含链表节点引用的桶；</li><li>2 对这个桶指向的链表进行遍历；</li><li>3 遍历完成后，再继续寻找下一个包含链表节点引用的桶.so on and so forth, till  can not find such a bucket;</li></ul><blockquote><p>操作过程图示</p></blockquote><p><img src="https://s1.ax1x.com/2020/09/02/wp8nzj.png" alt="遍历键集合的过程"></p><blockquote><p>验证</p></blockquote><p>原理：如果在创建HashMap时指定容器的大小为16，并在插入key-value时根据16来选择合适的key。就能把key-value插入到预期的桶中，并最终预测遍历操作的打印顺序</p><p>举例：key=43 43%16=11.所以该key-value会存储在编号为11的桶中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span> <span class="comment">// 因为IDEA的集成工作做得太棒了，有时候你真弄不清楚到底是谁完成了哪些工作...😳</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTraversal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap(<span class="number">16</span>);</span><br><span class="line">        <span class="comment">// 可以预见这些key-value会被映射到什么地方吗？</span></span><br><span class="line">        map.put(<span class="number">7</span>, <span class="string">""</span>);</span><br><span class="line">        map.put(<span class="number">11</span>, <span class="string">""</span>);</span><br><span class="line">        map.put(<span class="number">43</span>, <span class="string">""</span>);</span><br><span class="line">        map.put(<span class="number">59</span>, <span class="string">""</span>);</span><br><span class="line">        map.put(<span class="number">19</span>, <span class="string">""</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="string">""</span>);</span><br><span class="line">        map.put(<span class="number">35</span>, <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"遍历结果："</span>);</span><br><span class="line">        <span class="keyword">for</span> (Integer key : map.keySet()) &#123;</span><br><span class="line">            System.out.print(key + <span class="string">" -&gt; "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// 预期输出结果：19 -&gt; 3 -&gt; 35 -&gt; 7 -&gt; 11 -&gt; 43 -&gt; 59 -&gt; </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="向容器中插入新的key-value（input-方法）"><a href="#向容器中插入新的key-value（input-方法）" class="headerlink" title="向容器中插入新的key-value（input()方法）"></a>向容器中插入新的key-value（input()方法）</h6><blockquote><p>流程</p></blockquote><ul><li>找到键值对预期插入的桶编号；</li><li>判断桶是否为空，为空则直接插入key-value;</li><li>如果不为空，判断桶中的节点是哪一种类型的节点；<ul><li>如果是链表节点，则执行“向链表中插入新节点”的操作；</li><li>如果是树节点，则执行“向红黑树中插入新节点”的操作；</li></ul></li><li>插入操作结束后，需要考虑两个问题——扩容、树化；</li></ul><blockquote><p>核心操作（源码)</p></blockquote><p><font size=3>源码中有很多保证健壮性的代码，但它们不是核心代码，可以跳过</font></p><p><img src="https://s1.ax1x.com/2020/09/02/wpwKl8.jpg" alt="put添加key-value的过程"></p><p>这里比较困惑的是找到key相同的节点后，源码把找到的节点存储到了变量e中；</p><p>其实只需要明确一点，如果找到了key相同的节点，接下来肯定需要执行覆盖操作，具体的手段就要看源码的具体实现了（这里是使用变量e记录了已经存在的key-value，然后用新的value进行更新）。</p><p><strong>注：覆盖旧值后，put()方法会把旧的value值返回给调用者</strong>👇</p><p><img src="https://s1.ax1x.com/2020/09/03/wC3rxH.png" alt="覆盖旧值后，会把旧的value返回"></p><h6 id="对散列表进行扩容操作（resize-）"><a href="#对散列表进行扩容操作（resize-）" class="headerlink" title="对散列表进行扩容操作（resize()）"></a>对散列表进行扩容操作（resize()）</h6><blockquote><p>预备知识</p></blockquote><ul><li>在 HashMap 中，桶数组的长度均是2的幂，阈值大小为桶数组长度与负载因子的乘积。</li><li>当 HashMap 中的键值对数量超过阈值时，就会进行扩容操作。</li></ul><p><img src="https://s1.ax1x.com/2020/09/02/wpBtMT.jpg" alt="扩容方法"></p><blockquote><p>原理</p></blockquote><ul><li>按当前桶数组长度的2倍进行扩容，阈值也变为原来的2倍；</li><li>扩容之后，要重新计算键值对的位置，并把它们移动到合适的位置上去；</li></ul><blockquote><p>源码中的核心操作</p></blockquote><ul><li>1 计算新桶数组的容量 newCap 和新阈值 newThr</li><li>2 根据计算出的 newCap 创建新的桶数组，桶数组 table 也是在这里进行初始化的</li><li>3 将键值对节点重新映射到新的桶数组里。<ul><li>如果节点是 TreeNode 类型，则需要拆分红黑树。</li><li>如果是普通节点，则节点按原顺序进行分组。</li></ul></li></ul><blockquote><p>核心操作对应的代码- newCap 和 newThr 计算过程(分类讨论)</p></blockquote><p>​    this is way too much, Can not bear this right now.</p><blockquote><p>需要记忆的结论</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个条件分支</span></span><br><span class="line"><span class="keyword">if</span> ( oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 嵌套条件分支</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;...&#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY) &#123;...&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) &#123;...&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二个条件分支</span></span><br><span class="line"><span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;...&#125;</span><br></pre></td></tr></table></figure><ul><li><p>#Q:initialCapacity 参数没有被保存下来，那么它怎么参与桶数组的初始化过程的呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">            newCap = oldThr; <span class="comment">// 把旧的阈值绑定到newCap上</span></span><br></pre></td></tr></table></figure></li></ul><ul><li>#A: 上述语句等价于<code>newCap = threshold = tableSizeFor(initialCapacity)</code>。aka 我们在初始化时传入的 initialCapacity 参数经过 threshold 中转最终赋值给了 newCap</li></ul><ul><li><p>#Q：嵌套分支的作用是什么？</p><ul><li>#A：<ul><li>1 处理容器容量达到极限的情况； </li><li>2 处理容器正常扩容的情况（但用户指定的loadFactor可能会导致移位/扩大两倍时发生溢出归零）</li></ul></li></ul></li><li><p>#Q：为什么需要第二个分支？</p><ul><li>#A：<ul><li>第一个条件分支未计算 newThr的情况（当旧容量=0，而旧的阈值大于0时，分支中只是用旧阈值更新了newCap） ;</li><li>嵌套分支在计算过程中导致 newThr 溢出归零的情况（这时候需要使用loadFactor * newCap的公式重新计算阈值）；</li></ul></li></ul></li><li><p>链表桶经过重新映射后，两条链表中的节点顺序并未发生变化，还是保持了扩容前的顺序。</p></li></ul><h6 id="桶中节点的重新映射（在resize-方法中实现）"><a href="#桶中节点的重新映射（在resize-方法中实现）" class="headerlink" title="桶中节点的重新映射（在resize()方法中实现）"></a>桶中节点的重新映射（在resize()方法中实现）</h6><div id="anchor1"></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">...</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">            Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">            Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">            Node&lt;K,V&gt; next;</span><br><span class="line">            ...</span><br></pre></td></tr></table></figure><p>说明：对于不同的节点类型，重新映射的手段并不一样；</p><ul><li>对于树形节点，需先拆分红黑树再映射。</li><li>对于链表类型节点，则需先对链表进行分组，然后再映射（分组后，组内节点相对位置保持不变）。</li></ul><blockquote><p>对链表中的节点进行分组映射</p></blockquote><p>JDK1.7的手段：</p><ul><li>把链表中的节点重新插入到新的桶数组中；</li></ul><p>JDK1.8的手段:</p><ul><li>说明：扩容前被映射到同一个桶中的键值对，经过扩容后，可能会被映射到新的桶中；</li><li>原理：<ul><li>1 映射的过程是使用(n - 1) &amp; hash的方式来计算桶的位置;</li><li>2 扩容前，由于n=16，所以二进制表示的前四位是0000。真正参与&amp;运算的实际上只有hash的后四位——这会导致不同的哈希值被映射到同一个桶的位置；</li><li>3 扩容2倍后，n &gt; 16，所以参与&amp;运算的二进制数字位更多（多出的高位表示16）。不同的hash值会被映射到不同的桶位置；</li></ul></li><li>算法：<ul><li>1 依次遍历链表，并计算节点 <code>hash &amp; oldCap</code> 的值；</li><li>2 如果值为0，将 loHead 和 loTail 指向这个节点；<ul><li>如果后面还有节点 hash &amp; oldCap 为0的话，则将节点链入 loHead 指向的链表中，并将 loTail 指向该节点；</li></ul></li><li>3 如果值为非0的话，则让 hiHead 和 hiTail 指向该节点；</li><li>4 把分组后的两个链表存储到新的桶数组对应的桶中；</li></ul></li></ul><p>重新映射前的桶数组</p><p><img src="https://s1.ax1x.com/2020/09/03/wCNRds.png" alt="映射前"></p><p>重新映射算法得到的分组链表</p><p><img src="https://s1.ax1x.com/2020/09/03/wCUKOg.png" alt="分组后的链表"></p><p>重新映射后的桶数组</p><p><img src="https://s1.ax1x.com/2020/09/03/wCUwm4.png" alt="映射后的桶数组"></p><p>评论：相比于JDK1.7的做法，1.8的做法避免了插入操作的hash计算，效率有提高；</p><h6 id="链表树化-treeifyBin-方法"><a href="#链表树化-treeifyBin-方法" class="headerlink" title="链表树化(treeifyBin()方法)"></a>链表树化(treeifyBin()方法)</h6><p>the details is overwhelming, so we’ll just jump into the conclusion.</p><blockquote><p>流程</p></blockquote><ul><li>1 把链表中的普通节点，转化为树形节点(得到一个树形节点组成的链表)；</li><li>2 把树形节点组成的链表转换为红黑树（treeify()方法）；</li></ul><blockquote><p> 在扩容过程中，树化要满足两个条件：</p></blockquote><ul><li>链表长度大于等于 TREEIFY_THRESHOLD</li><li>桶数组容量大于等于 MIN_TREEIFY_CAPACITY<ul><li>原因：<ul><li>1 当桶数组容量比较小时，键值对节点 hash 的碰撞率可能会比较高，进而导致链表长度较长；</li><li>2 这个时候应该优先扩容，而不是立马树化——高碰撞率是因为桶数组容量较小引起的，这个是主因；</li><li>3 容量小时，优先扩容可以避免一些列的不必要的树化过程；</li><li>4 同时，桶容量较小时，扩容会比较频繁，而扩容时需要拆分红黑树并重新映射——所以在桶容量比较小的情况下，将长链表转成红黑树是一件吃力不讨好的事；</li></ul></li></ul></li></ul><blockquote><p>treeifyBin 方法-把链表转化为TreeNode类型节点组成的链表</p></blockquote><ul><li>TreeNode类型间接继承自Node类型，所以包含next指针/引用。aka 通过TreeNode就能保存原始链表中的节点顺序；</li></ul><blockquote><p>树化带来的问题与解决方案</p></blockquote><ul><li>问题：树化过程中需要比较键对象的大小，但是HashMap并没有强制要求键对象一定要实现Comparable接口。SO,如果键并没有实现Comparable接口，树化要怎么进行呢？</li><li>手段：<ul><li>1 比较键与键之间 hash 的大小，如果 hash 相同，继续往下比较</li><li>2 检测键类是否实现了 Comparable 接口，如果实现调用 compareTo 方法进行比较</li><li>3 如果仍未比较出大小，就需要进行仲裁了，仲裁方法为 tieBreakOrder（没看过具体实现）</li></ul></li></ul><p><font size=2>tieBreak(赛点)</font></p><blockquote><p>树化前后对比</p></blockquote><ul><li><p>树化前</p><p><img src="https://s1.ax1x.com/2020/09/02/wpLK3t.png" alt="桶中的链表结构"></p></li><li><p>树化后</p><p><img src="https://s1.ax1x.com/2020/09/02/wpOua4.png" alt="桶中的红黑树结构"></p><p>橙色的箭头表示 TreeNode 的 next 引用</p></li><li><p>特征：</p><ul><li>原链表的顺序仍旧保持（红黑树的根节点会被移动到链表的第一位），SO,可以按遍历链表的方式去遍历上面的红黑树;</li><li>这种结构非常有利于红黑树的切分 &amp; 红黑树转换为链表的操作</li></ul></li></ul><h6 id="红黑树拆分（split-方法）"><a href="#红黑树拆分（split-方法）" class="headerlink" title="红黑树拆分（split()方法）"></a>红黑树拆分（split()方法）</h6><blockquote><p>说明：散列数组扩容后，需要为先前存储的键值对重新找到存储位置（重新映射）。链表和红黑树上的节点要怎么重新映射呢？</p></blockquote><ul><li><p>链表：<a href="#anchor1">参考</a></p></li><li><p>红黑树：</p><ul><li><p>手段1（效率有点低）：</p><ul><li>1 先把红黑树转换成链表；</li><li>2 然后按照链表的方式对所有的键值对重新映射；</li></ul></li><li><p>手段2：</p><ul><li><p>原理：在将普通链表转成红黑树时，HashMap 通过两个额外的引用 next 和 prev 保留了原链表的节点顺序；</p></li><li><p>所以，在重新映射红黑树时，就能够按照映射链表的方式进行映射；</p></li><li><p>特征：</p><ul><li><p>1 重新映射红黑树的逻辑和重新映射链表的逻辑基本一致（代码结构基本相同）；</p></li><li><p>2 但是重新映射后，会将红黑树拆分成两条<em>由 TreeNode 组成的链表</em>（<em>中间状态</em>）；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TreeNode&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">  TreeNode&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure></li><li><p>3 如果链表长度小于 UNTREEIFY_THRESHOLD，则</p><ul><li>将链表转换成普通链表（Node）；</li><li>否则根据条件重新将 TreeNode 链表树化（treeify）；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (loHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (lc &lt;= UNTREEIFY_THRESHOLD) <span class="comment">// 重新映射后的链表长度小于等于UNTREEIFY_THRESHOLD</span></span><br><span class="line">        tab[index] = loHead.untreeify(map); <span class="comment">// 转化为普通链表</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        tab[index] = loHead;</span><br><span class="line">        <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) <span class="comment">// (else is already treeified)</span></span><br><span class="line">            loHead.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><p>红黑树重新映射第一步后的结果👇</p><p><img src="https://s1.ax1x.com/2020/09/02/wpX3kQ.png" alt="RBT重新映射后"></p></li></ul><h6 id="红黑树链化（untreeify-方法）"><a href="#红黑树链化（untreeify-方法）" class="headerlink" title="红黑树链化（untreeify()方法）"></a>红黑树链化（untreeify()方法）</h6><ul><li><p>场景：当链表中的节点数比较少时，就把红黑树转化为普通链表以节省空间；</p></li><li><p>原理：红黑树中仍然保留了原链表节点顺序；</p></li><li><p>手段(Thus)：</p><ul><li>将 TreeNode 链表转成 Node 类型的链表（即可）；</li></ul></li></ul><p>I do not really understand how does this work, yet time is consuming…</p><h6 id="从容器中删除键值对（remove-方法）"><a href="#从容器中删除键值对（remove-方法）" class="headerlink" title="从容器中删除键值对（remove()方法）"></a>从容器中删除键值对（remove()方法）</h6><blockquote><p>流程</p></blockquote><ul><li>第一步是定位桶位置；</li><li>第二步遍历链表并找到键值相等的节点；</li><li>第三步删除节点。</li></ul><blockquote><p>源码</p></blockquote><p><img src="https://s1.ax1x.com/2020/09/02/wpjDDf.jpg" alt="先找到后删除"></p><p><img src="https://s1.ax1x.com/2020/09/02/wpvCIe.jpg" alt="删除流程"></p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ul><li>在JDK8中HashMap的底层数据结构为：<strong>数组+链表(散列表)+红黑树</strong>；</li><li>当初始容量 * 装载因子 &lt; HashMap中的键值对数量时，对散列数组/桶数组进行扩容；</li><li>装在因子loadFactor默认为0.75;【太大会容易产生散列冲突 VS 太小容易引起扩容】</li><li>初始容量默认为16；【空间 VS 时间】</li><li>计算key的hash值：将key的哈希值的高16位进行异或操作，以此来增加随机性；</li><li>并不是桶子上有8位元素的时候它就能变成红黑树，它得同时满足我们的散列表容量大于64才行；</li><li>使用构造方法指定initialCapacity时，这个参数不会直接初始化capacity，而是先绑定到threshold上，在初始化桶数组时，才会再绑定到newCap上；</li></ul><blockquote><p>what have I done?!</p></blockquote><h5 id="启示"><a href="#启示" class="headerlink" title="启示"></a>启示</h5><p>1 写文章时，需要一些其他工具。比如截长图与截图文字标注工具，否则文字会缺少一些表现力</p><p>2 需要想办法能够对JDK源码进行编辑，这种可望不可及的感觉不好。而且很容易遗忘</p><h5 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h5><p><a href="http://www.tianxiaobo.com/2018/01/18/HashMap-%E6%BA%90%E7%A0%81%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90-JDK1-8/#342-%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6">http://www.tianxiaobo.com/2018/01/18/HashMap-%E6%BA%90%E7%A0%81%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90-JDK1-8/#342-%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&amp;mid=2247484139&amp;idx=1&amp;sn=bb73ac07081edabeaa199d973c3cc2b0&amp;chksm=ebd743eadca0cafc532f298b6ab98b08205e87e37af6a6a2d33f5f2acaae245057fa01bd93f4&amp;scene=21#wechat_redirect">https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&amp;mid=2247484139&amp;idx=1&amp;sn=bb73ac07081edabeaa199d973c3cc2b0&amp;chksm=ebd743eadca0cafc532f298b6ab98b08205e87e37af6a6a2d33f5f2acaae245057fa01bd93f4&amp;scene=21#wechat_redirect</a></p>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;java集合类型之HashMap&quot;&gt;&lt;a href=&quot;#java集合类型之HashMap&quot; class=&quot;headerlink&quot; title=&quot;java集合类型之HashMap&quot;&gt;&lt;/a&gt;java集合类型之HashMap&lt;/h4&gt;&lt;p&gt;对于JDK源码来说，它有点像吉他谱中的F和弦。第一道坎，跨过去就会是另一番风景&lt;/p&gt;</summary>
    
    
    
    <category term="JDK source type" scheme="https://henryinshanghai.github.io/categories/JDK-source-type/"/>
    
    
    <category term="Java stuff" scheme="https://henryinshanghai.github.io/tags/Java-stuff/"/>
    
  </entry>
  
  <entry>
    <title>记一次面试（字节跳动）_java基础之线程池</title>
    <link href="https://henryinshanghai.github.io/interview/2020/08/28/interview/20200826-%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%9D%A2%E8%AF%95%EF%BC%88%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%EF%BC%89_java%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0.html"/>
    <id>https://henryinshanghai.github.io/interview/2020/08/28/interview/20200826-%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%9D%A2%E8%AF%95%EF%BC%88%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%EF%BC%89_java%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0.html</id>
    <published>2020-08-28T02:30:00.000Z</published>
    <updated>2020-09-01T02:58:04.183Z</updated>
    
    <content type="html"><![CDATA[<h4 id="关于线程池的初印象"><a href="#关于线程池的初印象" class="headerlink" title="关于线程池的初印象"></a>关于线程池的初印象</h4><p>由于接触到的项目都简单到只是CRUD，我并没有直接编码使用过线程池。所以感觉上非常生疏，甚至在被打击了一次之后，现在仍然觉得它就是个绣花枕头…</p><a id="more"></a><h5 id="预备知识：池化技术"><a href="#预备知识：池化技术" class="headerlink" title="预备知识：池化技术"></a>预备知识：池化技术</h5><ul><li>参考：<a href="https://mp.weixin.qq.com/s/_wP3w2sm0qzBaGC5O6heAg">能看得懂的文章</a></li><li>是：一种通用的技术思想；</li><li>作用：提前准备一些资源，以应对紧急的需求（紧急响应组）；</li><li>特征：<ul><li>提前准备资源（节省临时创建线程的开销）；</li><li>这些资源可以重复使用；</li></ul></li></ul><blockquote><p>知识卡：Java对象创建的过程；</p><ul><li>1 根据代码中<em>new关键字后面的参数</em>来在JVM常量池中找到<em>类的符号引用</em>；</li><li>2 如果没有找到，就把类的class文件加载到JVM中；</li><li>3 类加载完成后，JVM会执行一系列的操作：<ul><li>在堆空间中分配内存空间；</li><li>把分配的空间初始化为0[预初始化,尽量避免NPE]；</li><li>建立对象头的描述结构[<strong>耗时操作，因为在更新堆内存的状态</strong>]；</li></ul></li><li>4 调用对象的初始化方法，完成实例真正的初始化[<strong>耗时操作,因为有一系列的校验过程</strong>]；</li></ul><p>anyway, 创建一个类的实例对象是一个很耗时的过程；BUT,这和池化技术有什么关系呢？</p></blockquote><ul><li><p>应用：</p><ul><li><p>线程池；</p><p>原理：把线程池当作紧急响应组；</p><ul><li>池子中有多个沉睡的线程；</li><li>如果客户端来了一个请求，则唤醒池子中的一个线程；</li><li>线程对请求进行处理；</li><li>处理完成后，线程回到池子里继续睡觉；</li></ul><p>作用：在高并发的场景中，避免所有的CPU资源都耗费在创建线程的工作上（线程才能真正地处理请求）。</p></li><li><p>内存池；</p></li><li><p>数据库连接池等</p></li></ul></li><li><p>验证：使用线程池比起临时创建线程更高效；</p><ul><li><p>手段：创建两个方法，方法1使用线程池执行任务A，方法2临时创建线程执行任务A。比较方法1与方法2的执行耗时；</p></li><li><p>线程的用法；</p><ul><li><p>创建线程对象，创建时传入任务对象（任务类本身也是一个线程）；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread td = <span class="keyword">new</span> Thread(<span class="keyword">new</span> PerformanceRunnable()); <span class="comment">// 把要执行的任务添加到线程中</span></span><br></pre></td></tr></table></figure></li><li><p>启动线程;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">td.start(); <span class="comment">// 启动线程</span></span><br></pre></td></tr></table></figure></li><li><p>等待线程执行完成；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">td.join(); <span class="comment">// 确保线程执行完成</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><ul><li><p>线程池的用法；</p><ul><li><p>创建线程池对象（构造方法有5个参数😄）；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor tp = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">10</span>, <span class="number">10</span>, <span class="number">0</span>,</span><br><span class="line">                  TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingDeque&lt;&gt;());</span><br></pre></td></tr></table></figure></li><li><p>使用线程池对象来执行任务；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tp.execute(<span class="keyword">new</span> PerformanceRunnable());</span><br></pre></td></tr></table></figure></li><li><p>关停线程池对象；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tp.shutdown(); <span class="comment">// 为什么任务还没有执行完，就要调用shutdown()?</span></span><br></pre></td></tr></table></figure></li><li><p>等待线程池执行完成；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tp.awaitTermination(<span class="number">1</span>, TimeUnit.SECONDS);  <span class="comment">// 等待线程池执行完成</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>运行耗时结果；</p><blockquote><p>线程执行时长：418 毫秒.<br>线程池执行时长：38 毫秒.</p></blockquote></li></ul><ul><li>结论：使用线程池能够大幅地提高程序性能；</li></ul><hr><h5 id="Java中的多线程与线程池"><a href="#Java中的多线程与线程池" class="headerlink" title="Java中的多线程与线程池"></a>Java中的多线程与线程池</h5><ul><li>应用场景：为了提高性能往往会在主线程里面开启一个新线程去执行；</li><li>事实：开启线程需要消耗很多资源；</li><li>issue：如果用户量上涨，如果每次任务都创建一个新的线程。服务器表示压力很大…</li><li>手段：使用线程池来预先创建线程，作为备用军团；</li></ul><h6 id="创建线程类的三种手段"><a href="#创建线程类的三种手段" class="headerlink" title="创建线程类的三种手段"></a>创建线程类的三种手段</h6><ul><li>1 继承Thread类；</li><li>2 实现Runnable接口；</li><li>3 实现Callable接口；</li></ul><h6 id="线程类的用法（启动）"><a href="#线程类的用法（启动）" class="headerlink" title="线程类的用法（启动）"></a>线程类的用法（启动）</h6><ul><li><p>如果是通过继承Thread类来创建的线程…</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  通过继承 thread 类</span></span><br><span class="line">Mytheard1 thread1 =  <span class="keyword">new</span> Mytheard1();</span><br><span class="line">thread1.start();</span><br></pre></td></tr></table></figure></li><li><p>如果是通过实现Runnable接口来创建的线程…</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  通过实现 runnable 接口</span></span><br><span class="line">Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Mytheard2()); <span class="comment">// 把实例作为Thread构造器的参数</span></span><br><span class="line">thread2.start();</span><br></pre></td></tr></table></figure></li><li><p>如果是通过实现Callable接口来创建的线程…</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  通过实现 callable 接口</span></span><br><span class="line">Mytheard3 th = <span class="keyword">new</span> Mytheard3();</span><br><span class="line">FutureTask&lt;Integer&gt; result = <span class="keyword">new</span> FutureTask&lt;&gt;(th); <span class="comment">// 把实例作为FutureTask构造器的参数</span></span><br><span class="line"><span class="keyword">new</span> Thread(result).start(); <span class="comment">// 把task对象再作为Thread构造器的参数</span></span><br></pre></td></tr></table></figure></li></ul><h6 id="线程类的特征"><a href="#线程类的特征" class="headerlink" title="线程类的特征"></a>线程类的特征</h6><ul><li>1 不会直接调用自定义线程类中的run()方法；</li><li>2 而是调用Thread类型对象的start()方法；<ul><li>原理：Thread实例对象的start()方法，会调用本地系统方法，并最终导致自定义线程类的run()方法被调用；</li></ul></li></ul><h6 id="线程的分类"><a href="#线程的分类" class="headerlink" title="线程的分类"></a>线程的分类</h6><ul><li><p>1 守护线程；</p><ul><li><p>任务：设置一个线程为守护线程；</p></li><li><p>手段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread.setDaemon(<span class="keyword">true</span>)；</span><br></pre></td></tr></table></figure></li><li><p>特征：</p><ul><li>1 必须在start()方法被调用之前完成set操作（否则会抛出异常）；</li><li>2 在守护线程中开启的新线程也是守护线程；</li></ul></li><li><p>作用：为所有的非守护进程提供守护服务；</p></li><li><p>应用：JVM中的垃圾回收(GC)线程；</p></li></ul></li><li><p>2 用户线程/非守护线程；</p><ul><li><p>特征：</p><ul><li>Java线程默认是非守护线程；</li><li>主线程运行结束后，如果主线程中还有非守护线程，则JVM就不会退出；</li><li>只有在所有的非守护线程执行完成后，JVM才会退出。</li></ul></li></ul></li></ul><blockquote><p>JVM退出时，只会考虑非守护线程的状态；</p></blockquote><h6 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h6><ul><li>场景：如果有多个并发同时访问主线程,而主线程中又创建了多个子线程。则创建线程的开销巨大;</li><li>解决手段：使用线程池来提前预备线程，避免短时间大量创建线程的情形；</li><li>作用：<ul><li>1 减少在创建和销毁线程上所花的时间以及系统资源的开销;</li><li>2 如不使用线程池，有可能造成系统创建大量线程而导致消耗完系统内存;</li></ul></li></ul><h6 id="自定义线程池"><a href="#自定义线程池" class="headerlink" title="自定义线程池"></a>自定义线程池</h6><ul><li><p>手段：</p><ul><li><p>1 自定义类型中持有具体的线程池类型；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> MyPool myPool = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//单例线程池中有两种具体的线程池</span></span><br><span class="line">    <span class="keyword">private</span> ThreadPoolExecutor threadPool = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> ScheduledThreadPoolExecutor scheduledPool = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure></li><li><p>2 以实例变量的方式来设置线程池的各项参数的大小；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置线程池的各个参数的大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> corePoolSize = <span class="number">10</span>;<span class="comment">// 池中所保存的线程数，包括空闲线程。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maximumPoolSize = <span class="number">20</span>;<span class="comment">// 池中允许的最大线程数。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> keepAliveTime = <span class="number">3</span>;<span class="comment">// 当线程数大于核心时，此为终止前多余的空闲线程等待新任务的最长时间。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> scheduledPoolSize = <span class="number">10</span>;</span><br></pre></td></tr></table></figure></li><li><p>3 在私有的构造方法中：</p><ul><li>实例化线程池；</li><li>实例化“计划任务线程池”；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">MyPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//实例化线程池，这里使用的 LinkedBlockingQueue 作为 workQueue ，使用 DiscardOldestPolicy 作为 handler</span></span><br><span class="line"><span class="keyword">this</span>.threadPool = <span class="keyword">new</span> ThreadPoolExecutor(corePoolSize, maximumPoolSize,</span><br><span class="line">keepAliveTime, TimeUnit.SECONDS,</span><br><span class="line"><span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(),</span><br><span class="line"><span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());<span class="comment">//不在新线程中执行任务，而是由调用者所在的线程来执行</span></span><br><span class="line"><span class="comment">//实例化计划任务线程池</span></span><br><span class="line"><span class="keyword">this</span>.scheduledPool = <span class="keyword">new</span> ScheduledThreadPoolExecutor(scheduledPoolSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>4 定义静态方法，返回线程池对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MyPool <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (myPool == <span class="keyword">null</span>)</span><br><span class="line">    create();</span><br><span class="line">    <span class="keyword">return</span> myPool;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>创建线程池时传入的参数说明：</p><ul><li>1 <code>corePoolSize（int）</code>：线程池中保持的线程数量，包括空闲线程在内。</li><li>2 <code>maximumPoolSize（int）</code>: 线程池中能够容纳最大线程数量；</li><li>3 <code>keepAliveTime(long)</code>：当线程池中线程数量大于 corePoolSize 的时候,空闲线程保持在线程池中的时间;</li><li>4 <code>unit(TimeUnit枚举类)</code>: 上面参数时间的单位，可以是分钟，秒，毫秒等等;</li><li>5 <code>workQueue（BlockingQueue）</code>: 任务队列；<ul><li>作用：当线程任务提交到线程池以后…<ul><li>1 首先放入队列中;</li><li>2 然后线程池按照该任务队列依次执行相应的任务;</li></ul></li></ul></li><li>6 <code>threadFactory(ThreadFactory类)</code>: 新线程产生工厂类;</li><li>7 <code>handler（RejectedExecutionHandler类）</code>: 当提交线程拒绝执行、异常的时候，处理异常的类;<ul><li>取值范围：<ul><li>AbortPolicy：丢弃任务并抛出异常；</li><li>DiscardPolicy：丢弃任务但是不抛出异常；</li><li>DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务；</li><li>CallerRunsPolicy：由调用线程处理该任务（？？？）；</li></ul></li></ul></li></ul></li><li><p>用法：获取线程池，并向其中添加任务；</p><ul><li><p>1 获取到线程池对象；</p><ul><li><p>手段1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor pool1 = (ThreadPoolExecutor) Executors.newCachedThreadPool(); <span class="comment">// 调用Executors类的newCachedThreadPool()方法</span></span><br></pre></td></tr></table></figure></li><li><p>手段2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor pool2 = MyPool.getInstance().getThreadPool(); <span class="comment">// 自定义类的静态方法</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>2 调用线程池对象的execute()方法执行指定的任务;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pool1.execute(() -&gt; System.out.println(<span class="string">"快捷线程池中的线程！"</span>));</span><br><span class="line"></span><br><span class="line">pool2.execute(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"pool2 普通线程池中的线程！"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">30</span>*<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;); <span class="comment">// 使用lambda表达式来表示待执行的任务</span></span><br></pre></td></tr></table></figure></li><li><p>3 打印线程池的状态信息；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"pool2 poolSize:"</span>+pool2.getPoolSize()); <span class="comment">// </span></span><br><span class="line">System.out.println(<span class="string">"pool2 corePoolSize:"</span>+pool2.getCorePoolSize()); <span class="comment">// 核心线程数</span></span><br><span class="line">System.out.println(<span class="string">"pool2 largestPoolSize:"</span>+pool2.getLargestPoolSize()); <span class="comment">// </span></span><br><span class="line">System.out.println(<span class="string">"pool2 maximumPoolSize:"</span>+pool2.getMaximumPoolSize()); <span class="comment">// ？？？</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>JDK中提供的几种常用线程池</p><ul><li><code>newFixedThreadPool</code> 创建固定大小数量线程池；</li><li><code>newSingleThreadExecutor</code> 创建容量为1的线程池——所有的线程依次执行；</li><li><code>newCachedThreadPool</code> 创建可缓存的线程池；<ul><li>特征：<ul><li>1 没有最大线程限制；</li><li>2 如果空闲线程等待时间超过1分钟，就关闭此线程；</li></ul></li></ul></li><li><code>newScheduledThreadPool</code> 创建计划 (延迟) 任务线程池；<ul><li>特征：可以设置线程池中线程的执行状态；<ul><li>1 使线程在特定的延迟时间后执行；</li><li>2 使线程周期性地执行；（作用等同于Timer）</li></ul></li></ul></li></ul></li></ul><h6 id="在SpringBoot中使用线程池"><a href="#在SpringBoot中使用线程池" class="headerlink" title="在SpringBoot中使用线程池"></a>在SpringBoot中使用线程池</h6><p>​    this is for further practice.</p><blockquote><p>全是文字，写着写着就没劲了。因为没有推理的过程，就只是照本宣科地陈列规则。<br>Plus,为什么一个构造方法需要有7个参数 OMG 🙃</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;关于线程池的初印象&quot;&gt;&lt;a href=&quot;#关于线程池的初印象&quot; class=&quot;headerlink&quot; title=&quot;关于线程池的初印象&quot;&gt;&lt;/a&gt;关于线程池的初印象&lt;/h4&gt;&lt;p&gt;由于接触到的项目都简单到只是CRUD，我并没有直接编码使用过线程池。所以感觉上非常生疏，甚至在被打击了一次之后，现在仍然觉得它就是个绣花枕头…&lt;/p&gt;</summary>
    
    
    
    <category term="interview" scheme="https://henryinshanghai.github.io/categories/interview/"/>
    
    
    <category term="Algorithm" scheme="https://henryinshanghai.github.io/tags/Algorithm/"/>
    
    <category term="Java stuff" scheme="https://henryinshanghai.github.io/tags/Java-stuff/"/>
    
  </entry>
  
  <entry>
    <title>记一次面试（字节跳动）_后续</title>
    <link href="https://henryinshanghai.github.io/interview/2020/08/28/interview/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%9D%A2%E8%AF%95%EF%BC%88%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%EF%BC%89_%E5%90%8E%E7%BB%AD.html"/>
    <id>https://henryinshanghai.github.io/interview/2020/08/28/interview/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%9D%A2%E8%AF%95%EF%BC%88%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%EF%BC%89_%E5%90%8E%E7%BB%AD.html</id>
    <published>2020-08-27T16:00:00.000Z</published>
    <updated>2020-08-28T15:33:14.166Z</updated>
    
    <content type="html"><![CDATA[<h4 id="ConcurrentHashMap的put-操作过程"><a href="#ConcurrentHashMap的put-操作过程" class="headerlink" title="ConcurrentHashMap的put()操作过程"></a>ConcurrentHashMap的put()操作过程</h4><p>这个问题在上次被问到后，我其实做了一番搜索。还搜索了一些文章，但都本着太长不看的原则跑进收藏夹里吃灰了</p><p>不过这次既然被同一个问题绊倒两次，还是坐下来跟它好好对付对付</p><a id="more"></a><h5 id="基本认识（5点认知）"><a href="#基本认识（5点认知）" class="headerlink" title="基本认识（5点认知）"></a>基本认识（5点认知）</h5><p>是：一个元素容器；</p><p>作用：对元素进行存储；</p><p>特征：</p><ul><li>与多线程相关；</li></ul><p>应用：xxx</p><p>用法：xxx</p><p>底层原理：散列表 + 红黑树；</p><h5 id="进一步认识"><a href="#进一步认识" class="headerlink" title="进一步认识"></a>进一步认识</h5><h6 id="底层数据结构（JDK1-8）"><a href="#底层数据结构（JDK1-8）" class="headerlink" title="底层数据结构（JDK1.8）"></a>底层数据结构（JDK1.8）</h6><p><img src="https://s1.ax1x.com/2020/08/28/dImSRf.md.png" alt="底层数据结构"></p><p>类的具体作用：参考源码中类上面的注释（不夸张的有两百行）；</p><p>简单概括（5点）：</p><ul><li>JDK1.8中的实现是散列表 + 红黑树；</li><li>ConcurrentHashMap支持高并发的访问与更新操作，因为它是线程安全的；</li><li>访问/检索操作不需要加锁；</li><li>get()方法是非阻塞的（啥意思？）；</li><li>key与value都不能为null；</li></ul><h6 id="WHY"><a href="#WHY" class="headerlink" title="WHY?"></a>WHY?</h6><ul><li>Hashtable实现线程安全的手段很直接（每个方法都添加了synchronized关键字），但是效率很低；</li><li>ConcurrentHashMap使用了更优的手段实现线程安全（部分加锁 + CAS算法）；</li></ul><h6 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h6><ul><li>CAS算法（compare and swap）<ul><li>作用：解决多个线程对变量的并发操作问题；</li><li>手段：规定对于任意一个线程，每次对变量进行修改操作时，都检查变量当前在主内存中的值 == 自己获取到的变量值；<ul><li>aka 判断主内存中的变量值是否被其他线程修改过了。</li><li>如果相等，说明没有其他线程修改主内存中的变量。则把修改过的值同步到主内存中；</li><li>如果不相等，说明已经有别的线程捷足先登，把主内存中的变量值修改了。则当前线程放弃自己计算的值，然后从主内存中重新获取变量的初始值，重新计算，然后再次尝试把计算结果同步到主内存中；</li></ul></li><li>知识卡：JMM(java内存模型 = CPU + 各个线程的工作内存 + 主内存；)</li></ul></li><li>volatile关键字<ul><li>作用：保证变量对所有线程的可见性（但是不保证原子性）；</li><li>原理-多线程环境下，变量对多个线程的可见性：一旦变量的值（主内存中）被某个线程修改，其他的线程都会看到修改后的变量；（从而重新获取、重新计算）</li><li>原理-无法保证变量操作的原子性：变量赋值的操作其实分成了多个步骤执行，而volatile没有对这一事实产生任何影响；</li></ul></li></ul><hr><h5 id="从源码认识类的实现原理"><a href="#从源码认识类的实现原理" class="headerlink" title="从源码认识类的实现原理"></a>从源码认识类的实现原理</h5><blockquote><p>bear this in mind：实现源码时，需要充分考虑底层数据结构被多个线程操作的可能性。以保证操作的线程安全</p></blockquote><h6 id="多线程下有哪些操作需要保证多线程安全呢？"><a href="#多线程下有哪些操作需要保证多线程安全呢？" class="headerlink" title="多线程下有哪些操作需要保证多线程安全呢？"></a>多线程下有哪些操作需要保证多线程安全呢？</h6><ul><li>增删改</li></ul><hr><h6 id="类的域对象（×10-不夸张的）"><a href="#类的域对象（×10-不夸张的）" class="headerlink" title="类的域对象（×10 不夸张的）"></a>类的域对象（×10 不夸张的）</h6><ul><li>Node&lt;K,V&gt;[] table; // 用于存储元素的散列表</li><li>其他域对象; // 为了其他API服务的</li><li>int sizeCtl; // 用于控制散列表的初始化与扩容； 规则：…</li></ul><h5 id="类的构造方法（×5-也不夸张）"><a href="#类的构造方法（×5-也不夸张）" class="headerlink" title="类的构造方法（×5 也不夸张）"></a>类的构造方法（×5 也不夸张）</h5><ul><li><p>构造方法的作用</p><ul><li>调用它，来创建实例对象；</li><li>强制调用者传入某些参数来初始化某些实例变量；</li></ul></li><li><p>选择一个构造方法进行代码分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* 参数判空代码... */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 为局部变量cap绑定一个值手段：判断xxx条件是否成立：如果是，绑定ooo。否则绑定tableSizeFor()方法的调用结果&gt;&gt;&gt;表示无符号右移操作</span></span><br><span class="line">        <span class="keyword">int</span> cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ?</span><br><span class="line">                   MAXIMUM_CAPACITY :</span><br><span class="line">                   tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>));</span><br><span class="line">    <span class="comment">// 把cap的值绑定到sizeCtl属性上</span></span><br><span class="line">        <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><p>tableSizeFor()方法的作用？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = c - <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        ...</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">return</span> ...;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这个实现手段不是重点，重点是它的作用是：获取到大于且最接近指定容量的2的指数数值；</p></li><li><p>this.sizeCtl = cap; // 指定下次扩容时，散列表容量的大小</p></li></ul></li></ul><h5 id="类的API-put-方法"><a href="#类的API-put-方法" class="headerlink" title="类的API-put()方法"></a>类的API-put()方法</h5><blockquote><p>OS:这是面试官真正问到的方法，我没有细致地看过 只能硬着头皮说，和HashMap地put()方法实现过程类似，只是添加了synchronized关键字吧吧🐷</p><p>参考:<a href="https://mp.weixin.qq.com/s/r1ErR7EroJt4b83Pm7Xk6g">Java3y</a></p></blockquote><ul><li><p>看之前推测一下子，put()作为一个添加键值对的api，可能的实现过程是怎样的；</p><ul><li>找到键值对应该存放的位置；</li><li>把键值对绑定到这个位置上；Over~</li></ul></li><li><p>真实情况是，put()方法需要做更多的工作（一方面是为了”容器的底层数据结构”,另一方面是为了“多线程操作的正确性”）</p><ul><li>代码拆解（源码基本没有给注释 引用图片：Java3y）</li></ul><p><img src="https://s1.ax1x.com/2020/08/28/do6lpn.png" alt="put()方法的工作"></p><p>这里面的步骤虽然多，但是层次还是能理清楚的。</p><ul><li><p>第一次插入键值对时，判断哈希表是否为空。如果是，就要先对哈希表进行初始化工作；</p></li><li><p>手段：调用initTable()方法，把方法的返回结果绑定到tab（在for循环中创建的局部变量）</p><p><img src="https://s1.ax1x.com/2020/08/28/dog6Fe.png" alt="初始化节点数组tab的代码"></p><ul><li>sizeCtl的规则：小于0时，表示有线程正在执行初始化操作。则，需要控制其他进程不能再次执行初始化的代码;</li><li>任务：对于多个线程，保证初始化的代码同一时刻就只能有唯一的线程在执行；</li><li>手段：<ul><li>1 在线程进入初始化的代码之前，先对sizeCtl属性进行判断；以决定线程能不能继续执行代码</li><li>2 如果线程能够执行初始化代码，在执行代码前，把sizeCtl设置为-1——支持1中的判断操作</li></ul></li><li>作用：多线程情况下，只会有一个线程取完成散列表的初始化操作；</li></ul></li></ul><blockquote><p>这种总结似乎缺了点意思 所以再从另一个角度补充下</p></blockquote></li></ul><h6 id="补充细节"><a href="#补充细节" class="headerlink" title="补充细节"></a>补充细节</h6><p>CAS操作的Java API：</p><ul><li><strong>tabAt</strong>    作用：获取 table 数组中索引为 i 的 Node 元素；</li><li><strong>casTabAt</strong>  作用：设置 table 数组中索引为 i 的元素</li><li><strong>setTabAt</strong>   作用：设置 table 数组中索引为 i 的元素</li></ul><h6 id="put-流程分析"><a href="#put-流程分析" class="headerlink" title="put()流程分析"></a>put()流程分析</h6><ul><li>1 计算出key应该在哈希表中插入的位置；<ul><li>手段：对key进行重哈希，以减少哈希冲突；</li></ul></li><li>2 判断当前数组是否为空，如果为空，就进行初始化操作intiTable();<ul><li>作用：只会有一个线程执行初始化的代码；</li></ul></li><li>3 判断key-value能不能直接添加到哈希表上；<ul><li>手段：<ul><li>1 计算key映射到的哈希表的索引； </li><li>2 调用CAS的tabAt()方法获取到该位置上的值； </li><li>3 如果当前值为null,直接调用casTabAt()完成插入操作；</li></ul></li></ul></li><li>4 如果预期插入哈希表的位置上的元素不为null,判断哈希表是不是正在扩容（多线程需要考虑的问题）<ul><li>手段：判断当前节点是不是特殊节点forwardingNode（这是ConcurrentHashMap中定义的一个内部类型，用于表示扩容操作状态下的节点）</li><li>具体方法：判断节点的hash值是不是等于-1（使用MOVED标识）；</li></ul></li><li>5 如果哈希表也没有在扩容中，说明可以执行插入节点的操作了（synchronzied加锁以实现线程安全性）</li><li>6 如果节点为链表的头节点：<ul><li>如果在链表中找到key相同的节点，则更新/覆盖节点的值</li><li>如果没有找到这样的节点，就直接在链表尾部添加一个新的节点</li></ul></li><li>7 如果节点为红黑树的根节点：<ul><li>说明：如果链表连接的节点长度太长的话，ConcurrentHashMap就会自动把链表转化成一个红黑树；</li><li>1 判断当前节点是不是红黑树的根节点；</li><li>2 判断红黑树中是否已经存在了键为key的节点；<ul><li>存在，则使用新的value来更新它；</li><li>不存在，则向红黑树中添加一个新的节点；</li></ul></li></ul></li><li>8 [<em>插入导致的结果</em>]根据当前链表的长度，来决定要不要把链表转化成一棵红黑树；</li><li>9 [<em>插入导致的结果</em>]插入新的键值对后，查看当前容量。如果超过临界值就进行扩容；</li></ul><h6 id="get-方法"><a href="#get-方法" class="headerlink" title="get()方法"></a>get()方法</h6><blockquote><p>get()的作用是取出数据</p></blockquote><ul><li>1 重hash；</li><li>2 找到节点在哈希表中的预期位置i；</li><li>3 如果哈希表的桶节点table[i]的key与待查找的key相等，则直接返回；</li><li>4 如果不相等，而根节点是红黑树节点。则<ul><li>在红黑树中查找</li></ul></li><li>5 如果不相等，而根节点是链表节点。则<ul><li>在链表中查找</li></ul></li></ul><blockquote><p>Java基础知识也挺繁杂的 until next time 😄</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;ConcurrentHashMap的put-操作过程&quot;&gt;&lt;a href=&quot;#ConcurrentHashMap的put-操作过程&quot; class=&quot;headerlink&quot; title=&quot;ConcurrentHashMap的put()操作过程&quot;&gt;&lt;/a&gt;ConcurrentHashMap的put()操作过程&lt;/h4&gt;&lt;p&gt;这个问题在上次被问到后，我其实做了一番搜索。还搜索了一些文章，但都本着太长不看的原则跑进收藏夹里吃灰了&lt;/p&gt;
&lt;p&gt;不过这次既然被同一个问题绊倒两次，还是坐下来跟它好好对付对付&lt;/p&gt;</summary>
    
    
    
    <category term="interview" scheme="https://henryinshanghai.github.io/categories/interview/"/>
    
    
    <category term="Algorithm" scheme="https://henryinshanghai.github.io/tags/Algorithm/"/>
    
    <category term="Java stuff" scheme="https://henryinshanghai.github.io/tags/Java-stuff/"/>
    
  </entry>
  
  <entry>
    <title>记一次面试（字节跳动）</title>
    <link href="https://henryinshanghai.github.io/interview/2020/08/26/interview/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%9D%A2%E8%AF%95%EF%BC%88%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%EF%BC%89.html"/>
    <id>https://henryinshanghai.github.io/interview/2020/08/26/interview/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%9D%A2%E8%AF%95%EF%BC%88%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%EF%BC%89.html</id>
    <published>2020-08-25T16:00:00.000Z</published>
    <updated>2020-08-26T11:37:00.340Z</updated>
    
    <content type="html"><![CDATA[<h3 id="字节跳动（视频面试一面）"><a href="#字节跳动（视频面试一面）" class="headerlink" title="字节跳动（视频面试一面）"></a>字节跳动（视频面试一面）</h3><hr><h4 id="关于面试官："><a href="#关于面试官：" class="headerlink" title="关于面试官："></a>关于面试官：</h4><p>​    面试官给我的感觉很好，年龄和我相仿，穿着也很随意。就不会让人产生紧张的情绪，而且问的问题也很有递进性。过程是挺轻松的，结果嘛…</p><a id="more"></a><h4 id="关于项目："><a href="#关于项目：" class="headerlink" title="关于项目："></a>关于项目：</h4><p>   这个主要问了做过项目中的一些难点问题。但实话讲，做过的项目有些头疼的问题，但都算不上技术难点。于是我先说了公司项目的特征：面向政府机构居多，所以不会存在什么高并发访问的情况。（这是真实情况，也算是降低面试官的期望，别一上来就问大流量情况下如何削峰、限流什么的）</p><p>   我说了两点：1 excel表格中大数据导入MySQL数据库的问题；2 后台上传多种格式的资料时的处理；富文本编辑器上传时的格式处理等等</p><p>   因为项目总是和业务强相关，面试官可能也不想纠结于细节问题。于是很快就跳到了Java基础的阶段</p><h4 id="关于Java基础："><a href="#关于Java基础：" class="headerlink" title="关于Java基础："></a>关于Java基础：</h4><p>这个据我推测，面试官面前可能有一个巨大的Xmind脑图，根据你简历上所写的内容。随机抽取一个点来问你，基本是要考察你对知识点了解的深度；具体问的问题如下：</p><h5 id="数据库联合索引与最左匹配原则"><a href="#数据库联合索引与最左匹配原则" class="headerlink" title="数据库联合索引与最左匹配原则"></a>数据库联合索引与最左匹配原则</h5><p>索引：为数据表中的指定字段添加的额外的数据结构；</p><p>作用：在查询时，能够通过某个字段的索引来快速定位到满足条件的记录行；</p><p>原理：</p><ul><li>索引一般使用树一类的结构进行存储，因此查询速度很快。</li><li>通过索引中的字段值，就能快速定位到数据表中对应的数据行；</li></ul><p>用法：在SQL查询语句中，使用添加了索引的字段作为查询条件（where xxx=???）。这样就能命中索引，从而实现快速查询；</p><p><strong>联合索引</strong>：使用数据表中的多个字段所创建的索引；</p><p>作用：在编写SQL语句时，就能够通过多个字段来命中索引——这会使得SQL语句的编写更加灵活；</p><p>规则：<strong>最左匹配原则</strong>；（这个我并没有答对）</p><p>示例：</p><ul><li>在创建联合索引时，选择了字段a、b、c；</li><li>在编写查询SQL时，<ul><li>如果查询的字段以a开头（a、a-b、a-b-c），则能够命中联合索引，从而加速查询；</li><li>如果查询的字段不是以a开头（准确的说，是不包含a字段），则无法命中联合索引，查询操作仍旧是遍历的方式；</li></ul></li></ul><p>（讲真，我只用Navicat这个可视化工具创建过索引。所以上面的这些东西都是事后找补的   印象分什么的基本就没了）</p><h5 id="volatile关键字："><a href="#volatile关键字：" class="headerlink" title="volatile关键字："></a>volatile关键字：</h5><p>（这个我两周之前很细致的看过，但是忘得永远比记住得要快）</p><p>是：Java提供的一个关键字；</p><p>作用：修饰一个变量，以保证多线程情况下，变量的可见性与有序性；</p><p>特征：</p><ul><li>volatile就只能修饰变量，不能修饰方法啥的；</li><li>volatile不能保证多线程操作下的原子性（可能线程A执行了一半后，线程B接管CPU时间片）——需要其他手段来保证；</li><li>真正在编码时，这个关键字用得并不多；</li></ul><p>原理：</p><ul><li><p>变量对多个线程的可见性：</p><ul><li><p>JMM（Java 内存模型）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> 每个线程都有自己的工作内存；</span><br><span class="line"><span class="number">2</span> 所有线程共享的变量都在主内存中；</span><br><span class="line"><span class="number">3</span> 线程操作变量时，先从主内存把变量的值拷贝到自己的工作内存中，操作结束后，再把变量的值更新到主内存</span><br><span class="line">中；</span><br></pre></td></tr></table></figure></li><li><p>结合JMM的3条规则，volatile关键字能够保证所有对变量的更新都即时地同步到主内存中；</p></li></ul></li><li><p>变量的有序性：</p><ul><li><p>JVM指令重排</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">为了提高代码执行的效率，CPU或者编译器可能会对程序员编写的代码进行重新排序；</span><br></pre></td></tr></table></figure><ul><li>规则：不管如何重新排序，JVM保证在单线程执行时，得到的结果总是相同的；</li><li>问题来了，多线程时，指令重排就可能导致程序出现非预期的执行结果；</li></ul></li><li><p>结合以上，volatile关键字能够保证变量的赋值过程（非原子操作）不会出现指令重排，aka，指令的有序性。</p></li></ul></li></ul><p>应用：实现双重检查锁的单例模式；</p><h5 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h5><p>是：Java提供的一个关键字；</p><p>作用：为一段代码加锁，从而限制此段代码同一时刻只能被一个线程访问；</p><p>特征：早期它的性能很低，但是JDK8中做了很多优化；</p><p>用法：</p><ul><li>修饰实例方法；<ul><li>作用：线程在执行实例方法之前，必须要获得当前实例的对象锁；</li></ul></li><li>修饰静态方法；（<em>这里面试官着重问了，但是我没能很好的区分实例锁与类锁</em>）<ul><li>作用：线程在执行静态方法之前，必须要获得当前类的对象锁；</li></ul></li><li>修饰代码块；<ul><li>作用：线程在执行代码块之前，必须要获得指定对象的锁；</li><li>特征：这里的对象可以由程序员手动指定；</li></ul></li></ul><p>应用：双重检查校验的单例模式（和volatile配合使用）；</p><p>原理：JVM层面的一些东西，在字节码上添加了一些独特的标识；</p><h5 id="synchronized关键字-与-ReentrantLock类型（这个面试官没问，可能是因为上面答得不好）"><a href="#synchronized关键字-与-ReentrantLock类型（这个面试官没问，可能是因为上面答得不好）" class="headerlink" title="synchronized关键字 与 ReentrantLock类型（这个面试官没问，可能是因为上面答得不好）"></a>synchronized关键字 与 ReentrantLock类型（这个面试官没问，可能是因为上面答得不好）</h5><p>作用：都能够为代码段加锁，从而限制多个线程对代码块的访问；</p><p>相同点：</p><ul><li>两者都是可重入锁（re-entree）;<ul><li>线程可以重复获取到对象的锁——当再次获取对象锁时，计数值+1；</li></ul></li></ul><p>不同点：</p><ul><li>实现层面<ul><li>synchronized关键字的实现是在JVM中，而ReentrantLock的实现在JDK的concurrent包中；</li></ul></li><li>用法层面<ul><li>synchronized是关键字，用法比较单一（无非修饰不同的成份），而ReentrantLock是一个类，用法就非常灵活了；</li></ul></li><li>功能层面<ul><li>ReentrantLock提供了更多的功能：<ul><li>1 使等待中的线程放弃等待（去做别的事情）；</li><li>2 指定锁的类型（是公平锁，还是非公平锁）；公平锁：等待最久的线程会在锁被释放时，优先获取到锁；</li><li>3 实现等待 - 通知机制；</li></ul></li></ul></li></ul><h5 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h5><p>参考：<a href="https://www.jianshu.com/p/f584799f1c77">公平🔒</a></p><p>必须：兔子喝水，黑狗看门；</p><p>结论：</p><ul><li>1、若在释放锁的时候总是没有新的兔子来打扰，则非公平锁等于公平锁；</li><li>2、若释放锁的时候，正好一个兔子来喝水，而此时位于队列头的兔子还没有被唤醒（因为线程上下文切换是需要不少开销的），此时后来的兔子则优先获得锁，成功打破公平，成为非公平锁；</li></ul><h5 id="类加载过程中的双亲委派模型"><a href="#类加载过程中的双亲委派模型" class="headerlink" title="类加载过程中的双亲委派模型"></a>类加载过程中的双亲委派模型</h5><p><strong>类加载过程</strong>：</p><p>是：一个过程；</p><p>作用：把编译器编译生成的class文件，以特定的格式加载到JVM内存中的特定区域；</p><p>特征：分为两类；</p><ul><li>预加载；<ul><li>在虚拟机启动时就会被加载到内存中的class文件；比如lang.*与util.*等；</li></ul></li><li>运行时加载；<ul><li>在运行程序时，虚拟机根据类的全限定名来去查找并加载对应的class文件；</li></ul></li></ul><p>SOP:</p><ul><li>通过类的全限定名获取到<em>类的二进制字节流</em>；</li><li>把<em>字节流所代表的静态存储结构</em>转化为<em>方法区的运行时数据结构</em>；</li><li>在JVM内存中生成<em>表示这个类的Class对象</em>——它包含类的一切信息，是反射机制的基础；</li></ul><p><strong>双亲委派模型</strong>：</p><p>是：一个使用类加载器时，推荐遵守的规则；</p><p>作用：保证核心类型都能够被安全地加载到内存中；防止不法分子写的String类型被JVM错误加载…</p><p>特征：</p><p>​    1 这不是一个强制遵守的规则；</p><p>​    2 每一层加载器都有自己能够加载的类型范围；</p><p>规则描述：</p><ul><li>当类加载器需要把一个类加载到内存中的时候，先尝试把加载的工作交给更高层的类加载器完成；</li><li>然后再转交给更高级的类加载器，so on and so forth,直到到达最高层的类加载器（Bootstrap）；</li><li>只有顶层类加载器无法加载的类型（每一层加载器都有自己所能加载的类型范围），才会交给底层的类加载器去加载；</li></ul><h5 id="Spring-IoC容器"><a href="#Spring-IoC容器" class="headerlink" title="Spring IoC容器"></a>Spring IoC容器</h5><p>是：一个管理对象 以及 对象之间依赖关系的第三方；</p><p><em>如何解决循环依赖的问题呢？</em></p><p><strong>循环依赖</strong>：</p><p>IoC容器中注入了实例a与实例b，实例a依赖于实例b，同时实例b也依赖于实例a；</p><p>issue：IoC容器在创建实例a时，需要先创建实例b。但是创建实例b时，又需要先创建实例a，狗咬尾巴</p><p>参考：<a href="https://segmentfault.com/a/1190000015221968">Spring对循环依赖的解决</a></p><p>解决方案：</p><p>1 尝试创建实例a，发现实例a依赖于实例b；</p><p>2 尝试创建实例b，发现实例b依赖于实例a；</p><p>3 获取到实例a的一个<strong>早期引用</strong>（属性未进行初始化的引用）；</p><p>4 把这个早期引用注入到实例b中，使得实例b完成初始化；</p><p>5 然后实例a再去获取到实例b的引用，得到实例a的<strong>完全引用</strong>；</p><h5 id="AOP（面向切面编程）"><a href="#AOP（面向切面编程）" class="headerlink" title="AOP（面向切面编程）"></a>AOP（面向切面编程）</h5><p>是：一种编程的方式；对标OOP</p><p>作用：能够把应用中一些公共的功能（事务、安全等）抽取出来单独实现，然后以声明的方式编织到需要它们的代码中；</p><p>特征：AOP是一种思想，不同框架对这种思想的实现会各有差异。比如Spring AOP与AspectJ；</p><p>用法：这个步骤比较多，不宜作为面试部分；</p><p>原理：Spring AOP的底层原理是动态代理+反射；</p><ul><li>代理类会封装目标类，并把<em>用于增强的切面类</em>添加到目标类的外围；</li><li>动态代理这种方式绝定了Spring AOP<em>只能对方法做一些增强（因为动态代理使用反射实现目标）</em>，而对字段等无能为力；</li><li>Java中的动态代理：JDK动态代理（要求被代理的类实现接口） 与 CGLib动态代理（不要求…）；</li></ul><h5 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h5><p>注：这是一个多线程安全的类型，我在简历中有写看过它的源码，但其实只看了分析的文章。时隔两周，就只记得“分段锁”这三个字了 😭</p><p>是：一个容器/集合；</p><p>作用：存储键值对；</p><p>特征：多线程安全；</p><p><strong>多线程安全原理</strong>：</p><p>​    JDK1.7的手段：</p><ul><li><p>把容器表示成多个数据段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcurrentHashMap</span></span>&#123;</span><br><span class="line">    <span class="comment">// Segment数组Segment类型本身继承了ReentrantLock，可以当作锁</span></span><br><span class="line">    Segment[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>数据段中存储多个键值对：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Segment</span></span>&#123;</span><br><span class="line">    HashEntry[]; <span class="comment">// HashEntry就是一个封装了键值对的类型；</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li>为每个数据段Segment添加一把锁，这样如果多个线程访问的是不同的数据段，就不会出现并发访问；而如果访问的是同一个数据段，仍旧是获取到锁的执行，没有获取到锁的等待</li></ul><p>​    JDK1.8使用的手段：</p><ul><li>synchronized关键字 + CAS乐观锁【细节需要看源码】</li><li>synchronized关键字只会锁住链表或红黑二叉树的头节点，如果多线程操作没有发生哈希冲突，就不会出现并发访问；如果操作到了同一个哈希位置，仍旧是…;</li></ul><p><strong>底层结构</strong>：</p><p>​    JDK1.7 Segment[] + HashEntry[]；</p><p>​    JDK1.8 Node[] + 链表 + 红黑树；</p><p>用法：</p><p>​    put()方法，前后有8步。</p><p>​    get()方法，就是按图索骥的过程，与多线程关系不大（毕竟它只是一个访问操作）；</p><blockquote><p>in case I don’t see u again, good morning, good afternoon, and good evening!😄</p></blockquote><p>​    </p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;字节跳动（视频面试一面）&quot;&gt;&lt;a href=&quot;#字节跳动（视频面试一面）&quot; class=&quot;headerlink&quot; title=&quot;字节跳动（视频面试一面）&quot;&gt;&lt;/a&gt;字节跳动（视频面试一面）&lt;/h3&gt;&lt;hr&gt;
&lt;h4 id=&quot;关于面试官：&quot;&gt;&lt;a href=&quot;#关于面试官：&quot; class=&quot;headerlink&quot; title=&quot;关于面试官：&quot;&gt;&lt;/a&gt;关于面试官：&lt;/h4&gt;&lt;p&gt;​    面试官给我的感觉很好，年龄和我相仿，穿着也很随意。就不会让人产生紧张的情绪，而且问的问题也很有递进性。过程是挺轻松的，结果嘛…&lt;/p&gt;</summary>
    
    
    
    <category term="interview" scheme="https://henryinshanghai.github.io/categories/interview/"/>
    
    
    <category term="Algorithm" scheme="https://henryinshanghai.github.io/tags/Algorithm/"/>
    
    <category term="Java stuff" scheme="https://henryinshanghai.github.io/tags/Java-stuff/"/>
    
  </entry>
  
  <entry>
    <title>奇偶链表_10</title>
    <link href="https://henryinshanghai.github.io/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8%EF%BC%88%E6%8A%8A%E5%A5%87%E6%95%B0%E4%BD%8D%E7%BD%AE%E4%B8%8E%E5%81%B6%E6%95%B0%E4%BD%8D%E7%BD%AE%E4%B8%8A%E7%9A%84%E8%8A%82%E7%82%B9%E8%BF%9E%E5%9C%A8%E4%B8%80%E8%B5%B7%EF%BC%89_10.html"/>
    <id>https://henryinshanghai.github.io/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8%EF%BC%88%E6%8A%8A%E5%A5%87%E6%95%B0%E4%BD%8D%E7%BD%AE%E4%B8%8E%E5%81%B6%E6%95%B0%E4%BD%8D%E7%BD%AE%E4%B8%8A%E7%9A%84%E8%8A%82%E7%82%B9%E8%BF%9E%E5%9C%A8%E4%B8%80%E8%B5%B7%EF%BC%89_10.html</id>
    <published>2020-08-16T12:46:25.000Z</published>
    <updated>2020-08-17T08:40:31.179Z</updated>
    
    <content type="html"><![CDATA[<h4 id="把链表中的奇数位置节点与偶数位置节点放在一起"><a href="#把链表中的奇数位置节点与偶数位置节点放在一起" class="headerlink" title="把链表中的奇数位置节点与偶数位置节点放在一起"></a>把链表中的奇数位置节点与偶数位置节点放在一起</h4><h4 id="题设-与-要求"><a href="#题设-与-要求" class="headerlink" title="题设 与 要求"></a>题设 与 要求</h4><p><img src="https://s1.ax1x.com/2020/08/15/dklpjK.md.png" alt="题设与要求"></p><a id="more"></a><h4 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h4><p><img src="https://s1.ax1x.com/2020/08/15/dkldDU.md.png" alt="测试用例"></p><h4 id="附加说明"><a href="#附加说明" class="headerlink" title="附加说明"></a>附加说明</h4><p><img src="https://s1.ax1x.com/2020/08/15/dklLKf.md.png" alt="提示信息"></p><h4 id="分析（问题的难点）"><a href="#分析（问题的难点）" class="headerlink" title="分析（问题的难点）"></a>分析（问题的难点）</h4><ul><li>如何把奇数/偶数位置的节点都连接起来？</li><li>如何把奇数位置节点的集合 与 偶数位置节点的集合连接起来？</li></ul><h4 id="思路（难点的解决方案）"><a href="#思路（难点的解决方案）" class="headerlink" title="思路（难点的解决方案）"></a>思路（难点的解决方案）</h4><ul><li>如何把奇数位置/偶数位置的节点都连接起来？<ul><li>答：使用两个指针odd、even，初始化指向第一个节点与第二个节点。然后去创建奇数位置节点链表与偶数位置节点链表；</li></ul></li><li>如何把奇数位置节点集合与偶数位置节点集合连接起来？<ul><li>答：只要把odd链表的尾节点连接到even链表的头节点就可以了</li></ul></li></ul><h4 id="根据思路进行编码（细节处理）"><a href="#根据思路进行编码（细节处理）" class="headerlink" title="根据思路进行编码（细节处理）"></a>根据思路进行编码（细节处理）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">oddEvenList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 鲁棒性代码</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1 定义需要的实例变量</span></span><br><span class="line">        ListNode odd = head; <span class="comment">// 奇数位置节点的指针作用：连接奇数位置的节点</span></span><br><span class="line">        ListNode even = head.next; <span class="comment">// 偶数位置节点的指针作用：连接偶数位置的节点</span></span><br><span class="line">        ListNode evenHead = even; <span class="comment">// 作用：记录偶数节点链表的头节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 遍历当前链表在循环中：1 创建奇数位置节点链表； 2 创建偶数位置节点链表</span></span><br><span class="line">        <span class="keyword">while</span>(even != <span class="keyword">null</span> &amp;&amp; even.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 创建链表SOP： 1 建立连接； 2 更新指针；</span></span><br><span class="line">            odd.next = even.next;</span><br><span class="line">            odd = odd.next;</span><br><span class="line"></span><br><span class="line">            even.next = odd.next;</span><br><span class="line">            even = even.next; <span class="comment">// even会率先达到链表的尾部</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 把偶数链表连接到奇数链表的尾节点上</span></span><br><span class="line">        odd.next = evenHead;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 返回新链表的头节点（作图可知）</span></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代码分解SOP"><a href="#代码分解SOP" class="headerlink" title="代码分解SOP"></a>代码分解SOP</h4><ul><li>定义需要的实例变量</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ListNode odd = head; <span class="comment">// 用于指向奇数位置的节点</span></span><br><span class="line">ListNode even = head.next; <span class="comment">// 用于指向偶数位置的节点</span></span><br></pre></td></tr></table></figure><ul><li>遍历当前链表中的所有节点    在循环中：1 创建奇数节点的链表； 2 创建偶数节点的链表</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(ture)&#123; <span class="comment">// 参考：画图</span></span><br><span class="line">    <span class="comment">// 创建连接</span></span><br><span class="line">    odd.next = even.next;</span><br><span class="line">    <span class="comment">// 更新指针</span></span><br><span class="line">    odd = odd.next;</span><br><span class="line">    </span><br><span class="line">    even.next = odd.next;</span><br><span class="line">    even = even.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2020/08/15/dkteIO.md.jpg" alt="遇事不决画个图"></p><ul><li>确定循环执行表达式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据链表中的节点数的不同，循环终结会有两种情况</span></span><br><span class="line"><span class="comment">// 1 链表中的节点数目为偶数个even.next == null</span></span><br><span class="line"><span class="comment">// 2 链表中的节点数目为奇数个even == null</span></span><br><span class="line"><span class="comment">// 当这两种情况之一发生时，就要终止循环 所以</span></span><br><span class="line"><span class="keyword">while</span>(even == <span class="keyword">null</span> &amp;&amp; even.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>把偶数链表连接到奇数链表上</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">odd.next = evenHead; <span class="comment">// 连接到记录的最初的偶数链表的头节点</span></span><br></pre></td></tr></table></figure><blockquote><p>Bingo! good morning,good afternoon,and good night 🌙</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;把链表中的奇数位置节点与偶数位置节点放在一起&quot;&gt;&lt;a href=&quot;#把链表中的奇数位置节点与偶数位置节点放在一起&quot; class=&quot;headerlink&quot; title=&quot;把链表中的奇数位置节点与偶数位置节点放在一起&quot;&gt;&lt;/a&gt;把链表中的奇数位置节点与偶数位置节点放在一起&lt;/h4&gt;&lt;h4 id=&quot;题设-与-要求&quot;&gt;&lt;a href=&quot;#题设-与-要求&quot; class=&quot;headerlink&quot; title=&quot;题设 与 要求&quot;&gt;&lt;/a&gt;题设 与 要求&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/08/15/dklpjK.md.png&quot; alt=&quot;题设与要求&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="ListNode" scheme="https://henryinshanghai.github.io/categories/ListNode/"/>
    
    
    <category term="Algorithm" scheme="https://henryinshanghai.github.io/tags/Algorithm/"/>
    
    <category term="LinkedList" scheme="https://henryinshanghai.github.io/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>分隔链表得到子链表_09</title>
    <link href="https://henryinshanghai.github.io/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E6%8A%8A%E9%93%BE%E8%A1%A8%E5%88%86%E9%9A%94%E6%88%90k%E4%B8%AA%E5%AD%90%E9%93%BE%E8%A1%A8_09.html"/>
    <id>https://henryinshanghai.github.io/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E6%8A%8A%E9%93%BE%E8%A1%A8%E5%88%86%E9%9A%94%E6%88%90k%E4%B8%AA%E5%AD%90%E9%93%BE%E8%A1%A8_09.html</id>
    <published>2020-08-16T11:00:00.000Z</published>
    <updated>2020-08-17T04:30:44.384Z</updated>
    
    <content type="html"><![CDATA[<h4 id="把链表分隔成k个子链表"><a href="#把链表分隔成k个子链表" class="headerlink" title="把链表分隔成k个子链表"></a>把链表分隔成k个子链表</h4><hr><h4 id="题设与要求"><a href="#题设与要求" class="headerlink" title="题设与要求"></a>题设与要求</h4><p><img src="https://s1.ax1x.com/2020/08/15/dFWppn.md.png" alt="题设与要求"></p><a id="more"></a><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p><img src="https://s1.ax1x.com/2020/08/15/dFICeP.md.png" alt="测试用例"></p><h4 id="提示信息"><a href="#提示信息" class="headerlink" title="提示信息"></a>提示信息</h4><p><img src="https://s1.ax1x.com/2020/08/15/dFoZtO.png" alt="提示信息"></p><h4 id="分析（题目中的难点）"><a href="#分析（题目中的难点）" class="headerlink" title="分析（题目中的难点）"></a>分析（题目中的难点）</h4><ul><li>根据题设，就是要把链表中的节点均分为k份；<ul><li>要如何处理(length % k)余下的这些个节点？</li></ul></li><li>k个连续的部分，每个部分相差不超过1；<ul><li>说明每个子链表中的节点数会有不一样。可以顺序的让靠前的子链表中多出一个节点，来消耗余下的节点</li><li>如何确定到哪一个子链表时，余下的节点已经被消耗完了呢？</li></ul></li><li>如果k &gt; length，缺少的部分补充null作为元素；</li></ul><h4 id="思路（对难点的解决方案）"><a href="#思路（对难点的解决方案）" class="headerlink" title="思路（对难点的解决方案）"></a>思路（对难点的解决方案）</h4><ul><li>定义一个大小为k数组，数组中的第i个元素表示：第i个子链表中应该包含的节点数目；</li><li>定义一个循环，每次循环都为数组中的一个元素绑定值<ul><li>先求出余数；</li><li>每次绑定值时，判断余数是否还大于0.如果是，就把要绑定的值+1； 同时余数-1</li><li>每个子节点要绑定的基础数值为：(length / k)</li></ul></li><li>定义一个子链表列表，用于存储分割后的子链表；</li><li>定义一个循环，每次循环<ul><li>从数组中取出当前子链表应该包含的节点数；</li><li>根据上面的节点数目来创建一个子链表，并把子链表绑定到子链表列表的一个元素上；</li><li>循环往复，直到链表中的所有节点都被安排了</li></ul></li></ul><h4 id="把思路翻译成代码（🙏）"><a href="#把思路翻译成代码（🙏）" class="headerlink" title="把思路翻译成代码（🙏）"></a>把思路翻译成代码（🙏）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode[] splitListToParts(ListNode root, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="comment">// 定义一个指针 作用：作为游标，计算链表的节点长度</span></span><br><span class="line">        ListNode cursor = root;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义一个链表列表 作用：存储分割后的多个子链表；</span></span><br><span class="line">        ListNode[] res = <span class="keyword">new</span> ListNode[k]; <span class="comment">// 默认每个元素绑定的都是一个null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 鲁棒性代码</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算链表长度</span></span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cursor != <span class="keyword">null</span>)&#123;</span><br><span class="line">            length++;</span><br><span class="line">            cursor = cursor.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 比较链表长度length 与 预期分割得到的子链表数目k</span></span><br><span class="line">        <span class="keyword">if</span>(k &gt;= length)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;length; i++)&#123; <span class="comment">// 使用root链表中的节点对res数组的元素进行重新初始化</span></span><br><span class="line">                res[i] = <span class="keyword">new</span> ListNode(root.val);</span><br><span class="line">                root = root.next;</span><br><span class="line">            &#125; <span class="comment">// 只初始化了length个元素。剩下的元素仍旧是null</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 计算出第N个子链表应该包含多少个节点</span></span><br><span class="line">            <span class="keyword">int</span> remainder = length % k;</span><br><span class="line">            <span class="keyword">int</span> part = length / k;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">                counts[i] = remainder &gt; <span class="number">0</span> ? part + <span class="number">1</span> : part;</span><br><span class="line">                remainder--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从原始链表中截取出k个子链表，并添加到链表数组中</span></span><br><span class="line">            ListNode p = root;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;k; i++)&#123;</span><br><span class="line"></span><br><span class="line">                res[i] = p;</span><br><span class="line">                <span class="comment">// 当前子链接中应该包含多少个节点</span></span><br><span class="line">                <span class="keyword">int</span> count = counts[i];</span><br><span class="line">                <span class="keyword">while</span>(--count &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    p = p.next;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 记录下一个节点</span></span><br><span class="line">                ListNode temp = p.next;</span><br><span class="line">                <span class="comment">// 为当前节点绑定null</span></span><br><span class="line">                p.next = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 更新当前节点</span></span><br><span class="line">                p = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回得到的子链表列表</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代码分解步骤"><a href="#代码分解步骤" class="headerlink" title="代码分解步骤"></a>代码分解步骤</h4><ul><li>定义需要的实例变量</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ListNode cursor = head; <span class="comment">// 用于在链表的节点上遍历</span></span><br><span class="line">ListNode[] res = <span class="keyword">new</span> ListNode[k]; <span class="comment">// 一个大小为k的ListNode类型的数组用于存储分割后的子链表</span></span><br></pre></td></tr></table></figure><ul><li>求出链表的长度</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(cursor != <span class="keyword">null</span>)&#123;</span><br><span class="line">length++;</span><br><span class="line">    cursor = cursor.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>比较链表长度length与预期分隔得到的子链表数目k</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(k &gt; length)&#123;</span><br><span class="line"><span class="comment">// 子链表数目比链表本身的节点还要多手段：不足的部分补上null</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 子链表数目小于等于链表本身的节点数目手段：平均分配，盈余的话可能要多分一个</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当子链表数目k比起链表本身的节点length还要多时</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化res数组中前面length个元素</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;length; i++)&#123;</span><br><span class="line">    <span class="comment">// 创建一个新的链表，并绑定到子链表中为什么要新建链表？</span></span><br><span class="line">    res[i] = <span class="keyword">new</span> ListNode(root.val);</span><br><span class="line">    root = root.next;</span><br><span class="line">&#125; <span class="comment">// 没有绑定子链表的节点，值默认是null 符合题目要求</span></span><br></pre></td></tr></table></figure><ul><li>当子链表数目小于等于链表本身的节点length时<ul><li>Ⅰ 计算出每个子链表应该包含的节点数量，并存储到一个数组中；</li><li>Ⅱ 遍历原始链表：<ul><li>从中取出正确数量的节点添加到子链表中；</li><li>当前子链接添加完成后，截断子链表。并把指针移动到下一个子链表的起始处</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Ⅰ计算出每个子链表应该包含的节点数量，并存储到一个数组中；</span></span><br><span class="line"><span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> perPart = length / k; <span class="comment">// 每个子链表的基础节点数目</span></span><br><span class="line"><span class="keyword">int</span> remainder = (length % k); <span class="comment">// 均分k份之后，余下的节点数量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;k; i++)&#123;</span><br><span class="line">    <span class="comment">// 使用三目运算符来替代一个if/else逻辑</span></span><br><span class="line">    counts[i] = (remainder &gt; <span class="number">0</span>) : perPart + <span class="number">1</span> : perPart;</span><br><span class="line">    remainder--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Ⅱ 遍历原始链表,把原始列表分割成k个子链表</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; k; i++)&#123;</span><br><span class="line"><span class="comment">/* ① 从原始链表中取出正确数量的节点添加到子链表中 */</span></span><br><span class="line">    <span class="comment">// 创建一个新的指针指向头节点</span></span><br><span class="line">    ListNode p = root; </span><br><span class="line">    <span class="comment">// 把当前子链表的头节点绑定到res[]的元素上</span></span><br><span class="line">    res[i] = p;</span><br><span class="line">    <span class="comment">// 获取到当前子链接中应该包含的节点数</span></span><br><span class="line">    <span class="keyword">int</span> count = counts[i];</span><br><span class="line">    <span class="comment">// 获取到指定数量的节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;count; j++)&#123; <span class="comment">// 应该向后遍历(count - 1)次</span></span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 当前子链接添加完成后，截断子链表。并把指针移动到下一个子链表的起始处 */</span></span><br><span class="line">    <span class="comment">// 记录下一个节点</span></span><br><span class="line">    ListNode temp = p.next; </span><br><span class="line">    <span class="comment">// 截断当前链表</span></span><br><span class="line">    p.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 更新当前节点</span></span><br><span class="line">    p = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>返回添加了子链表元素的res数组</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure><h4 id="启示"><a href="#启示" class="headerlink" title="启示"></a>启示</h4><p>对于循环次数已知的情况，推荐使用for循环。因为它的表达式非常容易写</p><p>while循环语法适用于那些循环次数不确定的场合</p><blockquote><p>until next time 😄</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;把链表分隔成k个子链表&quot;&gt;&lt;a href=&quot;#把链表分隔成k个子链表&quot; class=&quot;headerlink&quot; title=&quot;把链表分隔成k个子链表&quot;&gt;&lt;/a&gt;把链表分隔成k个子链表&lt;/h4&gt;&lt;hr&gt;
&lt;h4 id=&quot;题设与要求&quot;&gt;&lt;a href=&quot;#题设与要求&quot; class=&quot;headerlink&quot; title=&quot;题设与要求&quot;&gt;&lt;/a&gt;题设与要求&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/08/15/dFWppn.md.png&quot; alt=&quot;题设与要求&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="ListNode" scheme="https://henryinshanghai.github.io/categories/ListNode/"/>
    
    
    <category term="Algorithm" scheme="https://henryinshanghai.github.io/tags/Algorithm/"/>
    
    <category term="LinkedList" scheme="https://henryinshanghai.github.io/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>回文链表(迭代)_08_2</title>
    <link href="https://henryinshanghai.github.io/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E9%93%BE%E8%A1%A8%E6%98%AF%E4%B8%8D%E6%98%AF%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8%EF%BC%88%E8%BF%AD%E4%BB%A3%E6%96%B9%E5%BC%8F%EF%BC%89_08_2.html"/>
    <id>https://henryinshanghai.github.io/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E9%93%BE%E8%A1%A8%E6%98%AF%E4%B8%8D%E6%98%AF%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8%EF%BC%88%E8%BF%AD%E4%BB%A3%E6%96%B9%E5%BC%8F%EF%BC%89_08_2.html</id>
    <published>2020-08-16T10:30:00.000Z</published>
    <updated>2020-08-17T04:28:26.255Z</updated>
    
    <content type="html"><![CDATA[<h3 id="判断一个链表是不是回文链表（迭代方式）"><a href="#判断一个链表是不是回文链表（迭代方式）" class="headerlink" title="判断一个链表是不是回文链表（迭代方式）"></a>判断一个链表是不是回文链表（迭代方式）</h3><h4 id="题设与要求"><a href="#题设与要求" class="headerlink" title="题设与要求"></a>题设与要求</h4><p><img src="https://s1.ax1x.com/2020/08/15/diX5I1.png" alt="题设与要求"></p><a id="more"></a><h4 id="分析（问题的难点）"><a href="#分析（问题的难点）" class="headerlink" title="分析（问题的难点）"></a>分析（问题的难点）</h4><ul><li><p>这里不再考虑使用递归的方式，因为上一篇中已经实现了递归的代码；</p></li><li><p>为了判断链表是不是回文链表，肯定要对其左半边与右半边的节点进行比较；</p><p><strong>难点1</strong>：如何确定链表的左半边与右半边？aka 链表的中间节点位置</p></li><li><p>假设现在已经找到了中间节点的位置，接下来要怎么逐个比较各个节点呢？</p><p>方式1 从两边到中间，逐个比较节点的值；</p><p>方式2 从中间到两边，逐个比较节点的值；</p><p>说明：不管哪一种方式，都会面临一个问题——指针无法逆着链表节点移动；</p><p><strong>难点2</strong>：如何能让指针逆着链表的方向移动？</p></li><li><p>如果上面两个难点都得到解决，接下来就只需要逐个比较节点的值，分分钟无障碍</p></li></ul><h4 id="思路（难点的解决手段）"><a href="#思路（难点的解决手段）" class="headerlink" title="思路（难点的解决手段）"></a>思路（难点的解决手段）</h4><ul><li><p>难点1 如何确定链表的中间节点位置？</p><p>手段：快慢指针。</p><p>具体方法：从head节点开始（具体需要画图确认最佳方案），快指针一次走两个节点，慢指针一次走一个节点。</p><p>原理：当快指针指向链表尾节点时，慢指针应该刚好指向链表的中间节点。（或者前面一个节点）</p></li><li><p>难点2 如何能让指针逆着链表方向移动？</p><p>说明：实现这个目标其实有多个手段，比如借助额外空间整一个新链表。但是题目要求O(1)的空间复杂度，so pass this</p><p>手段：对链表的左半部分/右半部分进行翻转；</p><p>具体方法：翻转链表所需要的3个指针——prev、curr、temp；</p><p>原理：如果翻转左半部分，从中间节点到两边的节点进行比较；如果翻转右半部分，则是从两边的节点向中间节点进行比较；</p><p>这里我们选择翻转左半部分</p></li></ul><h4 id="把思路翻译成代码"><a href="#把思路翻译成代码" class="headerlink" title="把思路翻译成代码"></a>把思路翻译成代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1 作用：判断一个链表是不是回文链表，并返回布尔值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 迭代方式</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 防止NPE的指针</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用于翻转链表的指针</span></span><br><span class="line">        ListNode prev = dummy;</span><br><span class="line">        ListNode curr = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用于定位到中点的指针</span></span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一边定位，一边创建新的链表   翻转三部曲：1 记录当前节点的下一个节点； 2 改变当前节点的连接   3 更新指针prev与curr</span></span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123; <span class="comment">// slow与curr的位置关系还需要考察</span></span><br><span class="line">            <span class="comment">// 注： 当前节点的下一个节点总是slow,所以第1步省略</span></span><br><span class="line">            curr = slow; <span class="comment">// 3-2 更新指针curr</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新快慢指针</span></span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 翻转链表</span></span><br><span class="line">            curr.next = prev; <span class="comment">// 2 改变连接</span></span><br><span class="line">            prev = curr; <span class="comment">// 3-1 更新指针prev</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据fast的特征判断slow的位置</span></span><br><span class="line">        <span class="keyword">if</span>(fast != <span class="keyword">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过逐个比较两个链表的节点来判断是否为回文链表</span></span><br><span class="line">        <span class="keyword">while</span>(slow != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(curr.val != slow.val)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            curr = curr.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代码步骤分解"><a href="#代码步骤分解" class="headerlink" title="代码步骤分解"></a>代码步骤分解</h4><ul><li>定义需要的实例变量（包括指针变量）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方便定位链表头节点的指针</span></span><br><span class="line">      ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">      dummy.next = head;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 用于翻转链表的指针</span></span><br><span class="line">      ListNode prev = dummy;</span><br><span class="line">      ListNode curr = head;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 用于定位到中点的指针</span></span><br><span class="line">      ListNode slow = head;</span><br><span class="line">      ListNode fast = head;</span><br></pre></td></tr></table></figure><ul><li>循环中需要做的事情：Ⅰ 定位链表的中间节点；    </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123; <span class="comment">// 2 直到快指针指向链表的尾节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 手段SOP：1 不断更新快慢指针</span></span><br><span class="line">    slow = slow.next;</span><br><span class="line">    fast = fast.next.next;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Ⅱ 对左半部分链表进行翻转；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    翻转三步曲</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    // 1 记录当前节点的下一个节点；</span></span><br><span class="line"><span class="comment">    ListNode temp = curr.next;</span></span><br><span class="line"><span class="comment">    // 2 改变当前节点的连接</span></span><br><span class="line"><span class="comment">    curr.next = prev;</span></span><br><span class="line"><span class="comment">    // 3 更新指针prev与curr把prev更新到curr，把curr更新到temp</span></span><br><span class="line"><span class="comment">    prev = curr;</span></span><br><span class="line"><span class="comment">    curr = temp;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 问题来了：1 当前节点的下一个节点是什么呢？</span></span><br><span class="line">    <span class="comment">// 问题2：左半边的链表应该结束于哪一个节点呢？</span></span><br><span class="line">    <span class="comment">// 解决手段：为了准确定位左半部分链表的边界，把“当前节点的下一个节点”设置为slow指向的节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 知道了“当前节点的下一个节点为slow”后，套用上面的翻转三步曲 */</span></span><br><span class="line">    <span class="comment">// 1 记录当前节点的下一个节点 手段：直接获取slow就可以了</span></span><br><span class="line">    <span class="comment">// 2 更新当前节点的连接为前一个节点</span></span><br><span class="line">    curr.next = prev; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3 更新指针</span></span><br><span class="line">    prev = curr; </span><br><span class="line">    curr = slow; <span class="comment">// 更新当前指针</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2020/08/15/dFei4K.md.jpg" alt="翻转图示"></p><ul><li>确保curr总是落后于slow一个节点</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 手段：把更新curr的语句放在更新快慢指针的语句之前</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    curr = slow; <span class="comment">// 更新当前节点为temp</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更新快慢指针</span></span><br><span class="line">    slow = slow.next;</span><br><span class="line">    fast = fast.next.next;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 翻转链表中的节点</span></span><br><span class="line">    curr.next = prev;</span><br><span class="line">    prev = curr;</span><br><span class="line">    <span class="comment">// 更新curr指针的代码在第一行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>确定循环执行表达式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参考图示可知，fast应该停留在尾节点 或者 null节点上</span></span><br><span class="line"><span class="comment">// 原则：刚好形成可以一一对比其节点的左半部分链表（已翻转）</span></span><br><span class="line"><span class="keyword">while</span>(fast != <span class="keyword">null</span> || fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>根据情况来移动slow指针——因为这时候左右链表的节点数可能不一样</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参考图示可知：当链表节点数为奇数个时，slow指在最中间节点的位置。这时候右半部分链表的节点多了一个</span></span><br><span class="line"><span class="keyword">if</span>(fast != <span class="keyword">null</span>)&#123; <span class="comment">// fast!=null是这种情况下的特征</span></span><br><span class="line">    slow = slow.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>逐个比较左右两个链表的节点，来判断总链表是不是回文链表</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(curr.val != slow.val)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    curr = curr.next;</span><br><span class="line">    slow = slow.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>确定循环执行表达式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由于左右两个链表的节点长度是一样的，所以只要任一一个链表到头，循环就结束</span></span><br><span class="line"><span class="keyword">while</span>(slow != <span class="keyword">null</span>)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>鲁棒性代码</li><li>测试用例</li></ul><h4 id="代码重现（拆解之后的组合）"><a href="#代码重现（拆解之后的组合）" class="headerlink" title="代码重现（拆解之后的组合）"></a>代码重现（拆解之后的组合）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 定义需要的指针</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 翻转所需要用到的指针</span></span><br><span class="line">        ListNode prev = dummy;</span><br><span class="line">        ListNode curr = head;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 寻找中间节点所需要用到的指针</span></span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123; <span class="comment">// 只要有一个为false，循环就会结束</span></span><br><span class="line">            <span class="comment">// 翻转节点 - 2 </span></span><br><span class="line">            curr = slow;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 更新快慢指针</span></span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 翻转节点 - 1</span></span><br><span class="line">            curr.next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果需要，更新slow指针的位置</span></span><br><span class="line">        <span class="keyword">if</span>(fast != <span class="keyword">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历左右链表的每个节点，逐一比较</span></span><br><span class="line">        <span class="keyword">while</span>(slow != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(curr.val != slow.val)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            curr = curr.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>this is loads of code. until next time 😓</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;判断一个链表是不是回文链表（迭代方式）&quot;&gt;&lt;a href=&quot;#判断一个链表是不是回文链表（迭代方式）&quot; class=&quot;headerlink&quot; title=&quot;判断一个链表是不是回文链表（迭代方式）&quot;&gt;&lt;/a&gt;判断一个链表是不是回文链表（迭代方式）&lt;/h3&gt;&lt;h4 id=&quot;题设与要求&quot;&gt;&lt;a href=&quot;#题设与要求&quot; class=&quot;headerlink&quot; title=&quot;题设与要求&quot;&gt;&lt;/a&gt;题设与要求&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/08/15/diX5I1.png&quot; alt=&quot;题设与要求&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="ListNode" scheme="https://henryinshanghai.github.io/categories/ListNode/"/>
    
    
    <category term="Algorithm" scheme="https://henryinshanghai.github.io/tags/Algorithm/"/>
    
    <category term="LinkedList" scheme="https://henryinshanghai.github.io/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>回文链表_08</title>
    <link href="https://henryinshanghai.github.io/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E4%B8%BA%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8(%E9%80%92%E5%BD%92%E6%96%B9%E5%BC%8F)_08.html"/>
    <id>https://henryinshanghai.github.io/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E4%B8%BA%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8(%E9%80%92%E5%BD%92%E6%96%B9%E5%BC%8F)_08.html</id>
    <published>2020-08-16T10:00:00.000Z</published>
    <updated>2020-08-16T10:28:28.340Z</updated>
    
    <content type="html"><![CDATA[<h3 id="判断一个链表是否为回文链表"><a href="#判断一个链表是否为回文链表" class="headerlink" title="判断一个链表是否为回文链表"></a>判断一个链表是否为回文链表</h3><h4 id="题设与要求"><a href="#题设与要求" class="headerlink" title="题设与要求"></a>题设与要求</h4><p><img src="https://s1.ax1x.com/2020/08/15/diX5I1.png" alt="题设与要求"></p><a id="more"></a><h4 id="分析（问题的难点）"><a href="#分析（问题的难点）" class="headerlink" title="分析（问题的难点）"></a>分析（问题的难点）</h4><p>1 回文链表的定义:左半边与右半边完全对称——这样从左边读起与从右边读起来，读到的内容是相同的。</p><p>2 如果使用迭代的方式，比较直观的想法是：头尾节点各一个指针，然后指针向里走。指针每走一次，就要比较一次节点的值。</p><ul><li>难点：但是由于是单向链表，尾节点的指针没有办法直接向前走。所以在此之前需要把右半边的链表翻转，然后再进行迭代与比较操作。可以预见，需要确定诸多的细节：右半边链表的终点、循环终止条件等</li></ul><p>3 能不能使用递归的方式呢？</p><ul><li>把问题转换为更小规模的问题：head头节点 + 中间节点组成的链表 + tail尾节点；<ul><li>中间节点组成的链表是不是回文链表，这就是一个更小规模的问题；</li></ul></li><li>更小规模问题的处理结果，能用来解决问题本身吗？<ul><li>如果中间节点组成的链表middle是一个回文链表，就只需要判断head.val == tail.val。如果相等，则整个链表就是一个回文链表</li></ul></li></ul><h4 id="思路（优先使用递归）"><a href="#思路（优先使用递归）" class="headerlink" title="思路（优先使用递归）"></a>思路（优先使用递归）</h4><p>1 把方法定义为一个递归方法，确定方法的作用与返回值；</p><ul><li>方法作用：判断一个链表是否为回文链表；    返回值：true/false；</li></ul><p>2 确定递归的终止条件；</p><ul><li>链表为null/链表中只有一个节点；    这时候可以认为链表是一个回文链表</li></ul><p>3 确定本级递归要完成的事情；</p><ul><li>编码时再具体说明</li></ul><h4 id="把思路翻译成代码"><a href="#把思路翻译成代码" class="headerlink" title="把思路翻译成代码"></a>把思路翻译成代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ListNode类型的定义省略</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1 方法作用：判断一个链表是否为回文链表；返回值：true/false；</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 2 递归终结条件</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3 本级递归要做的事情</span></span><br><span class="line">        <span class="comment">// ① 把链表视为：链表头节点head + 中间节点组成的链表middle + 尾节点tail</span></span><br><span class="line">        <span class="comment">// ② 获取到head与tail，判断头节点与尾节点的值是否相等。如果不相等，返回false</span></span><br><span class="line">        <span class="comment">// ③ 如果相等，并且middle也是一个回文链表。则返回true，否则返回false</span></span><br><span class="line">        ListNode cursor = head;</span><br><span class="line">        <span class="keyword">while</span>(cursor.next != <span class="keyword">null</span>)&#123; <span class="comment">// 循环终止时，希望cursor指向尾节点，而不是null</span></span><br><span class="line">            cursor = cursor.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断头节点与尾节点的值是否相等</span></span><br><span class="line">        <span class="keyword">if</span>(head.val != cursor.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 获取到中间节点组成的链表middle</span></span><br><span class="line">            cursor = head.next;</span><br><span class="line">            ListNode middle = cursor;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 删除尾节点：这样其实破坏了原始的链表结构，需要和面试官确认</span></span><br><span class="line">            <span class="keyword">while</span>(cursor != <span class="keyword">null</span> &amp;&amp; cursor.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(cursor.next.next = <span class="keyword">null</span>)&#123;</span><br><span class="line">                    cursor.next = <span class="keyword">null</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cursor = cursor.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 判断middle是不是一个回文链表</span></span><br><span class="line">            <span class="keyword">return</span> isPalindrome(middle);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：这里获取到middle的过程还是差了点意思。</p><h4 id="添加鲁棒性的代码"><a href="#添加鲁棒性的代码" class="headerlink" title="添加鲁棒性的代码"></a>添加鲁棒性的代码</h4><h4 id="使用不同的测试用例测试"><a href="#使用不同的测试用例测试" class="headerlink" title="使用不同的测试用例测试"></a>使用不同的测试用例测试</h4><ul><li>功能性测试（各种极端情况下的有效输入）</li><li>非法输入测试（对各种非法输入是否进行了合适的处理）</li></ul><blockquote><p>until next time😄</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;判断一个链表是否为回文链表&quot;&gt;&lt;a href=&quot;#判断一个链表是否为回文链表&quot; class=&quot;headerlink&quot; title=&quot;判断一个链表是否为回文链表&quot;&gt;&lt;/a&gt;判断一个链表是否为回文链表&lt;/h3&gt;&lt;h4 id=&quot;题设与要求&quot;&gt;&lt;a href=&quot;#题设与要求&quot; class=&quot;headerlink&quot; title=&quot;题设与要求&quot;&gt;&lt;/a&gt;题设与要求&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/08/15/diX5I1.png&quot; alt=&quot;题设与要求&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="ListNode" scheme="https://henryinshanghai.github.io/categories/ListNode/"/>
    
    
    <category term="Algorithm" scheme="https://henryinshanghai.github.io/tags/Algorithm/"/>
    
    <category term="LinkedList" scheme="https://henryinshanghai.github.io/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>链表数相加_07</title>
    <link href="https://henryinshanghai.github.io/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E9%93%BE%E8%A1%A8%E8%A1%A8%E7%A4%BA%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%9B%B8%E5%8A%A0(%E8%BF%AD%E4%BB%A3%E6%96%B9%E5%BC%8F)_07.html"/>
    <id>https://henryinshanghai.github.io/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E9%93%BE%E8%A1%A8%E8%A1%A8%E7%A4%BA%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%9B%B8%E5%8A%A0(%E8%BF%AD%E4%BB%A3%E6%96%B9%E5%BC%8F)_07.html</id>
    <published>2020-08-16T09:30:00.000Z</published>
    <updated>2020-08-17T04:30:00.319Z</updated>
    
    <content type="html"><![CDATA[<h3 id="链表表示的两个数相加"><a href="#链表表示的两个数相加" class="headerlink" title="链表表示的两个数相加"></a>链表表示的两个数相加</h3><h4 id="题设与要求"><a href="#题设与要求" class="headerlink" title="题设与要求"></a>题设与要求</h4><p><img src="https://s1.ax1x.com/2020/08/14/diKVtx.md.png" alt="题目条件与要求"></p><a id="more"></a><h4 id="分析（面临的核心问题）"><a href="#分析（面临的核心问题）" class="headerlink" title="分析（面临的核心问题）"></a>分析（面临的核心问题）</h4><p>两个数的加法算法，主要的特征：</p><ul><li>从低位到高位计算（个十百千…）;</li><li>计算除了个位以外的位数上的数字时，都需要加上来自后一位的进位（如果没有进位数，默认为0）</li><li>位数上的数字 = （第一个数 + 第二个数 + 进位数）% 10；</li><li>当前位向高位数提供的进位数 = (第一个数 + 第二个数 + 进位数) / 10；</li><li>如果最高位计算时，有进位数。则直接把这个进位数作为加和结果的最高位；</li></ul><p>问题1：我们需要从低位向高位计算，对于链表来说，就是从链表尾节点到头节点计算。BUT，访问链表中的节点只能从头节点到尾节点。</p><p>怎么办？</p><p>解决手段：使用栈来存储链表各个节点中的值；</p><p>原理：链表这种数据容器的存储特征是“先进后出”——这样在从栈中取出数值时，获取到的其实就是链表尾部节点中的数值；</p><p>问题2：两个链表的长度可能不一样，如果在同一个循环中通过pop()来取值的话，肯定会有一个栈调用pop()时会抛出”栈为空”的异常；</p><p>解决手段：在调用isEmpty()结果为true时（表示栈已经空了），手动为操作数绑定0；</p><p>问题3：如果使用循环，在短链表中的节点用完后，如何保证循环继续进行（继续计算加和）？</p><p>手段：循环条件 = （链表A节点 != null || 链表B节点 != null);</p><p>问题4：即便使用长链表的节点数来控制循环次数（循环中执行操作数的计算），但是最高位在得到进位后，可能会再产生一个进位。这个进位要怎么处理？</p><p>手段：把进位carry !=0 添加到循环执行表达式中。这样上述情况下，循环会再执行一次(0 + 0 + 进位1) 的计算。计算后carry==0，循环退出，进位数也被作为最高位添加到链表中</p><h4 id="思路SOP"><a href="#思路SOP" class="headerlink" title="思路SOP"></a>思路SOP</h4><p>1 使用两个栈分别存储两个链表中的所有节点；</p><p>2 定义一个循环：</p><ul><li>从栈中弹出值进行计算。得到数位上的数与进位数；</li><li>把位数上的数封装到一个节点，并添加到链表中(使用头插法，即最新的节点总是头节点)； head - xxx - null</li></ul><p>3 循环结束后，循环中创建的链表就是加和结果；</p><h4 id="根据思路SOP来进行编码"><a href="#根据思路SOP来进行编码" class="headerlink" title="根据思路SOP来进行编码"></a>根据思路SOP来进行编码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ListNode类型的定义省略</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 鲁棒性代码</span></span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(l2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 定义两个栈</span></span><br><span class="line">        Stack&lt;Integer&gt; stack_l1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Stack&lt;Integer&gt; stack_l2 = <span class="keyword">new</span> Stack&lt;&gt;(); <span class="comment">// 作用：用于分别存储各个链表中的节点</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用栈来存储对应链表中的节点</span></span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack_l1.push(l1.val);</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack_l2.push(l2.val);</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 定义一个循环 循环中：1 得到位数上的数字； 2 使用1中的数字创建节点，并添加到新链表中</span></span><br><span class="line">        ListNode first = <span class="keyword">null</span>; </span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!stack_l1.isEmpty() || !stack_l2.isEmpty() || carry != <span class="number">0</span>)&#123; <span class="comment">// 循环执行条件:</span></span><br><span class="line">            <span class="comment">// 1 获取到操作数</span></span><br><span class="line">            <span class="keyword">int</span> num1 = stack_l1.isEmpty() ? <span class="number">0</span> : stack_l1.pop();</span><br><span class="line">            <span class="keyword">int</span> num2 = stack_l2.isEmpty() ? <span class="number">0</span> : stack_l2.pop();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 2 进行计算，得到数位上的数值remainder 与 进位数字carry</span></span><br><span class="line">            <span class="keyword">int</span> remainder = (num1 + num2 + carry) % <span class="number">10</span>;</span><br><span class="line">            carry = (num1 + num2 + carry) / <span class="number">10</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 3 使用数位上的数值来创建一个新的节点，并添加到first链表中</span></span><br><span class="line">            ListNode curr = <span class="keyword">new</span> ListNode(remainder);</span><br><span class="line">            curr.next = first;</span><br><span class="line">            first = curr;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回创建的新链表的头节点first</span></span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编码步骤分解"><a href="#编码步骤分解" class="headerlink" title="编码步骤分解"></a>编码步骤分解</h4><ul><li>定义两个栈，并把链表中节点的值添加到对应的栈中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;Integer&gt; stack_l1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">Stack&lt;Integer&gt; stack_l2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把链表节点中的值添加到栈中</span></span><br><span class="line"><span class="keyword">while</span>(l1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">    stack_l1.push(l1.val);</span><br><span class="line">    l1 = l1.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">    stack_l2.push(l2.val);</span><br><span class="line">    l2 = l2.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>定义一个循环 循环中：1 得到位数上的数字；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> carry = <span class="number">0</span>; <span class="comment">// 初始化进位数为0作用：用于个位数的计算</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    <span class="comment">// 1 从栈中获取到当前的操作数</span></span><br><span class="line">    <span class="keyword">int</span> num1 = stack_l1.isEmpty() ? <span class="number">0</span> : stack_l1.pop();</span><br><span class="line">    <span class="keyword">int</span> num2 = stack_l2.isEmpty() ? <span class="number">0</span> : stack_l2.pop();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2 计算操作数，得到位数上的数字</span></span><br><span class="line">    <span class="keyword">int</span> remainder = (num1 + num2 + carry) % <span class="number">10</span>;</span><br><span class="line">    carry = (num1 + num2 + carry) / <span class="number">10</span>; <span class="comment">// 这里需要计算出新的进位数，这样下次遍历时计算结果才能正确</span></span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>2 使用1中的数字创建节点，并添加到新链表中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">ListNode first = <span class="keyword">null</span>; <span class="comment">// 一个头节点作用：作为计算结果的链表容器；特征：头插法</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 头插法</span></span><br><span class="line">    <span class="comment">// 1 创建新节点</span></span><br><span class="line">    ListNode curr = <span class="keyword">new</span> ListNode(remainder);</span><br><span class="line">    <span class="comment">// 2 连接到first指针所指向的节点</span></span><br><span class="line">    curr.next = first;</span><br><span class="line">    <span class="comment">// 3 更新first指针</span></span><br><span class="line">    first = curr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>确定循环执行的表达式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由于栈中的每个数字都需要参与计算，所以最终两个栈要都为空</span></span><br><span class="line"><span class="comment">// 对应于表达式: !satck_l1.isEmpty() || !stack_l2.isEmpty()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最高位计算后，可能会有一个进位————这就要求循环体再执行一次，以便把新的进位添加到链表中。</span></span><br><span class="line"><span class="comment">// 进位添加到链表中后，需要对进位进行更新，以便终止循环</span></span><br><span class="line"><span class="comment">// 更新手段：现有代码 carry = (num1 + num2 + carry) / 10; // 这里需要计算出新的进位数，这样下次遍历时计算结果才能正确</span></span><br><span class="line"><span class="comment">// 此时，由于栈都已经空了。所以num1 = 0、num2 = 0、carry = 1（最高位的进位只会为1）</span></span><br><span class="line"><span class="comment">// 更新后carry的值 = 1 / 10; carry = 0</span></span><br><span class="line"><span class="comment">// 从而应该添加新的条件：carry != 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 综上有：循环执行表达式(!stack_l1.isEmpty() || !stack_l2.isEmpty() || carry != 0)</span></span><br><span class="line"><span class="keyword">while</span>(!stack_l1.isEmpty() || !stack_l2.isEmpty() || carry != <span class="number">0</span>)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>返回循环中创建的链表的头节点</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> first;</span><br></pre></td></tr></table></figure><ul><li>添加鲁棒性代码（或者叫防御性编程代码）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 鲁棒性代码</span></span><br><span class="line"><span class="keyword">if</span>(l1 == <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> l2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(l2 == <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> l1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用设计的测试用例进行功能测试 &amp; 非法输出测试</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 作用：</span></span><br><span class="line"><span class="comment">// 1 保证代码涵对所有可能的合法输入都有效；</span></span><br><span class="line"><span class="comment">// 2 保证对那些个非法输入，代码都做了合适的处理————不会导致程序崩溃；</span></span><br></pre></td></tr></table></figure><blockquote><p> this is whole loads of thing. until next time 😄</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;链表表示的两个数相加&quot;&gt;&lt;a href=&quot;#链表表示的两个数相加&quot; class=&quot;headerlink&quot; title=&quot;链表表示的两个数相加&quot;&gt;&lt;/a&gt;链表表示的两个数相加&lt;/h3&gt;&lt;h4 id=&quot;题设与要求&quot;&gt;&lt;a href=&quot;#题设与要求&quot; class=&quot;headerlink&quot; title=&quot;题设与要求&quot;&gt;&lt;/a&gt;题设与要求&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/08/14/diKVtx.md.png&quot; alt=&quot;题目条件与要求&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="ListNode" scheme="https://henryinshanghai.github.io/categories/ListNode/"/>
    
    
    <category term="Algorithm" scheme="https://henryinshanghai.github.io/tags/Algorithm/"/>
    
    <category term="LinkedList" scheme="https://henryinshanghai.github.io/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>交换链表节点_06_2</title>
    <link href="https://henryinshanghai.github.io/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9%EF%BC%88%E9%80%92%E5%BD%92%E6%96%B9%E5%BC%8F%EF%BC%89_06_2.html"/>
    <id>https://henryinshanghai.github.io/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9%EF%BC%88%E9%80%92%E5%BD%92%E6%96%B9%E5%BC%8F%EF%BC%89_06_2.html</id>
    <published>2020-08-16T09:00:00.000Z</published>
    <updated>2020-08-17T04:32:29.123Z</updated>
    
    <content type="html"><![CDATA[<h4 id="两两交换链表中的节点（递归方式）"><a href="#两两交换链表中的节点（递归方式）" class="headerlink" title="两两交换链表中的节点（递归方式）"></a>两两交换链表中的节点（递归方式）</h4><hr><h4 id="题设与要求"><a href="#题设与要求" class="headerlink" title="题设与要求"></a>题设与要求</h4><p><img src="https://s1.ax1x.com/2020/08/14/dPzGHH.md.png" alt="题设与要求"></p><a id="more"></a><h4 id="分析（递归的可行性）"><a href="#分析（递归的可行性）" class="headerlink" title="分析（递归的可行性）"></a>分析（递归的可行性）</h4><ul><li>问题能够拆解成更小的同类问题吗？<ul><li>答：对链表来说，总是可以把链表拆分成: 头节点head + 剩余节点组成的rest链表（这个链表还可以根据情况再去拆分）</li></ul></li><li>更小同类问题的返回值能够用来帮助解决大问题本身吗？<ul><li>答：对rest执行swapParis操作后，返回的是一个节点已经两两交换后的新链表。它可以和剩余的节点连接起来，从而得到一个所有节点都已经两两交换的新链表——大问题；</li></ul></li></ul><p>结论：这个问题可以使用递归进行解决；</p><h4 id="使用递归实现的SOP"><a href="#使用递归实现的SOP" class="headerlink" title="使用递归实现的SOP"></a>使用递归实现的SOP</h4><ul><li>1 明确方法的作用与返回值；</li><li>2 明确递归的终结条件（根据方法的作用推理）；</li><li>3 描述本次递归需要完成的工作</li></ul><h4 id="按照SOP进行编码"><a href="#按照SOP进行编码" class="headerlink" title="按照SOP进行编码"></a>按照SOP进行编码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 方法作用：把链表中的节点两两进行交换，并返回节点交换后的新链表参考：示例</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">swapParis</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 2 递归的终结条件 链表为null、链表中就只有一个节点</span></span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3 本级递归需要完成的事情</span></span><br><span class="line">    <span class="comment">// ① 把链表拆分为：头节点head + 第二个节点second + 剩余节点组成的链表rest</span></span><br><span class="line">    <span class="comment">// 原因：交换节点需要至少两个节点参与，而且我们不能改变swapPair(rest)的返回值</span></span><br><span class="line">    <span class="comment">// ② 对rest执行swapParis()的操作，并获取到返回值swapedRest</span></span><br><span class="line">    <span class="comment">// ③ 对head、second以及swapedRest进行必要的操作，以得到所有节点都已经两两交换的链表</span></span><br><span class="line">    ListNode second = head.next;</span><br><span class="line">    ListNode swapedRest = swapPairs(second.next);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 交换head与second节点</span></span><br><span class="line">    head.next = swapedRest;</span><br><span class="line">    second.next = head;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>启示</p></blockquote><p>递归大法好，不像递归那样。循环终止条件就能让人💫</p><blockquote><p>until next time😄</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;两两交换链表中的节点（递归方式）&quot;&gt;&lt;a href=&quot;#两两交换链表中的节点（递归方式）&quot; class=&quot;headerlink&quot; title=&quot;两两交换链表中的节点（递归方式）&quot;&gt;&lt;/a&gt;两两交换链表中的节点（递归方式）&lt;/h4&gt;&lt;hr&gt;
&lt;h4 id=&quot;题设与要求&quot;&gt;&lt;a href=&quot;#题设与要求&quot; class=&quot;headerlink&quot; title=&quot;题设与要求&quot;&gt;&lt;/a&gt;题设与要求&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/08/14/dPzGHH.md.png&quot; alt=&quot;题设与要求&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="ListNode" scheme="https://henryinshanghai.github.io/categories/ListNode/"/>
    
    
    <category term="Algorithm" scheme="https://henryinshanghai.github.io/tags/Algorithm/"/>
    
    <category term="LinkedList" scheme="https://henryinshanghai.github.io/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>倒数第k个节点_05_2</title>
    <link href="https://henryinshanghai.github.io/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E8%8A%82%E7%82%B9%EF%BC%88%E4%B8%80%E6%AC%A1%E9%81%8D%E5%8E%86%EF%BC%89_05_2.html"/>
    <id>https://henryinshanghai.github.io/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E8%8A%82%E7%82%B9%EF%BC%88%E4%B8%80%E6%AC%A1%E9%81%8D%E5%8E%86%EF%BC%89_05_2.html</id>
    <published>2020-08-16T08:30:00.000Z</published>
    <updated>2020-08-17T09:12:44.211Z</updated>
    
    <content type="html"><![CDATA[<h3 id="删除链表中的倒数第n个节点（一次遍历）"><a href="#删除链表中的倒数第n个节点（一次遍历）" class="headerlink" title="删除链表中的倒数第n个节点（一次遍历）"></a>删除链表中的倒数第n个节点（一次遍历）</h3><h4 id="题设-amp-要求"><a href="#题设-amp-要求" class="headerlink" title="题设 &amp; 要求"></a>题设 &amp; 要求</h4><p><img src="https://s1.ax1x.com/2020/08/14/dCLxyj.png" alt="题设 &amp; 要求"></p><a id="more"></a><h4 id="分析（难点）"><a href="#分析（难点）" class="headerlink" title="分析（难点）"></a>分析（难点）</h4><p>如何能找到倒数第N个节点（预期节点：此节点的上一个节点）？</p><h4 id="思路2（难点的解决方案）"><a href="#思路2（难点的解决方案）" class="headerlink" title="思路2（难点的解决方案）"></a>思路2（难点的解决方案）</h4><ul><li>定义两个指针front与back，设置两个指针之间的初始间距。</li><li>然后把两个指针同时向后移动，直到front指针到达了链表的尾节点。</li><li>这时候back指针就会指在某一个可以计算的位置——通过设置指针间的初始间距，就能确定back指针停下的具体位置。</li></ul><h4 id="实现SOP"><a href="#实现SOP" class="headerlink" title="实现SOP"></a>实现SOP</h4><ul><li>1 定义所需要的指针front与back与dummy（并初始化）；    注：画图分析指针初始化的位置；    原则：方便编码；&amp; 避免NPE；</li><li>2 画图分析，front指针与back指针之间的初始间距span与n的关系（span = n）；</li><li>3 把front与back指针初始化指向dummy节点(这里引入dummy节点只是为了方便计算指针应该移动的距离)；</li><li>4 把front指针向前移动n个节点；</li><li>5 把front与back指针同时向后移动，直到front指针指向链表的尾节点；</li><li>6 back指向预期节点后，对待删除节点进行删除；</li></ul><h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 实践证明：在删除的时候使用栈不是一个好主意</span></span><br><span class="line">        <span class="comment">// 鲁棒性代码</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 需要的实例变量</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line"></span><br><span class="line">        ListNode front = dummy;</span><br><span class="line">        ListNode back = dummy;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 先让front向前走n个节点   如果只有一个节点，然后要删除倒数第一个节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123; <span class="comment">// 注：front的初始化值会决定循环执行的次数</span></span><br><span class="line">            front = front.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 再让front与back一起先前移动，直到front到达尾节点</span></span><br><span class="line">        <span class="keyword">while</span>(front != <span class="keyword">null</span> &amp;&amp; front.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            front = front.next;</span><br><span class="line">            back = back.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 这里得到的back就是预期删除的节点的前一个节点</span></span><br><span class="line">        <span class="comment">// 执行删除</span></span><br><span class="line">        back.next = back.next.next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="启示"><a href="#启示" class="headerlink" title="启示"></a>启示</h4><p>1 代码的鲁棒性编码在实现了基本功能后，再进行添加；</p><p>2 对于循环执行次数已知的情况，使用for语法来实现循环——这样能避免令人纠结的循环执行/终止条件；</p><p>3 编写while循环执行表达式的参考：节点的最终状态； &amp;  避免代码中的NPE；</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;删除链表中的倒数第n个节点（一次遍历）&quot;&gt;&lt;a href=&quot;#删除链表中的倒数第n个节点（一次遍历）&quot; class=&quot;headerlink&quot; title=&quot;删除链表中的倒数第n个节点（一次遍历）&quot;&gt;&lt;/a&gt;删除链表中的倒数第n个节点（一次遍历）&lt;/h3&gt;&lt;h4 id=&quot;题设-amp-要求&quot;&gt;&lt;a href=&quot;#题设-amp-要求&quot; class=&quot;headerlink&quot; title=&quot;题设 &amp;amp; 要求&quot;&gt;&lt;/a&gt;题设 &amp;amp; 要求&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/08/14/dCLxyj.png&quot; alt=&quot;题设 &amp;amp; 要求&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="ListNode" scheme="https://henryinshanghai.github.io/categories/ListNode/"/>
    
    
    <category term="Algorithm" scheme="https://henryinshanghai.github.io/tags/Algorithm/"/>
    
    <category term="LinkedList" scheme="https://henryinshanghai.github.io/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>交换链表节点(迭代)_06</title>
    <link href="https://henryinshanghai.github.io/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9(%E8%BF%AD%E4%BB%A3%E6%96%B9%E5%BC%8F)_06.html"/>
    <id>https://henryinshanghai.github.io/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9(%E8%BF%AD%E4%BB%A3%E6%96%B9%E5%BC%8F)_06.html</id>
    <published>2020-08-16T08:30:00.000Z</published>
    <updated>2020-08-17T09:20:48.898Z</updated>
    
    <content type="html"><![CDATA[<h3 id="两两交换链表中的节点"><a href="#两两交换链表中的节点" class="headerlink" title="两两交换链表中的节点"></a>两两交换链表中的节点</h3><hr><h4 id="题设与要求"><a href="#题设与要求" class="headerlink" title="题设与要求"></a>题设与要求</h4><p><img src="https://s1.ax1x.com/2020/08/14/dP37xf.png" alt="题设与要求"></p><a id="more"></a><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>要求进行节点之间的两两交换。</p><p>如果使用迭代的方式，可以每次处理两个相邻节点之间的连接关系；</p><p>然后在下次迭代时，再去处理下一批的两个节点之间的连接关系；</p><p>还要处理每个区间（2个节点）之间的连接关系，来保证连接的正确性；</p><p>说明：</p><p>1 当通过这种分析无法得到有效的突破点时，就只好画图来找找规律了，对自己的想象力不要太自信；</p><p>2 翻转操作需要3个指针：两个指针用于指向需要交换的节点，一个指针用于迭代链表；</p><blockquote><p>画图大法(画图找规律)</p></blockquote><p><img src="https://s1.ax1x.com/2020/08/14/dPU7kD.md.jpg" alt="节点的交换过程"></p><ul><li>通过画图可以看出,可以通过连续翻转节点来实现题设中的“两两节点交换”；</li><li>节点翻转需要3个指针：curr指向当前节点、temp指向当前节点的下一个节点；prev指向当前节点的前驱节点（用于更新这三个连续的指针）</li><li>可以根据预期的指针情况（图3）与当前的指针情况（图2）来推理出指针更新的手段；prev = curr;</li></ul><h4 id="代码实现的SOP："><a href="#代码实现的SOP：" class="headerlink" title="代码实现的SOP："></a>代码实现的SOP：</h4><p>1 定义所需要的指针，并初始化指针的原始位置；</p><p>2 定义一个循环，在循环中完成以下工作：</p><ul><li>对指针指向的当前节点区间进行翻转；</li><li>更新指针，以便进行下一次的翻转操作；</li></ul><h4 id="代码实现（虽然SOP不复杂，但是代码实现还是挺讲究的）"><a href="#代码实现（虽然SOP不复杂，但是代码实现还是挺讲究的）" class="headerlink" title="代码实现（虽然SOP不复杂，但是代码实现还是挺讲究的）"></a>代码实现（虽然SOP不复杂，但是代码实现还是挺讲究的）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1 定义需要的指针</span></span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>); <span class="comment">// 作用：指向链表的头节点</span></span><br><span class="line">    dummy.next = head;</span><br><span class="line">    </span><br><span class="line">    ListNode prev = dummy; <span class="comment">// </span></span><br><span class="line">    ListNode curr = head;</span><br><span class="line">    <span class="comment">// ListNode temp = curr.next; // 有点不对劲，因为temp都是在遍历过程中临时更新的参考：翻转链表的操作</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2 定义一个循环，在循环中： 1 完成当前区间内节点的翻转； 2 更新到下一个翻转区间</span></span><br><span class="line">    <span class="keyword">while</span>(curr != <span class="keyword">null</span> &amp;&amp; curr.next != <span class="keyword">null</span>)&#123; <span class="comment">// 循环终止条件：curr == null(对应于奇数个节点) OR curr.next == null (对应于偶数个节点)</span></span><br><span class="line">        <span class="comment">// 1 获取到当前节点的下一个节点 [curr-temp]</span></span><br><span class="line">        ListNode temp = curr.next;</span><br><span class="line">        </span><br><span class="line">         <span class="comment">// 2 完成当前区间内节点的翻转(需要借助temp节点才能实现)</span></span><br><span class="line">        prev.next = temp;</span><br><span class="line">        curr.next = temp.next;</span><br><span class="line">        temp.next = curr;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3 更新到下一个翻转区间[prev-curr]</span></span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = prev.next;</span><br><span class="line">        <span class="comment">// temp = curr.next;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3 返回链表的头节点</span></span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代码实现过程SOP分解"><a href="#代码实现过程SOP分解" class="headerlink" title="代码实现过程SOP分解"></a>代码实现过程SOP分解</h4><ul><li>定义所需要的指针</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">dummy.next = head;<span class="comment">// 作用：指向链表的头节点</span></span><br><span class="line"></span><br><span class="line">ListNode prev = dummy; <span class="comment">// 作用：翻转区间内的第一个节点</span></span><br><span class="line">ListNode curr = prev.next; <span class="comment">// 作用：翻转区间内的第二个节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 所需要的辅助节点temp（当前节点的下一个节点），在循环中再临时获取</span></span><br></pre></td></tr></table></figure><ul><li>定义一个循环，在循环中完成<ul><li>当前节点区间的节点翻转；</li><li>更新当前节点区间；</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    <span class="comment">// 对当前节点区间中的节点进行翻转</span></span><br><span class="line">    <span class="comment">// ① 获取到当前节点的下一个节点作用：防止链表断裂</span></span><br><span class="line">    ListNode temp = curr.next;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ② 按照下图流程来实现节点的翻转参考：👇图</span></span><br><span class="line">    prev.next = temp; </span><br><span class="line">    curr.next = temp.next;</span><br><span class="line">    temp.next = curr;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更新当前的区间节点</span></span><br><span class="line">    prev = curr; <span class="comment">// 更新后的翻转区间第一个节点 参考：“分析”部分</span></span><br><span class="line">    curr = prev.next; <span class="comment">// 更新后的翻转区间第二个节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2020/08/14/dPLV7q.md.jpg" alt="节点翻转流程"></p><ul><li><p>确定循环执行的条件</p><ul><li>循环终止条件（直接根据代码不能NPE来反推）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ListNode temp = curr.next;<span class="comment">// 因此curr != null</span></span><br><span class="line">...</span><br><span class="line">curr.next = temp.next; <span class="comment">// 因此temp != null aka curr.next != null</span></span><br></pre></td></tr></table></figure><p>r u kidding me?</p><ul><li>循环终止条件（极端情况）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 极端情况：prev为倒数第二个节点、curr为尾节点 此时需要翻转prev与curr之间的指向</span></span><br><span class="line"><span class="comment">// 特征:curr.next == null aka 循环执行条件 curr.next != null</span></span><br><span class="line"><span class="comment">// 为了避免循环中的更新操作导致curr为null SO</span></span><br><span class="line"><span class="keyword">while</span>(curr != <span class="keyword">null</span> &amp;&amp; curr.next != <span class="keyword">null</span>)</span><br></pre></td></tr></table></figure><p>不很满意这种说法😳</p></li><li><p>返回新链表的头节点</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由于每个节点都只有一个next指针，所以dummy其实连接到了新的链表头部</span></span><br><span class="line"><span class="keyword">return</span> dummy.next;</span><br></pre></td></tr></table></figure><ul><li>添加鲁棒性代码</li><li>编写各种测试用例，测试代码：1 功能是否可用； 2 对于各种非法输出是否有合理的输出/提示信息；</li></ul><h4 id="代码默写-重现"><a href="#代码默写-重现" class="headerlink" title="代码默写/重现"></a>代码默写/重现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1 定义需要用到的指针</span></span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    dummy.next = head; <span class="comment">// 指向链表的头节点</span></span><br><span class="line">    </span><br><span class="line">    ListNode prev = dummy; <span class="comment">// 翻转区间的第一个节点</span></span><br><span class="line">    ListNode curr = prev.next; <span class="comment">// 翻转区间的第二个节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(curr != <span class="keyword">null</span> &amp;&amp; curr.next != <span class="keyword">null</span>)&#123; <span class="comment">// 烦人的循环执行条件</span></span><br><span class="line">        <span class="comment">// 翻转区间中节点的指向</span></span><br><span class="line">        ListNode temp = curr.next;</span><br><span class="line">        </span><br><span class="line">        prev.next = temp;</span><br><span class="line">        curr.next = temp.next;</span><br><span class="line">        temp.next = curr;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 更新翻转区间</span></span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = curr.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>until next time 😄</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;两两交换链表中的节点&quot;&gt;&lt;a href=&quot;#两两交换链表中的节点&quot; class=&quot;headerlink&quot; title=&quot;两两交换链表中的节点&quot;&gt;&lt;/a&gt;两两交换链表中的节点&lt;/h3&gt;&lt;hr&gt;
&lt;h4 id=&quot;题设与要求&quot;&gt;&lt;a href=&quot;#题设与要求&quot; class=&quot;headerlink&quot; title=&quot;题设与要求&quot;&gt;&lt;/a&gt;题设与要求&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/08/14/dP37xf.png&quot; alt=&quot;题设与要求&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="ListNode" scheme="https://henryinshanghai.github.io/categories/ListNode/"/>
    
    
    <category term="Algorithm" scheme="https://henryinshanghai.github.io/tags/Algorithm/"/>
    
    <category term="LinkedList" scheme="https://henryinshanghai.github.io/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>倒数第k个节点_05</title>
    <link href="https://henryinshanghai.github.io/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9(%E4%B8%A4%E6%AC%A1%E9%81%8D%E5%8E%86)_05.html"/>
    <id>https://henryinshanghai.github.io/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9(%E4%B8%A4%E6%AC%A1%E9%81%8D%E5%8E%86)_05.html</id>
    <published>2020-08-16T08:00:00.000Z</published>
    <updated>2020-08-17T09:13:15.746Z</updated>
    
    <content type="html"><![CDATA[<h3 id="删除链表中的倒数第N个节点"><a href="#删除链表中的倒数第N个节点" class="headerlink" title="删除链表中的倒数第N个节点"></a>删除链表中的倒数第N个节点</h3><h4 id="分析（找到问题的难点）："><a href="#分析（找到问题的难点）：" class="headerlink" title="分析（找到问题的难点）："></a>分析（找到问题的难点）：</h4><ul><li>对于单向链表，只能从前往后地查找节点；</li><li>删除链表节点的常用手段: curr.next = curr.next.next; // 这样就能把curr后面的一个节点从链表中删除掉</li></ul><a id="more"></a><h4 id="思路（解决问题难点）："><a href="#思路（解决问题难点）：" class="headerlink" title="思路（解决问题难点）："></a>思路（解决问题难点）：</h4><p>如果链表的长度已知，就能通过公式（length - N）来求出待删除节点的正向位置。这样就可以执行删除操作了</p><p>可能犯错的地方：找错了节点；</p><p>根据分析的第二点，我们应该找到的是待删除节点的上一个节点（预期节点）；</p><h4 id="实现SOP"><a href="#实现SOP" class="headerlink" title="实现SOP:"></a>实现SOP:</h4><ul><li>1 先计算出链表中的节点的总长度；</li><li>2 根据公式(length - N)计算出待删除节点的正向位置索引；</li><li>3 找到预期节点，然后删除“待删除的节点”；</li></ul><h4 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ListNode类型的定义省略</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 0 鲁棒性代码</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1 定义需要的指针</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>); <span class="comment">// 备用</span></span><br><span class="line">        dummy.next = head;</span><br><span class="line">        </span><br><span class="line">        ListNode cursor = head;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2 计算链表中节点的总长度</span></span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cursor != <span class="keyword">null</span>)&#123;</span><br><span class="line">            length++;</span><br><span class="line">            cursor = cursor.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3 计算预期节点的位置</span></span><br><span class="line">        <span class="keyword">int</span> expect_postion = length - n;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4 通过迭代的方式找到预期节点</span></span><br><span class="line">        cursor = head; <span class="comment">// 把游标拨回链表头节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i &lt; expect_position; i++)&#123;</span><br><span class="line">            cursor = cursor.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 5 找到预取节点后，对待删除节点执行删除操作</span></span><br><span class="line">        cursor.next = cursor.next.next; <span class="comment">// 由于题设已经保证n是有效的，所以这里不会出现NPE</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 6 返回删除节点后的链表</span></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="添加鲁棒性代码"><a href="#添加鲁棒性代码" class="headerlink" title="添加鲁棒性代码"></a>添加鲁棒性代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">参考 <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><h4 id="算法特征"><a href="#算法特征" class="headerlink" title="算法特征"></a>算法特征</h4><p>1 需要两次遍历：第一次遍历用来计算链表中的节点总长度；第二次遍历用来找到“预期的节点”，以便执行删除</p><h4 id="优化（只需要进行一次遍历）"><a href="#优化（只需要进行一次遍历）" class="headerlink" title="优化（只需要进行一次遍历）"></a>优化（只需要进行一次遍历）</h4><p>原理：通过前后指针来找到预期位置，而不是用（length - N）的方式。</p><blockquote><p>until NEXT time 😄</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;删除链表中的倒数第N个节点&quot;&gt;&lt;a href=&quot;#删除链表中的倒数第N个节点&quot; class=&quot;headerlink&quot; title=&quot;删除链表中的倒数第N个节点&quot;&gt;&lt;/a&gt;删除链表中的倒数第N个节点&lt;/h3&gt;&lt;h4 id=&quot;分析（找到问题的难点）：&quot;&gt;&lt;a href=&quot;#分析（找到问题的难点）：&quot; class=&quot;headerlink&quot; title=&quot;分析（找到问题的难点）：&quot;&gt;&lt;/a&gt;分析（找到问题的难点）：&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;对于单向链表，只能从前往后地查找节点；&lt;/li&gt;
&lt;li&gt;删除链表节点的常用手段: curr.next = curr.next.next; // 这样就能把curr后面的一个节点从链表中删除掉&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="ListNode" scheme="https://henryinshanghai.github.io/categories/ListNode/"/>
    
    
    <category term="Algorithm" scheme="https://henryinshanghai.github.io/tags/Algorithm/"/>
    
    <category term="LinkedList" scheme="https://henryinshanghai.github.io/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>链表去重_04_2</title>
    <link href="https://henryinshanghai.github.io/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%EF%BC%88%E9%80%92%E5%BD%92%E6%96%B9%E5%BC%8F%EF%BC%89_04_2.html"/>
    <id>https://henryinshanghai.github.io/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%EF%BC%88%E9%80%92%E5%BD%92%E6%96%B9%E5%BC%8F%EF%BC%89_04_2.html</id>
    <published>2020-08-16T07:30:00.000Z</published>
    <updated>2020-08-17T09:14:16.178Z</updated>
    
    <content type="html"><![CDATA[<h3 id="删除有序链表中的重复元素（递归方式）"><a href="#删除有序链表中的重复元素（递归方式）" class="headerlink" title="删除有序链表中的重复元素（递归方式）"></a>删除有序链表中的重复元素（递归方式）</h3><h4 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h4><p><img src="https://s1.ax1x.com/2020/08/14/dCTVln.png" alt="题设与要求"></p><a id="more"></a><h4 id="分析（确定思路）"><a href="#分析（确定思路）" class="headerlink" title="分析（确定思路）"></a>分析（确定思路）</h4><ul><li><p>使用递归的可行性；</p><ul><li>问题能够被分解为规模更小的问题吗？</li></ul><p>答：可以。手段：把链表视为：头节点head + 剩余节点组成的链表rest;</p><ul><li>可以在更小的问题上应用当前操作，并用它的返回值来帮助解决大问题吗？</li></ul><p>答：可以。对递归调用的返回值做一些额外的处理，就能得到整个链表删除重复元素之后的结果。</p></li></ul><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> val)&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1 递归方法的作用：删除链表中的重复元素并返回更新后的链表/头节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 2 递归终结条件 链表为空 OR 链表中就只有一个节点</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3 本级递归需要做的事情</span></span><br><span class="line">        <span class="comment">// ① 把链表视为：头节点head + 剩余节点构成的链表rest；</span></span><br><span class="line">        <span class="comment">// ② 对rest链表执行删除重复节点的操作（假设已经有一个功能可用的API）；</span></span><br><span class="line">        <span class="comment">// ③ 对返回值进行必要的处理</span></span><br><span class="line">        ListNode rest = deleteDuplicates(head.next); <span class="comment">// ② </span></span><br><span class="line">        <span class="keyword">if</span>(head.val == rest.val)&#123; <span class="comment">// 头节点的值与rest头节点的值相等... 重复了</span></span><br><span class="line">             <span class="comment">// 更新head指针</span></span><br><span class="line">             head = rest;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 把rest连接到head上</span></span><br><span class="line">            head.next = rest;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回新链表的头节点</span></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代码实现步骤SOP分解"><a href="#代码实现步骤SOP分解" class="headerlink" title="代码实现步骤SOP分解"></a>代码实现步骤SOP分解</h4><ul><li>确定递归的可行性</li><li>确定递归方法的作用与返回值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 递归方法的作用：删除链表中的重复元素并返回更新后的链表/头节点</span></span><br></pre></td></tr></table></figure><ul><li>确定递归方法的终结条件</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2 递归终结条件 链表为空 OR 链表中就只有一个节点</span></span><br><span class="line"><span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br></pre></td></tr></table></figure><ul><li>确定本级递归需要完成的事情</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3 本级递归需要做的事情</span></span><br><span class="line"><span class="comment">// ① 把链表视为：头节点head + 剩余节点构成的链表rest；</span></span><br><span class="line"><span class="comment">// ② 对rest链表执行删除重复节点的操作（假设已经有一个功能可用的API）；</span></span><br><span class="line"><span class="comment">// ③ 对返回值进行必要的处理</span></span><br><span class="line">ListNode rest = deleteDuplicates(head.next); <span class="comment">// ② </span></span><br><span class="line"><span class="keyword">if</span>(head.val == rest.val)&#123; <span class="comment">// 头节点的值与rest头节点的值相等... 重复了</span></span><br><span class="line">    <span class="comment">// 更新head指针</span></span><br><span class="line">    head = rest;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 把rest连接到head上</span></span><br><span class="line">    head.next = rest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>返回正确链表的头指针（最好画图确认）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回新链表的头节点</span></span><br><span class="line"><span class="keyword">return</span> head;</span><br></pre></td></tr></table></figure><h4 id="启示"><a href="#启示" class="headerlink" title="启示"></a>启示</h4><p>在分析递归可行的情况下，对递归调用的返回值还需要进一步处理。</p><p>基本的原则是：使用递归调用的返回值来解决本级递归所需要解决的问题；</p><blockquote><p>until next time 😄</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;删除有序链表中的重复元素（递归方式）&quot;&gt;&lt;a href=&quot;#删除有序链表中的重复元素（递归方式）&quot; class=&quot;headerlink&quot; title=&quot;删除有序链表中的重复元素（递归方式）&quot;&gt;&lt;/a&gt;删除有序链表中的重复元素（递归方式）&lt;/h3&gt;&lt;h4 id=&quot;题目要求&quot;&gt;&lt;a href=&quot;#题目要求&quot; class=&quot;headerlink&quot; title=&quot;题目要求&quot;&gt;&lt;/a&gt;题目要求&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/08/14/dCTVln.png&quot; alt=&quot;题设与要求&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="ListNode" scheme="https://henryinshanghai.github.io/categories/ListNode/"/>
    
    
    <category term="Algorithm" scheme="https://henryinshanghai.github.io/tags/Algorithm/"/>
    
    <category term="LinkedList" scheme="https://henryinshanghai.github.io/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>链表去重_04</title>
    <link href="https://henryinshanghai.github.io/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0(%E8%BF%AD%E4%BB%A3%E6%96%B9%E5%BC%8F)_04.html"/>
    <id>https://henryinshanghai.github.io/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0(%E8%BF%AD%E4%BB%A3%E6%96%B9%E5%BC%8F)_04.html</id>
    <published>2020-08-16T07:00:00.000Z</published>
    <updated>2020-08-17T09:15:13.257Z</updated>
    
    <content type="html"><![CDATA[<h3 id="删除排序链表中的重复元素"><a href="#删除排序链表中的重复元素" class="headerlink" title="删除排序链表中的重复元素"></a>删除排序链表中的重复元素</h3><hr><h4 id="题目要求："><a href="#题目要求：" class="headerlink" title="题目要求："></a>题目要求：</h4><p><img src="https://s1.ax1x.com/2020/08/14/dCy9C8.png" alt="题目要求"></p><p><img src="https://s1.ax1x.com/2020/08/14/dCguPP.png" alt="测试用例示例"></p><a id="more"></a><h4 id="题设分析："><a href="#题设分析：" class="headerlink" title="题设分析："></a>题设分析：</h4><ul><li>1 链表已经是有序的了，aka，重复的元素会相邻在一起；</li><li>2 删除元素时，只需要删除重复多次的部分，使元素只会出现一次；</li></ul><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>最直观的方式：</p><ul><li>遍历整个链表，逐个比较当前节点curr与当前节点的下一个节点next的值。</li><li>如果curr.val == next.val,就想办法删除掉当前节点；</li><li>如果不相等，就更新curr指针，以便迭代下一个节点；</li></ul><h4 id="代码实现的SOP"><a href="#代码实现的SOP" class="headerlink" title="代码实现的SOP"></a>代码实现的SOP</h4><ul><li>创建一个指针curr，初始化为链表的头节点head；    作用：用于迭代链表；</li><li>创建一个指针dummy,初始化为null； 作用：用于指向链表的头节点，方便返回更新后的链表；</li><li>循环链表中的每一个节点，判断节点是否是重复节点；<ul><li>如果是，删除此节点；</li><li>如果不是，继续执行循环，直到所有节点都已经被遍历了</li></ul></li></ul><h4 id="完整的代码实现"><a href="#完整的代码实现" class="headerlink" title="完整的代码实现"></a>完整的代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    </span><br><span class="line">    ListNode(<span class="keyword">int</span> val)&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 1 定义需要的指针</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        </span><br><span class="line">        ListNode curr = head;</span><br><span class="line">        <span class="comment">// 2 遍历链表中的每一个节点，判断是否为重复节点，并执行相应的操作</span></span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="keyword">null</span> &amp;&amp; curr.next != <span class="keyword">null</span>)&#123; <span class="comment">// 循环执行条件：当前节点与当前节点的下一个节点都不为null根据画图的边界条件推导 并使用代码中可能的NPE来验证</span></span><br><span class="line">            <span class="keyword">if</span>(curr.val == curr.next.val)&#123;</span><br><span class="line">                curr.next = curr.next.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                curr = curr.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3 遍历完成后，返回新链表的头节点</span></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="实现过程SOP"><a href="#实现过程SOP" class="headerlink" title="实现过程SOP"></a>实现过程SOP</h4><ul><li><p>定义需要的指针</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 定义需要的指针</span></span><br><span class="line">ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">dummy.next = head; <span class="comment">// dummy指针作用：指向链表的头节点，方便无脑地返回链表的头节点</span></span><br><span class="line"></span><br><span class="line">ListNode curr = head; <span class="comment">// 作用：在链表中遍历所有节点（结合循环）</span></span><br></pre></td></tr></table></figure></li><li><p>定义一个循环，在循环中执行判重与删除操作 &amp; 迭代链表的操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(curr.val == curr.next.val)&#123; <span class="comment">// 判重</span></span><br><span class="line">        <span class="comment">// 删除</span></span><br><span class="line">        curr.next = curr.next.next; <span class="comment">// 把当前节点连接到下下个节点上</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        curr = curr.next; <span class="comment">// 更新指针作用：实现遍历链表</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>确定循环()表达式的内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 临界情况：比较倒数第一与倒数第二个节点，判断倒数第一个节点是否需要删除</span></span><br><span class="line"><span class="comment">// curr为倒数第二个节点，curr.next为倒数第一个节点</span></span><br><span class="line"><span class="comment">// 为了循环能够正常执行，要求两个节点均不为null</span></span><br><span class="line"><span class="keyword">while</span>(curr != <span class="keyword">null</span> &amp;&amp; curr.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>确定方法的返回值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由于定义了指向原始链表头节点的指针dummy,而且没有改变链表中的连接方向，SO</span></span><br><span class="line"><span class="keyword">return</span> dummy.next; <span class="comment">// 直接返回dummy的下一个节点 aka 链表的头节点</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="代码重现"><a href="#代码重现" class="headerlink" title="代码重现"></a>代码重现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicats</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1 定义所需要的指针</span></span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    dummy.next = head;</span><br><span class="line">    </span><br><span class="line">    ListNode curr = dummy;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2 迭代链表中的节点，并完成必要的操作</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(curr.val == curr.next.val)&#123;</span><br><span class="line">            curr.next = curr.next.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 这里必须要有else字句，因为链表中可能出现连续重复的节点</span></span><br><span class="line">            <span class="comment">// 更新指针指向下一个节点</span></span><br><span class="line">            curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3 返回更新后的节点</span></span><br><span class="line">    <span class="keyword">return</span> dummy.next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>until next time 😄</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;删除排序链表中的重复元素&quot;&gt;&lt;a href=&quot;#删除排序链表中的重复元素&quot; class=&quot;headerlink&quot; title=&quot;删除排序链表中的重复元素&quot;&gt;&lt;/a&gt;删除排序链表中的重复元素&lt;/h3&gt;&lt;hr&gt;
&lt;h4 id=&quot;题目要求：&quot;&gt;&lt;a href=&quot;#题目要求：&quot; class=&quot;headerlink&quot; title=&quot;题目要求：&quot;&gt;&lt;/a&gt;题目要求：&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/08/14/dCy9C8.png&quot; alt=&quot;题目要求&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/08/14/dCguPP.png&quot; alt=&quot;测试用例示例&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="ListNode" scheme="https://henryinshanghai.github.io/categories/ListNode/"/>
    
    
    <category term="Algorithm" scheme="https://henryinshanghai.github.io/tags/Algorithm/"/>
    
    <category term="LinkedList" scheme="https://henryinshanghai.github.io/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>合并链表_03_2</title>
    <link href="https://henryinshanghai.github.io/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%EF%BC%88%E9%80%92%E5%BD%92%E6%96%B9%E5%BC%8F%EF%BC%89_03_2.html"/>
    <id>https://henryinshanghai.github.io/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%EF%BC%88%E9%80%92%E5%BD%92%E6%96%B9%E5%BC%8F%EF%BC%89_03_2.html</id>
    <published>2020-08-16T06:30:00.000Z</published>
    <updated>2020-08-17T09:15:59.075Z</updated>
    
    <content type="html"><![CDATA[<h3 id="合并两个有序链表（递归方式）"><a href="#合并两个有序链表（递归方式）" class="headerlink" title="合并两个有序链表（递归方式）"></a>合并两个有序链表（递归方式）</h3><hr><p><img src="https://s1.ax1x.com/2020/08/11/aOHNlD.png" alt="题目要求"></p><a id="more"></a><h4 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h4><ul><li><p>使用递归的可行性；</p><p>把第一个链表叫做l1，第二个链表叫做l2。可以把 l1 分解为（head + rest）,然后拿rest与l2进行合并操作，合并得到的结果再连接到head；</p><p>结论：可行</p></li><li><p>递归三部曲回顾：</p><p>1 方法的作用与返回值；</p><p>2 递归的终结条件（根据方法的作用推演）；</p><p>3 本级递归需要完成的工作（假设已经有了一个功能完整实现的API）；</p></li></ul><hr><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>一旦确定是可以递归的，这种方式需要关注的细节其实很少</p><hr><h4 id="完整实现"><a href="#完整实现" class="headerlink" title="完整实现"></a>完整实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ListNode定义的代码省略（参考其他文章）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1 作用：合并两个有序的列表，并返回合并后的列表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 2 递归终结条件</span></span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(l2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3 本级递归需要做的事情</span></span><br><span class="line">        <span class="comment">// ① 比较两个原始链表的头节点谁更小，对更小的那个链表进行拆分；</span></span><br><span class="line">        <span class="comment">// ② 把拆分后的rest链表与原始链表中的另一个进行合并操作，得到新的链表tempMerge</span></span><br><span class="line">        <span class="comment">// ③ 再对head头节点与tempMerge进行合并</span></span><br><span class="line">        <span class="keyword">if</span>(l1.val &lt; l2.val)&#123;</span><br><span class="line">            l1.next = mergeTwoLists(l1.next, l2); <span class="comment">// 把得到的新链表直接连接到头节点上</span></span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l2.next = mergeTwoLists(l2.next, l1);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h4><p>参考代码中的1、2、3</p><hr><h4 id="启示"><a href="#启示" class="headerlink" title="启示"></a>启示</h4><p>递归的代码真的非常简洁（不需要考虑很多的边界细节），而且只要确定可行性，代码一般不会太复杂</p><blockquote><p>until next time😄</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;合并两个有序链表（递归方式）&quot;&gt;&lt;a href=&quot;#合并两个有序链表（递归方式）&quot; class=&quot;headerlink&quot; title=&quot;合并两个有序链表（递归方式）&quot;&gt;&lt;/a&gt;合并两个有序链表（递归方式）&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/08/11/aOHNlD.png&quot; alt=&quot;题目要求&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="ListNode" scheme="https://henryinshanghai.github.io/categories/ListNode/"/>
    
    
    <category term="Algorithm" scheme="https://henryinshanghai.github.io/tags/Algorithm/"/>
    
    <category term="LinkedList" scheme="https://henryinshanghai.github.io/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>翻转链表_02_2</title>
    <link href="https://henryinshanghai.github.io/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E9%93%BE%E8%A1%A8%E7%BF%BB%E8%BD%AC%E4%B9%8B%E9%80%92%E5%BD%92%E8%A7%A3%E6%B3%95_02_2.html"/>
    <id>https://henryinshanghai.github.io/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E9%93%BE%E8%A1%A8%E7%BF%BB%E8%BD%AC%E4%B9%8B%E9%80%92%E5%BD%92%E8%A7%A3%E6%B3%95_02_2.html</id>
    <published>2020-08-16T06:00:00.000Z</published>
    <updated>2020-08-17T09:22:20.065Z</updated>
    
    <content type="html"><![CDATA[<h3 id="链表翻转之递归解法"><a href="#链表翻转之递归解法" class="headerlink" title="链表翻转之递归解法"></a>链表翻转之递归解法</h3><a id="more"></a><hr><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>并不是所有的情况都能使用递归解决，能用递归解决的问题需要有两个特征：</p><ul><li>1 能够通过某种方式把问题的规模变小；</li><li>2 对于1中更小规模的问题，可以使用同样的操作去处理它；</li></ul><p>现在先看看“翻转链表”这样的操作是不是符合上面的两个特征：</p><h5 id="能够通过某种方式把问题的规模变小"><a href="#能够通过某种方式把问题的规模变小" class="headerlink" title="能够通过某种方式把问题的规模变小"></a>能够通过某种方式把问题的规模变小</h5><p>由于链表本身就是递归的结构，所以总是可以把链表分为：头节点head + 剩余节点所组成的链表rest；</p><h5 id="对于更小规模的问题，可以使用同样的操作去处理它"><a href="#对于更小规模的问题，可以使用同样的操作去处理它" class="headerlink" title="对于更小规模的问题，可以使用同样的操作去处理它"></a>对于更小规模的问题，可以使用同样的操作去处理它</h5><p>在对rest做翻转操作后，我们就能得到一个已经翻转了的链表。接下来就只要想办法把头节点head连接进来即可</p><hr><h4 id="使用递归的三部曲"><a href="#使用递归的三部曲" class="headerlink" title="使用递归的三部曲"></a>使用递归的三部曲</h4><ul><li><p>1 明确方法的作用与返回值；</p></li><li><p>2 找到递归的终结条件——这个条件会停止递归，并开始弹出调用栈；</p></li><li><p>3 确定本级递归需要完成的工作；（这时候要假设已经有了功能可用的API给自己调用）</p></li></ul><p>注：一般而言，递归方法可以按照这3步来编写。但不尽然，有些递归方法的实现可能会surprise us</p><hr><h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 0 作用：翻转指定的链表，并返回链表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1 递归的终结条件</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 本级递归需要做的事情</span></span><br><span class="line">        <span class="comment">// ① 把链表视为：头节点 + 剩下节点组成的链表rest</span></span><br><span class="line">        <span class="comment">// ② 对rest中的节点执行翻转操作————翻转后，rest指向新链表的头节点</span></span><br><span class="line">        ListNode rest = reverseList(head.next);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ③ 把原始的头节点连接到新链表的尾节点</span></span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rest;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><h4 id="代码重现"><a href="#代码重现" class="headerlink" title="代码重现"></a>代码重现</h4><blockquote><p>step0 画个图，理清思路；需要什么东西，应该做怎样的操作；</p></blockquote><p><img src="https://s1.ax1x.com/2020/08/11/aOaGT0.md.jpg" alt="递归下的链表"></p><blockquote><p>step1 确定方法的作用与返回值；</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法作用：翻转链表，并返回翻转后的链表；</span></span><br></pre></td></tr></table></figure><blockquote><p>step2 编写递归终结条件；</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现翻转链表的最简情况是什么？ 答：空链表或者只有一个节点的链表</span></span><br><span class="line"><span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head; <span class="comment">// 这两种情况可以分开写，一起写只是为了让代码简洁一些</span></span><br></pre></td></tr></table></figure><blockquote><p>step3 本级递归需要做的事情；</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">① 把链表拆分为：头节点head + 剩下的节点所组成的链表rest;</span></span><br><span class="line"><span class="comment">② 对rest链表执行“翻转”操作————翻转后的链表头节点为旧链表的尾节点；</span></span><br><span class="line"><span class="comment">③ 处理head节点与rest链表，使得整个链表中的所有节点都被翻转；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 对rest链表执行“翻转”操作</span></span><br><span class="line">ListNode rest = reverseList(head.next);</span><br><span class="line"><span class="comment">// 把head节点添加到rest链表的末尾</span></span><br><span class="line">head.next.next = head;</span><br><span class="line"><span class="comment">// 为head连接一个null——表示链表结束</span></span><br><span class="line">head.next = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><h4 id="测试用例（检查代码功能与代码的健壮性）"><a href="#测试用例（检查代码功能与代码的健壮性）" class="headerlink" title="测试用例（检查代码功能与代码的健壮性）"></a>测试用例（检查代码功能与代码的健壮性）</h4><ul><li>极端情况下，功能是否正常工作； 传入的链表为空/只有一个节点</li></ul><h4 id="启示"><a href="#启示" class="headerlink" title="启示"></a>启示</h4><p>链表节点之间的关系，最好画张图比较容易弄清楚。</p><p>比如“把head连接到rest链表的末尾”这一步，刚开始我是想沿着链表找到rest的尾节点，然后再连接到head</p><p>但如果画图就能看出来，获取rest链表尾节点可以用head.next；</p><p>拆解一下head.next.next = head;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取到rest的尾节点</span></span><br><span class="line">ListNode lastOfRest = head.next;</span><br><span class="line"><span class="comment">// 把获取到的尾节点连接到head上</span></span><br><span class="line">lastOfRest.next = head;</span><br><span class="line"><span class="comment">// 把head连接到一个null这一步必须有，否则head与lastOfRest节点之间就会有环出现 这会导致报错</span></span><br><span class="line">head.next = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><blockquote><p>until next time 😄</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;链表翻转之递归解法&quot;&gt;&lt;a href=&quot;#链表翻转之递归解法&quot; class=&quot;headerlink&quot; title=&quot;链表翻转之递归解法&quot;&gt;&lt;/a&gt;链表翻转之递归解法&lt;/h3&gt;</summary>
    
    
    
    <category term="ListNode" scheme="https://henryinshanghai.github.io/categories/ListNode/"/>
    
    
    <category term="Algorithm" scheme="https://henryinshanghai.github.io/tags/Algorithm/"/>
    
    <category term="LinkedList" scheme="https://henryinshanghai.github.io/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>合并链表_03</title>
    <link href="https://henryinshanghai.github.io/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8-%E5%BE%97%E5%88%B0%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%EF%BC%88%E8%BF%AD%E4%BB%A3%E6%96%B9%E5%BC%8F%EF%BC%89_03.html"/>
    <id>https://henryinshanghai.github.io/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8-%E5%BE%97%E5%88%B0%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%EF%BC%88%E8%BF%AD%E4%BB%A3%E6%96%B9%E5%BC%8F%EF%BC%89_03.html</id>
    <published>2020-08-16T06:00:00.000Z</published>
    <updated>2020-08-17T09:21:47.190Z</updated>
    
    <content type="html"><![CDATA[<h3 id="合并两个有序链表，得到一个新的有序链表（迭代方式）"><a href="#合并两个有序链表，得到一个新的有序链表（迭代方式）" class="headerlink" title="合并两个有序链表，得到一个新的有序链表（迭代方式）"></a>合并两个有序链表，得到一个新的有序链表（迭代方式）</h3><a id="more"></a><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>1 创建一个链表就只需要想某个节点上不断连接其他节点就行了；</p><p>2 对两个链表对应位置节点的值进行比较，把较小的节点先连接到链表中；</p><p>3 如果出现某一个链表中的节点比较多（另一个链表中的节点已经用完了），直接把链表剩余的节点连接到正在创建的链表上就行了（因为剩余的这些节点都已经是有序的了，并且值也更大）</p><hr><h4 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h4><p>1 创建链表就只需要一个指针就可以；    </p><p>创建链表的SOP:</p><ul><li>1 连接到下一个节点；</li><li>2 更新当前指针到下一个节点；以便重复步骤1</li></ul><p>2 为了方便比较两个链表对应位置上的节点，这里需要添加一个假节点dummy；它总是指向链表的头节点</p><hr><h4 id="根据上面的分析尝试写代码"><a href="#根据上面的分析尝试写代码" class="headerlink" title="根据上面的分析尝试写代码"></a>根据上面的分析尝试写代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> val)&#123; <span class="keyword">this</span>.val = val;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 准备指针，用于生成链表</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>); <span class="comment">// 指向链表的头节点</span></span><br><span class="line">        ListNode cursor = dummy; <span class="comment">// 用于不管更新链表的指针</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 迭代并比较两个链表中节点的大小，并根据比较结果把节点连接到链表中</span></span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>)&#123; <span class="comment">// 循环执行条件：haed to describe</span></span><br><span class="line">            <span class="keyword">if</span>(l1.val &lt; l2.val)&#123;</span><br><span class="line">                <span class="comment">// 创建链表step1：连接到下一个节点</span></span><br><span class="line">                cursor.next = l1;</span><br><span class="line">                <span class="comment">// 更新l1链表的指针到下一个位置作用：实现迭代</span></span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 作用同上</span></span><br><span class="line">                cursor.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 创建链表step2：更新链表的指针作用：方便连接到下一个节点</span></span><br><span class="line">            cursor = cursor.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// always safe to use this to refer the ListNode, cus it always point to the first node of the ListNode</span></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h4><p>step1 定义需要的指针</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>); <span class="comment">// 方便新链表的创建</span></span><br><span class="line">ListNode cursor = dummy; <span class="comment">// cursor的意思是游标，我感觉比起指针更形象一些用于创建新链表</span></span><br></pre></td></tr></table></figure><p>step2 通过迭代的方式，遍历两个子链表中的指针，并连接到新链表中；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(l1.val &lt; l2.val)&#123;</span><br><span class="line"><span class="comment">// 为新链表连接到下一个节点扩展新链表</span></span><br><span class="line">cursor.next = l1;</span><br><span class="line"><span class="comment">// 找到原始链表中的下一个节点 用于比较两个原始链表之间的节点</span></span><br><span class="line">l1 = l1.next;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">cursor.next = l2;</span><br><span class="line">l2 = l2.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新cursor指针用于扩展链表</span></span><br><span class="line">cursor = cursor.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>step3 确定循环执行条件的表达式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 当表达式的值为true时，循环执行；</span></span><br><span class="line"><span class="comment">// 2 循环的作用：为新链表连接一个新节点，并且做一些方便连接下一个节点的操作</span></span><br><span class="line"><span class="comment">// 3 当某个链表的节点用尽时，应该终止循环：因为这时候不再需要进行节点间的比较</span></span><br><span class="line"><span class="comment">// 4 链表节点用尽的情况：l1 == null、l2 == null</span></span><br><span class="line"><span class="comment">// 这两种情况之间的逻辑关系是什么？只要有一个成立，循环就应该终止。对应地，为了让循环执行，应该两者都不为null aka l1 != null &amp;&amp; l2 != null</span></span><br><span class="line"><span class="keyword">while</span>(l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>)&#123; ... &#125;  <span class="comment">// this is truly a piece of work</span></span><br></pre></td></tr></table></figure><p>step4 处理某个原始链表中没有添加进新链表的节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为什么出现节点没有被添加的情况？ 因为另外一个链表中的节点已经用完了，它里面的节点值都比较小</span></span><br><span class="line"><span class="comment">// 如何确定是哪一个链表的节点没有被用完？ 没有被用完的链表指针不为null</span></span><br><span class="line"><span class="comment">// 如何处理没有被添加的节点？ 直接连接到新链表中即可 找对节点</span></span><br><span class="line"><span class="comment">// 这时候最好边看着操作图，边编写代码 因为某些边界条件很容易弄错</span></span><br><span class="line"><span class="keyword">if</span>(l1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">    cursor.next = l2;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span>(l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">    cursor.next = l1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>step5 返回创建的新链表的头节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> dummy.next;</span><br></pre></td></tr></table></figure><p>step6 编写基础测试用例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">main()&#123;</span><br><span class="line"><span class="comment">// 测试用例代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>step7 添加鲁棒性代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 鲁棒性代码一般添加在开始的地方，来对参数进行校验</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>until next time😄</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;合并两个有序链表，得到一个新的有序链表（迭代方式）&quot;&gt;&lt;a href=&quot;#合并两个有序链表，得到一个新的有序链表（迭代方式）&quot; class=&quot;headerlink&quot; title=&quot;合并两个有序链表，得到一个新的有序链表（迭代方式）&quot;&gt;&lt;/a&gt;合并两个有序链表，得到一个新的有序链表（迭代方式）&lt;/h3&gt;</summary>
    
    
    
    <category term="ListNode" scheme="https://henryinshanghai.github.io/categories/ListNode/"/>
    
    
    <category term="Algorithm" scheme="https://henryinshanghai.github.io/tags/Algorithm/"/>
    
    <category term="LinkedList" scheme="https://henryinshanghai.github.io/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>交换链表节点_02_1</title>
    <link href="https://henryinshanghai.github.io/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E5%AF%B9%E9%93%BE%E8%A1%A8%E8%BF%9B%E8%A1%8C%E7%BF%BB%E8%BD%AC(%E8%BF%AD%E4%BB%A3%E6%96%B9%E5%BC%8F)_02_1.html"/>
    <id>https://henryinshanghai.github.io/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E5%AF%B9%E9%93%BE%E8%A1%A8%E8%BF%9B%E8%A1%8C%E7%BF%BB%E8%BD%AC(%E8%BF%AD%E4%BB%A3%E6%96%B9%E5%BC%8F)_02_1.html</id>
    <published>2020-08-16T05:30:00.000Z</published>
    <updated>2020-08-17T09:22:49.088Z</updated>
    
    <content type="html"><![CDATA[<h3 id="对链表进行翻转（使用迭代的方式）"><a href="#对链表进行翻转（使用迭代的方式）" class="headerlink" title="对链表进行翻转（使用迭代的方式）"></a>对链表进行翻转（使用迭代的方式）</h3><hr><p><img src="https://s1.ax1x.com/2020/08/11/aLKOne.png" alt="翻转链表"></p><a id="more"></a><hr><h3 id="分析-👇👇👇"><a href="#分析-👇👇👇" class="headerlink" title="分析:👇👇👇"></a>分析:👇👇👇</h3><h4 id="节点翻转示意图"><a href="#节点翻转示意图" class="headerlink" title="节点翻转示意图"></a>节点翻转示意图</h4><p><img src="https://s1.ax1x.com/2020/08/11/aL1MgP.md.jpg" alt="节点翻转示意图"></p><p>1 既然是要翻转链表，那每个节点的连接方向都会发生变化；</p><p>2 每个节点都只能有一个连接。当它指向自己的前一个节点时，它就不能再指向自己的下一个节点；</p><p>3 需要处理链表中的每一个节点，但是根据2可知，节点连接方向改变后，无法再沿着链表获取到下一个节点；</p><p>解决手段：在改变节点的连接方向之前，使用一个临时变量保存当前节点的下一个节点；</p><blockquote><p>实现SOP</p></blockquote><p>1 为了能够遍历链表，我们需要一个指针；</p><p>2 为了能够改变节点的连接方向，我们需要另一个指针来指向当前节点的前一个节点；</p><blockquote><p>完整代码(不包含测试用例，可以自己编写main()函数作为测试用例)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 链表/节点的类定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val; <span class="comment">// 节点中存储的值</span></span><br><span class="line">    ListNode next; <span class="comment">// 节点连接到的下一个节点</span></span><br><span class="line">    ListNode(<span class="keyword">int</span> x) &#123;val = x;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 0 作用：翻转指定的链表，并返回链表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 迭代的方式</span></span><br><span class="line">        ListNode prev = <span class="keyword">null</span>; </span><br><span class="line">        ListNode curr = head; <span class="comment">// 翻转链表需要前后两个指针：一个用于更新头节点，一个用于创建链表的连接</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 记录原始的下一个节点 防止链表断掉</span></span><br><span class="line">            ListNode temp = curr.next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 建立链表的连接</span></span><br><span class="line">            curr.next = prev;</span><br><span class="line">            <span class="comment">// 更新两个指针</span></span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="实现过程☕☕☕"><a href="#实现过程☕☕☕" class="headerlink" title="实现过程☕☕☕"></a>实现过程☕☕☕</h3><h4 id="step1-定义两个指针，用来遍历和翻转链表；"><a href="#step1-定义两个指针，用来遍历和翻转链表；" class="headerlink" title="step1 定义两个指针，用来遍历和翻转链表；"></a>step1 定义两个指针，用来遍历和翻转链表；</h4><p>问题：如何初始化这两个指针？/这两个指针最开始应该指向什么位置？</p><p>答：参考上面的 [链表翻转示意图](#### 节点翻转示意图)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ListNode prev = <span class="keyword">null</span>; <span class="comment">// 初始化指向一个null节点</span></span><br><span class="line">ListNode curr = head; <span class="comment">// 初始化指向链表的头节点（head与curr一样，都是头节点的一个指针）</span></span><br></pre></td></tr></table></figure><h4 id="step2-遍历链表中的节点，并进行节点间的翻转；（每次翻转两个节点的连接）"><a href="#step2-遍历链表中的节点，并进行节点间的翻转；（每次翻转两个节点的连接）" class="headerlink" title="step2 遍历链表中的节点，并进行节点间的翻转；（每次翻转两个节点的连接）"></a>step2 遍历链表中的节点，并进行节点间的翻转；（每次翻转两个节点的连接）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123; <span class="comment">// 循环终止条件一般是比较容易出错的地方，所以放在最后再完成</span></span><br><span class="line"><span class="comment">// 1 保存当前节点的下一个节点作用：这样在遍历时才能直到下一个节点是哪一个</span></span><br><span class="line">    Node temp = curr.next;</span><br><span class="line">    <span class="comment">// 2 把当前节点连接到当前节点的前一个节点说明：这个相邻节点的关系需要手动维护</span></span><br><span class="line">    curr.next = prev;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3 维护相邻节点的关系作用：支持2</span></span><br><span class="line">    prev = curr;</span><br><span class="line">    <span class="comment">// 4 更新当前节点为当前节点的下一个节点作用：实现遍历链表操作</span></span><br><span class="line">    curr = curr.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="step3-确定循环终止条件"><a href="#step3-确定循环终止条件" class="headerlink" title="step3 确定循环终止条件"></a>step3 确定循环终止条件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">分析极端情况：</span></span><br><span class="line"><span class="comment">1 当前节点指针指向链表的尾节点（非null）时，还需要一次循环来翻转last与其上一个节点之间的连接方向；</span></span><br><span class="line"><span class="comment">2 当前节点指针指向null时，所有翻转都已经完成，循环结束；</span></span><br><span class="line"><span class="comment">所以循环终止条件为：curr == null;相应地，(表达式)就应该为curr != null</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">while</span>(curr != <span class="keyword">null</span>)&#123;...&#125;</span><br></pre></td></tr></table></figure><h4 id="step4-确定返回值"><a href="#step4-确定返回值" class="headerlink" title="step4 确定返回值"></a>step4 确定返回值</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原则：总是应该返回预期链表的头节点</span></span><br><span class="line"><span class="comment">// 手段：查看循环终止时，各个指针的指向情况翻转后链表的头节点应该是prev</span></span><br><span class="line"><span class="keyword">return</span> prev;</span><br></pre></td></tr></table></figure><hr><h3 id="代码重现-🦇🦇🦇"><a href="#代码重现-🦇🦇🦇" class="headerlink" title="代码重现 🦇🦇🦇"></a>代码重现 🦇🦇🦇</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    </span><br><span class="line">    ListNode(<span class="keyword">int</span> x)&#123; <span class="keyword">this</span>.val = x&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> <span class="title">Solution</span>(<span class="title">ListNode</span> <span class="title">head</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 定义两个指针并初始化作用：用于连接与遍历</span></span><br><span class="line">    ListNode prev = <span class="keyword">null</span>;</span><br><span class="line">    ListNode curr = head;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 开始遍历，并在遍历的过程中进行节点连接的翻转</span></span><br><span class="line">    <span class="keyword">while</span>(curr != <span class="keyword">null</span>)&#123; <span class="comment">// 循环执行条件</span></span><br><span class="line">        <span class="comment">// 记录当前节点（开始时是头节点）的下一个节点作用：实现遍历</span></span><br><span class="line">        ListNode temp = curr.next;</span><br><span class="line">        <span class="comment">// 更新当前节点的连接</span></span><br><span class="line">        curr.next = prev; <span class="comment">// 连接到前一个节点说明：需要维护这种节点的相邻关系</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 维护节点的相邻关系 &amp; 实现遍历</span></span><br><span class="line">        prev = curr; <span class="comment">// 1 把prev指向curr所指向的节点</span></span><br><span class="line">        curr = temp; <span class="comment">// 2 更新curr到链表的下一个节点由于节点的连接方向已经变化，所以不能使用curr.next 使用预先存储的节点temp</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回链表的头节点</span></span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="启示"><a href="#启示" class="headerlink" title="启示"></a>启示</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">知道为什么这么写后，才能把思路翻译成代码。不然就是在背代码了</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;对链表进行翻转（使用迭代的方式）&quot;&gt;&lt;a href=&quot;#对链表进行翻转（使用迭代的方式）&quot; class=&quot;headerlink&quot; title=&quot;对链表进行翻转（使用迭代的方式）&quot;&gt;&lt;/a&gt;对链表进行翻转（使用迭代的方式）&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/08/11/aLKOne.png&quot; alt=&quot;翻转链表&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="ListNode" scheme="https://henryinshanghai.github.io/categories/ListNode/"/>
    
    
    <category term="Algorithm" scheme="https://henryinshanghai.github.io/tags/Algorithm/"/>
    
    <category term="LinkedList" scheme="https://henryinshanghai.github.io/tags/LinkedList/"/>
    
  </entry>
  
</feed>
