<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Henry&#39;s blog</title>
  
  <subtitle>focus works better than curiosity</subtitle>
  <link href="https://henryinshanghai.github.io/atom.xml" rel="self"/>
  
  <link href="https://henryinshanghai.github.io/"/>
  <updated>2021-04-25T23:12:02.628Z</updated>
  <id>https://henryinshanghai.github.io/</id>
  
  <author>
    <name>henryInSH</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Git在工作场景中的用法02</title>
    <link href="https://henryinshanghai.github.io/Git/2021/04/18/%E6%95%99%E7%A8%8B%E7%B1%BB%E7%9A%84%E6%93%8D%E4%BD%9C%E4%B8%8E%E8%AE%A4%E8%AF%86/Github%E4%B8%8E%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/20210418-Git%E5%9C%A8%E5%B7%A5%E4%BD%9C%E5%9C%BA%E6%99%AF%E4%B8%AD%E7%9A%84%E7%94%A8%E6%B3%9502.html"/>
    <id>https://henryinshanghai.github.io/Git/2021/04/18/%E6%95%99%E7%A8%8B%E7%B1%BB%E7%9A%84%E6%93%8D%E4%BD%9C%E4%B8%8E%E8%AE%A4%E8%AF%86/Github%E4%B8%8E%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/20210418-Git%E5%9C%A8%E5%B7%A5%E4%BD%9C%E5%9C%BA%E6%99%AF%E4%B8%AD%E7%9A%84%E7%94%A8%E6%B3%9502.html</id>
    <published>2021-04-18T10:00:00.000Z</published>
    <updated>2021-04-25T23:12:02.628Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Git中的那些个允许你反悔的操作"><a href="#Git中的那些个允许你反悔的操作" class="headerlink" title="Git中的那些个允许你反悔的操作"></a>Git中的那些个允许你反悔的操作</h4><h5 id="反悔有哪些类型？"><a href="#反悔有哪些类型？" class="headerlink" title="反悔有哪些类型？"></a>反悔有哪些类型？</h5><a id="more"></a><blockquote><ul><li>做了不该做的事情；<ul><li>比如提交了不应该提交的文件(可能你正在尝试一种方案还没有结束)、填写了错误的提交信息…</li></ul></li><li>忘记了做该做的事情，而变更已经作为一个整体提交了。<ul><li>这种情况，一般可以通过添加新的提交来处理。所以也就不用反悔了</li></ul></li></ul></blockquote><h6 id="开发feature的工作流程"><a href="#开发feature的工作流程" class="headerlink" title="开发feature的工作流程"></a>开发feature的工作流程</h6><blockquote><p>一般情况下，对于任何功能的开发，我们都是从工作区开始进行编码的。普遍的操作流程如下：</p><p>本地操作</p><ul><li>在工作区中分阶段做出文件变更；</li><li>在正式形成一个commit(commit表示一系列变更的集合)之前，把当前的变更暂存到staging area;</li><li>在确认当前变更集合能够实现到某一个小功能时，创建一个commit，并添加对应的提交信息。</li></ul><p>远端操作</p><ul><li>对某个更高层级的feature，通常会需要在本地做出多个commit - 它们共同支持feature特性；</li><li>在本地测试feature的功能Okay后，开发者把本地的commits向push到远程分支 - push操作是对于两个分支来说的，所以一次push中可能会包含有多个commit（而一个commit中可能会包含有多个文件的变更）</li></ul></blockquote><h6 id="不满意工作区的变更，想要丢弃掉它们"><a href="#不满意工作区的变更，想要丢弃掉它们" class="headerlink" title="不满意工作区的变更，想要丢弃掉它们"></a>不满意工作区的变更，想要丢弃掉它们</h6><blockquote><p>场景1：不满意工作区中某一个文件的变更；</p><p>手段：git checkout – <filename></p><p>特征：这是针对于某一个文件的变更的丢弃操作。</p><p>验证手段：比较工作区中的该文件 与 暂存区中的该文件是否完全相同 - git diff – <filename></p></blockquote><blockquote><p>场景2：不满意工作区中所有文件的变更；</p><p>手段：git reset –hard HEAD</p><p>特征：这会把工作区、暂存区中的文件都恢复成为 HEAD指针指向的commit中的文件内容。</p><p>验证手段：比较工作区、暂存区、版本仓库中的文件集合之间是否存在差异 - git status</p></blockquote><h6 id="不满意暂存区中存储的变更，想要丢弃它们"><a href="#不满意暂存区中存储的变更，想要丢弃它们" class="headerlink" title="不满意暂存区中存储的变更，想要丢弃它们"></a>不满意暂存区中存储的变更，想要丢弃它们</h6><blockquote><p>场景1：为了实现featureA，尝试了实现方式1，本地测试后，把实现方式1相关的代码 暂存到了 staging area中。然后在工作区尝试了实现方式2，发现实现方式2更好。所以， 现在想要把暂存区中存储的所有文件先清空，然后把工作区中的变更 存储到 staging area中</p><p>手段：git reset HEAD</p><p>特征：</p><ul><li>1 这会把staging area中的内容 同步成 HEAD指针所指向的commit中的文件内容；</li><li>2 这样的操作不会干扰到工作区中的文件变更；</li><li>3 如果只是需要对staging area中的某个文件进行恢复，执行 git reset HEAD <filename></li></ul><p>验证手段：比较暂存区与HEAD指向的版本仓库之间的不同 - git diff –cached</p></blockquote><h6 id="不满意某一次commit中所包含的变更，想要调整-丢弃它们"><a href="#不满意某一次commit中所包含的变更，想要调整-丢弃它们" class="headerlink" title="不满意某一次commit中所包含的变更，想要调整/丢弃它们"></a>不满意某一次commit中所包含的变更，想要调整/丢弃它们</h6><blockquote><p>场景1：为了实现某一个任务，在工作区做了一些变更，其中有一些变更还暂存到了staging area.但是周末两天回来后，就已经忘记自己当前的状态了…</p><p>手段：git reset –hard HEAD</p><p>特征：</p><ul><li>1 –hard会把工作区、暂存区恢复成 与commit_reference所指定的commit中的文件完全相同；</li><li>2 在执行这个语句之后，被丢弃的commit会被Git视为垃圾，在一段时间后会被清理掉；</li></ul><p>注：由于使用–hard会把你工作区的变更一并抹掉，所以执行命令前需要确认工作区中的变更都已经statsh(寄存)到别处了</p></blockquote><blockquote><p>场景2：本地工作区中两个功能A与B在同时开发，结果在想要产生功能A的commit时，不小心把功能B相关的文件包含了进去。这时候想要丢掉这个错误的commit，从工作区重新产生正确的commit</p><p>手段：git reset –soft <commit_reference></p><p>特征：</p><ul><li>1 这里的<commit_reference>可以使用 HEAD表达式形式的相对引用，也可以使用 commitId形式的绝对引用；</li><li>2 –soft的作用 - 不删除工作空间改动代码，撤销commit，不撤销git add；</li></ul><p>扩展：</p><ul><li>1 –mixed选项的作用 - 不删除工作空间改动代码、撤销commit、并且撤销git add . 操作；<ul><li>注：不带选项时，默认使用的就是就是–mixed选项。</li></ul></li><li>2 如果想要修改最近一次commit的message，可以使用 - git commit –amend</li></ul><p>参考: <a href="https://blog.csdn.net/w958796636/article/details/53611133">git reset的各种选项</a></p></blockquote><h5 id="验证本地分支的当前情况"><a href="#验证本地分支的当前情况" class="headerlink" title="验证本地分支的当前情况"></a>验证本地分支的当前情况</h5><blockquote><p>如果上面的命令能够正常执行，你就应该能够得到你想要的效果(比如丢弃不想要的文件变更、丢弃不想要的commit，甚至于编辑位于中间位置的某一个commit)。</p><p>但是更有可能出现的是，在某一个命令执行后，出现了error，为了解决这个error，你又执行了别的命令…</p><p>最终，你不太清楚本地分支到底处在什么样的情况</p><p>验证手段：</p><ul><li>1 以时间倒序的方式，来查看本地当前分支的commit历史记录；<pre><code>- 命令：（current_branch）git log --oneline -n5 // 显示当前分支最近五次的commit记录，单行显示</code></pre><ul><li>特征：<pre><code>- 1 当没有指定具体分支时，git log默认显示当前分支的commit历史；- 2 添加--oneline选项，能够使输出结果单行显示 - 有利于对比远程分支上的commit；- 3 -n5表示限制最近的5次commit。如果想要显示最近10次，使用-n10即可。</code></pre><ul><li>2 查看远程分支的commit历史记录，对比本地分支的commit历史记录；- 这能帮你定位到是从哪一个commit开始，本地与远端开始不一样了</li><li>命令：查看远程分支的commit历史记录，可以直接使用Github/Bitbucket上提供的UI页面。</li><li>特征：</li></ul></li><li>1 为了查看某个分支上的commit历史，需要先把当前分支，切换到对应的分支上；</li><li>2 Github与Bitbucket上显示分支的开关有点不一样，主要是找到commits这个字样。<ul><li>3 找到本地分支的问题之后，就可以对症下药；</li><li>如果本地分支落后于远程分支，则：需要把远程分支新的commits添加到本地分支上</li></ul></li><li>手段：在本地分支上执行 git pull origin <remote_branch>:<local_branch> // 这是比较强大的方式，不需要考虑local_branch 与  remote_branch之间的上下游关系<ul><li>如果本地分支超前于远程分支，则：需要对比查看本地多出的commits是不是都是有必要的。</li></ul></li><li>如果本地的多个commit都是有必要的，则：<ul><li>把本地分支中新添加的commit，也添加到远程分支上；</li><li>手段：git push origin <local_branch>:<remote_branch></li><li>特征：这是分支到分支的操作，本地分支所有新的commit都会被包含进去。因此执行前，需要确定这里的多个commits都是需要的</li></ul></li><li>如果发现本地的某一个commit中包含有不想要提交的文件，则：<ul><li>现在还没有很好的办法，但可以在本地分支上添加一个新的commit - 在这个commit中，去掉不想要提交的文件。然后整体再做一次push操作；</li><li>特征：这个办法不够好，因为为了弥补错误而引入了新的commit - 这个commit对其他的开发者是干扰信息。</li><li>如果本地分支与远程分支发生了分离（专业点说，不再是fast forward关系），则：</li></ul></li><li>1 画个本地分支commit与远程分支commit的关系图；</li><li>2 找出哪些是想要的commit，哪些是不想要的commit - 基本来说，远程分支的commit总是有用的；</li><li>3 对症处理。</li></ul></li></ul></blockquote><blockquote><p>Here it is, until next time 😄</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;Git中的那些个允许你反悔的操作&quot;&gt;&lt;a href=&quot;#Git中的那些个允许你反悔的操作&quot; class=&quot;headerlink&quot; title=&quot;Git中的那些个允许你反悔的操作&quot;&gt;&lt;/a&gt;Git中的那些个允许你反悔的操作&lt;/h4&gt;&lt;h5 id=&quot;反悔有哪些类型？&quot;&gt;&lt;a href=&quot;#反悔有哪些类型？&quot; class=&quot;headerlink&quot; title=&quot;反悔有哪些类型？&quot;&gt;&lt;/a&gt;反悔有哪些类型？&lt;/h5&gt;</summary>
    
    
    
    <category term="Git" scheme="https://henryinshanghai.github.io/categories/Git/"/>
    
    
    <category term="Tools" scheme="https://henryinshanghai.github.io/tags/Tools/"/>
    
    <category term="Git Related Info" scheme="https://henryinshanghai.github.io/tags/Git-Related-Info/"/>
    
  </entry>
  
  <entry>
    <title>Git在工作场景中的用法</title>
    <link href="https://henryinshanghai.github.io/Git/2021/02/06/%E6%95%99%E7%A8%8B%E7%B1%BB%E7%9A%84%E6%93%8D%E4%BD%9C%E4%B8%8E%E8%AE%A4%E8%AF%86/Github%E4%B8%8E%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/20210206-Git%E5%9C%A8%E5%B7%A5%E4%BD%9C%E5%9C%BA%E6%99%AF%E4%B8%AD%E7%9A%84%E7%94%A8%E6%B3%95.html"/>
    <id>https://henryinshanghai.github.io/Git/2021/02/06/%E6%95%99%E7%A8%8B%E7%B1%BB%E7%9A%84%E6%93%8D%E4%BD%9C%E4%B8%8E%E8%AE%A4%E8%AF%86/Github%E4%B8%8E%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/20210206-Git%E5%9C%A8%E5%B7%A5%E4%BD%9C%E5%9C%BA%E6%99%AF%E4%B8%AD%E7%9A%84%E7%94%A8%E6%B3%95.html</id>
    <published>2021-02-06T11:51:00.000Z</published>
    <updated>2021-02-06T15:23:41.624Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Git的使用方式与用法理解"><a href="#Git的使用方式与用法理解" class="headerlink" title="Git的使用方式与用法理解"></a>Git的使用方式与用法理解</h4><h5 id="Git工作流程（宏观）"><a href="#Git工作流程（宏观）" class="headerlink" title="Git工作流程（宏观）"></a>Git工作流程（宏观）</h5><a id="more"></a><p><img src="https://s3.ax1x.com/2021/02/06/yYXLZQ.jpg" alt="本地仓库 &amp; 远程仓库之间的交互"></p><h6 id="terms（i-know-this-is-a-lot-just-bear-with-me）"><a href="#terms（i-know-this-is-a-lot-just-bear-with-me）" class="headerlink" title="terms（i know this is a lot, just bear with me）:"></a>terms（i know this is a lot, just bear with me）:</h6><blockquote><ul><li>远程仓库（Remote repo）一般在Github、Bitbucket这样的公共平台上的repository；</li><li>本地仓库(local repo) 是本地电脑上的一个文件夹，由于其中的/.git隐藏子文件夹而成为了git认识的repository——Git就是使用它来对文件夹中的文件进行有效的版本管理</li><li>提交(commit) n./v., 用于 汇总对一系列文件的改动——这样Git就能够把这些改动作为一个单位来管理<ul><li>每次commit操作都会有一个单独的ID，用来标识这一次的提交操作；</li></ul></li><li>分支（branch） 由一连串的commit所构成的链条——Git用它来记录/表示项目沿着时间轴不断变化的历史<ul><li>在Git中，每个分支都是一个独立的区域。aka 如果你自己创建了一个分支，在这个分支上不管你做了什么，都不会对别人产生影响</li></ul></li><li>master、feature 这是Git中比较通用的分支名称。比如master分支就是公共分支（所有开发者共同维护）、feature分支就是功能分支（由某个开发者负责具体实现）…<ul><li>分支的名字可以由程序员自己指定，但是在指定时应该遵守一定的规则（能够达到见名知意）</li></ul></li><li>～～～ 分隔本地环境 与 远端环境，这意味着它两边的单元交互/沟通需要通过网络;</li><li>git xxx 这是由Git提供的命令，通过这些命令你能够方便地执行一些自己想要的操作;</li><li>PR(pull request) 这是远端 请求把分支A 的commits合并到分支B 的操作。<ul><li>为啥不直接把本地的commits 直接push到分支B呢？<ul><li>你只是一个普通的开发者，能不能marge，管理员要检查的呀<ul><li>管理员怎么检查？<ul><li>Github/Bitbucket对git diff都进行了页面化的封装呀…</li></ul></li></ul></li></ul></li></ul></li></ul></blockquote><h6 id="phaseⅠ-从远端拉取仓库到本地；"><a href="#phaseⅠ-从远端拉取仓库到本地；" class="headerlink" title="phaseⅠ 从远端拉取仓库到本地；"></a>phaseⅠ 从远端拉取仓库到本地；</h6><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone &lt;remote_repo_address&gt; </span><br></pre></td></tr></table></figure><p> note that:</p><ul><li>1 you need ask the admin of this repo add you as the group name first, manually;</li><li>2 normally, with this executed. you will have all repo info in your local machine. but somehow, you only have one branch(the default branch) on your local 🙋</li></ul></blockquote><h6 id="phaseⅡ-使用默认分支来-在本地创建一个新的分支"><a href="#phaseⅡ-使用默认分支来-在本地创建一个新的分支" class="headerlink" title="phaseⅡ 使用默认分支来 在本地创建一个新的分支"></a>phaseⅡ 使用默认分支来 在本地创建一个新的分支</h6><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b &lt;newly_create_branch&gt;</span><br></pre></td></tr></table></figure><p>note that:</p><ul><li>1 weirdly, the git command used to create a new branch is ‘git checkout’. what the word ‘checkout’ even means?! there’s gotta be some bureaucrary here 😠</li><li>2 this <newly_create_branch> name should be decriptive. means you know what this branch is about by its name</li></ul></blockquote><h6 id="phaseⅢ-在你自己的分支上改动、再改动、喝杯咖啡🍻接着改动"><a href="#phaseⅢ-在你自己的分支上改动、再改动、喝杯咖啡🍻接着改动" class="headerlink" title="phaseⅢ 在你自己的分支上改动、再改动、喝杯咖啡🍻接着改动"></a>phaseⅢ 在你自己的分支上改动、再改动、喝杯咖啡🍻接着改动</h6><blockquote><p>这个是与业务有关的工作，与Git的流程没有直接关联</p></blockquote><h6 id="phaseⅣ-把你所做的改动放到一次commit中，然后push到远端的同名分支"><a href="#phaseⅣ-把你所做的改动放到一次commit中，然后push到远端的同名分支" class="headerlink" title="phaseⅣ 把你所做的改动放到一次commit中，然后push到远端的同名分支"></a>phaseⅣ 把你所做的改动放到一次commit中，然后push到远端的同名分支</h6><blockquote><p>桥豆麻袋，现在远端还没有叫我这个名字的分支(比如feature_generate_qr_code)，怎么办？</p><p>答：可以在推送分支到远端时，在远端创建一个名字相同的分支；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin &lt;same_name_as_local_newly_created_branch&gt;</span><br></pre></td></tr></table></figure><p>note that:</p><ul><li>这里的-u是为了设置本地分支xxx与远程分支xxx的上下游关系，这样在下次push时就不需要指定远端的分支名字了</li><li>origin这里表示的就是 远端仓库地址(origin是一种被Git接受的简写形式)</li></ul></blockquote><h6 id="phaseⅤ-在远端的平台上，创建一个从-xxx分支-到-目标分支的PR，然后口头通知管理员"><a href="#phaseⅤ-在远端的平台上，创建一个从-xxx分支-到-目标分支的PR，然后口头通知管理员" class="headerlink" title="phaseⅤ 在远端的平台上，创建一个从 xxx分支 到 目标分支的PR，然后口头通知管理员"></a>phaseⅤ 在远端的平台上，创建一个从 xxx分支 到 目标分支的PR，然后口头通知管理员</h6><blockquote><p>note 这个功能其实不是Git提供的，而是由Github这样的管理网站提供的</p></blockquote><h5 id="Git工作流程-微观"><a href="#Git工作流程-微观" class="headerlink" title="Git工作流程(微观)"></a>Git工作流程(微观)</h5><p><img src="https://s3.ax1x.com/2021/02/06/ytkGxH.jpg" alt="在本地电脑上的git操作流程"></p><h6 id="terms"><a href="#terms" class="headerlink" title="terms"></a>terms</h6><blockquote><p>1 工作区(workspace)  你修改文件的工作空间（比如说IDEA，VS Code等）</p><p>2 暂存区(staging area) 一个用于临时存储被编辑文件的空间，用于定制化地批量处理多个文件；</p><p>3 版本库(git repo commit history) 一个管理得非常好的仓库，管理着每一次commit操作的结果；</p></blockquote><h6 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h6><blockquote><p>phaseⅠ 在编辑器中对代码疯狂CRUD，然后本地对功能进行测试；</p><ul><li>从开发安全性的角度，在本地建议使用小步提交的方式。这样能够细致地管理自己的实现过程</li><li>但是在推送到远端的时候，你可能并不想一下推送这么多微小功能的commit。怎么办？🙋</li></ul></blockquote><blockquote><p>phaseⅡ 在git-bash/编辑器中集成的terminal黑窗口中，把被改动的文件按照自己的预期添加到暂存区</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add xxx ooo iii</span><br></pre></td></tr></table></figure><p>note that:</p><ul><li>1 you have loads of variation based on ‘git add’ to suit your need. just google them</li><li>2 for those files you never want to be managed by Git, there is some approach git provide named gitignore, please google it</li></ul></blockquote><blockquote><p>phaseⅢ 把暂存区中的文件列表 提交到 历史版本仓库中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">'&lt;descriptive message&gt;'</span> -m <span class="string">'&lt;if you are really proud of yourself&gt;'</span></span><br></pre></td></tr></table></figure><p>note that:</p><ul><li>1 you do not need specify any files here, since it would commit all the files in staging area;</li><li>2 -m is short for message;</li><li>3 that <message> part usually contains what you have done and why you done that</li></ul></blockquote><h5 id="Git工作流程-推荐做法"><a href="#Git工作流程-推荐做法" class="headerlink" title="Git工作流程(推荐做法)"></a>Git工作流程(推荐做法)</h5><p><img src="https://s3.ax1x.com/2021/02/06/ytZCy4.jpg" alt="保持本地的分支是最新的分支 aka 与master分支的最新提交保持一致"></p><h6 id="terms-1"><a href="#terms-1" class="headerlink" title="terms"></a>terms</h6><blockquote><p>there’s no new term in this diagram 😄</p></blockquote><h6 id="工作流程（保持本地代码最新）"><a href="#工作流程（保持本地代码最新）" class="headerlink" title="工作流程（保持本地代码最新）"></a>工作流程（保持本地代码最新）</h6><blockquote><p>phaseⅠ 从远端拉取 master分支最新的commit 到 本地的master分支；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull [origin master]</span><br></pre></td></tr></table></figure><p>note that:</p><ul><li>1 normally, the master branch’s upstream relationship is set as default. therefore, you do not type ‘origin master’;</li><li>2 if you do want to specify one perticular remote branch as the pull source, the grammar would go like ‘git pull origin <remote_branch>:<local_branch>‘</li></ul></blockquote><blockquote><p>phase Ⅱ 在本地，把master分支上的最新提交 合并到 feature分支;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;feature_branch&gt; <span class="comment">// switch to feature branch</span></span><br><span class="line">xxx(feature)git diff master <span class="comment">// compare the difference between feature_branch and master_branch</span></span><br><span class="line">xxx(feature)git merge master <span class="comment">// merge all the newly commits in master_branch into feature_branch</span></span><br></pre></td></tr></table></figure><p>note that:</p><p>1 weirdly, to switch to another branch. you need to use ‘git checkout’, again, what ‘checkout’ even means? 😳</p><p>2 the later two command can be tricky for you may not sure which one is objective and which one is subjective. just remember, to whom -&gt; (whom) …</p></blockquote><h5 id="Merge-Confilct在Git工作流中出现的情况"><a href="#Merge-Confilct在Git工作流中出现的情况" class="headerlink" title="Merge Confilct在Git工作流中出现的情况"></a>Merge Confilct在Git工作流中出现的情况</h5><p><img src="https://s3.ax1x.com/2021/02/06/ytnATs.jpg" alt="henry对文件index.html第47行的改动做了一次提交 紧跟着quinta也对index.html第47行的改动做了一次提交"></p><h6 id="Statement"><a href="#Statement" class="headerlink" title="Statement"></a>Statement</h6><blockquote><p>出现冲突并不是Git的锅。在多人协作的场景下，就有可能出现多个人在相邻的提交中，修改了某一个文件中的同一行。这时候如果版本管理工具不分青红皂白地 直接覆盖掉 时间上比较靠前的commit 中的文件的改动，就可能导致 该commit的开发者的工作成果被抹掉 然后开发者就要大家 世界就不再和平了 </p><p>所以Git选择把冲突的细节抛出来，开发者们当面锣、对面鼓地合计合计用谁的代码更好 </p></blockquote><h6 id="场景重现"><a href="#场景重现" class="headerlink" title="场景重现"></a>场景重现</h6><blockquote><p>多人开发场景，现在有程序员henry、quinta以及cassie</p><p>phaseⅠ quinta实现了 feature_a, 其中包含了对 index.html文件第47行的改动。然后通过提PR的方式，把自己的commit(commit_quinta) 合并到了 远端的master分支；</p><p>phase Ⅱ henry正在实现 feature_b, 本地已经做了一次提交（commit_henry 其中也包含了对index.html文件第47行的改动）；</p><p>phase Ⅲ 为了让本地分支的代码最新，henry执行了命令git pull origin master（对否？？？）, 来 把远端master的最新提交 更新到自己本地的分支上</p><p>结果/现状：相邻的两个commit(commit_henry、commit_quinta)</p><ul><li>1 来自于两个不同的开发者henry、quinta；</li><li>2 并且两个commit中包含有对同一个文件同一行的改动(index.html文件的第47行)</li></ul><p>Git不知道该选择谁的代码，索性抛出问题，让henry与quinta去处理吧</p></blockquote><blockquote><p>处理手段：</p><ul><li>approach01：使用github的UI界面；</li><li>使用git-bash的黑窗口界面；</li><li>使用编辑器的编辑区解决冲突（推荐使用）；<ul><li>1 找到具体发生冲突的是哪一行代码；（How❓）</li><li>2 分析具体为什么发生冲突；</li><li>3 最终决定处理方案(使用henry的代码/使用quinta的代码/两个人的代码都留下，把一部分调整到其他行)</li><li>4 冲突处理完后，需要做一次提交(commit_henry_tackle_confilct)</li></ul></li></ul></blockquote><blockquote><p>this is take a lot longer than I thought. until next time😄</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;Git的使用方式与用法理解&quot;&gt;&lt;a href=&quot;#Git的使用方式与用法理解&quot; class=&quot;headerlink&quot; title=&quot;Git的使用方式与用法理解&quot;&gt;&lt;/a&gt;Git的使用方式与用法理解&lt;/h4&gt;&lt;h5 id=&quot;Git工作流程（宏观）&quot;&gt;&lt;a href=&quot;#Git工作流程（宏观）&quot; class=&quot;headerlink&quot; title=&quot;Git工作流程（宏观）&quot;&gt;&lt;/a&gt;Git工作流程（宏观）&lt;/h5&gt;</summary>
    
    
    
    <category term="Git" scheme="https://henryinshanghai.github.io/categories/Git/"/>
    
    
    <category term="Tools" scheme="https://henryinshanghai.github.io/tags/Tools/"/>
    
    <category term="Git Related Info" scheme="https://henryinshanghai.github.io/tags/Git-Related-Info/"/>
    
  </entry>
  
  <entry>
    <title>Git官网信息</title>
    <link href="https://henryinshanghai.github.io/Git/2020/09/19/%E6%95%99%E7%A8%8B%E7%B1%BB%E7%9A%84%E6%93%8D%E4%BD%9C%E4%B8%8E%E8%AE%A4%E8%AF%86/Github%E4%B8%8E%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/20200919-Git%E5%AE%98%E7%BD%91%E4%BF%A1%E6%81%AF.html"/>
    <id>https://henryinshanghai.github.io/Git/2020/09/19/%E6%95%99%E7%A8%8B%E7%B1%BB%E7%9A%84%E6%93%8D%E4%BD%9C%E4%B8%8E%E8%AE%A4%E8%AF%86/Github%E4%B8%8E%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/20200919-Git%E5%AE%98%E7%BD%91%E4%BF%A1%E6%81%AF.html</id>
    <published>2020-09-19T04:30:00.000Z</published>
    <updated>2021-02-06T15:23:35.692Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Git官网上的信息（第一手资料）"><a href="#Git官网上的信息（第一手资料）" class="headerlink" title="Git官网上的信息（第一手资料）"></a>Git官网上的信息（第一手资料）</h4><a id="more"></a><h5 id="主页面（官网的信息对初学者并不友好）"><a href="#主页面（官网的信息对初学者并不友好）" class="headerlink" title="主页面（官网的信息对初学者并不友好）"></a>主页面（官网的信息对初学者并不友好）</h5><ul><li><p>Git is a <a href="https://git-scm.com/about/free-and-open-source">free and open source</a> distributed version control system designed to handle everything from small to very large projects with speed and efficiency.</p><blockquote><p>Git是一个免费、开源的分布式版本控制系统，用于快速高效地处理小型-大型项目；</p></blockquote><blockquote><p>链接详情：</p><ul><li>Git开源遵守的是什么类型的许可证；<ul><li>作用：你可以拿Git做哪些事，又不至于违反规则；</li><li>特征：对你我这种不同的程序员不重要，别多想😳</li></ul></li></ul></blockquote></li><li><p>Git is <a href="https://git-scm.com/doc">easy to learn</a> and has a <a href="https://git-scm.com/about/small-and-fast">tiny footprint with lightning fast performance</a>. It outclasses SCM tools like Subversion, CVS, Perforce, and ClearCase with features like <a href="https://git-scm.com/about/branching-and-merging">cheap local branching</a>, convenient <a href="https://git-scm.com/about/staging-area">staging areas</a>, and <a href="https://git-scm.com/about/distributed">multiple workflows</a>.</p><blockquote><p>Git很容易学习并且占用空间很小（tiny footprint），速度快。</p><p>它超越了很多SCM（Software configuration management）工具（比如Subversion, CVS, 其他同类品）,具体原因在于<strong>快捷的本地分支</strong>、<strong>方便的暂存区</strong>、<strong>多个工作流</strong>；</p></blockquote></li></ul><h6 id="链接详情1：easy-to-learn"><a href="#链接详情1：easy-to-learn" class="headerlink" title="链接详情1：easy to learn"></a>链接详情1：<a href="https://git-scm.com/doc">easy to learn</a></h6><blockquote><ul><li>1 使用手册/cheat sheet；</li><li>2 书；</li><li>3 视频；</li></ul><p>我就纳闷了，要是容易学的话。还需要一本书吗？🙋</p></blockquote><h6 id="链接详情2：tiny-footprint-with-lightning-fast-performance"><a href="#链接详情2：tiny-footprint-with-lightning-fast-performance" class="headerlink" title="链接详情2：tiny footprint with lightning fast performance"></a>链接详情2：<a href="https://git-scm.com/about/small-and-fast">tiny footprint with lightning fast performance</a></h6><blockquote><p><strong>Git is fast</strong>. With Git, nearly all operations are performed locally, giving it a huge speed advantage on centralized systems that constantly have to communicate with a server somewhere.</p><p>Git was built to work on the Linux kernel, meaning that it has had to effectively handle large repositories from day one. Git is written in C, reducing the overhead of runtimes associated with higher-level languages. Speed and performance has been a primary design goal of the Git from the start.</p></blockquote><blockquote><p>翻译：</p><p>Git很快. 使用Git时,几乎所有的操作都是在本地执行的—比起集中式的系统，这给了Git一个巨大的速度优势（因为集中式的系统总是会与某个远程的服务器执行网络操作）</p><p>Git是为了在Linux内核上工作而创建的,这意味着它一开始就必须能够有效地处理大的仓库;</p><p>Git是用C语言写成的，这减少了使用高级语言时会产生的运行时开销；</p><p>速度与性能是设计Git时考虑的首要目标；</p></blockquote><hr><blockquote><p>Let’s see how common operations <strong>stack up against</strong> Subversion, a common centralized version control system that is similar to CVS or Perforce. <em>Smaller is faster.</em></p><p>翻译：让我们看一下Git在常用操作中与Subversion的比拼（Subxxx是一个常用的中心化版本控制系统,它与CVS或者Perforce这些个产品类似） 更小意味着更快</p></blockquote><p><font size=2>看不太懂的图片</font></p><p><img src="https://s1.ax1x.com/2020/09/19/wokO78.png" alt="对比图"></p><p>虽然不太清楚具体是啥意思，但是git的条状图明显低很多…</p><p>不过既然是在对Git和Subversion进行操作耗时比较,肯定需要准备相同的测试用例，然后进行同样的操作（初中物理之<strong>控制变量法</strong>）</p><blockquote><p>For testing, large AWS instances were set up in the same availability zone. Git and SVN were installed on both machines, the Ruby repository was copied to both Git and SVN servers, and common operations were performed on both.</p></blockquote><blockquote><p>测试条件：</p><p>1 在同一可用区域中设置了大型AWS实例；</p><p>2 Git和SVN都安装在这两台机器上；</p><p>3 Ruby存储库被复制到Git和SVN服务器上，并在这两台机器上执行常见操作。</p></blockquote><blockquote><p>In some cases the commands don’t match up exactly. Here, matching on the lowest common denominator was attempted. For example, the ‘commit’ tests also include the time to push for Git, though most of the time you would not actually be pushing to the server immediately after a commit where the two commands cannot be separated in SVN.</p></blockquote><blockquote><p>测试的不精确性说明：</p><p>在某些情况下，命令与预期操作并不完全匹配。所以在这里，尝试在最小公分母上进行匹配。<br>例如，“commit”测试还包括推送Git的时间——多数情况下您不会在<strong>提交</strong>之后立即<strong>推送到服务器</strong>（但是在SVN中两个命令不能分开）</p></blockquote><p>实验数据(单位为s)；</p><table><thead><tr><th>Operation</th><th></th><th align="center">Git</th><th align="center">SVN</th><th></th></tr></thead><tbody><tr><td>Commit Files (A)</td><td>Add, commit and push 113 modified files (2164+, 2259-)</td><td align="center">0.64</td><td align="center">2.60</td><td>4x</td></tr><tr><td>Commit Images (B)</td><td>Add, commit and push a thousand 1 kB images</td><td align="center">1.53</td><td align="center">24.70</td><td>16x</td></tr><tr><td>Diff Current</td><td>Diff 187 changed files (1664+, 4859-) against last commit</td><td align="center">0.25</td><td align="center">1.09</td><td>4x</td></tr><tr><td>Diff Recent</td><td>Diff against 4 commits back (269 changed/3609+,6898-)</td><td align="center">0.25</td><td align="center">3.99</td><td>16x</td></tr><tr><td>Diff Tags</td><td>Diff two tags against each other (v1.9.1.0/v1.9.3.0)</td><td align="center">1.17</td><td align="center">83.57</td><td>71x</td></tr><tr><td>Log (50)</td><td>Log of the last 50 commits (19 kB of output)</td><td align="center">0.01</td><td align="center">0.38</td><td>31x</td></tr><tr><td>Log (All)</td><td>Log of all commits (26,056 commits – 9.4 MB of output)</td><td align="center">0.52</td><td align="center">169.20</td><td>325x</td></tr><tr><td>Log (File)</td><td>Log of the history of a single file (array.c – 483 revs)</td><td align="center">0.60</td><td align="center">82.84</td><td>138x</td></tr><tr><td>Update</td><td>Pull of Commit A scenario (113 files changed, 2164+, 2259-)</td><td align="center">0.90</td><td align="center">2.82</td><td>3x</td></tr><tr><td>Blame</td><td>Line annotation of a single file (array.c)</td><td align="center">1.91</td><td align="center">3.04</td><td>1x</td></tr></tbody></table><p><font size=2>同样这里的操作先不逐一解释，只是看实验数据</font></p><blockquote><p>Note that this is the best case scenario for SVN—a server with no load with a gigabit connection to the client machine. Nearly all of these times would be even worse for SVN if that connection was slower, while many of the Git times would not be affected.</p></blockquote><blockquote><p>留意对于SVN来说，这是最好的情况—一个与客户机有千兆位连接的无负载服务器。</p><p>如果这个允许链接的数量更低一些，那么：</p><ul><li>SVN几乎所有操作的时间数据都会变得更糟；</li><li>但是Git的许多操作都不会受到影响。</li></ul></blockquote><blockquote><p>Clearly, in many of these common version control operations, <strong>Git is one or two orders of magnitude faster than SVN</strong>, even under ideal conditions for SVN.</p></blockquote><blockquote><p>显然，在许多常见的版本控制操作中，Git比SVN快一到两个数量级，即使在SVN的理想条件下也是如此。</p></blockquote><blockquote><p>One place where Git is slower is in the initial clone operation. Here, Git is downloading the entire history rather than only the latest version. As seen in the above charts, it’s not considerably slower for an operation that is only performed once.</p></blockquote><blockquote><p>但是有一个操作Git会更慢一些（比起SVN）：初始的克隆操作；在这个操作中,Git会下载整个历史不只是当前的最新版本。</p><p>从上面的图表可以看出，对于一个只会执行一次的操作，它还不算太慢；</p></blockquote><table><thead><tr><th>Operation</th><th></th><th align="center">Git*</th><th align="center">Git</th><th align="center">SVN</th></tr></thead><tbody><tr><td>Clone</td><td>Clone and shallow clone(*) in Git vs checkout in SVN</td><td align="center">21.0</td><td align="center">107.5</td><td align="center">14.0</td></tr><tr><td>Size (MB)</td><td>Size of total client side data and files after clone/checkout (in MB)</td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><blockquote><p>It’s also interesting to note that the size of the data on the client side is very similar even though Git also has every version of every file for the entire history of the project. This illustrates how efficient it is at compressing and storing data on the client side.</p></blockquote><blockquote><p>有趣的是，尽管Git还拥有项目整个历史中每个文件的每个版本，但客户端的数据大小非常相似。</p><p>这说明了它在客户端压缩和存储数据的效率。</p></blockquote><h6 id="链接详情3：-cheap-local-branching"><a href="#链接详情3：-cheap-local-branching" class="headerlink" title="链接详情3： cheap local branching"></a>链接详情3： <a href="https://git-scm.com/about/branching-and-merging">cheap local branching</a></h6><ul><li>分支与合并</li></ul><blockquote><p>The Git feature that really makes it <strong>stand apart from</strong> nearly every other SCM out there is its branching model.</p><p>Git allows and encourages you to have multiple local branches that can be entirely independent of each other. The creation, merging, and deletion of those lines of development takes seconds.</p></blockquote><blockquote><p>Git所以区别于其他的SCM(Software configuration management)工具的主要原因在于：它的分支模型；</p><p>Git允许/鼓励你持有多个相互独立的本地分支；</p><p>这些个分支（开发线）的创建、合并与删除都只是几秒钟的工作；</p></blockquote><ul><li>分支模型的作用</li></ul><blockquote><p>This means that you can do things like:</p><ul><li><strong>Frictionless Context Switching</strong>. <ul><li>Create a branch to try out an idea, commit a few times, switch back to where you branched from, apply a patch, switch back to where you are experimenting, and merge it in.</li></ul></li><li><strong>Role-Based Codelines</strong>. Have a branch that always contains only what goes to production, another that you merge work into for testing, and several smaller ones for day to day work.</li></ul></blockquote><blockquote><p>这意味着你可以做下面这样的事情:</p><ul><li>简单的上下文切换.<ul><li>创建一个分支来尝试一个新的想法，提交几次改动，然后切换回创建分支的地方，应用一个补丁（🚩），切换回你正在进行试验的地方，把实验的恭喜合并到主分支；</li></ul></li><li>基于角色的代码行；<ul><li>创建一个分支：这个分支中只包含会提交到生产环境中的代码；</li><li>创建另一个分支：这个分支用于用于合并新添加的功能后进行测试；</li><li>创建其他几个分支：这些个分支用于日常工作，aka，小功能的开发；</li></ul></li></ul></blockquote><blockquote><ul><li><strong>Feature Based Workflow</strong>. Create new branches for each new feature you’re working on so you can seamlessly switch back and forth between them, then delete each branch when that feature gets merged into your main line.</li><li><strong>Disposable Experimentation</strong>. Create a branch to experiment in, realize it’s not going to work, and just delete it - abandoning the work—with nobody else ever seeing it (even if you’ve pushed other branches in the meantime).</li></ul></blockquote><blockquote><ul><li>基于功能特性的工作流.<ul><li>为每一个你正在开发的新功能创建一个新的分支，这样你可以在这些分支之间<strong>无缝地/无顾忌地</strong>来回切换。并且在把功能合并到代码主分支之后，就可以删除该功能对应的分支</li></ul></li><li>一次性的实验.<ul><li>创建一个分支用来试验一些想法，然后发现这个想法行不通，接着就可以把这个分支删除掉—放弃那些失败的尝试—甚至都不会有人看到它；</li></ul></li></ul></blockquote><p><img src="https://s1.ax1x.com/2020/09/20/wouzy4.png" alt="Git中的分支模型"></p><blockquote><p>Notably, when you push to a remote repository, you do not have to push all of your branches. You can choose to share just one of your branches, a few of them, or all of them. This tends to free people to try new ideas without worrying about having to plan how and when they are going to merge it in or share it with others.</p><p>There are ways to accomplish some of this with other systems, but the work involved is much more difficult and <strong>error-prone</strong>. Git makes this process incredibly easy and it changes the way most developers work when they learn it.</p></blockquote><blockquote><p>值得注意的是，当你推送代码到远程仓库时，你不需要推送你的所有分支。</p><p>你可以选择分享你的某一个分支/其中几个分支或是所有的分支。</p><p>这样的话，团队中的其他成员在尝试新的想法时，就不需要担心应该在何时，以何种方式把新的想法合并或者分享给其他人；</p></blockquote><blockquote><p>在其他系统中,也有一些手段能够实现这些功能，但是所涉及的工作要困难得多，而且容易出错。</p><p>Git使这个过程非常简单，它改变了大多数开发人员学习它时的工作方式。</p></blockquote><h6 id="链接详情4：staging-areas"><a href="#链接详情4：staging-areas" class="headerlink" title="链接详情4：staging areas"></a>链接详情4：<a href="https://git-scm.com/about/staging-area">staging areas</a></h6><blockquote><p>Unlike the other systems, Git has something called the “staging area” or “index”. This is an intermediate area where commits can be formatted and reviewed before completing the commit.</p><p>One thing that <strong>sets Git apart from</strong> other tools is that it’s possible to quickly <strong>stage</strong> some of your files and commit them without committing all of the other modified files in your working directory or having to list them on the command line during the commit.</p></blockquote><blockquote><p>与其他系统不同，Git有一个叫做“临时区域”或“索引”的东西。这是一个中间区域，可以在完成提交之前,<strong>对提交的内容进行格式化和检查</strong>。</p><p>Git与其他工具不同的一点是，它可以<strong>快速暂存一些文件并提交它们</strong>，而无需：</p><ul><li>1 提交工作目录中的<strong>所有修改过的其他文件</strong>；</li><li>2 也不必在提交期间将<strong>它们</strong>列在命令行上。</li></ul></blockquote><p>暂存区的工作流程</p><p><img src="https://s1.ax1x.com/2020/09/20/woMT5q.png" alt="暂存区的SOP"></p><blockquote><p>This allows you to stage only portions of a modified file. Gone are the days of making two logically unrelated modifications to a file before you realized that you forgot to commit one of them. Now you can just stage the change you need for the current commit and stage the other change for the next commit. This feature scales up to as many different changes to your file as needed.</p></blockquote><blockquote><p>这允许您仅暂存<strong>已修改文件的部分内容</strong>。</p><p>对一个文件进行了两次逻辑上不相关的改动，然后你发现自己忘记了提交其中的某个改动。这样的事情再也不会发生了。</p><p>现在，您只需<strong>为当前提交准备所需的更改</strong>，并<strong>为下一次提交准备另一个更改</strong>。此功能可根据需要对文件进行多次不同的更改。</p></blockquote><blockquote><p>Of course, Git also makes it easy to ignore this feature if you don’t want that kind of control — just add a ‘-a’ to your commit command in order to add all changes to all files to the staging area.</p></blockquote><blockquote><p>当然，如果您不想要这种控制，Git还可以让您很容易忽略此功能—只需在commit命令中添加’-a’，以便将对所有文件的所有更改添加到临时区域。(这个貌似更常用吧<del>~</del>)</p></blockquote><p><img src="https://s1.ax1x.com/2020/09/20/woQGLQ.png" alt="一次性提交文件中的所有改动"></p><h6 id="链接详情5：-multiple-workflows"><a href="#链接详情5：-multiple-workflows" class="headerlink" title="链接详情5： multiple workflows"></a>链接详情5： <a href="https://git-scm.com/about/distributed">multiple workflows</a></h6><p>Distributed(分配/分发)</p><blockquote><p>One of the nicest features of any Distributed SCM, Git included, is that it’s distributed. This means that instead of doing a “checkout” of <strong>the current tip of the source code</strong>, you do a “clone” of the entire repository.</p></blockquote><blockquote><p>分布式SCM工具（包括Git）的最好的一个特性就是：它是distributed的。</p><p>这意味着，不必对<strong>源代码的当前tip</strong>进行“签出”，而是对<strong>整个存储库</strong>进行“克隆”。</p></blockquote><blockquote><h6 id="Multiple-Backups"><a href="#Multiple-Backups" class="headerlink" title="Multiple Backups"></a>Multiple Backups</h6><p>This means that even if you’re using a centralized workflow, every user <strong>essentially</strong> has a full backup of the main server. Each of these copies could be pushed up to replace the main server in the event of a crash or corruption. In effect, there is no <strong>single point of failure</strong> with Git unless there is only a single copy of the repository.</p></blockquote><blockquote><h6 id="多个备份"><a href="#多个备份" class="headerlink" title="多个备份"></a>多个备份</h6><p>这意味着，即使您使用集中化的工作流，每个用户<strong>实际上</strong>都有主服务器的完整备份。在发生崩溃或损坏时，这些副本中的每一个都可以进行push操作以替换主服务器。实际上，Git不存在单点故障，除非存储库只有一个副本。</p></blockquote><blockquote><h6 id="Any-Workflow"><a href="#Any-Workflow" class="headerlink" title="Any Workflow"></a>Any Workflow</h6><p>Because of Git’s distributed nature and superb branching system, an almost endless number of workflows can be implemented with relative ease.</p></blockquote><blockquote><h6 id="任何工作流"><a href="#任何工作流" class="headerlink" title="任何工作流"></a>任何工作流</h6><p>由于<strong>Git的分布式特性</strong>和<strong>出色的分支系统</strong>，因此可以相对容易地实现<strong>几乎无止境的工作流</strong>。</p></blockquote><blockquote><h6 id="Subversion-Style-Workflow"><a href="#Subversion-Style-Workflow" class="headerlink" title="Subversion-Style Workflow"></a>Subversion-Style Workflow</h6><p>A centralized workflow is very common, especially from people transitioning from a centralized system. Git will not allow you to push if someone has pushed since the last time you fetched, so a centralized model where all developers push to the same server works just fine.</p></blockquote><blockquote><p>Subversion类别的工作流<br>集中化工作流是非常常见的，尤其是从集中化系统过渡的人员。</p><p>如果在你<strong>拉取代码</strong>之后，有其他人做了<strong>提交的操作</strong>，那么Git不允许你推送；所以一个<strong>所有开发人员都推到同一个服务器上</strong>的“集中式模型”其实就能够很好地工作。</p></blockquote><p><img src="https://s1.ax1x.com/2020/09/20/wolY6O.png" alt="Subversion类别的工作流"></p><blockquote><h6 id="Integration-Manager-Workflow"><a href="#Integration-Manager-Workflow" class="headerlink" title="Integration Manager Workflow"></a>Integration Manager Workflow</h6><p>Another common Git workflow involves an integration manager — a single person who commits to the ‘blessed’ repository. A number of developers then clone from that repository, push to their own independent repositories, and ask the integrator to pull in their changes. This is the type of development model often seen with open source or GitHub repositories.</p></blockquote><blockquote><h6 id="Integration-Manager工作流"><a href="#Integration-Manager工作流" class="headerlink" title="Integration Manager工作流"></a>Integration Manager工作流</h6><p>另一个常见的Git工作流涉及到一个<strong>集成经理</strong>-一个提交到“受祝福”存储库的人。然后，许多开发人员<strong>从该存储库中克隆</strong>，推送到他们<strong>自己的独立存储库</strong>，并<strong>要求集成经理引入他们的更改</strong>。这是在开源或GitHub存储库中经常看到的开发模型类型。【clone - &lt;改动&gt; - pull request】</p></blockquote><p><img src="https://s1.ax1x.com/2020/09/20/wo1CjO.png" alt="有一个审核经理的工作流模式"></p><blockquote><h6 id="Dictator-and-Lieutenants-Workflow"><a href="#Dictator-and-Lieutenants-Workflow" class="headerlink" title="Dictator and Lieutenants Workflow"></a>Dictator and Lieutenants Workflow</h6><p>For more massive projects, a development workflow like that of the Linux kernel is often effective. In this model, some people (‘lieutenants’) are in charge of a specific subsystem of the project and they merge in all changes related to that subsystem. Another integrator (the ‘dictator’) can pull changes from only his/her lieutenants and then push to the ‘blessed’ repository that everyone then clones from again.</p></blockquote><blockquote><h6 id="独裁者和中尉工作流"><a href="#独裁者和中尉工作流" class="headerlink" title="独裁者和中尉工作流"></a>独裁者和中尉工作流</h6><p>对于更大规模的项目，像<strong>Linux内核</strong>那样的开发工作流通常是有效的。在这个模型中，一些人（“副手”）负责项目的一个特定子系统，他们将与该子系统相关的所有变更合并在一起。另一个集成商（“独裁者”）可以只从他/她的副手那里获取更改，然后推送到“受祝福的”存储库，然后每个人都可以从中再次克隆。</p></blockquote><p><img src="https://s1.ax1x.com/2020/09/20/wo1VUA.png" alt="Linux系统开发的工作流"></p><blockquote><p>I’m not satisfied, what is repository after all?</p><p>这就是我不满意官方网站的地方，就是我通读了整个网站，也是没有得到我需要了解的内容。Git到底是怎么工作的？</p></blockquote><h5 id="官网提供的视频资料"><a href="#官网提供的视频资料" class="headerlink" title="官网提供的视频资料"></a>官网提供的视频资料</h5><p>官网提供的视频是打不开的😳</p><h5 id="尝试搜索youtube上的学习资料"><a href="#尝试搜索youtube上的学习资料" class="headerlink" title="尝试搜索youtube上的学习资料"></a>尝试搜索youtube上的学习资料</h5><p>参考:<a href="https://www.youtube.com/watch?v=SWYqp7iY_Tc">Traversy Media</a></p><blockquote><p>个人还是更偏向英文的视频，可能有点偏见…</p><p>但是看视频有一个缺点（相比于看文本），你没办法快速定位到你想要的内容。所以很大可能你需要把了解过的内容重新看一遍…这时候的心态应该是”温故而知新”</p></blockquote><ul><li><p>什么叫分布式/非中心化的版本管理系统？</p><p>多个程序员合作同一个项目，而不需要呆在同一个局域网中。</p></li><li><p>Git常用命令</p><p><img src="https://s1.ax1x.com/2020/09/20/wog34I.png" alt="Git常用命令"></p></li><li><p>安装Git</p><ul><li>Linux系统；使用命令安装</li><li>Mac：官网/包管理工具HomeBrew;</li><li>Windows：官网（包含Git-Bash命令行工具）；/GUI工具（不推荐）</li></ul><blockquote><p>bear in mind:你不需要了解Git的方方面面，因为它会很复杂。Just Basics</p></blockquote></li></ul><ul><li><p>tips</p><ul><li>1 使用git bash命令行工具，而不是Windows自带的命令行工具（aka cmd黑窗口）；</li></ul></li><li><p>用法</p><ul><li><p>1 创建一个空的文件夹；</p></li><li><p>2 在文件夹中创建几个文件；</p></li><li><p>3 把文件夹初始化为一个仓库；</p></li><li><p>4 把特定的文件添加到暂存区(staging area)并查看当前缓存区的文件状态;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;file&gt; <span class="comment">// 把文件添加到暂存区用于后继提交</span></span><br><span class="line">git status <span class="comment">// 查看当前暂存区中的文件</span></span><br><span class="line">    暂存区中的文件状态：</span><br><span class="line">    <span class="number">1</span> 待提交（Changes to be committed）；</span><br><span class="line">    <span class="number">2</span> 未被追踪(Untracked files);</span><br><span class="line">git rm --cached &lt;file&gt; <span class="comment">// 把文件从暂存区中移除</span></span><br></pre></td></tr></table></figure></li></ul><hr><p>在添加文件到暂存区时使用通配符*：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add *.html <span class="comment">// 把所有后缀名为html的文件添加到暂存区</span></span><br></pre></td></tr></table></figure><p>在添加所有文件都添加到暂存区:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add . <span class="comment">// .表示的是all</span></span><br></pre></td></tr></table></figure><p>声明那些在仓库中你不想要添加到版本控制系统中的文件（预期-git add也无法添加这些文件）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">在项目的根目录下创建.gitignore文件</span><br><span class="line">touch .gitignore</span><br><span class="line"></span><br><span class="line">然后编辑.gitignore文件，添加想要忽略的文件与目录</span><br><span class="line">log.txt</span><br><span class="line">/dir2</span><br></pre></td></tr></table></figure><ul><li><p>验证.gitignore中声明的<strong>被版本管理系统忽略的文件/目录</strong>是不是真的被忽略的；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> 在工作目录中做一些改动；</span><br><span class="line">    添加新的目录/dir1（目录中添加新的文件test1.txt）</span><br><span class="line">    添加新的目录/dir2(目录中添加新的文件test2.txt)</span><br><span class="line"><span class="number">2</span> 在.gitignore文件中添加“预期被忽略的文件/目录”</span><br><span class="line">    log.txt</span><br><span class="line">    /dir2</span><br><span class="line"><span class="number">3</span> 把所有文件添加到暂存区</span><br><span class="line">    git add .</span><br><span class="line"><span class="number">4</span> 查看暂存区中所有状态下的文件</span><br><span class="line">    git status</span><br><span class="line">预期：暂存区中没有记录新增的文件log.txt与新增的目录/dir;但是却记录了新增的目录/dir1</span><br><span class="line">结果：符合预期</span><br></pre></td></tr></table></figure></li><li><p>如果你和其他几个开发者共同开发一个项目，并且你被分配了login功能这个任务。</p><blockquote><p>在功能没有完全开发完成之前，开发者不应该把自己做出的改动提交到主分支中；</p></blockquote><p>手段：</p><ul><li>1 创建一个叫做login的<strong>分支</strong>，然后把自己改动的代码提交到login分支中（而不是主分支）；</li><li>2 在login功能开发完成后，再把login分支<strong>合并到</strong>主分支中；</li></ul><p>用法：</p><ul><li><p>1 创建一个login分支；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch &lt;自定义的分支名称login&gt;</span><br></pre></td></tr></table></figure><p>注：这时只是创建了分支，但是开发环境仍旧处在master分支上；</p></li><li><p>2 切换开发环境到刚刚创建的login分支；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;预期切换到的分支名称login&gt;</span><br></pre></td></tr></table></figure></li><li><p>3 在新的分支上开发login功能；</p><p>xxx</p></li><li><p>4 验证在提交到login分支上的改动是否会影响到master分支；</p><ul><li><p>手段：切换回主分支，然后查看Git仓库中是否存在3中做出的改动；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;预期切换到的分支名称master&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><ul><li><p>5 在login功能开发完成后，希望把<strong>提交到login分支的改动</strong>合并到master分支上；</p><ul><li><p>手段：</p><ul><li>1 在master分支中，把login分支合并进来；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge &lt;预期合并进来的分支名称login&gt;</span><br></pre></td></tr></table></figure><ul><li>2 填写合并此分支到master分支的原因（这应该是master分支的管理者需要做的事情）；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add the login function, blah blah blah...</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr></li><li><p>远程仓库；</p><p>用法：</p><ul><li><p>1 创建一个Github账号xxx；</p></li><li><p>2 在xxx账号下，创建一个公开仓库；</p></li><li><p>3 把<strong>在Github上创建的仓库</strong>作为<strong>本地仓库的远程仓库</strong>；</p><ul><li><p>查看本地仓库当前所有的远程仓库；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote <span class="comment">// 没有绑定远程仓库时，命令执行的结果为空</span></span><br></pre></td></tr></table></figure></li><li><p>根据github项目中提供的命令行信息，把github项目作为本地项目的远程仓库；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git<span class="meta">@github</span>.com:henryinshanghai/my_webapp_sample.git</span><br></pre></td></tr></table></figure></li></ul></li><li><p>4 把本地仓库的内容推送到<strong>远程仓库的主分支</strong>中；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin master <span class="comment">// 同样是github项目提供的命令，可以无脑复制</span></span><br></pre></td></tr></table></figure></li><li><p>5 推送成功后，刷新github项目的页面就能够看到本地项目的内容已经推送到远程仓库中了；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在github项目的网页上点击一下刷新按钮</span><br></pre></td></tr></table></figure><hr></li><li><p>6 为了让其他程序员更容易了解这个项目，为项目添加README.md文件（项目说明）</p><ul><li><p>0 通过git bash页面来在项目根目录下创建一个README.md文件；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch README.md <span class="comment">// 这是Linux系统的语法吧</span></span><br></pre></td></tr></table></figure></li><li><p>1 然后编辑这个文件的内容（可以直接在命令行中使用命令来编辑，也可以通过文本编辑器软件进行编辑）；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">I<span class="string">'m the night!</span></span><br><span class="line"><span class="string">I'</span>m Vengeance!</span><br><span class="line">I<span class="string">'m batman</span></span><br></pre></td></tr></table></figure></li><li><p>2 把所有工作区（working area）被改动的文件添加到暂存区(staging area);</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add . <span class="comment">// .表示all的意思</span></span><br></pre></td></tr></table></figure></li><li><p>3 把所有暂存区中待提交的文件，提交到本地仓库（local repository）；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push <span class="comment">// 由于前面已经为本地项目指定了github项目作为远程仓库，所以这里直接push即可</span></span><br></pre></td></tr></table></figure><p><font size=2>注：首次推送到github项目时，可能需要登录github来验证用户的合法性;</font></p></li></ul></li></ul></li></ul></li></ul><hr><ul><li><p>在github上公开的仓库可以被其他程序员克隆到本地进行学习。这里模拟克隆github项目到本地的过程；</p><ul><li><p>说明：由于没有其他的程序员，所以这里<strong>自己来克隆自己的项目到自己的电脑上</strong>。只是为了熟悉流程</p></li><li><p>手段：</p><ul><li><p>1 在自己的电脑上创建一个新的文件夹/myapp2；</p></li><li><p>2 在/myapp2中打开git bash界面；</p></li><li><p>3 从github上拉取项目到自己电脑的文件夹中；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">语法：git clone &lt;github项目所提供的克隆地址&gt;</span><br><span class="line">特征：克隆项目时，由于是远程通信，所以有多个协议可以选择（https、ssh等）。这里选择https，因为它是第一个</span><br><span class="line">git clone https:<span class="comment">//github.com/henryinshanghai/my_webapp_sample.git</span></span><br><span class="line">结果：github项目中的所有内容都会被拷贝到本地文件夹中</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>在多个开发的情况下，如果其他开发者对远程仓库做了某些改动。在一天的工作开始之前，你需要把这些改动从远程仓库拉取到本地仓库中</p><ul><li><p>手段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull <span class="comment">// 拉取远程仓库的变动到本地仓库</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><blockquote><p>alright, can’t dwell on this forever. until next time 😄</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;Git官网上的信息（第一手资料）&quot;&gt;&lt;a href=&quot;#Git官网上的信息（第一手资料）&quot; class=&quot;headerlink&quot; title=&quot;Git官网上的信息（第一手资料）&quot;&gt;&lt;/a&gt;Git官网上的信息（第一手资料）&lt;/h4&gt;</summary>
    
    
    
    <category term="Git" scheme="https://henryinshanghai.github.io/categories/Git/"/>
    
    
    <category term="Tools" scheme="https://henryinshanghai.github.io/tags/Tools/"/>
    
    <category term="Git Related Info" scheme="https://henryinshanghai.github.io/tags/Git-Related-Info/"/>
    
  </entry>
  
  <entry>
    <title>从Github的操作到SSH协议的应用</title>
    <link href="https://henryinshanghai.github.io/Network/2020/09/18/%E6%95%99%E7%A8%8B%E7%B1%BB%E7%9A%84%E6%93%8D%E4%BD%9C%E4%B8%8E%E8%AE%A4%E8%AF%86/Github%E4%B8%8E%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/20200918-%E4%BB%8EGithub%E7%9A%84%E6%93%8D%E4%BD%9C%E5%88%B0SSH%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%BA%94%E7%94%A8.html"/>
    <id>https://henryinshanghai.github.io/Network/2020/09/18/%E6%95%99%E7%A8%8B%E7%B1%BB%E7%9A%84%E6%93%8D%E4%BD%9C%E4%B8%8E%E8%AE%A4%E8%AF%86/Github%E4%B8%8E%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/20200918-%E4%BB%8EGithub%E7%9A%84%E6%93%8D%E4%BD%9C%E5%88%B0SSH%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%BA%94%E7%94%A8.html</id>
    <published>2020-09-18T04:30:00.000Z</published>
    <updated>2021-02-06T15:23:38.289Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Github与班级作业"><a href="#Github与班级作业" class="headerlink" title="Github与班级作业"></a>Github与班级作业</h4><h5 id="从一个大事件说起"><a href="#从一个大事件说起" class="headerlink" title="从一个大事件说起"></a>从一个大事件说起</h5><a id="more"></a><p>长期的CURD让小明同学陷入生活的土拨鼠漩涡，这个框架也只是要记忆更多的规则。每天都会生理不适到想要呕吐… 痛定思痛，于是他倒吸一口气，花了几千大洋从黑客空间上买下了一门算法课程。课程要过些天才正式开始，但是想象自己能够在leetcode上各种造，他的内心满是欢喜…</p><p>课程本身有各种安排和各种口号，按图索骥，为了能够以一种统一的方式让大家交作业。要求每个学生都创建自己的Github账号，然后做一通操作。操作都有截图教程，小明不多想，一通操作猛如虎，然后就遇到了一个经典的现象：操作时，电脑没有按照教程预期地成功执行对应的操作；</p><p>小明一阵心绞痛，TM我再也做这些我根本不知道在干嘛的操作了。于是，唰唰唰，3分钟里标签页就开了10多个…</p><h5 id="小明看到的教程：克隆Github上的项目到本地"><a href="#小明看到的教程：克隆Github上的项目到本地" class="headerlink" title="小明看到的教程：克隆Github上的项目到本地"></a>小明看到的教程：<a href="https://shimo.im/docs/m5rtM8K8rNsjw5jk/read">克隆Github上的项目到本地</a></h5><h6 id="step0：从黑客空间提供的Github项目地址（用来交作业的仓库），fork这个项目到自己的账号下；"><a href="#step0：从黑客空间提供的Github项目地址（用来交作业的仓库），fork这个项目到自己的账号下；" class="headerlink" title="step0：从黑客空间提供的Github项目地址（用来交作业的仓库），fork这个项目到自己的账号下；"></a>step0：从黑客空间提供的Github项目地址（用来交作业的仓库），<strong>fork</strong>这个项目到自己的账号下；</h6><ul><li><p>Github是什么？</p><p>是：一个互联网上的网站；</p><p>作用：</p><ul><li>1 超大存储空间的U盘；</li><li>2 为用户<strong>管理自己所存储的东西</strong>提供各种类型的操作；</li></ul><p>特征：</p><ul><li>1 只要有网络，就可以对自己存储的东西进行访问（类似于百度网盘）；</li><li>2 能够记录用户<strong>对自己所存储内容的各种改动</strong>（类似于???）;</li></ul><p>应用：</p><ul><li>1 使用者使用Github对自己的项目（可能是代码项目也可能是其他的资料）进行历史版本管理；</li></ul><p>用法：</p><p>​    <font size=2>这个我还不是很熟悉，Github主要的应用是代码托管。并且还有社交化的属性，难点就在于具体用法 🚩Mark 找到好的教程后回来填坑</font></p><hr></li><li><p>fork是什么意思？</p><p>fork的英文本意是叉子。一个叉子有多个分叉，这是fork操作所借用的词语特性</p><p>在上面的语境中，fork一个项目有两个含义：</p><ul><li>1 把原始项目拷贝一份，得到<strong>与当前时刻的原始项目完全相同</strong>的一个项目副本；</li><li>2 把拷贝得到的项目副本存储在你自己的github账号下；</li></ul></li></ul><blockquote><p> 内心OS:计算机行业层出不穷的新缩写有时候真是叫人心累。</p><p> 一方面那些达则兼济天下的奇才把各种工具封装到<strong>路人可用</strong>的程度，</p><p> 另一方面为了知道自己到底在做什么，<strong>作为路人的我等</strong>又要去了解具体的实现原理。</p></blockquote><ul><li>前置条件：在Github的网站上注册一个账号（类似于注册QQ）</li></ul><p><font size=2>评论：这一步操作我知道自己在做什么，而且操作也是成功的；😄</font></p><h6 id="step1-在你的电脑上创建一个空文件夹，然后执行git命令，把这个空文件夹变成一个被Git管理的仓库；"><a href="#step1-在你的电脑上创建一个空文件夹，然后执行git命令，把这个空文件夹变成一个被Git管理的仓库；" class="headerlink" title="step1:在你的电脑上创建一个空文件夹，然后执行git命令，把这个空文件夹变成一个被Git管理的仓库；"></a>step1:在你的电脑上创建一个空文件夹，然后执行git命令，把这个空文件夹变成一个被Git管理的仓库；</h6><ul><li><p>Git是什么？</p><p>是：一个工具；</p><p>作用：对特定类型的文件进行版本管理；</p><hr></li><li><p>版本管理是什么？</p><ul><li><p>是：一个过程；</p></li><li><p>作用：记录一个文件从初始版本到当前版本的变化过程；</p></li><li><p>应用：</p><ul><li>1 不断扩展一个文件的功能（今天没干完，保存一下，明天接着来）；</li><li>2 尝试扩展文件的某个功能，如果尝试失败，则回退到之前功能正常的版本（后悔药）；</li></ul></li><li><p>特征：</p><ul><li>1 该工具只能在命令行环境下使用；</li><li>2 这样的工作方式下，不存在<strong>中心仓库</strong>这样的概念，终端程序员对代码有更大的自主权；</li><li>3 Git中使用<strong>仓库</strong>来描述<strong>一个被Git工具管理的文件夹</strong>；</li></ul></li><li><p>用法：</p><ul><li>1 在预期被Git管理的文件夹下，执行git命令git init；<ul><li>作用：在文件夹中创建一个.git的子目录，用来保存版本信息。文件夹也就从普通的文件夹变成了<strong>Git中的一个仓库</strong>；（鸟枪换铳/老母鸡变鸭）</li></ul></li><li>参考:<a href="http://www.ruanyifeng.com/blog/2018/10/git-internals.html">Git操作入门</a></li></ul></li></ul></li><li><p>评论：这一步我也清楚在做什么，并且操作是成功的；</p></li><li><p>前置条件：在你的电脑上已经安装了Git这个工具（在官网上就能找到教程 请认准官网）；</p></li></ul><h6 id="step2：配置Git使用者的用户名和邮箱；"><a href="#step2：配置Git使用者的用户名和邮箱；" class="headerlink" title="step2：配置Git使用者的用户名和邮箱；"></a>step2：配置Git使用者的用户名和邮箱；</h6><blockquote><p>为什么Git这种工具类的产品还需要注册用户呢？😱</p><p>答：Git其实更多用于团队中的多个成员合作一个项目，为了能够记录项目的某些改动具体是由哪一个成员做出的，所以需要记录使用Git的成员。Thus，使用Git前需要注册用户名与邮箱；</p></blockquote><ul><li><p>手段:git config命令</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">"用户名"</span></span><br><span class="line">git config --global user.email <span class="string">"邮箱"</span></span><br></pre></td></tr></table></figure></li><li><p>特征：手动配置完成关于Git的属性后，需要验证自己进行的配置是否已经生效了；</p><ul><li><p>手段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global --list <span class="comment">// 列表显式当前所有的配置信息</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h6 id="step3：配置Git的密钥；"><a href="#step3：配置Git的密钥；" class="headerlink" title="step3：配置Git的密钥；"></a>step3：配置Git的密钥；</h6><blockquote><p>为什么Git这种工具类的产品还需要有密钥呢？</p><p>答：密钥是用于加密通信双方的通信内容的；</p></blockquote><blockquote><p>#Q 我使用Git来记录项目中的改动，为什么会有通信过程的出现呢？</p><p>答：因为具体的使用场景是-</p><ul><li><p>1 主线项目托管在github上（比如Redis项目的开源代码）；</p></li><li><p>2 各路程序员分别fork一个项目副本到自己的github账号下（这一步并不总是必要吧😒）；</p><p>作用：项目fork到自己的账号下，程序员就对这个项目副本<strong>有完全的权限</strong>了，aka，可以自由编码</p></li><li><p>3 程序员A把fork得到的项目副本克隆到本地，愉快地做各种各样的尝试（策马奔腾）</p></li></ul><p>所以，在本地对文件进行改动后，需要<strong>把本地做出的改动通过网络提交到远程仓库上</strong>。通信的过程就是这么来的</p></blockquote><ul><li><blockquote><p>为啥会有通信我清楚了，但为啥会需要密钥的？</p><p>答：对于网络间的通信，为了保证通信的安全。一般都需要一些额外的措施来保证安全性；</p></blockquote><ul><li><blockquote><p>任务：保证通信过程的安全性；</p><p>手段：在通信时，选择某个支持安全通信的通信协议；</p><p>特征：</p><ul><li>1 通信协议都已经实现了通信安全的细节；</li><li>2 不同的通信协议有不同的特性；</li><li>3 支持安全通信的协议往往都会需要密钥（参考：协议的原理）；</li></ul></blockquote></li></ul></li></ul><hr><p>说明：在这里<strong>使用SSH协议</strong>来支持从本地仓库到远程仓库之间的安全通信；</p><p>原因：在<strong>对通信进行校验</strong>时，SSH协议可以<strong>通过配置公私钥的方式</strong>实现校验（而不需要像其他协议那样每次输入密码进行校验）；</p><blockquote><p>SSH协议；</p><p>是：一种网络通信/传输协议；</p><p>作用：保证网络通信的安全性；</p><p>原理：在网络中创建<strong>安全隧道</strong>来实现SSH客户端与服务端的连接；</p><p>应用：</p><ul><li>1 远程登录到其他的电脑主机上；</li></ul><p>用法：</p><ul><li>在主流的操作系统中，都有封装了这些通信协议的软件可以直接使用（比如Windows中的Secure CRT）。</li></ul></blockquote><hr><blockquote><p>SSH协议用于远程登录的基本用法；</p><p>任务：以user作为用户名来登录到远程主机host上；</p><p>手段/命令：$ ssh user@host</p><p>特征：</p><ul><li>1 主机上SSH服务一般在22端口启动；</li><li>2 在命令中使用-p参数可以修改客户端所连接到的主机端口（这是两边的事情，需要相互兼顾）</li></ul></blockquote><hr><blockquote><p>SSH协议能够保证安全通信的原理；</p><p>手段：公钥加密；</p><p>SOP:</p><ul><li>0 客户端发出登录请求给远程主机host；</li><li>1 收到请求后，远程主机host把自己的公钥响应给客户端；</li><li>2 客户端使用拿到的公钥<strong>对登录信息进行加密</strong>，然后再次请求远程主机host；</li><li>3 远程主机host接受到请求后，使用自己的私钥<strong>对加密后的登录信息进行解密</strong>——在服务器端对比密码，根据密码是否正确决定用户能否登录成功。</li></ul><p>特征：</p><ul><li>1 SSH协议中的公钥是远程主机自己签发的，没有经过第三方认证（不像https协议那样）；<ul><li>既然没有经过认证，第三方就很容易对公钥进行伪造。aka <strong>中间人攻击</strong></li></ul></li></ul></blockquote><hr><blockquote><p>中间人攻击；</p><p>是：一个术语；</p><p>作用：描述“利用通信过程原理上的缺陷，通过伪装通信方，而达到欺骗通信方的目的”的过程；</p><p>原理：</p><ul><li>既然远程主机的公钥是没有第三方认证的，我就可以伪造一个公钥，用来冒充远程主机的公钥（假设我使用了主机fake自己签发的公钥）；</li><li>在步骤1中，主机fake把自己的公钥发送给客户端；</li><li>在步骤2中，主机fake拦截来自客户端的请求，并直接对加密的登录信息进行解密（毕竟客户端是使用自己提供的公钥加密的嘛）。然后伪装成客户端向远程主机host发起登录请求；</li><li>最终远程主机会校验登录信息通过，fake成功（伪装客户端）登录到了远程主机中（😳）</li></ul></blockquote><hr><ul><li><p>SSH协议解决中间人攻击的手段；</p><ul><li><p>手段1：口令登录（即密码登录）；</p></li><li><p>原理：客户端手动校验主机的公钥并选择新人；</p><blockquote><p>SOP:</p><ul><li><p>键入命令尝试直接登录；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh user<span class="meta">@host</span> <span class="comment">// $是一个提示符，不是键入的内容</span></span><br></pre></td></tr></table></figure></li><li><p>SSH协议会给出一个提示信息：您当前登录的主机公钥为xxx，但是不确定它是不是您想要登录的主机…</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The authenticity of host <span class="string">'host (12.18.429.21)'</span> can<span class="string">'t be established.</span></span><br><span class="line"><span class="string">RSA key fingerprint is 98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d.</span></span><br><span class="line"><span class="string">Are you sure you want to continue connecting (yes/no)?</span></span><br></pre></td></tr></table></figure><blockquote><p>RSA key fingerprint:公钥指纹</p><p>是：对公钥字符串进行MD5计算的结果；</p><p>特征：</p><ul><li><p>1 RSA算法得到的公钥长度为1024位字符；</p></li><li><p>2 MD5计算后，得到的公钥指纹只有128位，且具有唯一性；</p><p>98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d</p></li></ul></blockquote></li><li><p>客户端拿到SSH协议提示的信息，再去远程主机的网站上找到它所公布出来的公钥。一一对照核对公钥是不是正确的；</p></li><li><p>经过核对后，客户端接受了当前主机的公钥；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Are you sure you want to <span class="keyword">continue</span> <span class="title">connecting</span> <span class="params">(yes/no)</span>? </span></span><br></pre></td></tr></table></figure></li><li><p>输入yes后，系统提示:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Warning: Permanently added <span class="string">'host,12.18.429.21'</span> (RSA) to the list of known hosts.</span><br></pre></td></tr></table></figure><p>警告：永久性地把主机xxx添加到认证主机的列表中；</p></li><li><p>然后系统提示输入密码（口令）；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Password:(enter password)</span><br></pre></td></tr></table></figure></li><li><p>密码正确，则登录成功👍</p></li></ul></blockquote></li><li><p>特征：</p><ul><li>再次登录时，很多步骤都会被简化（因为远程主机的公钥已经被存储在本地了）。会直接要求输入密码；</li></ul></li></ul></li></ul><hr><ul><li><p>手段2：公钥登录；</p></li><li><p>原理：</p><ul><li>1 客户端把自己的公钥存在远程主机上；</li><li>2 客户端尝试登录请求时，服务器在给客户端的响应中包含一个随机字符串；</li><li>3 客户端使用自己的私钥对随机字符串进行加密，然后再次尝试发送登录请求（包含加密后的字符串信息）；</li><li>4 请求达到远程主机后，远程主机使用<strong>1中存储的公钥</strong>对加密字符串进行解密；<ul><li>如果解密得到的字符串与自己之前响应的字符串相同，则：客户端是可信的，允许登录；</li><li>否则，不允许登录</li></ul></li></ul></li><li><p>特征：</p><ul><li>1 客户端不需要每次登录时都使用口令/密码；</li><li>2 要求客户端必须要提供自己的公钥；</li></ul><blockquote><p>客户端从哪儿能获取到自己的公钥？</p><ul><li><p>手段：使用ssh协议提供的命令自己生成一个；</p></li><li><p>命令：ssh-keygen</p></li><li><p>用法：</p><ul><li>1 键入命令后，一路回车；</li><li>2 想办法把生成的公钥放到远程主机上；</li></ul></li><li><p>结果：命令执行结束后，在$HOME/.ssh/目录下，会新生成两个文件——id_rsa.pub（公钥）和id_rsa（私钥）</p></li></ul></blockquote><p>更多细节，参考:<a href="https://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html">SSH协议之远程登录</a></p></li></ul><hr><p>  按照图文教程提供的命令，执行下来没得动静。但现在我知道我在做什么了：<strong>生成客户端的公钥</strong>，然后<strong>把生成的公钥字符串添加到远程主机中</strong>；</p><blockquote><p>任务1：生成客户端的公钥；</p><p>手段：ssh-keygen命令；</p><p>用法：一路回车（不设置私钥）；</p></blockquote><blockquote><p>任务2：把生成的公添加到远程主机中；</p><p>手段：Github的仓库提供了一个页面字段（<strong>页面字段</strong>是一个封装地很好地设置某个属性值地方式了，因为它不需要使用者打开某种类型的shell窗口-这玩意挺吓人的），在页面中填入公钥文件的内容即可；</p></blockquote><p>  评论：这一通操作后，客户端被远程仓库成功授权。以后提交本地仓库的改动就再也不需要输入密码了😄</p><blockquote><p>验证Git密钥的配置（客户端 + 远程仓库）是否成功；</p><p>手段：ssh -T <a href="mailto:git@github.com">git@github.com</a>命令；</p><p>用法：</p><ul><li>1 键入命令直接回车；</li><li>2 预期出现successfully…</li></ul></blockquote><h6 id="step4-把自己github账号下的远程仓库克隆到-拉取到本地，放肆玩耍"><a href="#step4-把自己github账号下的远程仓库克隆到-拉取到本地，放肆玩耍" class="headerlink" title="step4: 把自己github账号下的远程仓库克隆到/拉取到本地，放肆玩耍"></a>step4: 把自己github账号下的远程仓库克隆到/拉取到本地，放肆玩耍</h6><ul><li>手段：git clone命令；</li><li>用法：git clone &lt;远程仓库在指定协议下的url&gt;;</li><li>实例：git clone <a href="mailto:git@github.com">git@github.com</a>:henryinshanghai/algorithm017.git</li><li>特征：如果项目比较大，从github远程仓库拉取到本地会比较慢；</li><li>解决手段：<a href="https://www.bilibili.com/video/BV1aE411p7Cd?from=search&seid=7922504800095438521">用gitee做跳板</a></li></ul><blockquote><p>上面短短的4个步骤，小明就花了一天的时间。但现在如果小花也要弄这些操作，小明半个小时既可以搞定了</p><p>🚩但是小明的脑壳上始终有一篇阴云：SSH加密过程中的公钥和私钥到底是什么说法，有点子混沌…</p></blockquote><h5 id="把本地仓库的改动弄到自己账号下的远程仓库中"><a href="#把本地仓库的改动弄到自己账号下的远程仓库中" class="headerlink" title="把本地仓库的改动弄到自己账号下的远程仓库中"></a>把本地仓库的改动<em>弄到</em>自己账号下的远程仓库中</h5><blockquote><p>明确任务的各个阶段；</p><p>Git中的概念：</p><ul><li><p>工作区（Working Directory）；</p><p>是：一个文件夹/目录；</p><p>作用：程序员能够直接对这个目录/目录下的文件进行各种操作；</p><p>特征：</p><ul><li>1 这个目录接受Git版本工具的管理；</li><li>2 程序员能够把工作区的变动提交到xxx；</li></ul></li><li><p>版本库（Repository）；</p><ul><li><p>是：一个隐藏目录/.git；</p></li><li><p>作用：支持Git对工作区进行版本管理；</p></li><li><p>特征：</p><ul><li>1 这个隐藏目录就是Git的版本库；</li><li>2 版本库中有很多东西（引用:<a href="https://www.liaoxuefeng.com/wiki/896043488029600/897271968352576">工作区与暂存区</a>）：<ul><li>01 stage暂存区；</li><li>02 仓库的第一个分支master；</li><li>03 指向master的一个指针HEAD;</li></ul></li></ul><p><img src="https://s1.ax1x.com/2020/09/18/w5pNyF.png" alt="工作区与版本库"></p></li></ul></li><li><p>原理：Git版本库如何能够记录对文件的改动呢？</p><ul><li>step1：使用git add &lt;被修改的文件&gt;命令来<strong>把文件的变动添加stage暂存区</strong>；</li><li>step2：使用git commit xxx命令来提交改动，aka，<strong>把暂存区的内容提交到当前分支</strong>；</li></ul></li></ul><blockquote><p>这里廖雪峰的讲法似乎有很多人并不认同，明天还是要到官网上看看。see u tomorrow🌙</p></blockquote></blockquote><p>参考：<a href="https://git-scm.com/">Git官网</a></p><p>这个内容相对较多，分到下一篇吧</p><blockquote><p>until next time~ 😄</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;Github与班级作业&quot;&gt;&lt;a href=&quot;#Github与班级作业&quot; class=&quot;headerlink&quot; title=&quot;Github与班级作业&quot;&gt;&lt;/a&gt;Github与班级作业&lt;/h4&gt;&lt;h5 id=&quot;从一个大事件说起&quot;&gt;&lt;a href=&quot;#从一个大事件说起&quot; class=&quot;headerlink&quot; title=&quot;从一个大事件说起&quot;&gt;&lt;/a&gt;从一个大事件说起&lt;/h5&gt;</summary>
    
    
    
    <category term="Network" scheme="https://henryinshanghai.github.io/categories/Network/"/>
    
    
    <category term="Network" scheme="https://henryinshanghai.github.io/tags/Network/"/>
    
    <category term="Github Operation" scheme="https://henryinshanghai.github.io/tags/Github-Operation/"/>
    
  </entry>
  
  <entry>
    <title>验证一棵二叉树是否是二叉搜索树</title>
    <link href="https://henryinshanghai.github.io/Binary-Search-Tree/2020/09/17/%E7%AE%97%E6%B3%95/%E6%A0%91/20200917-%E9%AA%8C%E8%AF%81%E4%B8%80%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%A0%91%E6%98%AF%E5%90%A6%E6%98%AF%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html"/>
    <id>https://henryinshanghai.github.io/Binary-Search-Tree/2020/09/17/%E7%AE%97%E6%B3%95/%E6%A0%91/20200917-%E9%AA%8C%E8%AF%81%E4%B8%80%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%A0%91%E6%98%AF%E5%90%A6%E6%98%AF%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html</id>
    <published>2020-09-17T06:30:00.000Z</published>
    <updated>2020-09-17T12:57:09.943Z</updated>
    
    <content type="html"><![CDATA[<h4 id="LeetCode-98-验证一棵树是否是二叉搜索树"><a href="#LeetCode-98-验证一棵树是否是二叉搜索树" class="headerlink" title="LeetCode#98 验证一棵树是否是二叉搜索树"></a>LeetCode#98 验证一棵树是否是二叉搜索树</h4><h5 id="题设与要求"><a href="#题设与要求" class="headerlink" title="题设与要求"></a>题设与要求</h5><a id="more"></a><p><img src="https://s1.ax1x.com/2020/09/17/wfibon.png" alt="题设与要求"></p><h5 id="分析题目难点-amp-提出解决手段"><a href="#分析题目难点-amp-提出解决手段" class="headerlink" title="分析题目难点 &amp; 提出解决手段"></a>分析题目难点 &amp; 提出解决手段</h5><blockquote><p>什么是有效的二叉搜索树？</p><p>特征：</p><ul><li>1 左子树中的节点小于当前节点；</li><li>2 右子树中的节点大于当前节点；</li><li>3 左右子树都是BST；</li></ul></blockquote><blockquote><p>怎么能判断一棵树是不是同时满足这3条性质？</p><ul><li>左右子树都是BST；<ul><li>手段：在左右子树上递归调用用来判断的方法；</li></ul></li><li>左子树中的节点小于当前节点； &amp;&amp; 右子树中的节点大于当前节点；<ul><li>手段：对二叉树进行中序遍历（左 - 根 - 右），中序遍历时，判断当前节点是不是总大于上一个节点即可；</li></ul></li></ul></blockquote><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><ul><li>1 准备一个变量，记录<strong>中序遍历序列中的上一个节点的值</strong>；</li><li>2 定义一个递归方法isValidBST(),方法作用：判断指定的二叉树是否为BST；<ul><li>2-1 定义递归终结条件；</li><li>2-2 定义本级递归需要做的事情；<ul><li>实现中序遍历，通过比较当前节点与<strong>序列中的前一个节点</strong>的值来判断是否满足特性1、2；</li><li>在左右子树上递归调用isValidBST(),以此来判断是否满足特性3；</li></ul></li></ul></li></ul><h5 id="把思路翻译成代码"><a href="#把思路翻译成代码" class="headerlink" title="把思路翻译成代码"></a>把思路翻译成代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 准备一个变量用于绑定“中序序列中前一个节点的值”</span></span><br><span class="line"><span class="comment">// 之所以使用long类型，是因为测试用例中使用了一些对应类型的数据</span></span><br><span class="line"><span class="keyword">long</span> pre = Long.MIN_VALUE; <span class="comment">// -2的63次方</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归方法作用：判断给定的二叉树是不是BST，并返回布尔值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1 递归终结条件</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2 本级递归需要做的事情</span></span><br><span class="line">    <span class="comment">// 2-1 实现中序遍历：左节点 - 根节点 - 右节点</span></span><br><span class="line">    <span class="comment">// 左节点root.left;对于左节点，判断左节点是否是一个BST</span></span><br><span class="line">   <span class="keyword">if</span>(!isValidBST(root.left))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根节点（当前节点）对于当前节点，比较它与序列中的上一个节点的值，以判断二叉树是不是一个BST</span></span><br><span class="line">    <span class="keyword">if</span>(root.val &lt;= pre)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用当前节点来更新pre：中序序列中的前一个节点的值</span></span><br><span class="line">    pre = root.val;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> isValidBST(root.right); <span class="comment">// 三个特性都已经被判断，完满完成任务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="代码拆解SOP"><a href="#代码拆解SOP" class="headerlink" title="代码拆解SOP"></a>代码拆解SOP</h5><blockquote><p>1 以中序遍历规则遍历二叉树中的节点</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中序遍历规则: 左节点 - 根节点 - 右节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 左节点</span></span><br><span class="line">something(root.left);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根节点/当前节点</span></span><br><span class="line">    somethingElse(root);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 右节点</span></span><br><span class="line">    somethingOtherElse(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：<strong>以前序遍历的规则来执行遍历</strong>更像是一个执行框架；</p><blockquote><p>2 判断左右子树是否为BST；</p><p>手段：在左右子树上调用isValidBST()进行判断；</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 左子树</span></span><br><span class="line"><span class="keyword">if</span>(!isValidBST(root.left))&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 右子树</span></span><br><span class="line"><span class="keyword">if</span>(!isValidBST(root.right))&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="comment">// 这里其实可以简化为: return isValidBST(root.right);因为代码的判断已经结束了</span></span><br></pre></td></tr></table></figure><blockquote><p>3 比较当前节点与序列中的前一个节点值的大小（判断是否为升序）；</p><p>手段：使用一个变量pre来记录“前一个节点的值”；</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> pre = Long.MIN_VALUE; <span class="comment">// 使用long类型是因为测试用例中有这种类型的数据这里取long类型的最小值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 当前节点</span></span><br><span class="line"><span class="keyword">if</span>(root.val &lt; pre)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用当前节点的值来更新pre的值作用：使pre变量一直绑定“上一个被处理的节点的值（aka 序列中上一个节点的值）”</span></span><br><span class="line">    pre = root.val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="代码重现"><a href="#代码重现" class="headerlink" title="代码重现"></a>代码重现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> pre = Long.MIN_VALUE;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 递归终结条件 &amp; 鲁棒性代码</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 本级递归需要做的事情</span></span><br><span class="line"><span class="comment">// 1 按照中序遍历的规则处理二叉树中的节点</span></span><br><span class="line">    <span class="comment">// root.left;</span></span><br><span class="line">    <span class="keyword">if</span>(!isValidBST(root.left))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// root;</span></span><br><span class="line">    <span class="keyword">if</span>(root.val &lt;= pre)&#123; <span class="comment">// 注：根据BST的规则，这里要包含等号</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pre = root.val;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// root.right;</span></span><br><span class="line">    <span class="keyword">return</span> isValidBST(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="启示-技巧"><a href="#启示-技巧" class="headerlink" title="启示/技巧"></a>启示/技巧</h5><p>对于<strong>多个条件同时成立</strong>时才能得出的判断结果（boolean类型），这里的<strong>多个条件</strong>都是<strong>必要条件</strong>。</p><p>在进行判断逻辑时，<strong>应该逐一判断违反规则导致false的情况</strong>。</p><p>当所有违反规则的情况都被排除后，就可以放心地返回true了；</p><blockquote><p>alright, this is henry. until next time 😄</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;LeetCode-98-验证一棵树是否是二叉搜索树&quot;&gt;&lt;a href=&quot;#LeetCode-98-验证一棵树是否是二叉搜索树&quot; class=&quot;headerlink&quot; title=&quot;LeetCode#98 验证一棵树是否是二叉搜索树&quot;&gt;&lt;/a&gt;LeetCode#98 验证一棵树是否是二叉搜索树&lt;/h4&gt;&lt;h5 id=&quot;题设与要求&quot;&gt;&lt;a href=&quot;#题设与要求&quot; class=&quot;headerlink&quot; title=&quot;题设与要求&quot;&gt;&lt;/a&gt;题设与要求&lt;/h5&gt;</summary>
    
    
    
    <category term="Binary Search Tree" scheme="https://henryinshanghai.github.io/categories/Binary-Search-Tree/"/>
    
    
    <category term="Algorithm" scheme="https://henryinshanghai.github.io/tags/Algorithm/"/>
    
    <category term="Binary Search Tree" scheme="https://henryinshanghai.github.io/tags/Binary-Search-Tree/"/>
    
  </entry>
  
  <entry>
    <title>计算二叉树的最大深度（递归写法）</title>
    <link href="https://henryinshanghai.github.io/Binary-Tree/2020/09/17/%E7%AE%97%E6%B3%95/%E6%A0%91/20200917-%E8%AE%A1%E7%AE%97%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6%EF%BC%88%E9%80%92%E5%BD%92%E5%86%99%E6%B3%95%EF%BC%89.html"/>
    <id>https://henryinshanghai.github.io/Binary-Tree/2020/09/17/%E7%AE%97%E6%B3%95/%E6%A0%91/20200917-%E8%AE%A1%E7%AE%97%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6%EF%BC%88%E9%80%92%E5%BD%92%E5%86%99%E6%B3%95%EF%BC%89.html</id>
    <published>2020-09-17T02:30:00.000Z</published>
    <updated>2020-09-17T12:49:18.393Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Leetcode-104-计算二叉树的最大深度"><a href="#Leetcode-104-计算二叉树的最大深度" class="headerlink" title="Leetcode#104 计算二叉树的最大深度"></a>Leetcode#104 计算二叉树的最大深度</h4><a id="more"></a><h5 id="题设与要求"><a href="#题设与要求" class="headerlink" title="题设与要求"></a>题设与要求</h5><p><img src="https://s1.ax1x.com/2020/09/17/wRTu0H.png" alt="题设与要求"></p><h5 id="分析难点-amp-提出解决手段"><a href="#分析难点-amp-提出解决手段" class="headerlink" title="分析难点 &amp; 提出解决手段"></a>分析难点 &amp; 提出解决手段</h5><blockquote><p>二叉树的深度到底是啥意思？</p><ul><li>1 从根节点到子节点会构成一条路径；</li><li>2 深度指的就是路径中节点的个数；</li><li>3 二叉树的最大深度：二叉树中存在的所有路径中，最长路径的节点个数；</li></ul></blockquote><blockquote><p>如何得到二叉树中的一条路径？</p><p>答：使用深度优先遍历，一头扎到底，直到遇到叶子节点时，就得到了一条完整的路径；</p></blockquote><blockquote><p>如何能从多个路径中找到最长路径？</p><p>手段1：在一个循环的过程中，不断更新最长路径maxLength；</p><p>手段2：利用二叉树结构本身的递归性，递归地处理左、右子树。然后加和出maxLength；</p></blockquote><h5 id="思路（递归）"><a href="#思路（递归）" class="headerlink" title="思路（递归）"></a>思路（递归）</h5><ul><li>1 定义一个方法，方法作用：计算给定的二叉树的最大深度并返回；</li><li>2 准备递归方法的递归终结条件 aka 递归调用触底返回的条件；</li><li>3 准备本级递归需要做的事情；<ul><li>1 在更小规模的二叉树中执行递归方法提供的操作；</li><li>2 利用1中的返回值来得到本级递归需要的返回值；</li></ul></li></ul><h5 id="把思路翻译成代码"><a href="#把思路翻译成代码" class="headerlink" title="把思路翻译成代码"></a>把思路翻译成代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 递归方法；作用：返回指定二叉树的最大深度</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line"><span class="comment">// 2 递归终结条件：当前节点为nil</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3 本级递归需要做的事情：</span></span><br><span class="line">    <span class="comment">// 3-1 对当前节点的左右子树求最大深度</span></span><br><span class="line">    <span class="keyword">int</span> leftDepth = maxDepth(root.left);</span><br><span class="line">    <span class="keyword">int</span> rightDepth = maxDepth(root.right);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3-2 使用子问题的结果来得到本级递归需要返回的值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + Math.max(leftDepth, rightDepth);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="几点疑问"><a href="#几点疑问" class="headerlink" title="几点疑问"></a>几点疑问</h5><ul><li><p>1 既然递归操作的终点是叶子节点（左右节点为nil），那么递归终结条件能不能改成:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><ul><li>这样写会导致空指针异常，因为传入的参数root可以为null；相当于代码不够鲁棒</li></ul></li><li><p>2 if(root == null) return 0; 具体表示什么含义？</p><ul><li>1 作为递归终结条件，aka，在当前节点为nil节点时，递归调用开始返回（<strong>这不是最外层调用的返回，而只是上一级调用开始返回</strong>）</li><li>2 作为鲁棒性代码，aka，处理方法参数为null的情况；</li></ul></li></ul><h5 id="代码重现"><a href="#代码重现" class="headerlink" title="代码重现"></a>代码重现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归方法作用：计算给定二叉树的最大深度并返回</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 递归终止条件/鲁棒性代码</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 本级递归要完成的事情</span></span><br><span class="line">    <span class="keyword">int</span> leftDepth = maxDepth(root.left);</span><br><span class="line">    <span class="keyword">int</span> rightDepth = maxDepth(root.right);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + Math.max(leftDepth, rightDepth);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>until next time,mate 😄</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;Leetcode-104-计算二叉树的最大深度&quot;&gt;&lt;a href=&quot;#Leetcode-104-计算二叉树的最大深度&quot; class=&quot;headerlink&quot; title=&quot;Leetcode#104 计算二叉树的最大深度&quot;&gt;&lt;/a&gt;Leetcode#104 计算二叉树的最大深度&lt;/h4&gt;</summary>
    
    
    
    <category term="Binary Tree" scheme="https://henryinshanghai.github.io/categories/Binary-Tree/"/>
    
    
    <category term="Algorithm" scheme="https://henryinshanghai.github.io/tags/Algorithm/"/>
    
    <category term="Binary Tree" scheme="https://henryinshanghai.github.io/tags/Binary-Tree/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的前序遍历（迭代方式）</title>
    <link href="https://henryinshanghai.github.io/Binary-Node/2020/09/16/%E7%AE%97%E6%B3%95/%E6%A0%91/20200916-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E8%BF%AD%E4%BB%A3%E6%96%B9%E5%BC%8F%EF%BC%89.html"/>
    <id>https://henryinshanghai.github.io/Binary-Node/2020/09/16/%E7%AE%97%E6%B3%95/%E6%A0%91/20200916-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E8%BF%AD%E4%BB%A3%E6%96%B9%E5%BC%8F%EF%BC%89.html</id>
    <published>2020-09-16T14:30:00.000Z</published>
    <updated>2020-09-16T16:13:39.484Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Leetcode-144-二叉树的前序遍历（迭代方式）"><a href="#Leetcode-144-二叉树的前序遍历（迭代方式）" class="headerlink" title="Leetcode#144 二叉树的前序遍历（迭代方式）"></a>Leetcode#144 二叉树的前序遍历（迭代方式）</h4><h5 id="题设与要求"><a href="#题设与要求" class="headerlink" title="题设与要求"></a>题设与要求</h5><a id="more"></a><p><img src="https://s1.ax1x.com/2020/09/16/w2qXjK.png" alt="题设与要求"></p><h5 id="分析问题难点-amp-提出解决手段"><a href="#分析问题难点-amp-提出解决手段" class="headerlink" title="分析问题难点 &amp; 提出解决手段"></a>分析问题难点 &amp; 提出解决手段</h5><blockquote><p>提出解决手段，有时候会需要giant leap😱</p></blockquote><blockquote><p>1 什么是二叉树的前序遍历？</p><p>答：以前序遍历的规则对二叉树这种非线性结构中的节点进行遍历；</p><p>前序遍历规则：对二叉树中的任意一棵子树，遍历的顺序总是—根节点、左节点、右节点；</p></blockquote><blockquote><p>2 如何才能按照这样的顺序来遍历树中的节点呢？</p><p>分析：因为遍历树中节点时，会有往回走的动作（aka 回溯），所以用栈结构应该可以实现</p><p>答：</p><ul><li>1 把当前节点存入一个栈中；</li><li>2 出栈当前节点，并按照特定顺序来入栈当前节点的子节点；</li><li>3 出栈预期的节点，并处理该节点的子节点（放到一个循环中进行）；</li></ul></blockquote><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><ul><li>0 准备一个列表，用于存储当前遍历的节点；</li><li>1 准备一个栈，用于安排遍历二叉树节点的顺序；</li><li>2 把当前节点先入栈；</li><li>3 准备一个循环（栈不为空时执行循环体 aka 仍旧有未被处理的节点），在循环体中：<ul><li>1 弹出栈顶元素；</li><li>2 把栈顶元素的值添加到列表中；</li><li>3 把当前节点的子节点按照特定顺序添加到栈中（以便在遍历节点时，满足<strong>前序遍历所要求的顺序</strong>）</li><li>4 重复1-2-3，直到所有的节点都处理完成</li></ul></li></ul><h5 id="把思路翻译成代码"><a href="#把思路翻译成代码" class="headerlink" title="把思路翻译成代码"></a>把思路翻译成代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123; <span class="comment">// 树节点</span></span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">    </span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">        root = stack.pop();</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 先入栈右节点，以便出栈时得到的是左节点</span></span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="keyword">null</span>)&#123; <span class="comment">// 这里一定要进行判空，否则可能会NPE</span></span><br><span class="line">            stack.push(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(root.left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注：其实就是N叉树前序遍历的一个变体啦</p></blockquote><blockquote><p>until next time 😄</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;Leetcode-144-二叉树的前序遍历（迭代方式）&quot;&gt;&lt;a href=&quot;#Leetcode-144-二叉树的前序遍历（迭代方式）&quot; class=&quot;headerlink&quot; title=&quot;Leetcode#144 二叉树的前序遍历（迭代方式）&quot;&gt;&lt;/a&gt;Leetcode#144 二叉树的前序遍历（迭代方式）&lt;/h4&gt;&lt;h5 id=&quot;题设与要求&quot;&gt;&lt;a href=&quot;#题设与要求&quot; class=&quot;headerlink&quot; title=&quot;题设与要求&quot;&gt;&lt;/a&gt;题设与要求&lt;/h5&gt;</summary>
    
    
    
    <category term="Binary Node" scheme="https://henryinshanghai.github.io/categories/Binary-Node/"/>
    
    
    <category term="Algorithm" scheme="https://henryinshanghai.github.io/tags/Algorithm/"/>
    
    <category term="Binary Node" scheme="https://henryinshanghai.github.io/tags/Binary-Node/"/>
    
  </entry>
  
  <entry>
    <title>N叉树的前序遍历（迭代方式）</title>
    <link href="https://henryinshanghai.github.io/Node/2020/09/16/%E7%AE%97%E6%B3%95/%E6%A0%91/20200916-N%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E8%BF%AD%E4%BB%A3%E6%96%B9%E5%BC%8F%EF%BC%89.html"/>
    <id>https://henryinshanghai.github.io/Node/2020/09/16/%E7%AE%97%E6%B3%95/%E6%A0%91/20200916-N%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E8%BF%AD%E4%BB%A3%E6%96%B9%E5%BC%8F%EF%BC%89.html</id>
    <published>2020-09-16T12:30:00.000Z</published>
    <updated>2020-09-16T16:13:49.497Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Leetcode-589-N叉树的前序遍历（迭代方式）"><a href="#Leetcode-589-N叉树的前序遍历（迭代方式）" class="headerlink" title="Leetcode#589    N叉树的前序遍历（迭代方式）"></a>Leetcode#589    N叉树的前序遍历（迭代方式）</h4><h5 id="题设与要求"><a href="#题设与要求" class="headerlink" title="题设与要求"></a>题设与要求</h5><a id="more"></a><p><img src="https://s1.ax1x.com/2020/09/16/w2T2LQ.png" alt="题设与要求"></p><h5 id="分析难点-amp-提出解决手段"><a href="#分析难点-amp-提出解决手段" class="headerlink" title="分析难点&amp;提出解决手段"></a>分析难点&amp;提出解决手段</h5><blockquote><p>1 什么是N叉树的前序遍历？</p><p>答： 根节点 - 左子节点 - 中间节点（从左往右） - 右子节点</p></blockquote><blockquote><p>2 如何能够<strong>按照前序遍历的规则</strong>来遍历这样一个<strong>非线性数据结构</strong>中的节点呢？</p><ul><li>前序遍历的规则：根节点 - 左节点-…-右节点；</li><li>非线性数据结构：数据结构中有分叉的情况，因此如果使用不同的遍历规则，就会得到不同的结果（这些结果都是合理存在的）</li></ul><p>答：</p><ul><li>1 把当前节点存入一个栈中；</li><li>2 出栈当前节点，并按照特定顺序来入栈当前节点的子节点；</li><li>3 出栈预期的节点，并处理该节点的子节点（放到一个循环中进行）；</li></ul></blockquote><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><ul><li><p>0 准备一个列表，用于在合适的位置存储节点；</p></li><li><p>1 准备一个栈，用于以特定顺序处理<strong>树结构中的节点</strong>；</p></li><li><p>2 把当前节点root入栈；</p></li><li><p>3 准备一个循环（栈不为空时执行循环体），在循环体中：</p><ul><li>1 出栈当前元素；</li><li>2 把当前元素的子节点以特定顺序入栈；</li><li>重复步骤12，以便按照预期的顺序来处理节点；</li></ul></li></ul><h5 id="把思路翻译成代码"><a href="#把思路翻译成代码" class="headerlink" title="把思路翻译成代码"></a>把思路翻译成代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Node类型的定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Node&gt; children;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> _val)</span> </span>&#123;</span><br><span class="line">        val = _val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> _val, List&lt;Node&gt; _children)</span> </span>&#123;</span><br><span class="line">        val = _val;</span><br><span class="line">        children = _children;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preOrder</span><span class="params">(Node root)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 准备一个列表</span></span><br><span class="line">List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 鲁棒性代码</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 准备一个栈</span></span><br><span class="line">    Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 准备一个循环</span></span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">        root = stack.pop(); <span class="comment">// 注：此处出栈的元素必须绑定到root变量上，否则会超时</span></span><br><span class="line">        </span><br><span class="line">        res.add(root.val);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 把当前节点的子节点按照特定顺序入栈</span></span><br><span class="line">        <span class="comment">// 先入栈右边的节点，最后入栈左节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=root.children.size()-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123; <span class="comment">// 从右往左遍历</span></span><br><span class="line">            stack.push(root.children.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="代码重现"><a href="#代码重现" class="headerlink" title="代码重现"></a>代码重现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preOrder</span><span class="params">(Node root)</span></span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">    </span><br><span class="line">    Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">        <span class="comment">// 当前节点</span></span><br><span class="line">        root = stack.pop();</span><br><span class="line">        <span class="comment">// 以特定顺序入栈当前节点的子节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = root.children.size()-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">         stack.push(root.children.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>alright here, until next time 😄</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;Leetcode-589-N叉树的前序遍历（迭代方式）&quot;&gt;&lt;a href=&quot;#Leetcode-589-N叉树的前序遍历（迭代方式）&quot; class=&quot;headerlink&quot; title=&quot;Leetcode#589    N叉树的前序遍历（迭代方式）&quot;&gt;&lt;/a&gt;Leetcode#589    N叉树的前序遍历（迭代方式）&lt;/h4&gt;&lt;h5 id=&quot;题设与要求&quot;&gt;&lt;a href=&quot;#题设与要求&quot; class=&quot;headerlink&quot; title=&quot;题设与要求&quot;&gt;&lt;/a&gt;题设与要求&lt;/h5&gt;</summary>
    
    
    
    <category term="Node" scheme="https://henryinshanghai.github.io/categories/Node/"/>
    
    
    <category term="Algorithm" scheme="https://henryinshanghai.github.io/tags/Algorithm/"/>
    
    <category term="Node" scheme="https://henryinshanghai.github.io/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>N叉树的前序遍历</title>
    <link href="https://henryinshanghai.github.io/Node/2020/09/16/%E7%AE%97%E6%B3%95/%E6%A0%91/20200916-N%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86(%E9%80%92%E5%BD%92%E6%96%B9%E5%BC%8F).html"/>
    <id>https://henryinshanghai.github.io/Node/2020/09/16/%E7%AE%97%E6%B3%95/%E6%A0%91/20200916-N%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86(%E9%80%92%E5%BD%92%E6%96%B9%E5%BC%8F).html</id>
    <published>2020-09-16T10:30:00.000Z</published>
    <updated>2020-09-16T16:14:05.124Z</updated>
    
    <content type="html"><![CDATA[<h4 id="对N叉树进行前序遍历（递归方式）"><a href="#对N叉树进行前序遍历（递归方式）" class="headerlink" title="对N叉树进行前序遍历（递归方式）"></a>对N叉树进行前序遍历（递归方式）</h4><h5 id="题设与要求"><a href="#题设与要求" class="headerlink" title="题设与要求"></a>题设与要求</h5><a id="more"></a><p><img src="C:%5CUsers%5CHenryInSH%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200916215515549.png" alt="题设与要求"></p><h5 id="分析题目的难点"><a href="#分析题目的难点" class="headerlink" title="分析题目的难点"></a>分析题目的难点</h5><blockquote><p>1 N叉树的前序遍历是到底是什么？</p><p>根据上面的题目示例，前序遍历 = 根节点 + 左节点 - … - 右节点；</p></blockquote><blockquote><p>2 要怎样才能以前序遍历的顺序遍历N叉树中的节点？</p><p>手段：深度优先遍历(DFS) + 递归调用（因为是在重复进行规模更小的问题）；</p></blockquote><blockquote><p>3 如何能够存储<strong>当前正在被遍历的节点</strong>？</p><p>手段：准备一个列表，在遍历时，把当前节点添加进去；</p></blockquote><h5 id="递归思路"><a href="#递归思路" class="headerlink" title="递归思路"></a>递归思路</h5><ul><li>1 先处理<strong>当前节点对应的子树</strong>；</li><li>2 然后依次遍历<strong>当前节点的子节点所对应的子树</strong>，并使用相同的方式来处理<strong>该子树中的节点</strong>；</li></ul><h5 id="把思路翻译成代码"><a href="#把思路翻译成代码" class="headerlink" title="把思路翻译成代码"></a>把思路翻译成代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// N叉树的定义（题目已给出）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Node&gt; children; <span class="comment">// 有一堆的孩子节点</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> _val)</span> </span>&#123;</span><br><span class="line">        val = _val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> _val, List&lt;Node&gt; _children)</span> </span>&#123;</span><br><span class="line">        val = _val;</span><br><span class="line">        children = _children;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编写的代码</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="comment">// 准备一个数组，用于存储当前正在被遍历的节点</span></span><br><span class="line">List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定义前序遍历函数</span></span><br><span class="line">    <span class="comment">// 作用：以前序遍历的规则对N叉树中的节点进行遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 递归终结条件; / 递归调用触底返回的条件</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根节点（当前节点）</span></span><br><span class="line">        res.add(root.val);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按照顺序来遍历根节点的孩子节点</span></span><br><span class="line">        <span class="keyword">for</span>(Node child:root.children)&#123;</span><br><span class="line">            <span class="comment">// 对当前子节点进行递归调用（以在更小的规模上做同样的事情）</span></span><br><span class="line">            preorder(child);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="代码拆解SOP"><a href="#代码拆解SOP" class="headerlink" title="代码拆解SOP"></a>代码拆解SOP</h5><blockquote><p>1 准备一个列表，用来存储当前正在被遍历的节点；</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure><blockquote><p>2 使用递归的方式实现preOrder()方法；</p><ul><li>作用：按照前序遍历的规则把N叉树中的节点添加到列表中，并返回列表；</li><li>递归的手段：<ul><li>1 递归终结条件（递归调用触底返回条件）/ 鲁棒性代码；</li><li>2 定义本级递归需要完成的工作；<ul><li>1 缩小问题的规模，并对小规模的问题进行同样的处理；</li><li>2 使用小规模问题的处理结果来解决大问题；</li></ul></li></ul></li></ul></blockquote><blockquote><p>01 递归终止条件；</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归终结条件/递归调用触底返回的条件</span></span><br><span class="line"><span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure><blockquote><p>02 本级递归要做的事情；</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历当前节点的所有子节点</span></span><br><span class="line"><span class="keyword">for</span>(Node child : root.children)&#123;</span><br><span class="line">    <span class="comment">// 对子节点所表示的N叉树执行前序遍历操作</span></span><br><span class="line">    preOrder(child);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>3 在本级递归结束后，返回res列表</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure><h5 id="代码重现"><a href="#代码重现" class="headerlink" title="代码重现"></a>代码重现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preOrder</span><span class="params">(Node root)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 递归终止条件</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 本级递归的工作</span></span><br><span class="line">    <span class="keyword">for</span>(Node child:root.children)&#123;</span><br><span class="line">        preOrder(child);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 本级递归调用结束后的返回值</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>until next time😄</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;对N叉树进行前序遍历（递归方式）&quot;&gt;&lt;a href=&quot;#对N叉树进行前序遍历（递归方式）&quot; class=&quot;headerlink&quot; title=&quot;对N叉树进行前序遍历（递归方式）&quot;&gt;&lt;/a&gt;对N叉树进行前序遍历（递归方式）&lt;/h4&gt;&lt;h5 id=&quot;题设与要求&quot;&gt;&lt;a href=&quot;#题设与要求&quot; class=&quot;headerlink&quot; title=&quot;题设与要求&quot;&gt;&lt;/a&gt;题设与要求&lt;/h5&gt;</summary>
    
    
    
    <category term="Node" scheme="https://henryinshanghai.github.io/categories/Node/"/>
    
    
    <category term="Algorithm" scheme="https://henryinshanghai.github.io/tags/Algorithm/"/>
    
    <category term="Node" scheme="https://henryinshanghai.github.io/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>盛水最多的容器</title>
    <link href="https://henryinshanghai.github.io/Array/2020/09/15/%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84/20200915-%E7%9B%9B%E6%B0%B4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AE%B9%E5%99%A8.html"/>
    <id>https://henryinshanghai.github.io/Array/2020/09/15/%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84/20200915-%E7%9B%9B%E6%B0%B4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AE%B9%E5%99%A8.html</id>
    <published>2020-09-15T10:30:00.000Z</published>
    <updated>2020-09-16T13:42:33.106Z</updated>
    
    <content type="html"><![CDATA[<h4 id="使用数组构造盛水最多的容器"><a href="#使用数组构造盛水最多的容器" class="headerlink" title="使用数组构造盛水最多的容器"></a>使用数组构造盛水最多的容器</h4><h5 id="题设与要求"><a href="#题设与要求" class="headerlink" title="题设与要求"></a>题设与要求</h5><a id="more"></a><p><img src="https://s1.ax1x.com/2020/09/15/w6GfeK.png" alt="题设与要求"></p><h5 id="分析要求（得到难点）"><a href="#分析要求（得到难点）" class="headerlink" title="分析要求（得到难点）"></a>分析要求（得到难点）</h5><blockquote><p>如何才能让容器盛放尽可能多的水呢？</p><p>分析：V = S * D;    S = length * height;</p><ul><li><p>获取到length；</p><p>手段：使用数组中两个指针来求取指针间距length；</p></li><li><p>获取到height；</p><p>手段：两个指针指向的元素值的较小者（因为面积是由短板决定的）</p></li></ul></blockquote><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><ul><li><p>1 准备两个指针i、j，分别指向数组的头元素&amp;尾元素；</p></li><li><p>2 计算当前数组元素所围成的界面面积，并作为当前Smax；</p></li><li><p>3 准备一个循环，在循环中：</p><ul><li>1 按照<strong>特定规则</strong>来更新指针i/指针j，以使得面积S尽可能变大；</li><li>2 使用新的界面面积与旧的截面面积比较，从而更新Smax；</li></ul><hr><p>循环结束时得到的Smax就是数组元素可能围成的界面面积的最大值；</p></li><li><p>4 返回这个最大值即可；</p></li></ul><h5 id="把思路翻译成代码"><a href="#把思路翻译成代码" class="headerlink" title="把思路翻译成代码"></a>把思路翻译成代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span></span>&#123; <span class="comment">// 参数：一个由挡板高度作为元素所组成的数组</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 准备两个指针作用：指向数组的头元素与尾元素</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = height.length - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 准备一个循环作用：计算面积的最大值</span></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)&#123; <span class="comment">// 循环次数不可预期，使用while循环</span></span><br><span class="line">        <span class="comment">// 用旧的res 与 新的res中的较大者来更新res</span></span><br><span class="line">        res = Math.max(res, (j - i) * Math.min(height[i], height[j]));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 更新指针</span></span><br><span class="line">        <span class="keyword">if</span>(height[i] &lt; height[j])&#123; <span class="comment">// 如果指针指向的是一个短板，移动另一个指针肯定不会让Smax更大</span></span><br><span class="line">            i++; <span class="comment">// 所以这里移动表示短板的指针</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>until next time 😄</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;使用数组构造盛水最多的容器&quot;&gt;&lt;a href=&quot;#使用数组构造盛水最多的容器&quot; class=&quot;headerlink&quot; title=&quot;使用数组构造盛水最多的容器&quot;&gt;&lt;/a&gt;使用数组构造盛水最多的容器&lt;/h4&gt;&lt;h5 id=&quot;题设与要求&quot;&gt;&lt;a href=&quot;#题设与要求&quot; class=&quot;headerlink&quot; title=&quot;题设与要求&quot;&gt;&lt;/a&gt;题设与要求&lt;/h5&gt;</summary>
    
    
    
    <category term="Array" scheme="https://henryinshanghai.github.io/categories/Array/"/>
    
    
    <category term="Algorithm" scheme="https://henryinshanghai.github.io/tags/Algorithm/"/>
    
    <category term="Array" scheme="https://henryinshanghai.github.io/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>移动数组中的零到特定位置（双指针 + 交换操作）</title>
    <link href="https://henryinshanghai.github.io/Array/2020/09/15/%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84/20200915-%E7%A7%BB%E5%8A%A8%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%9B%B6%E5%88%B0%E7%89%B9%E5%AE%9A%E4%BD%8D%E7%BD%AE%EF%BC%88%E5%8F%8C%E6%8C%87%E9%92%88-+-%E4%BA%A4%E6%8D%A2%E6%93%8D%E4%BD%9C%EF%BC%89.html"/>
    <id>https://henryinshanghai.github.io/Array/2020/09/15/%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84/20200915-%E7%A7%BB%E5%8A%A8%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%9B%B6%E5%88%B0%E7%89%B9%E5%AE%9A%E4%BD%8D%E7%BD%AE%EF%BC%88%E5%8F%8C%E6%8C%87%E9%92%88-+-%E4%BA%A4%E6%8D%A2%E6%93%8D%E4%BD%9C%EF%BC%89.html</id>
    <published>2020-09-15T07:30:00.000Z</published>
    <updated>2020-09-15T11:13:06.848Z</updated>
    
    <content type="html"><![CDATA[<h4 id="把数组中所有的零元素移动到数组末尾"><a href="#把数组中所有的零元素移动到数组末尾" class="headerlink" title="把数组中所有的零元素移动到数组末尾"></a>把数组中所有的零元素移动到数组末尾</h4><h5 id="题设与要求"><a href="#题设与要求" class="headerlink" title="题设与要求"></a>题设与要求</h5><a id="more"></a><p><img src="https://s1.ax1x.com/2020/09/15/wyITmt.png" alt="题设与要求"></p><h5 id="分析（约束-amp-难点）"><a href="#分析（约束-amp-难点）" class="headerlink" title="分析（约束 &amp; 难点）"></a>分析（约束 &amp; 难点）</h5><ul><li><p>约束；</p><blockquote><p> 如何把0移动到数组末尾？</p></blockquote><blockquote><p>如何保持非零元素的相对顺序？</p></blockquote></li><li><p>难点；</p><blockquote><p>有可能用一个操作同时满足两个约束吗？</p><p>这时候需要使用具体考察一个测试用例[0, 1, 0, 3, 12]，否则操作的过程非常不清晰（除非你可以图形化的调试）</p></blockquote></li><li><p>手段；</p><ul><li>把非零元素与<strong>指针指向的元素</strong>进行交换；<ul><li>如果<strong>指针指向的元素</strong>为0，则：<ul><li>交换后，0元素就会被交换到数组的后面（它还可能被继续交换到数组更靠后的位置）；</li></ul></li><li>如果指针指向的元素不为0，则：<ul><li>交换操作等同于什么都没有做。</li></ul></li></ul></li><li>执行完成交换后，需要把两个指针都向后移动一个位置；</li></ul></li></ul><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><ul><li>1 准备两个指针：一个用于保持元素的相对顺序（anchor），一个用于遍历数组中的元素（explorer）；</li><li>2 对数组元素进行遍历，如果当前元素为非零元素，则：<ul><li>1 把当前元素与anchor指向的元素进行交换；<ul><li>作用：1 把非零元素绑定到了预期位置； 2 把0元素移动到了数组靠后的位置（这个0还可能继续向后移动）</li></ul></li><li>2 交换操作后，把anchor指针指向下一个位置；<ul><li>作用：使anchor指针指向<strong>非零元素预期被交换到的位置</strong>；</li></ul></li></ul></li></ul><blockquote><p>这个思路并不流畅，一点子都不流畅😳</p></blockquote><h5 id="把思路翻译成代码"><a href="#把思路翻译成代码" class="headerlink" title="把思路翻译成代码"></a>把思路翻译成代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeros</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 准备一个anchor指针；作用：指向非零元素预期被交换到的位置；</span></span><br><span class="line">    <span class="keyword">int</span> anchor = <span class="number">0</span>; <span class="comment">// 初始化指向数组的头元素；</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> explorer=<span class="number">0</span>; explorer &lt; nums.length; explorer++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[explorer] != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[anchor];</span><br><span class="line">            nums[anchor] = nums[explorer];</span><br><span class="line">            nums[explorer] = temp;</span><br><span class="line">            </span><br><span class="line">            anchor++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="添加鲁棒性代码"><a href="#添加鲁棒性代码" class="headerlink" title="添加鲁棒性代码"></a>添加鲁棒性代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(nums == <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="代码分解SOP"><a href="#代码分解SOP" class="headerlink" title="代码分解SOP"></a>代码分解SOP</h5><ul><li><p>1 准备anchor指针；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> anchor = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li><li><p>2 遍历数组元素，找到非零元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> explorer=<span class="number">0</span>; explorer &lt; nums.length; explorer++)&#123;</span><br><span class="line">    <span class="comment">// 找到非零元素...</span></span><br><span class="line">    <span class="keyword">if</span>(nums[explorer] != <span class="number">0</span>)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>找到非零元素后…</p><ul><li><p>1 把非零元素交换到预期的位置；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> temp = nums[explorer];</span><br><span class="line">nums[explorer] = nums[anchor];</span><br><span class="line">nums[anchor] = temp;</span><br></pre></td></tr></table></figure></li><li><p>2 把anchor指针移动到下一个位置；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">anchor++;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>遍历结束后，所有的非零元素都已经被交换到了预期位置，所有的0元素都已经被交换到了数组末尾；</p></li></ul><h5 id="代码重现"><a href="#代码重现" class="headerlink" title="代码重现"></a>代码重现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeros</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> anchor = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> explorer=<span class="number">0</span>; explorer &lt; nums.length; explorer++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[explorer] != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[explorer];</span><br><span class="line">            nums[explorer] = nums[anchor];</span><br><span class="line">            nums[anchor] = temp;</span><br><span class="line">            </span><br><span class="line">            anchor++;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>一个老年人可能对她的孙子有着令人讨厌的耐心，甚至各种苦口婆心也变成了叨叨叨 不听不听 和尚念经🐢</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;把数组中所有的零元素移动到数组末尾&quot;&gt;&lt;a href=&quot;#把数组中所有的零元素移动到数组末尾&quot; class=&quot;headerlink&quot; title=&quot;把数组中所有的零元素移动到数组末尾&quot;&gt;&lt;/a&gt;把数组中所有的零元素移动到数组末尾&lt;/h4&gt;&lt;h5 id=&quot;题设与要求&quot;&gt;&lt;a href=&quot;#题设与要求&quot; class=&quot;headerlink&quot; title=&quot;题设与要求&quot;&gt;&lt;/a&gt;题设与要求&lt;/h5&gt;</summary>
    
    
    
    <category term="Array" scheme="https://henryinshanghai.github.io/categories/Array/"/>
    
    
    <category term="Algorithm" scheme="https://henryinshanghai.github.io/tags/Algorithm/"/>
    
    <category term="Array" scheme="https://henryinshanghai.github.io/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>删除数组中的重复项</title>
    <link href="https://henryinshanghai.github.io/Array/2020/09/15/%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84/20200915-%E5%88%A0%E9%99%A4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9.html"/>
    <id>https://henryinshanghai.github.io/Array/2020/09/15/%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84/20200915-%E5%88%A0%E9%99%A4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9.html</id>
    <published>2020-09-15T07:30:00.000Z</published>
    <updated>2020-09-16T16:15:30.500Z</updated>
    
    <content type="html"><![CDATA[<h4 id="删除数组中的重复项"><a href="#删除数组中的重复项" class="headerlink" title="删除数组中的重复项"></a>删除数组中的重复项</h4><h5 id="题设与要求"><a href="#题设与要求" class="headerlink" title="题设与要求"></a>题设与要求</h5><a id="more"></a><p><font size=2>没有找到截长图的好用工具，所以先用图片拼接吧</font></p><p><img src="https://s1.ax1x.com/2020/09/15/w6uQyD.png" alt="题设与要求"></p><p><img src="https://s1.ax1x.com/2020/09/15/w6uhXF.png" alt="示例2"></p><p><img src="https://s1.ax1x.com/2020/09/15/w6Km7j.png" alt="备注说明"></p><h5 id="分析（约束-与-难点）"><a href="#分析（约束-与-难点）" class="headerlink" title="分析（约束 与 难点）"></a>分析（约束 与 难点）</h5><ul><li>如何找到排序数组中的重复项？   <ul><li>在排序数组中，重复的项一定是相邻的。所以只需要比较相邻的两个元素是否相等即可</li></ul></li><li>找到重复的元素后，如何把元素删除掉？   <ul><li>数组中删除元素的方式就只有覆盖元素了</li></ul></li></ul><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><ul><li>1 先找到数组中的重复元素；<ul><li>手段：比较两个指针指向的元素是否相等（因为可能同一个元素多次重复出现）</li></ul></li><li>2 然后删除掉重复多余的元素；<ul><li>手段：当出现新的元素/不重复元素时，把新元素覆盖到正确的位置上；</li></ul></li><li>3 处理数组中剩余的元素；<ul><li>既然我们只是要返回不重复的有序元素，后面的元素保留即可（如果需要可以填充为null）</li></ul></li></ul><h5 id="把思路翻译成代码"><a href="#把思路翻译成代码" class="headerlink" title="把思路翻译成代码"></a>把思路翻译成代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 准备两个指针，这样能够对数组元素进行预期的比较</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指针j作为数组的遍历指针即可</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;nums.length; j++)&#123;</span><br><span class="line">        <span class="comment">// 比较两个元素是否相等</span></span><br><span class="line">        <span class="comment">// 如果相等，说明出现了重复元素，则...移动后指针即可：j++</span></span><br><span class="line">        <span class="keyword">if</span>(nums[i] == nums[j])&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果不相等,说明出现了新元素，则...把新元素绑定到/覆盖到正确的位置上</span></span><br><span class="line">            <span class="comment">// 手段：把后指针指向的元素覆盖到前指针位置的下一个位置</span></span><br><span class="line">            <span class="comment">// 把前指针后移一位</span></span><br><span class="line">            i++; </span><br><span class="line">            <span class="comment">// 把新元素绑定到正确的位置</span></span><br><span class="line">            nums[i] = nums[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回nums[]数组的前N个元素（不重复）组成的子数组的长度</span></span><br><span class="line">    <span class="keyword">return</span> i+<span class="number">1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="代码分解"><a href="#代码分解" class="headerlink" title="代码分解"></a>代码分解</h5><blockquote><p>1 找到重复的元素；</p><p>手段：使用两个指针，比较数组中相邻的元素；</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>; <span class="comment">// like an anchor</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; nums.length; j++)&#123;</span><br><span class="line">        <span class="comment">// 比较相邻的两个元素作用：找到重复的元素</span></span><br><span class="line">        <span class="keyword">if</span>(nums[i] == nums[j])&#123;</span><br><span class="line">            <span class="comment">// 找到重复元素之后，要怎么处理？</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>2 处理找到的重复元素；</p><p>手段：把重复元素后面的新元素覆盖到/绑定到正确的位置上；</p><p>特征：这并没有删除多余的重复元素，只是构造出了一个不重复元素的子数组；</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j &lt; nums.length; j++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums[j] == nums[i])&#123;</span><br><span class="line">        <span class="comment">// 只移动后指针即可 j++</span></span><br><span class="line">        <span class="comment">// 手段：跳过本次循环的其他代码</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 找到新的元素时...</span></span><br><span class="line">        <span class="comment">// 把新元素绑定到正确的位置</span></span><br><span class="line">        i++;</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// 循环结束后，会得到一个无重复元素的子数组</span></span><br></pre></td></tr></table></figure><blockquote><p>3 返回有序子数组的长度；</p><p>手段：使用指针i的值凑出子数组的长度len；</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> i+<span class="number">1</span>;</span><br></pre></td></tr></table></figure><h5 id="代码重现"><a href="#代码重现" class="headerlink" title="代码重现"></a>代码重现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 这个鲁棒性代码和 if(nums == null) return 0;有差别吗</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; nums.length; j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[j] == nums[i])&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i++;</span><br><span class="line">            nums[i] = nums[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> i+<span class="number">1</span>; <span class="comment">// 返回有序子数组的长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>until next time 😄</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;删除数组中的重复项&quot;&gt;&lt;a href=&quot;#删除数组中的重复项&quot; class=&quot;headerlink&quot; title=&quot;删除数组中的重复项&quot;&gt;&lt;/a&gt;删除数组中的重复项&lt;/h4&gt;&lt;h5 id=&quot;题设与要求&quot;&gt;&lt;a href=&quot;#题设与要求&quot; class=&quot;headerlink&quot; title=&quot;题设与要求&quot;&gt;&lt;/a&gt;题设与要求&lt;/h5&gt;</summary>
    
    
    
    <category term="Array" scheme="https://henryinshanghai.github.io/categories/Array/"/>
    
    
    <category term="Algorithm" scheme="https://henryinshanghai.github.io/tags/Algorithm/"/>
    
    <category term="Array" scheme="https://henryinshanghai.github.io/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>移动数组中的零到特定位置</title>
    <link href="https://henryinshanghai.github.io/Array/2020/09/15/interview/20200915-%E7%A7%BB%E5%8A%A8%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%9B%B6%E5%88%B0%E7%89%B9%E5%AE%9A%E4%BD%8D%E7%BD%AE(%E5%8F%8C%E6%8C%87%E9%92%88+%E8%A6%86%E7%9B%96).html"/>
    <id>https://henryinshanghai.github.io/Array/2020/09/15/interview/20200915-%E7%A7%BB%E5%8A%A8%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%9B%B6%E5%88%B0%E7%89%B9%E5%AE%9A%E4%BD%8D%E7%BD%AE(%E5%8F%8C%E6%8C%87%E9%92%88+%E8%A6%86%E7%9B%96).html</id>
    <published>2020-09-15T06:30:00.000Z</published>
    <updated>2020-09-18T04:14:11.194Z</updated>
    
    <content type="html"><![CDATA[<h4 id="把数组中所有的零都移动到数组尾部"><a href="#把数组中所有的零都移动到数组尾部" class="headerlink" title="把数组中所有的零都移动到数组尾部"></a>把数组中所有的零都移动到数组尾部</h4><h5 id="题设与要求"><a href="#题设与要求" class="headerlink" title="题设与要求"></a>题设与要求</h5><a id="more"></a><p><img src="https://s1.ax1x.com/2020/09/15/wyITmt.png" alt="题目与示例"></p><h5 id="分析出问题的难点"><a href="#分析出问题的难点" class="headerlink" title="分析出问题的难点"></a>分析出问题的难点</h5><blockquote><p>如何把0都移到数组的末尾？</p></blockquote><blockquote><p>如何能保持非零元素的相对顺序呢？</p></blockquote><blockquote><p>bear in mind:</p><p>对于一维数组这种数据结构，能够执行的操作有：</p><ul><li>遍历（需要一个指针）；</li><li>比较两个元素（需要两个指针）<ul><li>相邻元素；</li><li>指针指向的元素；</li></ul></li><li>交换两个位置上的元素</li></ul></blockquote><ul><li>手段1：<ul><li>1 依次找到所有的非零元素，然后<strong>向前覆盖</strong>到特定的位置（以<strong>保持非零元素的相对顺序</strong>）；</li><li>2 把数组中那些没有被覆盖的位置填充上0；</li></ul></li></ul><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><ul><li><p>1 定义一个循环，顺序遍历数组中的每一个元素（遍历数组需要提供一个指针cursor）；</p></li><li><p>2 准备另一个指针expect_cover，用于指向<strong>当前非零元素预期覆盖的位置</strong>；</p><ul><li>初始化指向<strong>数组的头元素</strong>；</li></ul></li><li><p>3 当遇到非零元素时，则：</p><ul><li>1 把非零元素覆盖到<strong>expect_cover指针指向的位置</strong>；</li><li>2 把expect_cover指向向后移动一个位置；</li></ul><hr><p>遍历/循环结束后，所有的非零元素就已经按照相对顺序被绑定到了预期的位置；</p></li><li><p>4 把expect_cover指针指向的位置（&amp;后面的所有位置）上的元素都绑定0；</p></li></ul><h5 id="把思路翻译成代码"><a href="#把思路翻译成代码" class="headerlink" title="把思路翻译成代码"></a>把思路翻译成代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 准备一个指针 expect_cover初始化指向数组的头元素  作用：指向非零元素要绑定到的位置</span></span><br><span class="line">    <span class="keyword">int</span> expect_cover = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 准备一个循环作用：遍历数组，找到其中的非零元素以执行需要的操作</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> cursor = <span class="number">0</span>; cursor &lt; nums.length; cursor++) &#123;</span><br><span class="line">        <span class="comment">// 如果当前元素是非零元素,则：</span></span><br><span class="line">        <span class="keyword">if</span>(nums[cursor] != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 把元素覆盖到指定的位置</span></span><br><span class="line">            nums[expect_cover++] = nums[cursor]; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">/* 循环结束后，指针j指向最后一个非零元素的下一个位置 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把从expect_cover指针到数组末尾的所有位置都绑定0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> cursor = expect_cover; cursor &lt; nums.length; cursor++) &#123;</span><br><span class="line">        nums[expect_cover++] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="添加鲁棒性代码"><a href="#添加鲁棒性代码" class="headerlink" title="添加鲁棒性代码"></a>添加鲁棒性代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 鲁棒性代码</span></span><br><span class="line"><span class="keyword">if</span>(nums==<span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="使用不同的测试用例检查代码的正确性-amp-健壮性"><a href="#使用不同的测试用例检查代码的正确性-amp-健壮性" class="headerlink" title="使用不同的测试用例检查代码的正确性&amp;健壮性"></a>使用不同的测试用例检查代码的正确性&amp;健壮性</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">现在好像没有特别好的方式（只能在leetcode编辑器的控制台上修改测试用例）</span><br><span class="line"><span class="comment">// 修改测试用例的建议</span></span><br><span class="line">    <span class="number">1</span> 为空的情况；</span><br><span class="line">    <span class="number">2</span> 元素重复的情况；</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><h5 id="代码重现"><a href="#代码重现" class="headerlink" title="代码重现"></a>代码重现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeros</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 鲁棒性代码</span></span><br><span class="line">    <span class="keyword">if</span>(nums == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 不用做任何操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 准备一个指针expect_cover作用：指向预期被当前非零元素覆盖的位置；</span></span><br><span class="line">    <span class="keyword">int</span> expect_cover = <span class="number">0</span>; <span class="comment">// 初始化指向数组的头元素</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 准备一个循环作用：找到非零元素，并把它们按顺序绑定到预期的位置</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> cursor=<span class="number">0</span>; cursor &lt; nums.length; cursor++)&#123;</span><br><span class="line">        <span class="comment">// 如果当前元素为非零元素，则...</span></span><br><span class="line">        <span class="keyword">if</span>(nums[cursor] != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 把该元素绑定到预期的位置：如果一开始就是非零元素，这里其实就做了自己绑定到自己的操作</span></span><br><span class="line">            nums[expect_cover++] = nums[cursor];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 把expect_cover指针开始的所有位置都绑定0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> cursor=expect_cover; cursor &lt; nums.length; cursor++)&#123;</span><br><span class="line">        nums[cursor] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;把数组中所有的零都移动到数组尾部&quot;&gt;&lt;a href=&quot;#把数组中所有的零都移动到数组尾部&quot; class=&quot;headerlink&quot; title=&quot;把数组中所有的零都移动到数组尾部&quot;&gt;&lt;/a&gt;把数组中所有的零都移动到数组尾部&lt;/h4&gt;&lt;h5 id=&quot;题设与要求&quot;&gt;&lt;a href=&quot;#题设与要求&quot; class=&quot;headerlink&quot; title=&quot;题设与要求&quot;&gt;&lt;/a&gt;题设与要求&lt;/h5&gt;</summary>
    
    
    
    <category term="Array" scheme="https://henryinshanghai.github.io/categories/Array/"/>
    
    
    <category term="Algorithm" scheme="https://henryinshanghai.github.io/tags/Algorithm/"/>
    
    <category term="Array" scheme="https://henryinshanghai.github.io/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>移动数组中的零到特定位置</title>
    <link href="https://henryinshanghai.github.io/Array/2020/09/15/%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84/20200915-%E7%A7%BB%E5%8A%A8%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%9B%B6%E5%88%B0%E7%89%B9%E5%AE%9A%E4%BD%8D%E7%BD%AE(%E5%8F%8C%E6%8C%87%E9%92%88+%E8%A6%86%E7%9B%96).html"/>
    <id>https://henryinshanghai.github.io/Array/2020/09/15/%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84/20200915-%E7%A7%BB%E5%8A%A8%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%9B%B6%E5%88%B0%E7%89%B9%E5%AE%9A%E4%BD%8D%E7%BD%AE(%E5%8F%8C%E6%8C%87%E9%92%88+%E8%A6%86%E7%9B%96).html</id>
    <published>2020-09-15T06:30:00.000Z</published>
    <updated>2020-09-15T09:49:07.518Z</updated>
    
    <content type="html"><![CDATA[<h4 id="把数组中所有的零都移动到数组尾部"><a href="#把数组中所有的零都移动到数组尾部" class="headerlink" title="把数组中所有的零都移动到数组尾部"></a>把数组中所有的零都移动到数组尾部</h4><h5 id="题设与要求"><a href="#题设与要求" class="headerlink" title="题设与要求"></a>题设与要求</h5><a id="more"></a><p><img src="https://s1.ax1x.com/2020/09/15/wyITmt.png" alt="题目与示例"></p><h5 id="分析出问题的难点"><a href="#分析出问题的难点" class="headerlink" title="分析出问题的难点"></a>分析出问题的难点</h5><blockquote><p>如何把0都移到数组的末尾？</p></blockquote><blockquote><p>如何能保持非零元素的相对顺序呢？</p></blockquote><blockquote><p>bear in mind:</p><p>对于一维数组这种数据结构，能够执行的操作有：</p><ul><li>遍历（需要一个指针）；</li><li>比较两个元素（需要两个指针）<ul><li>相邻元素；</li><li>指针指向的元素；</li></ul></li><li>交换两个位置上的元素</li></ul></blockquote><ul><li>手段1：<ul><li>1 依次找到所有的非零元素，然后<strong>向前覆盖</strong>到特定的位置（以<strong>保持非零元素的相对顺序</strong>）；</li><li>2 把数组中那些没有被覆盖的位置填充上0；</li></ul></li></ul><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><ul><li><p>1 定义一个循环，顺序遍历数组中的每一个元素（遍历数组需要提供一个指针cursor）；</p></li><li><p>2 准备另一个指针expect_cover，用于指向<strong>当前非零元素预期覆盖的位置</strong>；</p><ul><li>初始化指向<strong>数组的头元素</strong>；</li></ul></li><li><p>3 当遇到非零元素时，则：</p><ul><li>1 把非零元素覆盖到<strong>expect_cover指针指向的位置</strong>；</li><li>2 把expect_cover指向向后移动一个位置；</li></ul><hr><p>遍历/循环结束后，所有的非零元素就已经按照相对顺序被绑定到了预期的位置；</p></li><li><p>4 把expect_cover指针指向的位置（&amp;后面的所有位置）上的元素都绑定0；</p></li></ul><h5 id="把思路翻译成代码"><a href="#把思路翻译成代码" class="headerlink" title="把思路翻译成代码"></a>把思路翻译成代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 准备一个指针 expect_cover初始化指向数组的头元素  作用：指向非零元素要绑定到的位置</span></span><br><span class="line">    <span class="keyword">int</span> expect_cover = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 准备一个循环作用：遍历数组，找到其中的非零元素以执行需要的操作</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> cursor = <span class="number">0</span>; cursor &lt; nums.length; cursor++) &#123;</span><br><span class="line">        <span class="comment">// 如果当前元素是非零元素,则：</span></span><br><span class="line">        <span class="keyword">if</span>(nums[cursor] != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 把元素覆盖到指定的位置</span></span><br><span class="line">            nums[expect_cover++] = nums[cursor]; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">/* 循环结束后，指针j指向最后一个非零元素的下一个位置 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把从expect_cover指针到数组末尾的所有位置都绑定0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> cursor = expect_cover; cursor &lt; nums.length; cursor++) &#123;</span><br><span class="line">        nums[expect_cover++] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="添加鲁棒性代码"><a href="#添加鲁棒性代码" class="headerlink" title="添加鲁棒性代码"></a>添加鲁棒性代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 鲁棒性代码</span></span><br><span class="line"><span class="keyword">if</span>(nums==<span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="使用不同的测试用例检查代码的正确性-amp-健壮性"><a href="#使用不同的测试用例检查代码的正确性-amp-健壮性" class="headerlink" title="使用不同的测试用例检查代码的正确性&amp;健壮性"></a>使用不同的测试用例检查代码的正确性&amp;健壮性</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">现在好像没有特别好的方式（只能在leetcode编辑器的控制台上修改测试用例）</span><br><span class="line"><span class="comment">// 修改测试用例的建议</span></span><br><span class="line">    <span class="number">1</span> 为空的情况；</span><br><span class="line">    <span class="number">2</span> 元素重复的情况；</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><h5 id="代码重现"><a href="#代码重现" class="headerlink" title="代码重现"></a>代码重现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeros</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 鲁棒性代码</span></span><br><span class="line">    <span class="keyword">if</span>(nums == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 不用做任何操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 准备一个指针expect_cover作用：指向预期被当前非零元素覆盖的位置；</span></span><br><span class="line">    <span class="keyword">int</span> expect_cover = <span class="number">0</span>; <span class="comment">// 初始化指向数组的头元素</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 准备一个循环作用：找到非零元素，并把它们按顺序绑定到预期的位置</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> cursor=<span class="number">0</span>; cursor &lt; nums.length; cursor++)&#123;</span><br><span class="line">        <span class="comment">// 如果当前元素为非零元素，则...</span></span><br><span class="line">        <span class="keyword">if</span>(nums[cursor] != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 把该元素绑定到预期的位置：如果一开始就是非零元素，这里其实就做了自己绑定到自己的操作</span></span><br><span class="line">            nums[expect_cover++] = nums[cursor];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 把expect_cover指针开始的所有位置都绑定0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> cursor=expect_cover; cursor &lt; nums.length; cursor++)&#123;</span><br><span class="line">        nums[cursor] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;把数组中所有的零都移动到数组尾部&quot;&gt;&lt;a href=&quot;#把数组中所有的零都移动到数组尾部&quot; class=&quot;headerlink&quot; title=&quot;把数组中所有的零都移动到数组尾部&quot;&gt;&lt;/a&gt;把数组中所有的零都移动到数组尾部&lt;/h4&gt;&lt;h5 id=&quot;题设与要求&quot;&gt;&lt;a href=&quot;#题设与要求&quot; class=&quot;headerlink&quot; title=&quot;题设与要求&quot;&gt;&lt;/a&gt;题设与要求&lt;/h5&gt;</summary>
    
    
    
    <category term="Array" scheme="https://henryinshanghai.github.io/categories/Array/"/>
    
    
    <category term="Algorithm" scheme="https://henryinshanghai.github.io/tags/Algorithm/"/>
    
    <category term="Array" scheme="https://henryinshanghai.github.io/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>计算机基础（1）</title>
    <link href="https://henryinshanghai.github.io/Computer-Basic/2020/09/14/interview/20200914-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%EF%BC%881%EF%BC%89.html"/>
    <id>https://henryinshanghai.github.io/Computer-Basic/2020/09/14/interview/20200914-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%EF%BC%881%EF%BC%89.html</id>
    <published>2020-09-14T14:30:00.000Z</published>
    <updated>2020-09-14T14:58:20.770Z</updated>
    
    <content type="html"><![CDATA[<h5 id="计算机中数据的表示方式"><a href="#计算机中数据的表示方式" class="headerlink" title="计算机中数据的表示方式"></a>计算机中数据的表示方式</h5><a id="more"></a><blockquote><p>知识卡：在计算机中，数据是使用二进制进行表示的；</p><p>原因：</p><ul><li>1 计算机内部是由IC（集成电路）构成的；</li><li>2 IC的每个引脚，只能表示两种状态——二进制与IC的特性非常吻合😄；</li></ul><p>手段：IC的一个引脚表示二进制数中的一位bit（<strong>计算机中信息的最小单位</strong>）；</p><p>特征：</p><ul><li>1 二进制数字的位数一般是8的倍数；<ul><li>原因：计算机处理信息的基本单元是8位二进制数（一个字节）；</li><li>应用：内存和磁盘使用<strong>字节单位</strong>来读写数据；</li><li>用法：<ul><li>1 如果被处理的数字小于存储它所使用的字节空间，则：在数字的高位上补0；</li></ul></li></ul></li><li>2 不同的处理器的引脚数量不相同，因此一次能够处理的二进制数据的位数也就不同（比如奔腾32位处理器，一次就可以处理32位的二进制数信息 🚩 不太懂）</li></ul><p>结论：计算机中，使用二进制数来表示一切信息；</p></blockquote><blockquote><p>知识卡：数字的位权；</p><ul><li>是：特定<strong>位数上的数字</strong>所表示的实际权重； </li><li>作用：描述<strong>当前位数上的数字</strong>所表示的实际数值大小；</li><li>特征：<ul><li>1 数字所在的位数不同，数字的权重也就不同；</li><li>2 不同的进制下，特定位数的权重是不一样的；</li></ul></li><li>应用：<ul><li>计算<strong>特定进制下</strong>，某个<strong>数据表示方式</strong>所表示的<strong>实际数值大小</strong><ul><li>十进制下123的实际大小 = 1 × 100（数字1的位权） + 2 × 10（数字2的位权） + 3 × 1（数字3的位权）；</li></ul></li></ul></li></ul></blockquote><blockquote><p>知识卡：N进制；</p><ul><li>是：一种记录大数值的技术；</li><li>作用：表示大的数值；</li><li>特征：<ul><li>1 N进制的基数为N aka 如果一个位数上的数字达到了N，就会发生进位操作；</li><li>2 数值 = SUM(位上的数字 × 当前位数的权重)；</li></ul></li></ul></blockquote><h6 id="二进制中的运算规则"><a href="#二进制中的运算规则" class="headerlink" title="二进制中的运算规则"></a>二进制中的运算规则</h6><ul><li><p>常见的四则运算：加、减、乘除？？？</p></li><li><p>二进制中特有的运算：</p><ul><li><p>1 移位运算；</p><ul><li><p>作用：把二进制数值的各个数位进行移动（shift）；</p></li><li><p>特征：</p><ul><li><p>1 移动时有两个方向：向高位移动 + 向低位移动；</p></li><li><p>2 移位操作可以一次性移动多个数位；</p></li><li><p>3 可以直接对10进制数字进行移位操作，因为它的底层表示仍旧是二进制数；</p><hr></li><li><p>移动操作会导致一些位上的数字位空，怎么办？</p><ul><li>1 如果是向左移动，说明低权重的位会空出来，而高权重的位会溢出边界。则：<ul><li>给低权重的位数上补0；</li><li>把高权位的位数丢弃； </li></ul></li><li>2 如果是向右移动，说明高权重的位会空出来。则：<font size=2>有点子复杂，单独认识🚩<a href="#rightMove">跳转</a></font></li></ul></li></ul></li><li><p>用法/语法：待操作的数字 &lt;&lt; 预期移动的位数量；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">39</span>;</span><br><span class="line"><span class="keyword">int</span> b = a &lt;&lt; <span class="number">2</span>; <span class="comment">// 把39的二进制数值向左移动两个位置，然后把移位之后的结果绑定到变量b上</span></span><br></pre></td></tr></table></figure></li><li><p>应用：使用移位运算来代替乘法/除法；</p><ul><li>二进制数字左移一位，则其对应的十进制表示会变成原来的2倍；</li><li>二进制数字右移一位，则其对应的十进制表示会变成原来的1/2倍；</li></ul><p>由于CPU能够直接对二进制数字进行运算，所以移位运算的效率要比乘除法要高（CPU也不会计算乘除法😳）</p></li></ul></li></ul></li></ul><h6 id="二进制中，如何表示负数？"><a href="#二进制中，如何表示负数？" class="headerlink" title="二进制中，如何表示负数？"></a>二进制中，如何表示负数？</h6><ul><li><p>手段：把<strong>二进制数字的最高位</strong>作为<strong>符号位</strong>使用；</p></li><li><p>规则：</p><ul><li>1 符号位的数字是0时，表示正数；</li><li>2 符号位的数字是1时，表示负数；</li></ul></li><li><p>用法：</p><ul><li><p>任务：使用8位二进制数字来表示（-1）DEC;</p><ul><li><p>错误手段：</p><ul><li>1 把(1)DEC转化为其二进制表示(0000 0001)BIN;</li><li>2 为1中得到的二进制表示添加符号位，得到(1000 0001)BIN;</li></ul><p>原因：在表示负数时，需要使用<strong>二进制数字的补数</strong>；而不是单纯地添加一个符号位🌚</p><blockquote><p>知识卡：补数；</p><p>是：二进制中的一种性质；</p><p>作用：表示负数；</p><p>特征：</p><ul><li>它会使用正数来表示一个负数；（因为计算机只会做加法）；</li></ul><p>用法SOP：计算一个<strong>二进制数字的补数（用来表示负数）</strong>；</p><ul><li>1 把二进制数的各个数位上的数值全部取反；</li><li>2 把1中得到的结果+1；</li></ul><p>应用：<strong>求一个二进制数字的负数</strong>等价于<strong>求这个二进制数字的补数</strong>；</p></blockquote></li><li><p>正确手段：</p><ul><li><p>1 计算(-1)DEC的绝对值，得到(1)DEC；</p></li><li><p>2 求(1)DEC的补数，从而得到(-1)DEC的二进制表示；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把十进制的正数转化为二进制</span></span><br><span class="line">(<span class="number">1</span>)DEC = (<span class="number">0000</span> <span class="number">0001</span>)BIN</span><br><span class="line"><span class="comment">// 求二进制数字的补数</span></span><br><span class="line">Ⅰ 取反；</span><br><span class="line">(<span class="number">0000</span> <span class="number">0001</span>)BIN =&gt; (<span class="number">1111</span> <span class="number">1110</span>)BIN</span><br><span class="line">Ⅱ +<span class="number">1</span>；</span><br><span class="line">(<span class="number">1111</span> <span class="number">1110</span>)BIN + <span class="number">1</span> =&gt; (<span class="number">1111</span> <span class="number">1111</span>)BIN</span><br></pre></td></tr></table></figure><p>所以(-1)正确的二进制表示为(1111 1111)BIN;</p></li></ul></li></ul></li></ul></li><li><p>原理/证明其正确性：</p><ul><li><p>(1)DEC的二进制表示 与 (-1)DEC的二进制表示，相加的结果是否为0；</p><p>结论：当<strong>使用补数的方式来表示负数</strong>时，A + (-A) = 0这个表达式才是成立的；</p></li></ul></li></ul><blockquote><p>二进制数字的运算法则：</p><p>把二进制数字<strong>取反后加1</strong>（得到其补数）的结果，与原来的值相加，结果为0；</p><p>简言之，一个二进制数的负数形式其实就是它的补数；</p></blockquote><h6 id="在任何运算场景中，总是可以使用补数来表示一个负数吗？"><a href="#在任何运算场景中，总是可以使用补数来表示一个负数吗？" class="headerlink" title="在任何运算场景中，总是可以使用补数来表示一个负数吗？"></a>在任何运算场景中，总是可以使用补数来表示一个负数吗？</h6><ul><li><p>结论：是的；</p></li><li><p>特征：</p><ul><li>如果计算结果是负数，那么计算结果的值<strong>也是用补数形式来表示的</strong>；</li></ul></li><li><p>计算示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">任务：求(<span class="number">3</span> - <span class="number">5</span>)的二进制表示；</span><br><span class="line"><span class="number">1</span>. 把减法转化为加法；</span><br><span class="line">    （<span class="number">3</span> - <span class="number">5</span>） =&gt; (<span class="number">3</span> + (-<span class="number">5</span>))</span><br><span class="line"><span class="number">2</span>. 把十进制数转化为二进制数；</span><br><span class="line">    <span class="number">3</span>的二进制数字：<span class="number">0000</span> <span class="number">0011</span></span><br><span class="line">    (-<span class="number">5</span>)的二进制数字：</span><br><span class="line">    <span class="number">5</span>的二进制数字：<span class="number">0000</span> <span class="number">0101</span></span><br><span class="line">    (-<span class="number">5</span>)的二进制数字：<span class="number">1111</span> <span class="number">1011</span></span><br><span class="line"><span class="number">3</span> 对转化后的二进制数字执行加法运算；</span><br><span class="line">    (<span class="number">3</span> + (-<span class="number">5</span>)) &lt;=&gt; <span class="number">0000</span> <span class="number">0011</span> + <span class="number">1111</span> <span class="number">1011</span></span><br></pre></td></tr></table></figure></li></ul><h6 id="补数在编程语言中的应用？"><a href="#补数在编程语言中的应用？" class="headerlink" title="补数在编程语言中的应用？"></a>补数在编程语言中的应用？</h6><blockquote><p>知识卡：一个以1开头的二进制数总是负数吗？</p><p>答：No.只有在<strong>规定把第一个数位视为符号位</strong>时，以1开头的二进制数才会是一个负数；</p></blockquote><p>C语言中的整数数据类型：</p><ul><li><p>unsigned short类型；</p><ul><li>特征：<ul><li>1 不能够处理负数；</li><li>2 占用两个字节的内存空间；</li><li>3 所能够表示整数的数据范围：0~65535；</li></ul></li></ul></li><li><p>short类型；</p><ul><li>特征：<ul><li>1 能够处理负数；</li><li>2 占用两个字节的内存空间；</li><li>3 所能够表示的整数数据范围：-32768~32767；</li></ul></li></ul></li><li><p>原理：为什么特征上会有这些差异（① 能否表示负数？ ② 所能表示的整数的数据范围）</p><ul><li>1 是否把二进制数字的第一位作为符号位；<ul><li>unsigned short没有这么做，因此它只能够表示正整数；</li><li>short类型<strong>规定了二进制数字的第一位是符号位</strong>，所以它能够表示正整数 &amp; 负整数；</li></ul></li><li>2 数据类型占用的内存空间，决定了该数据类型能够表示多少种结果；<ul><li>两者都占据2个字节（16个bit），所以能够表示2的16次方个结果（65536）；</li></ul></li><li>3 short类型规定了符号位的存在，所以可以用补数来表示负数；<ul><li>1 最高位为0时（表示这是一个正数），可以使用剩下的15bit来表示数值。所以正数的范围为0~32767（共32768个结果 = 2的15次方）；</li><li>2 最高位为1时（表示这是一个负数），仍旧可以用剩下的15bit来表示数值。但是数值范围不需要包括0，所以负数的范围是-1~-32768(共32768个结果，不包含0)</li></ul></li></ul><h6 id="二进制数字的右移操作"><a href="#二进制数字的右移操作" class="headerlink" title="二进制数字的右移操作"></a>二进制数字的右移操作</h6></li></ul><p>二进制数字的应用：</p><ul><li><p>表示<strong>图形模式</strong>；</p><ul><li><p>这种情况下，进行右移操作时，就：只需要在移动后空出的高权重位上补0；</p></li><li><p>这种情况下的右移操作也叫做<strong>逻辑右移</strong>；</p><p><img src="https://s1.ax1x.com/2020/09/14/wr4Q7F.png" alt="逻辑右移，高位补零"></p></li></ul></li><li><p>表示<strong>带符号的数值</strong>；</p><ul><li><p>这种情况下，进行右移操作时，就：需要在移动后空出来的高权重位上补<strong>原始二进制数字符号位的值</strong>；</p><ul><li>如果原始的二进制数字为正数，则：在高权重位上补0；</li><li>如果原始的二进制数字为负数（补数表示），则：在高权重位上补1；</li></ul></li><li><p>这种情况下的右移操作也叫做<strong>算术移位</strong>；</p></li><li><p>应用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">任务：对(-<span class="number">4</span>)DEC执行算术右移，计算右移两位后的结果；</span><br><span class="line">预期：(-<span class="number">4</span>)右移两位后，得到的结果 = (-<span class="number">4</span>) * (<span class="number">1</span>/<span class="number">2</span>) * (<span class="number">1</span>/<span class="number">2</span>) = (-<span class="number">1</span>)DEC</span><br><span class="line">手段：按照算术移位的规则进行移位操作；</span><br><span class="line">SOP:</span><br><span class="line"><span class="number">1</span> 把(-<span class="number">4</span>)DEC转化为二进制数字；</span><br><span class="line">        <span class="number">4</span> =&gt; <span class="number">0000</span> <span class="number">0100</span></span><br><span class="line">        (-<span class="number">4</span>) =&gt; <span class="number">1111</span> <span class="number">1100</span></span><br><span class="line"><span class="number">2</span> 对<span class="number">1</span>中得到的二进制数字执行算术右移，移动<span class="number">2</span>位；</span><br><span class="line">        规则：在空出的高权重位上补<span class="string">"原始二进制数字符号位的值"</span>；</span><br><span class="line">        <span class="number">1111</span> <span class="number">1100</span> =&gt; (右移两位) xx11 <span class="number">1111</span> =&gt;(高权重位补“👆”) <span class="number">1111</span> <span class="number">1111</span></span><br><span class="line"><span class="number">3</span> 验证得到的二进制结果是否符合预期；</span><br><span class="line">        手段：把二进制数字转化为DEC进制数字；</span><br><span class="line">        注：这个二进制数字是规定了符号位的二进制数字；</span><br><span class="line">        具体方法（尝试）：求出补数的原始数值；</span><br><span class="line">        SOP:</span><br><span class="line"><span class="number">1</span> 减<span class="number">1</span>； <span class="number">1111</span> <span class="number">1111</span> - <span class="number">0000</span> <span class="number">0001</span> = <span class="number">1111</span> <span class="number">1110</span></span><br><span class="line"><span class="number">2</span> 取反；<span class="number">1111</span> <span class="number">1110</span> =&gt;(取反后) <span class="number">0000</span> <span class="number">0001</span></span><br><span class="line"><span class="number">3</span> 把计算结果转化为DEC进制；(<span class="number">0000</span> <span class="number">0001</span>)BIN = (<span class="number">1</span>)DEC</span><br><span class="line">SO:</span><br><span class="line">补数对应的原始数字为<span class="number">1</span>，说明补数表示的DEC数字为(-<span class="number">1</span>);</span><br><span class="line">结论：符合预期 😄；</span><br></pre></td></tr></table></figure><p>参考图示:<img src="https://s1.ax1x.com/2020/09/14/wrTAbV.png" alt="逻辑右移 VS 算术右移"></p></li></ul></li></ul><blockquote><p>只有在右移操作时，才需要考虑<strong>逻辑移位</strong>与<strong>算术移位</strong>的差别；</p><p>左移操作（图形模式下表示单纯地移动，数值模式下表示乘法）时，就：在空位补零即可；</p></blockquote><h6 id="把一个8位二进制数字表示成8-N位二进制数字？"><a href="#把一个8位二进制数字表示成8-N位二进制数字？" class="headerlink" title="把一个8位二进制数字表示成8*N位二进制数字？"></a>把一个8位二进制数字表示成8*N位二进制数字？</h6><ul><li>手段：符号位扩充；</li><li>作用：把二进制数字的位数转化为其他8的倍数；</li><li>用法：<ul><li>1 如果二进制数字是正数，则：用符号位0填充高权重的位即可；</li><li>2 如果二进制数字是负数（用补数表示），则：用符号位1填充高权重的位即可；</li></ul></li></ul><h6 id="计算机可以执行的运算"><a href="#计算机可以执行的运算" class="headerlink" title="计算机可以执行的运算"></a>计算机可以执行的运算</h6><ul><li>算术运算；<ul><li>是：加减乘除四则运算；</li><li>作用：按照特定的规则，操作得到预期的结果；</li><li>特征：<ul><li>与十进制数的加减乘除一样，也涉及到进位问题；</li></ul></li></ul></li><li>逻辑运算；<ul><li>是：一种操作；</li><li>作用：按照特定的规则，操作得到预期的结果；</li><li>特征：<ul><li>1 对二进制数各数字位的0或1会分别进行处理；</li><li>2 不存在进位的问题；</li><li>3 有4种具体的运算；<ul><li>1 逻辑非(NOT运算)；<ul><li>规则：0变1，1变0；</li></ul></li><li>2 逻辑与(AND运算)；<ul><li>规则：全1为1，否则为0；</li></ul></li><li>3 逻辑或(OR运算)；<ul><li>规则：有1为1，否则为0；</li></ul></li><li>4 逻辑异或(XOR运算 exclusive-or 独家的/不同的)；<ul><li>规则：不同为1，相同为0；</li></ul></li></ul></li></ul></li><li>技巧：<ul><li>1 逻辑运算中，<strong>二进制数表示的不是数值，而是一组ON/OFF开关</strong>；</li><li>2 逻辑运算真值表的规律；</li></ul></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h5 id=&quot;计算机中数据的表示方式&quot;&gt;&lt;a href=&quot;#计算机中数据的表示方式&quot; class=&quot;headerlink&quot; title=&quot;计算机中数据的表示方式&quot;&gt;&lt;/a&gt;计算机中数据的表示方式&lt;/h5&gt;</summary>
    
    
    
    <category term="Computer Basic" scheme="https://henryinshanghai.github.io/categories/Computer-Basic/"/>
    
    
    <category term="Computer stuff" scheme="https://henryinshanghai.github.io/tags/Computer-stuff/"/>
    
  </entry>
  
  <entry>
    <title>java基础之快速复习（5）</title>
    <link href="https://henryinshanghai.github.io/Java-Basic/2020/09/13/interview/20200913-java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BF%AB%E9%80%9F%E5%A4%8D%E4%B9%A0%EF%BC%885%EF%BC%89.html"/>
    <id>https://henryinshanghai.github.io/Java-Basic/2020/09/13/interview/20200913-java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BF%AB%E9%80%9F%E5%A4%8D%E4%B9%A0%EF%BC%885%EF%BC%89.html</id>
    <published>2020-09-13T14:30:00.000Z</published>
    <updated>2020-09-14T14:57:56.993Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Java基础速查"><a href="#Java基础速查" class="headerlink" title="Java基础速查"></a>Java基础速查</h4><h5 id="JDK中哈希操作"><a href="#JDK中哈希操作" class="headerlink" title="JDK中哈希操作"></a>JDK中哈希操作</h5><p>参考：<a href="https://juejin.im/post/6844903583255642120#heading-7">JDK中的哈希应用</a></p><a id="more"></a><blockquote><p>知识卡：哈希；</p><ul><li><p>是：一种技术；</p></li><li><p>作用：把任意长度的输入转化为固定长度的输出（哈希值）；</p></li><li><p>特征：</p><ul><li>1 相同的输入总是得到相同的输出；</li><li>2 不同的输入总是得到不同的输出（真实实现时无法保证 aka 碰撞）；</li></ul></li><li><p>手段：哈希函数；</p><ul><li>直接定址法：直接以<strong>关键字k或者k加上某个常数（k+c）</strong>作为哈希地址。</li><li>数字分析法：提取<strong>关键字中取值比较均匀的数字</strong>作为哈希地址。</li><li>除留余数法：用<strong>关键字k除以某个不大于哈希表长度m的数p</strong>，将所得余数作为哈希表地址。</li></ul><p>衡量哈希函数质量好坏的指标：1 发生碰撞的概率； 2 发生碰撞时的解决方案；</p><ul><li>哈希函数发生碰撞时，常用的解决手段：<ul><li>1 开放定址法；<ul><li>如果发生了冲突，就去寻找下一个空的散列地址；</li></ul></li><li>2 链地址法；<ul><li>如果发生冲突，就把新的键值对作为链表节点链接在已有的键值对后面；</li></ul></li></ul></li></ul></li></ul></blockquote><h6 id="HashMap存储键值对的过程"><a href="#HashMap存储键值对的过程" class="headerlink" title="HashMap存储键值对的过程"></a>HashMap存储键值对的过程</h6><ul><li>1 根据key-value中的key，找到键值对预期插入的哈希桶数组中的位置；</li><li>2 根据具体情况，把键值对插入到底层数据结构中；</li></ul><h6 id="根据key-value中的key来计算预期插入到的桶位置（Java8）"><a href="#根据key-value中的key来计算预期插入到的桶位置（Java8）" class="headerlink" title="根据key-value中的key来计算预期插入到的桶位置（Java8）"></a>根据key-value中的key来计算预期插入到的桶位置（Java8）</h6><p>SOP:</p><ul><li><p>1 根据key计算出一个哈希值；</p></li><li><p>2 根据哈希值与哈希桶数组的长度，计算得到预期插入的桶位置；</p><ul><li>代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>代码说明</p><ul><li><p>1 先使用key的hashCode()方法，得到一个最初版本的hash值（一个32位的数字）；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h = key.hashCode() <span class="comment">// hashCode()是Object类型的实例方法</span></span><br></pre></td></tr></table></figure></li><li><p>2 对1中得到的hash值执行无符号右移16位的操作；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h &gt;&gt;&gt; <span class="number">16</span> <span class="comment">// &gt;&gt;&gt;是无符号右移的操作符：忽略符号位，空位都用0补齐</span></span><br></pre></td></tr></table></figure></li><li><p>3 把1中计算得到的hash值与右移16位之后的结果，进行异或操作；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>)</span><br></pre></td></tr></table></figure><blockquote><p>作用(2+3)：最终减少哈希碰撞;</p><p>手段：把最初hash值的高16位与低16位异或，使得每一位的数字都能参与到<strong>桶位置的计算</strong>中；</p><p>原理：避免了<strong>虽然哈希值不同，但由于哈希值低位上的数字相同，而计算得到了相同的桶位置</strong>这种碰撞情况；</p></blockquote></li></ul></li></ul></li></ul><h5 id="Java中的基本数据类型（8种）"><a href="#Java中的基本数据类型（8种）" class="headerlink" title="Java中的基本数据类型（8种）"></a>Java中的基本数据类型（8种）</h5><h6 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h6><ul><li>1 整数类型；<ul><li><code>byte</code> - 8 位。<ul><li>数值范围：-128~127；</li></ul></li><li><code>short</code> - 16 位。</li><li><code>int</code> - 32 位。</li><li><code>long</code> - 64 位，赋值时一般在数字后加上 <code>l</code> 或 <code>L</code>。</li></ul></li><li>2 浮点型；<ul><li><code>float</code> - 32 位，直接赋值时必须在数字后加上 <code>f</code> 或 <code>F</code>。</li><li><code>double</code> - 64 位，赋值时一般在数字后加 <code>d</code> 或 <code>D</code> 。</li></ul></li><li>3 字符型；<ul><li><code>char</code> - 16 位，存储 Unicode 码，用单引号赋值。</li><li>数值范围：0~65535；</li></ul></li><li>4 布尔型；<ul><li><code>boolean</code> - 只有 true 和 false 两个取值。</li></ul></li></ul><h6 id="为什么long类型与double类型都是使用8字节内存，但是所能表示的数据范围却差别那么大呢？"><a href="#为什么long类型与double类型都是使用8字节内存，但是所能表示的数据范围却差别那么大呢？" class="headerlink" title="为什么long类型与double类型都是使用8字节内存，但是所能表示的数据范围却差别那么大呢？"></a>为什么long类型与double类型都是使用8字节内存，但是所能表示的数据范围却差别那么大呢？</h6><p>答：因为整数类型与浮点数类型在计算机中的底层表示是不一样的；</p><ul><li>整数类型long的底层存储方式；<ul><li>符号位（一个bit） + 数值位（63个bit）；</li></ul></li><li>浮点类型double的底层表示方式；<ul><li>符号位 + 指数位 + 尾数位；</li></ul></li></ul><h5 id="Base64编码"><a href="#Base64编码" class="headerlink" title="Base64编码"></a>Base64编码</h5><p>参考：<a href="https://www.cnblogs.com/linguanh/p/11205256.html">Base64编码过程</a></p><blockquote><p> 知识卡：编码</p><p>是：一种技术/一个过程；</p><p>作用：把信息转换成另一种形式，方便计算机进行处理；</p><p>手段：Basexxx编码；</p><p>原理：</p><ul><li>1 编码算法；</li><li>2 编码对照表格；</li></ul><p>特征：</p><ul><li>不同编码方式的基本原理都是相同的，主要差异在于：<ul><li>1 具体使用<strong>几位二进制数字</strong>来作为<strong>编码对照表的查找索引</strong>;</li><li>2 不同编码方式<strong>使用的编码对照表格</strong>各有不同；</li></ul></li></ul></blockquote><h6 id="流程SOP"><a href="#流程SOP" class="headerlink" title="流程SOP:"></a>流程SOP:</h6><ul><li>0 准备预期要被编码的字符串；</li><li>1 把字符串中的字符转化成Ascii编码表的数值；</li><li>2 把1中得到的数值转化为二进制数字（要求为8位的整数倍）；</li><li>3 根据BaseX编码算法中的<strong>获取查找索引的规则</strong>，把2中得到的二进制数字划分成一个个单元；</li><li>4 把3中得到的一个个单元转化为10进制数字；</li><li>5 使用4中得到的10进制数字作为<strong>编码对照表的查找索引</strong>，得到编码后的字符集合；</li></ul><h6 id="应用示例："><a href="#应用示例：" class="headerlink" title="应用示例："></a>应用示例：</h6><ul><li><p>任务：对原始字符串“ILU”按照Base16算法进行编码；</p></li><li><p>流程：</p><ul><li><p>1 把字符串中的字符转化成Ascii编码表的数值；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I = <span class="number">73</span>, L = <span class="number">76</span>, U = <span class="number">85</span></span><br></pre></td></tr></table></figure></li><li><p>2 把1中得到的数值转化为二进制数字（要求为8位的整数倍）；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">73</span> = <span class="number">01001001</span></span><br><span class="line"></span><br><span class="line"><span class="number">76</span> = <span class="number">01001100</span></span><br><span class="line"></span><br><span class="line"><span class="number">85</span> = <span class="number">01010101</span></span><br></pre></td></tr></table></figure></li><li><p>3 根据BaseX编码算法中的<strong>计算查找索引的规则</strong>，把2中得到的二进制数字划分成一个个单元；</p><blockquote><p>说明：Base16规定-使用4位二进制数字来计算查找索引</p></blockquote></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;Java基础速查&quot;&gt;&lt;a href=&quot;#Java基础速查&quot; class=&quot;headerlink&quot; title=&quot;Java基础速查&quot;&gt;&lt;/a&gt;Java基础速查&lt;/h4&gt;&lt;h5 id=&quot;JDK中哈希操作&quot;&gt;&lt;a href=&quot;#JDK中哈希操作&quot; class=&quot;headerlink&quot; title=&quot;JDK中哈希操作&quot;&gt;&lt;/a&gt;JDK中哈希操作&lt;/h5&gt;&lt;p&gt;参考：&lt;a href=&quot;https://juejin.im/post/6844903583255642120#heading-7&quot;&gt;JDK中的哈希应用&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Java Basic" scheme="https://henryinshanghai.github.io/categories/Java-Basic/"/>
    
    
    <category term="Java stuff" scheme="https://henryinshanghai.github.io/tags/Java-stuff/"/>
    
  </entry>
  
  <entry>
    <title>java基础之快速复习（4）</title>
    <link href="https://henryinshanghai.github.io/Java-Basic/2020/09/12/interview/20200912-java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BF%AB%E9%80%9F%E5%A4%8D%E4%B9%A0%EF%BC%884%EF%BC%89.html"/>
    <id>https://henryinshanghai.github.io/Java-Basic/2020/09/12/interview/20200912-java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BF%AB%E9%80%9F%E5%A4%8D%E4%B9%A0%EF%BC%884%EF%BC%89.html</id>
    <published>2020-09-12T02:30:00.000Z</published>
    <updated>2020-09-13T10:44:53.411Z</updated>
    
    <content type="html"><![CDATA[<h5 id="HashMap类型的resize-过程"><a href="#HashMap类型的resize-过程" class="headerlink" title="HashMap类型的resize()过程"></a>HashMap类型的resize()过程</h5><blockquote><p>这个其实在上次分析的时候就学了一遍，但是不够熟悉 所以没有答上来。再复习一波~</p></blockquote><p>参考：<a href="http://www.tianxiaobo.com/2018/01/18/HashMap-%E6%BA%90%E7%A0%81%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90-JDK1-8/#342-%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6">HashMap详解-田小波</a></p><a id="more"></a><h6 id="resize-方法SOP："><a href="#resize-方法SOP：" class="headerlink" title="resize()方法SOP："></a>resize()方法SOP：</h6><ul><li>1 计算新的<strong>哈希桶数组的容量newCap</strong>和<strong>新阈值newThr</strong>；<a href="#step1">跳转</a></li><li>2 根据1中计算出的newCap来<strong>创建新的哈希桶数组</strong>/<strong>对桶数组table进行初始化</strong>；<a href="#step2">跳转</a></li><li>3 把键值对重新映射到新的桶数组中（<strong>比较复杂</strong>）；<a href="#step3">跳转</a><ul><li>1 如果节点是树节点，则需要对红黑树进行拆分；【红黑树对象的split()方法】</li><li>2 如果节点是链表节点，则将节点按照原始顺序进行分组；【循环 + 重新映射】</li></ul></li></ul><h6 id="源码-SOP框架-："><a href="#源码-SOP框架-：" class="headerlink" title="源码(SOP框架)："></a>源码(SOP框架)：</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line"><span class="comment">/* Step1: 计算新的桶数组的容量newCap与阈值newThr */</span></span><br><span class="line">...</span><br><span class="line">threshold = newThr;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* step2: 根据计算出的newCap来得到新的桶数组newTab,并绑定到table引用上 */</span></span><br><span class="line">...</span><br><span class="line">table = newTab;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* step3:把旧的哈希桶数组中的键值对重新映射到新的哈希桶数组中 */</span></span><br><span class="line"><span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="源码拆解："><a href="#源码拆解：" class="headerlink" title="源码拆解："></a>源码拆解：</h6><ul><li><span id="step1">step1</span>：计算新哈希桶数组的容量newCap与新阈值newThr；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记录旧桶数组的容量与阈值</span></span><br><span class="line">Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">   <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">   <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">   <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">   <span class="comment">// 如果 table 不为空，表明已经初始化过了</span></span><br><span class="line">   <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="comment">// 当 table 容量超过容量最大值，则不再扩容</span></span><br><span class="line">       <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">           threshold = Integer.MAX_VALUE;</span><br><span class="line">           <span class="keyword">return</span> oldTab;</span><br><span class="line">       &#125; </span><br><span class="line">       <span class="comment">// 如果旧容量并没有超过最大容量，则:按旧容量和阈值的2倍计算新容量和阈值的大小</span></span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">           newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// 🚩注：这里计算newThr，可能会导致newThr的值为零（因为数值溢出）</span></span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// 如果旧的阈值大于0，说明“程序员在调用构造方法时指定了初始容量”，则：</span></span><br><span class="line">       <span class="comment">// 把“程序员指定的初始化容量”作为“新桶数组的容量”</span></span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 手段：把 threshold 的值绑定到 newCap（以作为新桶数组的容量）</span></span><br><span class="line"><span class="comment">        * 原理：HashMap()构造方法中，使用了threshold变量来暂时保 initialCapacity参数的值（🚩 参考id="helper" 😳）</span></span><br><span class="line"><span class="comment">        */</span> </span><br><span class="line">       newCap = oldThr;</span><br><span class="line">   <span class="keyword">else</span> &#123;  <span class="comment">// 如果旧的阈值为0，说明“程序员调用了默认的构造方法”，则:</span></span><br><span class="line">       <span class="comment">// 为newCap、newThr变量绑定默认值（默认容量、默认阈值）</span></span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 调用无参构造方法时，桶数组容量为默认容量，</span></span><br><span class="line"><span class="comment">        * 阈值为默认容量与默认负载因子乘积</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">       newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 如果newThr 为 0，说明：1 上面的if&#123;&#125;中没有更新newThr的值； 或者2在计算newThr发生了溢出，导致newThr的值为0。则</span></span><br><span class="line"><span class="comment">// 按“阈值计算公式”进行计算；公式：阈值 = 容量 * 负载因子</span></span><br><span class="line">   <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">       <span class="comment">// 从两个值中取一个绑定到newThr</span></span><br><span class="line">       newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                 (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把计算得到的newThr绑定到全局变量threshold上</span></span><br><span class="line">   threshold = newThr;</span><br></pre></td></tr></table></figure><blockquote><p>🚩 程序员调用了有初始容量的构造方法时…</p><p><span id="helper">辅助代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 参数判空</span></span><br><span class="line">    ...</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// 把程序员指定的初始容量调整后绑定到了threshold变量上（暂存initialCapacity）</span></span><br><span class="line">        <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>计算新容量与新阈值的代码说明：</p></blockquote><ul><li><p>如果旧哈希桶的容量大于0，说明“哈希桶已经初始化过了”。则：</p><ul><li>尝试使用旧容量&amp;旧阈值的2倍来更新newCap&newThr;<ul><li>1 判断容量是否已经到达最大容量MAXIMUM_CAPACITY，如果是，直接返回旧的哈希桶数组；</li><li>2 如果旧容量没有到达最大容量MAXIMUM_CAPACITY，则：<ul><li>尝试按照扩容两倍的方式来更新newCap与newThr；</li><li>注：如果扩容两倍导致容量超限，则语句不会被执行（newCap与newThr仍旧为0）</li></ul></li></ul></li></ul></li><li><p>如果旧哈希桶的容量等于0，说明“哈希桶还没有被初始化”（aka 程序员通过默认构造器创建的hashMap对象），则：</p><ul><li>如果旧的阈值大于0，说明“程序员在调用构造方法时指定了初始容量”，则：<ul><li>使用”程序员指定的初始容量调整后的值”来更新newCap；</li></ul></li><li>如果旧的阈值等于0，说明”程序员调用了默认的构造方法”，则:<ul><li>使用“默认的值”来更新newCap&amp;newThr；</li></ul></li></ul><hr></li><li><p>处理上面流程中可能没有被更新的newThr；</p><ul><li>如果newThr仍旧等于0，说明：要么newThr的值没有被更新过，要么在更新newThr时发生了溢出。则：<ul><li>使用“阈值 = 容量 * 扩容因子”的公式来计算阈值，并使用计算结果来更新newThr；</li></ul></li></ul></li></ul><p><strong>Period</strong></p><ul><li><p><span id="step2">step2: </span> 根据1中计算出的newCap来<strong>创建新的哈希桶数组</strong>;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建新的桶数组，桶数组的初始化也是在这里完成的</span></span><br><span class="line">Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">table = newTab; <span class="comment">// 把新创建的数组绑定到table全局变量上</span></span><br></pre></td></tr></table></figure></li><li><p><span id="step3">step3: </span>把键值对重新映射到新的桶数组中;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果旧的桶数组不为空，则遍历桶数组，并将键值对映射到新的桶数组中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="comment">// 重新映射时，需要对红黑树进行拆分</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="comment">// 遍历链表，并将链表节点按原顺序进行分组</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 将分组后的链表映射到新桶中</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>重新映射键值对的代码说明</p></blockquote><ul><li><p>分类1：对桶中的链表进行分组映射；</p><blockquote><p>知识卡1：向HashMap中插入键值对的流程；</p><ul><li>1 计算键值对应该插入到的哈希桶的位置；</li><li>2 尝试把键值对插入到桶中（作为链表节点/红黑树节点）；</li></ul><p>说明：JDK1.8中，对第一步做了优化以减少哈希冲突；</p></blockquote><blockquote><p>知识卡2：JDK1.8中，计算键值对预期插入的桶位置的流程；</p><ul><li>1 根据键值对的key，调用key的hashCode()方法计算得到其哈希值hash_key；</li><li>2 根据公式(n - 1) &amp; hash_key来计算出它预期插入的桶位置；</li></ul></blockquote><blockquote><p>知识卡3：默认情况下，扩容操作会被桶数组的容量扩大为旧容量的2倍；</p></blockquote><ul><li><p>手段：把链表中的键值对重新映射到<strong>扩容后新的哈希桶数组</strong>中；</p></li><li><p>特征：</p><ul><li>1 先前被映射到同一个桶中的键值对，在重新映射时，会被映射到不同的桶中；</li><li>2 <strong>不同的桶</strong>分为两个桶：旧位置的桶 + （旧位置 + 扩容长度）位置的桶；</li><li>3 这种手段不需要重新计算哈希值，只要查看高一位bit的值是0还是1，就能够得到<strong>键值对应该被映射到的哈希桶位置</strong>；</li></ul></li><li><p>原理：</p><ul><li>1 重新映射时， (n - 1) &amp; hash_key表达式中hash_key的值是不变的；</li><li>2 表达式中的n变成了先前的2倍，具体到二进制表示上——最高位1的前一个bit的值从0变成1；</li><li>3 由于按位与&amp;的特征（全1为1，否则为0），所以，根据hash_key的对应bit的值就能得到表达式(n - 1) &amp; hash_key的结果（aka 桶的位置）</li></ul></li><li><p>具体代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 如果旧的桶数组不为空，则遍历桶数组，并将键值对映射到新的桶数组中</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">Node&lt;K,V&gt; e;</span><br><span class="line"><span class="comment">// 获取当前桶位置的节点e，如果节点e不为null...</span></span><br><span class="line"><span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 处理其他的情况</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line"><span class="comment">/* 准备需要的指针 注：根据原理，链表的键值对会被映射到两个桶中 */</span></span><br><span class="line">Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>; <span class="comment">// “原始桶位置上的链表分组”的头尾指针 </span></span><br><span class="line">Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>; <span class="comment">// “新的桶位置上的链表分组”的头尾指针</span></span><br><span class="line">Node&lt;K,V&gt; next; <span class="comment">// 记录当前节点的下一个节点</span></span><br><span class="line"><span class="comment">// 遍历链表，并将链表节点按原顺序进行分组</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">next = e.next;</span><br><span class="line">                    <span class="comment">// 判断当前节点应该添加到的“链表分组”</span></span><br><span class="line">                    <span class="comment">// 手段：判断节点的哈希值 &amp; 桶数组的旧容量 的结果是否为0【WHY？】</span></span><br><span class="line"><span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 构建链表loHead</span></span><br><span class="line"><span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">loHead = e;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">loTail.next = e;</span><br><span class="line">loTail = e;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 构建链表hiHead</span></span><br><span class="line"><span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">hiHead = e;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">hiTail.next = e;</span><br><span class="line">hiTail = e;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">// 将分组后的链表（loHead、hiHead）添加到新桶中</span></span><br><span class="line"><span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">loTail.next = <span class="keyword">null</span>;</span><br><span class="line">newTab[j] = loHead;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">newTab[j + oldCap] = hiHead;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>链表中的键值对重新映射过程的SOP：</p><ul><li><p>原始桶数组；</p><p><img src="https://s1.ax1x.com/2020/09/13/w0dbnK.png" alt="原始桶数组"></p></li><li><p>桶数组扩容后，对链表中的键值对重新映射；</p><ul><li><p>1 依次遍历链表，并计算节点 <code>hash &amp; oldCap</code> 的值【为什么是这个公式？🚩】；</p><p><img src="https://s1.ax1x.com/2020/09/13/w0wFHS.png" alt="遍历桶中链表的节点"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    next = e.next;</span><br><span class="line">    <span class="comment">// 判断当前节点应该添加到的“链表分组”</span></span><br><span class="line">    <span class="comment">// 手段：判断节点的哈希值 &amp; 桶数组的旧容量 的结果是否为0【WHY？】</span></span><br><span class="line">    <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 构建链表loHead</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 构建链表hiHead</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul></li></ul></li></ul><pre><code>- 2 根据计算结果，对节点进行分组并创建分组后的链表（&lt;font size=2&gt;分组依据：键值对应该存放在原始桶位置or新的桶位置&lt;/font&gt;）；  手段：创建链表的一般步骤（两个指针head + tail）；  ![分组节点并创建分组链表](https://s1.ax1x.com/2020/09/13/w0ws4H.png)  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建loHead链表</span></span><br><span class="line"><span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">    loHead = e;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    loTail.next = e;</span><br><span class="line">loTail = e;</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 创建hiHead链表</span></span><br><span class="line"><span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">    hiHead = e;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    hiTail.next = e;</span><br><span class="line">hiTail = e;</span><br></pre></td></tr></table></figure>- 3 把创建的分组链表添加到新桶数组中预期位置；  手段：把分组后链表的头节点绑定到桶数组的预期位置上；  ![把链表绑定到桶数组的预期位置](https://s1.ax1x.com/2020/09/13/w00dRs.png)  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将分组后的链表（loHead、hiHead）添加到新桶中</span></span><br><span class="line"><span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">    loTail.next = <span class="keyword">null</span>;</span><br><span class="line">    newTab[j] = loHead; <span class="comment">// 旧的桶位置</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">    hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">    newTab[j + oldCap] = hiHead; <span class="comment">// 新的桶位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><hr><h6 id="哈希桶扩容后，红黑树中节点的重新映射过程"><a href="#哈希桶扩容后，红黑树中节点的重新映射过程" class="headerlink" title="哈希桶扩容后，红黑树中节点的重新映射过程"></a>哈希桶扩容后，红黑树中节点的重新映射过程</h6><blockquote><p>这个过程又会有很多细节，所以这里就简单捋一下</p></blockquote><p>参考：<a href="http://www.tianxiaobo.com/2018/01/18/HashMap-%E6%BA%90%E7%A0%81%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90-JDK1-8/#342-%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6">红黑树的拆分</a></p><ul><li><p>手段：按照映射链表节点的方式来重新映射红黑树中的节点；</p></li><li><p>原理：在<strong>将普通链表转成红黑树treeifyBin()方法</strong>时，HashMap 通过两个额外的引用 next 和 prev <strong>保留了原链表的节点顺序</strong>；</p></li><li><p>特征：不需要先把红黑树转化成链表，然后再映射到新的桶数组（效率更高）；</p></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 红黑树转链表阈值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index, <span class="keyword">int</span> bit)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; b = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// Relink into lo and hi lists, preserving order</span></span><br><span class="line">    TreeNode&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">    TreeNode&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * 红黑树节点仍然保留了 next 引用，故仍可以按链表方式遍历红黑树。</span></span><br><span class="line"><span class="comment">     * 下面的循环是对红黑树节点进行分组，与“对链表分组”类似</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; e = b, next; e != <span class="keyword">null</span>; e = next) &#123;</span><br><span class="line">        next = (TreeNode&lt;K,V&gt;)e.next;</span><br><span class="line">        e.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> ((e.hash &amp; bit) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                loHead = e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                loTail.next = e;</span><br><span class="line">            loTail = e;</span><br><span class="line">            ++lc;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                hiHead = e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                hiTail.next = e;</span><br><span class="line">            hiTail = e;</span><br><span class="line">            ++hc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断分组后的树是否需要反树化为链表</span></span><br><span class="line">    <span class="keyword">if</span> (loHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果 loHead 不为空，且链表长度小于等于 6，则将红黑树转成链表</span></span><br><span class="line">        <span class="keyword">if</span> (lc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">            tab[index] = loHead.untreeify(map);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tab[index] = loHead;</span><br><span class="line">            <span class="comment">/* </span></span><br><span class="line"><span class="comment">             * hiHead == null 时，表明扩容后，</span></span><br><span class="line"><span class="comment">             * 所有节点仍在原位置，树结构不变，无需重新树化</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) </span><br><span class="line">                loHead.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 把分组后的红黑树绑定到预期的桶中</span></span><br><span class="line">    <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">            tab[index + bit] = hiHead.untreeify(map);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tab[index + bit] = hiHead;</span><br><span class="line">            <span class="keyword">if</span> (loHead != <span class="keyword">null</span>)</span><br><span class="line">                hiHead.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h6 id="其他参考文章"><a href="#其他参考文章" class="headerlink" title="其他参考文章"></a>其他参考文章</h6><p><a href="https://www.toocruel.net/java8de-hashmapxiang-jie-cun-chu-jie-gou-gong-neng-shi-xian-kuo-rong-you-hua-xian-cheng-an-quan-bian-li-fang-fa/">JDK1.8中HashMap扩容机制简介</a></p><p><a href="https://mp.weixin.qq.com/s/qVoebks_Ba17ZtKMlzcbgw">JDK1.7中HashMap扩容机制简介</a></p><blockquote><p>it’s been a day, until next time 😄</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h5 id=&quot;HashMap类型的resize-过程&quot;&gt;&lt;a href=&quot;#HashMap类型的resize-过程&quot; class=&quot;headerlink&quot; title=&quot;HashMap类型的resize()过程&quot;&gt;&lt;/a&gt;HashMap类型的resize()过程&lt;/h5&gt;&lt;blockquote&gt;
&lt;p&gt;这个其实在上次分析的时候就学了一遍，但是不够熟悉 所以没有答上来。再复习一波~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;参考：&lt;a href=&quot;http://www.tianxiaobo.com/2018/01/18/HashMap-%E6%BA%90%E7%A0%81%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90-JDK1-8/#342-%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6&quot;&gt;HashMap详解-田小波&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Java Basic" scheme="https://henryinshanghai.github.io/categories/Java-Basic/"/>
    
    
    <category term="Java stuff" scheme="https://henryinshanghai.github.io/tags/Java-stuff/"/>
    
  </entry>
  
  <entry>
    <title>java基础之快速复习（3）</title>
    <link href="https://henryinshanghai.github.io/Java-Basic/2020/09/12/interview/20200912-java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BF%AB%E9%80%9F%E5%A4%8D%E4%B9%A0%EF%BC%883%EF%BC%89.html"/>
    <id>https://henryinshanghai.github.io/Java-Basic/2020/09/12/interview/20200912-java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BF%AB%E9%80%9F%E5%A4%8D%E4%B9%A0%EF%BC%883%EF%BC%89.html</id>
    <published>2020-09-12T02:30:00.000Z</published>
    <updated>2020-09-12T17:53:50.210Z</updated>
    
    <content type="html"><![CDATA[<h5 id="自定义注解相关知识"><a href="#自定义注解相关知识" class="headerlink" title="自定义注解相关知识"></a>自定义注解相关知识</h5><a id="more"></a><p>参考：<a href="https://mp.weixin.qq.com/s/gdYysBB3aD_HmPyvEThFXw">只会用注解，不会自己写？</a></p><blockquote><p>注解</p><p>是：Java中提供的一项技术；</p><p>作用：</p><ul><li>1 声明被标记的部分有/支持特殊的功能；</li><li>2 为被标记的部分添加额外的信息（以便在后面的代码中方便地使用这些信息）</li></ul><p>特征：</p><ul><li>1 在代码中可以用注进行解标注的部分：<ul><li>类/接口；</li><li>字段变量；</li><li>方法；</li></ul></li><li>2 特殊的功能：<ul><li>代码生成；</li><li>数据校验；</li><li>资源整合（🚩？？？）</li></ul></li></ul><p>用法：</p><ul><li>1 使用注解来标注需要的代码；</li><li>2 使用反射机制，在运行时动态地获取到注解中的标注信息，从而实现注解预期的功能；</li></ul></blockquote><h6 id="手动编写一个注解-Length-amp-验证注解的作用"><a href="#手动编写一个注解-Length-amp-验证注解的作用" class="headerlink" title="手动编写一个注解@Length&amp;验证注解的作用"></a>手动编写一个注解@Length&amp;验证注解的作用</h6><blockquote><p>说明：Spring框架其实提供了很多注解来对类的字段进行校验； 比如@NotNull、@NotEmpty、@Min、@Max、@Length</p></blockquote><ul><li><p>1 定义注解；</p><ul><li><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.FIELD&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Length &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">()</span></span>;  <span class="comment">// 字符串所允许的最小值</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">()</span></span>; <span class="comment">// 字符串所允许的最大值</span></span><br><span class="line">    <span class="function">String <span class="title">errorMsg</span><span class="params">()</span></span>; <span class="comment">// 自定义的错误提示信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>手段：</p><ul><li><p>1 关键字：@interface；</p></li><li><p>2 指定自定义注解的一些特性（注解可以添加到的位置、注解的声明周期）：</p><ul><li><p>手段：Java提供的元注解（BIA）；</p></li><li><p>分类：</p><ul><li><p>@Target(xxx)，用于指定该自定义注解可以用在什么位置【字段 - 方法 - 类（and more）】</p><ul><li><code>ElementType.FIELD</code>：说明自定义的注解可以用于类的变量</li><li><code>ElementType.METHOD</code>：说明自定义的注解可以用于类的方法</li><li><code>ElementType.TYPE</code>：说明自定义的注解可以用于类本身、接口或 <code>enum</code>类型</li></ul></li><li><p>@Retention(xxx)，用于指定自定义注解的生命周期【运行时 - 编译时 - 源码时】</p><ul><li><code>@Retention(RetentionPolicy.RUNTIME)</code>：表示注解可以一直保留到运行时（因此可以通过反射获取注解信息）</li><li><code>@Retention(RetentionPolicy.CLASS)</code>：表示注解被编译器编译进 <code>class</code>文件，但运行时会忽略</li><li><code>@Retention(RetentionPolicy.SOURCE)</code>：表示注解仅在源文件中有效，编译时就会被忽略</li></ul><p>一般选择的生命周期为：@Retention(RetentionPolicy.RUNTIME). Retention,延续</p></li></ul></li></ul></li></ul></li></ul></li><li><p>2 定义一个工具类，在类中添加静态方法——用于动态获取当前实例的字段值，并于程序员指定的字段值边界进行比较；</p><ul><li><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">validate</span><span class="params">(Object object)</span> <span class="keyword">throws</span> IllegalAccessException </span>&#123;</span><br><span class="line">        <span class="comment">// Ⅰ 获取类的所有字段</span></span><br><span class="line">        Field[] fields = object.getClass().getDeclaredFields();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Ⅱ 遍历这些个字段对象</span></span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">            <span class="comment">// Ⅲ 如果字段上存在“自定义的注解”...</span></span><br><span class="line">            <span class="keyword">if</span> (field.isAnnotationPresent(Length<span class="class">.<span class="keyword">class</span>)) </span>&#123; </span><br><span class="line">                <span class="comment">// Ⅳ 获取到字段上的注解类实例</span></span><br><span class="line">                MyPattern myPattern = field.getAnnotation(MyPattern<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">                field.setAccessible(<span class="keyword">true</span>); <span class="comment">// 允许通过反射访问到私有变量</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// Ⅴ 通过反射，获取到程序员给对象的该字段绑定的值     诡异地反转：对象的某个字段的值 - 字段.get(对象)</span></span><br><span class="line">                String myRex = (String)field.get(object); <span class="comment">// 获取到字段的值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="comment">// Ⅵ 对字段绑定的值进行判断，如果不在指定的区间内。就返回自定义的异常信息</span></span><br><span class="line">                Pattern p = Pattern.compile(myPattern.regularExpression());</span><br><span class="line">                Matcher m = p.matcher(myRex);</span><br><span class="line">                <span class="keyword">if</span> (!m.matches()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> myPattern.errorMag();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// 否则返回null</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>3 在自定义类型的字段上，使用自定义的注解；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.annotationDemo2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在字段上标记自定义的注解</span></span><br><span class="line">    <span class="meta">@Length</span>(min=<span class="number">11</span>, max=<span class="number">11</span>, errorMsg = <span class="string">"电话号码的长度必须为11位"</span>)</span><br><span class="line">    <span class="keyword">private</span> String mobile;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>4 验证注解是否发挥作用；</p><ul><li>手段：<ul><li>1 写一段代码，尝试给实例的mobile绑定一个6位数字的号码；</li><li>2 然后调用工具类中的静态方法对实例进行校验，如果失败，就返回errorMsg；</li></ul></li></ul></li></ul><h5 id="Spring中常用的注解"><a href="#Spring中常用的注解" class="headerlink" title="Spring中常用的注解"></a>Spring中常用的注解</h5><p>参考：<a href="http://cmsblogs.com/?p=4040">Spring中常用的20+注解</a></p><blockquote><p>知识卡</p><p>Spring注解</p><ul><li>是：Spring框架所提供的一种技术；</li><li>作用：<ul><li>声明式地描述Spring框架的指定功能；</li><li>部分替代Spring的XML配置文件的工作（比如描述<strong>被Spring所管理的Bean</strong>、<strong>装配Bean之间的关系</strong>等）</li></ul></li><li>特征：<ul><li>1 对于Spring的不同功能，Spring都提供了实现该功能的注解手段；</li><li>2 注解能够声明式地使用，不需要像OOP编程一样指定很多的细节（只需要给出关键信息即可）</li></ul></li><li>用法/分类：<ul><li>参考：👇👇👇</li></ul></li></ul></blockquote><h6 id="1-用于描述组件的注解"><a href="#1-用于描述组件的注解" class="headerlink" title="1.用于描述组件的注解"></a>1.用于描述组件的注解</h6><ul><li><p>作用：为Java类添加一个标识，声明此Java类接受Spring容器的管理（这部分替代了Spring配置文件的作用）。</p></li><li><p>具体注解：</p><ul><li><strong>@Component</strong>：声明当前类型接受Spring容器的管理（aka 可以视为Spring容器中的一个组件）；</li><li>@Repository、@Service、@Controller：作用与@Component完全相同，但是能让程序员直接了解到组件所在的层次；<ul><li>@Controller标注的类型：表示此类型为controller层的组件(页面交互层)；</li><li>@Service标注的类型：表示此类型为service层的组件（业务逻辑处理层）；</li><li>@Repository标注的类型：表示此类型为dao层的组件（数据库操作层）；【<font size=2>引申：开发应用时采用的三层架构</font>】</li></ul></li><li>原理（这些注解的作用相同）：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;) <span class="comment">// 此注解可以使用的位置</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME) <span class="comment">// 此注解有效的范围</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Component</span> <span class="comment">// 🚩所有其他的三个注解都被@Component注解所标注</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Controller &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>特征</p><ul><li><p>1 Java类型被声明为Spring容器中的Bean（不管是注解手段还是…）后，bean实例的名称默认为：<strong>首字母变成小写</strong>后Bean类型的名称;</p></li><li><p>2 实际开发时，尽量使用三层架构对应的注解；</p></li><li><p>3 为Java类型添加注解后，还需要些其他操作才能<strong>由Spring容器来完全管理Java类型的实例</strong>；</p><blockquote><p>知识卡：</p><p>任务：把一个Java类型交给Spring容器管理；</p><p>手段：</p><ul><li><p>1 为Java类型标注Spring提供的注解@Component;</p></li><li><p>2 在Spring的配置文件中添加<strong>预期执行注解扫描的路径</strong>这个配置信息；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 自动扫描指定包及其子包下的所有Bean类 --&gt;</span><br><span class="line">&lt;context:component-scan base-<span class="keyword">package</span>=<span class="string">"org.springframework.*"</span>/&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote></li></ul></li></ul><h6 id="2-用于进行装配Bean的注解"><a href="#2-用于进行装配Bean的注解" class="headerlink" title="2.用于进行装配Bean的注解"></a>2.用于进行装配Bean的注解</h6><ul><li>作用：<ul><li>1 描述Spring容器中不同Bean之间的依赖关系；</li><li>2 在Spring容器中建立这种依赖关系（把B类型的bean实例绑定到/注入到/装配到A类型的属性上）；</li></ul></li><li>具体注解：<ul><li><strong>@Autowired</strong>：Spring内置注解；</li><li>@Inject：由JSR-330规范提供;</li><li>@Resource：由JSR-250规范提供;【非嫡系】</li></ul></li><li>用法：都可以标注在set方法和属性上，<strong>推荐直接标注在属性上</strong>（一目了然，少写代码）</li></ul><h6 id="3-用于声明“这是一个用于配置的类型”的注解"><a href="#3-用于声明“这是一个用于配置的类型”的注解" class="headerlink" title="3.用于声明“这是一个用于配置的类型”的注解"></a>3.用于声明“这是一个用于配置的类型”的注解</h6><ul><li>作用：声明这是一个用于配置Bean之间依赖关系的Java类型；</li><li>具体注解：<ul><li>@Configuration <ul><li>作用：声明当前类为配置类，相当于配置文件中的xxx标签；</li><li>用法：标注在类上</li></ul></li><li>@Bean <ul><li>作用：产生一个Bean对象，然后这个Bean对象交给Spring管理；</li><li>用法：标注在方法上；</li></ul></li><li>@ComponentScan <ul><li>作用：用于对Component进行自动扫描（相当于配置文件中的xxx标签）；</li><li>用法：标注在类上；</li></ul></li></ul></li></ul><h6 id="4-用于支持AOP的注解"><a href="#4-用于支持AOP的注解" class="headerlink" title="4.用于支持AOP的注解"></a>4.用于支持AOP的注解</h6><ul><li><p>作用：支持AOP编程中的技术细节（where、when&amp;how）；</p></li><li><p>具体注解：</p><ul><li><p>@Aspect（how）：</p><ul><li>作用：把一个类声明为切面类（aka 用于对其他类型进行增强的类）；</li><li>用法：<ul><li>1 标注在Java类上；</li><li>2 直接把<strong>拦截规则（where）</strong>作为@Aspect注解的参数；</li></ul></li></ul></li><li><p>@After（when）：</p><ul><li>作用：声明<strong>当前用于增强的方法</strong>在<strong>切点方法</strong>执行之后再去执行；</li><li>用法：标注在用于增强的方法上；</li></ul><blockquote><p>@Before注解作用与用法和@After都类似；</p></blockquote></li><li><p>@Around（when）</p><ul><li>作用：声明<strong>当前用于增强的方法</strong>在 <strong>切点方法执行之前</strong> 与 <strong>切点方法执行之后</strong>都会执行；</li><li>用法：标注在用于增强的方法上；</li></ul></li><li><p>@PointCut（where）</p><ul><li>作用：声明预期会被增强的方法/代码；</li><li>用法：<ul><li>0 开启Spring对AspectJ代理的支持；<ul><li>手段：在Java配置类上标注@EnableAspectJAutoProxy注解；</li></ul></li><li>1 把@PointCur注解标注在方法上；</li><li>2 编写预期的切点表达式作为@PointCut注解的参数；</li></ul></li></ul></li></ul></li></ul><h6 id="5-用于声明bean实例相关属性的注解"><a href="#5-用于声明bean实例相关属性的注解" class="headerlink" title="5.用于声明bean实例相关属性的注解"></a>5.用于声明bean实例相关属性的注解</h6><ul><li><p>作用：对bean实例进行更细致的管理（声明bean实例在容器中的作用域）；</p></li><li><p>具体注解;</p><ul><li><p>@Scope；</p><blockquote><p>知识卡—Spring容器中bean实例的作用域分类：</p><p>作用域的作用：声明容器中当前Bean的特性；</p><ul><li>Singleton作用域；<ul><li>当前Bean的特性：整个容器中有且只有一个当前Bean的实例；</li></ul></li><li>Prototype作用域；<ul><li>当前Bean的特性：代码每次从容器中获取bean实例时，容器都会为这个get操作创建一个新的实例；</li></ul></li><li>Request作用域；<ul><li>当前Bean的特性：web项目中，给每个http request（请求与获取bean实例没有必然关系呀？🚩）新建一个bean</li><li>特征：创建出的实例只在本次HTTP请求期间有效；</li></ul></li><li>Session作用域；<ul><li>当前Bean的特性：同上；</li><li>特征：创建出的bean实例只在本次会话期间有效（时间范围比起以此请求更长）；</li></ul></li></ul></blockquote><ul><li>作用：声明bean实例在Spring容器中的<strong>作用域属性</strong>；</li><li>用法：标注在<strong>用于创建bean实例的方法</strong>上；</li></ul></li><li><p>@PostConstruct </p><ul><li><p>作用：声明方法会在<strong>在构造函数执行完之后（bean的生命周期的一个阶段）</strong>执行；</p></li><li><p>特征：</p><ul><li>1 由JSR-250规范提供；</li><li>2 等价于xml配置文件中xxx标签的ooo属性；</li></ul></li><li><p>用法：标注在<strong>预期在依赖注入操作执行完成后会被调用</strong>的方法上；</p></li><li><p>原理：</p><ul><li><p>bean的生命周期中执行注解的顺序；</p><p><img src="https://s1.ax1x.com/2020/09/12/walSC4.png" alt="生命周期中顺序执行的注解"></p></li></ul></li></ul></li><li><p>@PreDestory </p><ul><li>作用：声明方法会<strong>在Bean销毁之前（bean生命周期的另一个阶段）</strong>执行;</li><li>特征：<ul><li>1 由JSR-250规范提供；</li><li>2 等价于xml配置文件中xxx标签的ooo属性；</li></ul></li><li>用法：标注在<strong>预期在bean实例被销毁之后会被调用</strong>的方法上；</li></ul></li></ul></li></ul><h6 id="6-用于为属性绑定值的注解"><a href="#6-用于为属性绑定值的注解" class="headerlink" title="6.用于为属性绑定值的注解"></a>6.用于为属性绑定值的注解</h6><ul><li><p>作用：为Bean类型的属性绑定/注入值；</p></li><li><p>用法：从配置文件中加载值，并绑定到成员属性上；</p><ul><li><p>1 在配置文件<em>test.properties</em>中定义一堆的<strong>属性 - 值</strong>对；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">book.name=《三体》</span><br></pre></td></tr></table></figure></li><li><p>2 在<strong>当前类</strong>中加载配置文件；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PropertySource(<span class="string">"classpath:com/hgs/hello/test/test.propertie"</span>) <span class="comment">// 在类上标注PropertySource注解</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span>&#123; ... &#125;</span><br></pre></td></tr></table></figure></li><li><p>3 在配置类中添加一个用于填充占位符的bean实例；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">🚩</span><br></pre></td></tr></table></figure></li><li><p>4 在<strong>属性上</strong>标注@Value注解；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value</span>(<span class="string">"$&#123;user.age:11&#125;"</span>) <span class="comment">// 引用配置文件中的键值对，然后把得到的值绑定到age属性上</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h6 id="7-用于切换代码运行环境的注解"><a href="#7-用于切换代码运行环境的注解" class="headerlink" title="7.用于切换代码运行环境的注解"></a>7.用于切换代码运行环境的注解</h6><ul><li><p>作用：指定代码运行的当前环境；</p><blockquote><p>知识卡1——代码的不同阶段</p><ul><li>1 对于一个项目来说，相同的代码需要先后经历<strong>开发环境 - 测试环境 - 生产环境</strong>的阶段；</li><li>2 每一种环境，配置使用的数据库肯定是不同的（还有一些其他的配置信息也会不同）；</li></ul><p>知识卡2——代码部署</p><p>手段1：</p><ul><li><p>1 当把代码部署到一个新的环境时，修改配置文件中<strong>与代码运行环境相关的信息</strong>；</p></li><li><p>2 修改正确后，把代码+编辑后的配置文件<strong>放到/部署到新的工作环境中</strong>；</p><p>特征：每次部署工作都需要重新修改配置文件，很容易出错；</p></li></ul><p>手段2：</p><ul><li><p>1 准备好每一种工作环境所对象的配置文件(file_dev、file_test、file_prod);</p></li><li><p>2 在代码中，通过@Profile注解来指定当前代码所使用的运行环境配置；</p><p>特征： 这样每次部署时，就只需要修改一行代码即可（🚩 Not for sure）</p></li></ul></blockquote></li><li><p>具体注解：</p><ul><li><p>@Profile；</p><ul><li><p>作用：指定<strong>代码运行的当前环境</strong>（aka <em>当前context</em>所需要使用的配置环境）；</p></li><li><p>手段：设定<em>Environment的ActiveProfiles</em>；</p></li><li><p>用法：</p><ul><li><p>1 在<strong>预期使用xxx环境配置信息的方法上</strong>标注@Profile(‘xxx’)注解；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Profile</span>(<span class="string">"dev"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">devDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 具体配置信息</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> basicDataSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>2 激活<strong>预期使用的xxx环境配置</strong>;</p><ul><li><p>手段：在类上标注<code>@ActiveProfiles</code>注解；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Not going into the details now</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul></li><li><p>@Conditional；</p><ul><li>作用：声明那些个<strong>在特定条件下才会被实例化</strong>的bean；</li><li>用法：<ul><li>1 自定义类型实现Condition接口，并重写matches()方法；</li><li>2 根据matches()方法的返回结果来确定<strong>Bean类型是否会被实例化</strong>；</li></ul></li></ul></li></ul></li></ul><h6 id="8-用于支持异步操作的注解"><a href="#8-用于支持异步操作的注解" class="headerlink" title="8.用于支持异步操作的注解"></a>8.用于支持异步操作的注解</h6><ul><li>作用：支持异步操作并指定具体的操作细节；</li><li>具体注解：<ul><li>@EnableAsync；<ul><li>作用：开启Spring对异步任务的支持；</li><li>用法：标注在配置类上；</li></ul></li><li>@Async；<ul><li>作用：声明<strong>bean方法是一个异步任务</strong>（啥意思🚩）；</li><li>用法：标注在<strong>预期声明其为异步任务</strong>的方法上；</li></ul></li></ul></li></ul><h6 id="9-用于支持定时任务的注解"><a href="#9-用于支持定时任务的注解" class="headerlink" title="9.用于支持定时任务的注解"></a>9.用于支持定时任务的注解</h6><ul><li><p>具体注解：</p><ul><li><p>@EnableScheduling：</p><ul><li>作用：开启Spring对定时任务的支持；</li><li>用法：标注在配置类上；</li></ul></li><li><p>@Scheduled：</p><ul><li><p>作用：声明<strong>bean方法是一个待执行的任务(比如爬取新闻)</strong>；</p></li><li><p>用法：</p><ul><li><p>1 标注在<strong>预期按照指定规则运行的方法</strong>上；</p></li><li><p>2 通过注解的参数来指定<strong>任务的运行规则</strong>；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scheduled</span>(cron = <span class="string">"0 0 0 1 Jan ?"</span>) <span class="comment">//每年的1月的1日的0时0分0秒执行</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><p>参考:<a href="https://juejin.im/post/6844903470793752584">@Schedule注解的用法</a></p></li></ul><h6 id="10-形如-Enable-的注解说明"><a href="#10-形如-Enable-的注解说明" class="headerlink" title="10.形如@Enable*的注解说明"></a>10.形如@Enable*的注解说明</h6><ul><li>作用：用于开启Spring对*所表示的功能的支持；</li><li>常用注解：<ul><li>@EnableAsync 开启对<strong>异步方法</strong>的支持</li><li>@EnableScheduling 开启对<strong>计划任务</strong>的支持</li><li>@EnableWebMvc 开启对<strong>Web MVC</strong>的支持</li><li>@EnableCaching 开启<strong>注解式的缓存</strong>支持</li></ul></li></ul><h6 id="11-用于支持代码测试的注解"><a href="#11-用于支持代码测试的注解" class="headerlink" title="11.用于支持代码测试的注解"></a>11.用于支持代码测试的注解</h6><ul><li><p>@RunWith</p><ul><li><p>作用：指定<strong>当前代码上下文</strong>所使用的<strong>运行器</strong>（aka 运行当前代码的工具）；</p></li><li><p>用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RunWith(SpringJUnit4ClassRunner<span class="class">.<span class="keyword">class</span>) // 为参数绑定具体运行器的<span class="title">class</span>对象</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>@ContextConfiguration【上下文配置】</p><ul><li><p>作用：指定<strong>当前代码上下文</strong>所使用的<strong>Spring容器配置</strong>（aka 具体实例与实例之间的装配关系）；</p></li><li><p>用法（通过Java配置类来指定Spring容器配置）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ContextConfiguration</span>(classes=&#123;TestConfig<span class="class">.<span class="keyword">class</span>&#125;) // 为<span class="title">classes</span>参数绑定配置类的<span class="title">class</span>对象</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h6 id="12-SpringMVC框架所使用的注解"><a href="#12-SpringMVC框架所使用的注解" class="headerlink" title="12.SpringMVC框架所使用的注解"></a>12.SpringMVC框架所使用的注解</h6><ul><li><p>作用：开启SpringMVC框架，并指定MVC框架处理请求的细节；</p></li><li><p>具体注解；</p><ul><li><p>@EnableWebMvc；</p><ul><li>作用：开启Spring<strong>对Web MVC配置的支持</strong>；</li><li>用法：标注在配置类上；</li></ul></li><li><p>@Controller;</p><ul><li>作用：声明当前类为<strong>MVC模型中的控制器</strong>；</li><li>用法：标注在当前类型上；</li></ul></li><li><p>@RequestMapping：</p><ul><li>作用：映射Web请求到特定的Controller方法上；</li><li>特征：<ul><li>1 映射内容除了路径外，还包括请求参数；</li><li>2 请求参数到controller方法参数的绑定会有很多种手段；</li></ul></li></ul></li><li><p>@ResponseBody；</p><ul><li>作用：声明方法的返回值会<strong>存入response内</strong>，而不是需要<strong>作为一个视图名</strong>;</li><li>用法：标注在controller方法上；</li></ul></li><li><p>@RequestBody；</p><ul><li>作用：把请求的参数封装到请求体中，而不是跟在请求地址后面；</li><li>用法：标注在controller方法参数的前面；</li></ul></li><li><p>@PathVariable；</p><ul><li>作用：接受Web请求中的路径参数，并把参数值绑定到controller方法参数上；</li><li>用法：<ul><li>1 编写@RequestMapping注解时，使用<strong>路径参数</strong>来接收Web请求中的参数；</li><li>2 把@PathVariable注解标注在controller方法参数的前面即可;（more details）</li></ul></li></ul></li><li><p>@RestController;</p><ul><li>作用：@Controller+@ResponseBody；</li><li>特征：组合注解；</li></ul></li><li><p>@InitBinder；</p><ul><li>作用：设置从web请求到controller方法参数的数据绑定；</li><li>原理：<ul><li>1 使用WebDataBinder来自动绑定前台请求参数到Model中；</li><li>2 通过InitBinder注解能够设置WebDataBinder的细节；</li></ul></li></ul><blockquote><p>OMG, so much details you may want to puke(⚡吼)</p></blockquote></li></ul></li></ul><h5 id="多线程中常用的方法说明"><a href="#多线程中常用的方法说明" class="headerlink" title="多线程中常用的方法说明"></a>多线程中常用的方法说明</h5><blockquote><p>多线程的应用场景：</p><ul><li>1 流程中的耗时任务（比如发通知时，需要给每一个参会人员发送短信）；</li><li>2 创建需要在后台一直执行的线程（比如定时任务，像备份数据库等）；</li><li>3 处理并发请求（Tomcat）/处理多个任务（多任务场景？🚩）；</li><li>4 多次独立的循环；</li></ul></blockquote><p>参考：<a href="https://mp.weixin.qq.com/s/FHyqxHcfzOtKvA1_PFtnXw">田小齐-多线程</a></p><h6 id="线程的生命周期-6种状态"><a href="#线程的生命周期-6种状态" class="headerlink" title="线程的生命周期(6种状态)"></a>线程的生命周期(6种状态)</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> State &#123;</span><br><span class="line">  NEW,</span><br><span class="line">  RUNNABLE,</span><br><span class="line">  BLOCKED,</span><br><span class="line">  WAITTING,</span><br><span class="line">  TIMED_WAITTING,</span><br><span class="line">  TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>线程6种状态之间的转移图</li></ul><p><img src="https://s1.ax1x.com/2020/09/12/wd4gP0.png" alt="状态转移图"></p><ul><li><p>New;</p><ul><li><p>状态：A thread that has not yet started is in this state.</p><blockquote><p>一个还没有启动的线程就处在这种状态；</p></blockquote></li><li><p>手段：创建线程；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyThread myThread = <span class="keyword">new</span> MyThread();</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Runnable;</p><ul><li><p>状态：A thread is executing in the Java virtual machine but it may be waiting for other resources from the operating system such as processor.</p><blockquote><p>线程在Java虚拟机中执行，但它可能在等待从操作系统中得到其他需要的资源（比如CPU资源）</p></blockquote></li><li><p>手段：启动线程；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myThread.start();</span><br></pre></td></tr></table></figure></li><li><p>特征：</p><ul><li>1 线程启动后就会进入Runnable状态；</li><li>2 Runnable状态的线程都会被添加到一个等待队列中，等待CPU的调度（皇帝临幸）；</li><li>3 线程得到CPU资源后，就会执行。如果没得到，继续等待</li></ul></li></ul></li><li><p>Blocked;</p><ul><li><p>状态：Thread state for a thread blocked waiting for a monitor lock.<br>A thread in the blocked state is <strong>waiting for a monitor lock to enter a synchronized block/method</strong> or reenter a synchronized block/method after calling <code>wait()</code> Object.</p><blockquote><p>描述线程的一种状态：线程阻塞以等待一个监视器的锁；</p><p>阻塞状态下的线程会等待监视器的锁来：</p><ul><li>1 进入一个synchronized修饰的代码块/方法；</li><li>2 或者在调用wait()方法后重新进入synchronized修饰的代码块/方法；</li></ul></blockquote></li><li><p>特征：</p><ul><li>1 阻塞状态下的线程是在<strong>等待锁资源</strong>;</li><li>2 线程是否能够等待到锁<strong>不是很可控</strong>（起码程序员没有办法指定某个线程获得锁）；</li></ul></li></ul></li><li><p>Waiting;</p><ul><li><p>状态：A thread in the waiting state is waiting for another thread to perform a particular action.</p><blockquote><p>等待状态下的线程，正在等待另一个线程执行特定的动作；</p></blockquote></li><li><p>手段</p><p>A thread is in the waiting state due to calling one of the following methods:</p><ul><li><p>Object.wait with no timeout</p></li><li><p>Thread.join with no timeout</p></li><li><p>LockSupport.park</p><blockquote><p>以下原因会导致线程进入到等待状态：</p><ul><li>调用了wait()方法；</li><li>调用了join()方法；</li><li>调用了park()方法；</li></ul></blockquote></li></ul></li><li><p>特征：</p><ul><li>1 等待状态没有时间限制（无限期等待），所以需要某些方式来唤醒线程；</li><li>2 由于使线程进入睡眠状态的手段是可控的，所以唤醒线程的手段也是可控的；<ul><li>如果使用wait()方法使线程A进入等待状态，则<ul><li>需要使用notify()/notifyall()方法来唤醒；</li></ul></li><li>如果使用join()方法使线程A进入等待状态，则<ul><li>需要<strong>等待目标线程运行结束</strong></li></ul></li></ul></li></ul></li><li><p>应用：生产者-消费者模型中，当没有产品时，就需要</p><ul><li>1 让消费者等待；    手段：在消费者线程上调用wait()方法；</li><li>2 在生产者生产完毕后，唤醒消费者(去消费)； 手段：在消费者线程上调用notify()方法；</li></ul></li></ul></li><li><p>Timed_waiting;</p><ul><li><p>状态：有时长限制的等待状态（太久的话我就不等你了）</p></li><li><p>手段：</p><blockquote><ul><li>Thread.sleep</li><li>Object.wait with timeout</li><li>Thread.join with timeout</li><li>LockSupport.parkNanos</li><li>LockSupport.parkUntil</li></ul></blockquote></li><li><p>特征：</p><ul><li>1 其实就是在等待状态上添加了<strong>等待时长限制</strong>；</li><li>2 在时长超限后，线程就不再等待（可以做其他事情）；</li></ul></li></ul></li><li><p>Terminated;</p><ul><li><p>状态：A thread that has exited is in this state.</p><blockquote><p>一个已经退出的线程就处在这种状态；</p></blockquote></li><li><p>手段：</p><ul><li>1 执行完所有代码，线程正常结束；</li><li>2 线程被强制结束；【手段：stop()方法；   注：此手段已弃用】</li><li>3 线程执行时，抛出了未处理的异常；</li></ul></li><li><p>特征：</p><ul><li>1 线程一旦终结/死亡，就无法再复活了（不像超人）；</li><li>2 如果在已经终结的线程上调用start()方法，则程序会抛出<strong>非法线程状态异常</strong>；</li></ul></li></ul></li></ul><h6 id="线程实例常用的APIs"><a href="#线程实例常用的APIs" class="headerlink" title="线程实例常用的APIs"></a>线程实例常用的APIs</h6><ul><li><p>join()方法；</p><ul><li><p>作用：</p><blockquote><p>Waits for this thread to die. 等待当前线程死亡</p></blockquote></li><li><p>手段：<strong>强制让该线程执行</strong>，并且一直会让它执行完；</p></li><li><p>用法：</p><ul><li><p>1 实现一个线程类；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123; <span class="comment">// 手段2</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 线程执行时的工作：打印100次特定字符串</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Henry666："</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在类中直接定义主线程</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>2 在主线程中：</p><ul><li>创建线程实例；</li><li>启动线程；</li><li>强制线程执行完成；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123; <span class="comment">// 定义main()函数aka 开启一个主线程</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建一个新线程</span></span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable());</span><br><span class="line">    <span class="comment">// 开启新线程</span></span><br><span class="line">        t.start();</span><br><span class="line">    <span class="comment">// 等待，直到新线程执行结束</span></span><br><span class="line">        t.join();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程的工作</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"主线程"</span> + i + <span class="string">"：齐姐666"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">// 注：通过控制台的打印结果可以得到：主线程与新创建线程之间的执行顺序</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>应用：使某个线程优先执行，直到线程执行结束（然后才会回到公平竞争的情况）；</p></li><li><p>原理：join()方法其实是使用wait()方法实现的；</p></li></ul></li><li><p>wait()方法 &amp; notify()方法；</p><ul><li>作用：使得当前线程实例<strong>进入等待状态</strong>；</li><li>特征：<ul><li>1 wait()方法并不是线程类的方法，而是Object类的方法；</li><li>2 可以为wait()方法设置时长参数（这样就不需要别的线程唤醒了）</li></ul></li><li>用法【🚩 不够清晰】：<ul><li>1 在当前线程实例上调用wait()方法，使之进入<strong>无限期等待的状态</strong>；</li><li>2 直到某个线程调用了notify()/notifyall()方法，唤醒<strong>等待状态下的当前线程</strong>；</li></ul></li><li>代码：xxx</li></ul></li><li><p>yield()方法；</p><ul><li>作用：强制当前线程让出CPU资源，使得线程从<strong>执行中</strong>切换到<strong>可执行</strong>（都是Runnable状态）；</li><li>特征：让出CPU资源后，线程会回到等待队列中，重新等待CPU资源；</li></ul></li><li><p>sleep()方法；</p><ul><li><p>作用：使当前线程睡一会；</p></li><li><p>特征：</p><ul><li><p>1 线程并不会让出CPU资源（它只是占着CPU不做事罢了）；</p></li><li><p>2 sleep()方法的方法签名中抛出了异常，所以调用时需要使用try/catch捕获可能的异常进行检查；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myThread.sleep(<span class="number">1000</span>); <span class="comment">// 睡眠 1 秒钟</span></span><br></pre></td></tr></table></figure></li></ul><hr></li><li><p>currentThread()方法；</p><ul><li><p>作用：Returns a reference to the currently executing thread object.</p><blockquote><p>返回一个当前正在执行的线程对象的引用；</p></blockquote></li><li><p>特征：</p><ul><li>1 它是Thread类型的一个static方法；</li><li>2 方法的返回值类型是Thread类型；</li></ul></li><li><p>应用：打印当前线程实例；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Thread.currentThread());</span><br></pre></td></tr></table></figure></li></ul></li><li><p>getName()方法；</p><ul><li><p>作用：获取当前线程的名称；</p></li><li><p>特征：当前线程实例的名称可以由程序员手动设置；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable(), <span class="string">"壹齐学"</span>); <span class="comment">// 手段：Thread类的构造方法</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>getId()方法；</p><ul><li>作用：获取当前线程的id；</li></ul></li><li><p>getPriority()方法；</p><ul><li><p>作用：获取当前线程的优先级；</p></li><li><p>特征：</p><ul><li><p>1 优先级高的线程更有可能被CPU率先执行；</p></li><li><p>2 优先级的可选级别为1-10；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The minimum priority that a thread can have.最低优先级</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MIN_PRIORITY = <span class="number">1</span>;</span><br><span class="line">      </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The default priority that is assigned to a thread. 默认优先级</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> NORM_PRIORITY = <span class="number">5</span>;</span><br><span class="line">      </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The maximum priority that a thread can have. 最高优先级</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_PRIORITY = <span class="number">10</span>;</span><br></pre></td></tr></table></figure></li><li><p>3 如果设置的优先级别不在{1, 5, 10}中，则JDK会抛出非法参数异常；</p></li></ul></li></ul></li><li><p>setPriority()方法；</p><ul><li>作用：设置线程的优先级；</li></ul></li><li><p>stop()方法；</p><ul><li>作用：强制停止线程；</li><li>特征：已弃用（因为可能会导致一些线程安全方面的问题<strong>留坑了</strong>）</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h5 id=&quot;自定义注解相关知识&quot;&gt;&lt;a href=&quot;#自定义注解相关知识&quot; class=&quot;headerlink&quot; title=&quot;自定义注解相关知识&quot;&gt;&lt;/a&gt;自定义注解相关知识&lt;/h5&gt;</summary>
    
    
    
    <category term="Java Basic" scheme="https://henryinshanghai.github.io/categories/Java-Basic/"/>
    
    
    <category term="Java stuff" scheme="https://henryinshanghai.github.io/tags/Java-stuff/"/>
    
  </entry>
  
  <entry>
    <title>java基础之快速复习（2）</title>
    <link href="https://henryinshanghai.github.io/Java-Basic/2020/09/11/interview/20200911-java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BF%AB%E9%80%9F%E5%A4%8D%E4%B9%A0%EF%BC%882%EF%BC%89.html"/>
    <id>https://henryinshanghai.github.io/Java-Basic/2020/09/11/interview/20200911-java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BF%AB%E9%80%9F%E5%A4%8D%E4%B9%A0%EF%BC%882%EF%BC%89.html</id>
    <published>2020-09-11T02:30:00.000Z</published>
    <updated>2020-09-13T10:47:07.476Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Java基础-2"><a href="#Java基础-2" class="headerlink" title="Java基础(2)"></a>Java基础(2)</h4><h5 id="Java中的接口相关的内容"><a href="#Java中的接口相关的内容" class="headerlink" title="Java中的接口相关的内容"></a>Java中的接口相关的内容</h5><a id="more"></a><p>参考：<a href="https://juejin.im/post/6844903734053437448">接口的最少必要内容</a></p><ul><li><p>是：一个技术名称；</p></li><li><p>作用：定义一组抽象的行为规范；</p></li><li><p>创建接口的手段：interface接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> 接口名称</span>&#123;</span><br><span class="line">    <span class="comment">// 全局常量；</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 多个抽象方法；</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>用法：</p><ul><li><p>1 定义接口类型（<strong>只能定义这两个部分</strong>）；</p><ul><li><p>1 定义接口中的静态常量；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String name = <span class="string">"张三"</span>; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">String name = <span class="string">"张三"</span>; <span class="comment">// 2 接口中的成员变量一般都是常量(静态不可变)</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><pre><code>- 2 定义接口中的静态方法；  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> List&lt;String&gt; <span class="title">getUserNames</span><span class="params">(Long companyId)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">List&lt;String&gt; <span class="title">getUserNames</span><span class="params">(Long companyId)</span></span>; <span class="comment">// 接口中的抽象方法都是：公开抽象的</span></span><br></pre></td></tr></table></figure></code></pre><ul><li>2 定义具体类型来实现接口；</li></ul><ul><li><p>特征：</p><ul><li><p>1 接口类型<strong>不能直接实例化</strong>（从而得到实例）；</p><ul><li>手段：接口类型中<strong>不允许定义构造方法</strong>，会直接编译报错；</li></ul></li><li><p>2 定义类型时，可以同时实现多个不同类型的接口；</p><ul><li>超人既能Fly,还能Fight；</li></ul></li><li><p>3 接口类型不能继承自<strong>普通类型/抽象类型</strong>；</p><ul><li>原因：普通类型/抽象类型对方法与变量都没有任何限制，而接口对方法与变量有限制。所以不能直接继承它们</li></ul></li><li><p>4 如果：</p><ul><li><p>Ⅰ 类型A，继承自类型B，并实现了接口C；</p><blockquote><p>知识卡</p><ul><li>继承自类型B，则：<ul><li>A继承了类型B中的所有用 <strong>public 和 protected 关键字</strong>修饰的方法和属性（啥意思？😕）</li></ul></li><li>实现了接口C，则：<ul><li>A必须要实现接口C中规定的所有抽象方法；</li></ul></li></ul></blockquote></li><li><p>Ⅱ 类型B与接口C中有相同的方法f()…</p><ul><li>方法名相同的情况下，讨论<strong>方法的参数&amp;返回值类型</strong>:<ul><li>方法签名与返回值类型都相同，则：如果实现类中没有显式实现抽象方法f()，最终会执行父类中的f()方法；</li><li>方法签名相同，但返回值类型不同，则：子类无法成功定义，因为<strong>先继承，后实现</strong>（子类中方法的返回值类型必须与父类中保持一致）；</li><li>参数不同，但是返回值类型相同，则：在子类中需要实现接口中的抽象方法（签名不同，aka 一个新的方法）；</li><li>参数不同，返回值类型不同，则：子类中需要重新实现接口中的抽象方法；</li></ul></li><li>原理：子类会<strong>先继承自父类，然后再去实现接口</strong>；</li></ul></li></ul><hr></li><li><p>可以在一个普通类型中定义接口；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//源码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"><span class="comment">// 定义接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Climb</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>可以在一个接口类型中定义接口；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//源码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Hunt</span> </span>&#123;</span><br><span class="line"><span class="comment">// 定义接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Kill</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>应用（设计模式-wise）：</p><ul><li>工厂模式中：<ul><li>1 在工厂父类中定义一个接口；（用于创建产品对象）</li><li>2 在子类实现中来具体地创建实例；</li></ul></li></ul></li></ul><h5 id="Java中的访问权限修饰符的具体含义"><a href="#Java中的访问权限修饰符的具体含义" class="headerlink" title="Java中的访问权限修饰符的具体含义"></a>Java中的<em>访问权限修饰符</em>的具体含义</h5><p>参考：<a href="https://mp.weixin.qq.com/s/F7Rl64M5aD4UrzxUydPQdw">从HotSpot虚拟机源码认识访问权限修饰符</a></p><ul><li>private：<ul><li>被private修饰的部分，只在<strong>当前类</strong>中可以访问到</li></ul></li><li>package/default:<ul><li>被default修饰的部分，<strong>当前包中的其他类</strong>都能够访问到</li></ul></li><li>protected:<ul><li>被protected修饰的部分，<strong>其他包中的子类（继承自当前类）</strong>都能访问到</li></ul></li><li>public:<ul><li>被public修饰的部分，<strong>其他包中的任意类</strong>访问到</li></ul></li></ul><blockquote><p>访问控制因素：1 访问者是否在当前包； 2 访问者是否是当前类的子类；</p></blockquote><p><img src="https://s1.ax1x.com/2020/09/11/wNiTy9.png" alt="修饰符限定的访问范围"></p><h5 id="Java语言特性多态的具体应用场景"><a href="#Java语言特性多态的具体应用场景" class="headerlink" title="Java语言特性多态的具体应用场景"></a>Java语言特性<em>多态</em>的具体应用场景</h5><blockquote><p>注：这个问题真的把我问住了，对于多态的作用，一个基本的答案是“能够使一套代码根据运行时具体的实例产生不同的执行结果”。但是面试官并不满意，大脑迅速搜索库存中可能接近的答案，但是没能找到特别贴切的例子…😳</p></blockquote><p>其实JDBC就是多态应用的一个很好的例子🐣<font size=2>之前的理解只限于Oracle制定用法标准，具体的数据库厂商负责提供具体实现（像是某种设计模式）</font> 但其实在具体使用时，多态发挥了关键作用</p><p>参考：<a href="https://mp.weixin.qq.com/s/XShFqTkw2wmOd8-VCVNC-w">认识JDBC</a></p><ul><li>是：Oracle（Java语言的发明公司）所制定的<strong>Java程序员应该如何操作数据库</strong>的规范；</li><li>作用：<ul><li>1 规定了Java程序员在编写操作数据库的代码时所使用到的APIs（具体化程序员的工作）；</li><li>2 帮助程序员避开了操作数据库时繁琐的底层协议；</li></ul></li></ul><blockquote><p>说明：</p><ul><li>市场上有很多种类型的数据库（在Java语言之前就已经存在），比如MySQL、Oracle、 DB2等；</li><li>这些个厂商提供给Java程序员操作数据库的接口各不相同（毕竟是竞争关系嘛），这就导致Java程序员在编写代码时，需要根据具体使用的数据库类型来编写对应的代码；</li></ul></blockquote><ul><li><p>原理：</p><ul><li>1 Oracle（Java所属的公司）制定了JDBC规范，统一了Java程序员编写DB操作的编码方式；</li><li>2 Oracle要求/请求/强制/协商所有的数据库厂商，请大家根据我制定的规范，实现一个能够操作你家数据库的工具（这个工具叫做<strong>驱动</strong>）；</li><li>3 各大厂商就真的去根据JDBC规则实现了<strong>操作自家数据库的工具</strong>，然后免费开放出来，给Java程序员下载来用；</li></ul></li><li><p>用法（Java程序员编码过程）：</p><ul><li>1 把数据库厂商提供的jar包工具添加进项目中；（这个工具相当于接口的实现类）</li><li>2 使用JDBC规定的API编写代码来操作数据库；（JDBC规定的API相当于接口中的抽象方法）</li></ul><blockquote><p>Java程序员编写的代码为什么能够成功操作数据库的？</p><p>1 程序员在编写代码时，是在使用接口编程；</p><p>2 程序在运行时，会为接口类型绑定具体实例（厂商jar包中的实现类 <strong>代码中的多态</strong>）。所以代码真正执行时，使用的是<strong>厂商提供的子类的实例</strong>去完成对应数据库的操作；</p><p>3 既然用他们家的工具操作他们家的产品，当然就能正常地操作啦😄</p></blockquote></li></ul><h5 id="如何通过反射机制访问到类中的私有方法？"><a href="#如何通过反射机制访问到类中的私有方法？" class="headerlink" title="如何通过反射机制访问到类中的私有方法？"></a>如何通过反射机制访问到类中的私有方法？</h5><blockquote><p>注：这应该只是某个API，但当时记不得这么多细节了</p></blockquote><p>参考：<a href="https://www.cnblogs.com/mengdd/archive/2013/01/26/2878136.html">利用反射访问私有字段、方法</a></p><blockquote><p>使用反射机制的流程：</p><ul><li>1 获取到类的Class对象；</li><li>2 根据需要，获取到Method对象或者Field对象；<ul><li>任务：获取到Method对象；</li><li>API(参考文档):<ul><li>getMethod()方法，返回的是public的Method对象</li><li>getDeclaredMethod()，返回的Method对象可以是非public的</li></ul></li></ul></li></ul></blockquote><h6 id="访问私有方法的手段-反射用法："><a href="#访问私有方法的手段-反射用法：" class="headerlink" title="访问私有方法的手段/反射用法："></a>访问私有方法的手段/反射用法：</h6><ul><li>Prepare: 准备一个私有方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrivateClass</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 被private访问修饰符修饰的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">sayHello</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello: "</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>0 获取到私有方法的Method对象；</p><ul><li><p>手段：&lt;class对象&gt;.getDeclaredMethod(xxx, ooo);</p></li><li><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Ⅰ 创建实例</span></span><br><span class="line">PrivateClass p = <span class="keyword">new</span> PrivateClass();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ⅱ 使用实例获取到Class对象</span></span><br><span class="line">Class&lt;?&gt; classType = p.getClass();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ⅲ 使用Class对象获取Method对象</span></span><br><span class="line">Method method = classType.getDeclaredMethod(<span class="string">"sayHello"</span>,</span><br><span class="line">                                            <span class="keyword">new</span> Class[] &#123; String<span class="class">.<span class="keyword">class</span> &#125;)</span>;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>1 <strong>抑制Java访问权限的检查</strong>；</p><ul><li><p>手段：通过<strong>AccessibleObject类</strong>（Constructor、 Field和Method类的基类）中的<strong>setAccessible()</strong>方法；</p></li><li><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">method.setAccessible(<span class="keyword">true</span>); <span class="comment">// 抑制Java的访问控制检查</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>2 实现对方法的调用；</p><ul><li><p>手段：Method对象的invoke()方法；</p></li><li><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str = (String) method.invoke(p, <span class="keyword">new</span> Object[] &#123; <span class="string">"zhangsan"</span> &#125;);</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>总结：反射机制破坏了类的封装，private本来是保护方法只有在类的内部才能被访问到。但是现在通过反射机制，在其他类中（类的外部）同样可以访问private修饰的方法；</p><h5 id="项目中多线程具体的应用场景"><a href="#项目中多线程具体的应用场景" class="headerlink" title="项目中多线程具体的应用场景"></a>项目中多线程具体的应用场景</h5><blockquote><p>注：这个如果没有答好会很吃亏，对于项目中没有真正多线程经验的同学尤其如此。很露怯😳</p></blockquote><p>参考：<a href="https://mp.weixin.qq.com/s/hrhyihWRBnLX_ZRNachJmA">多线程的应用案例与具体场景</a></p><h6 id="多线程的使用场景"><a href="#多线程的使用场景" class="headerlink" title="多线程的使用场景"></a>多线程的使用场景</h6><ul><li>1 在一组操作中，有一个<strong>操作比较耗时</strong>（但又没那么重要）。可以开启一个新线程来执行这个操作<ul><li>比如用户注册完成后，赠送积分的操作；</li></ul></li><li>2 由于某些需求，可能<strong>需要某个线程一直在后台运行</strong>（比如定期执行某项任务-更新配置文件、采集特定信息…）；</li><li>3 某一个<strong>非常耗时的操作</strong>（比如备份数据库，这其实也算是后台任务）<ul><li>注：这种情况下，主线程需要轮询开启的线程以便了解备份的进度情况；</li></ul></li><li>4  某个业务逻辑有<strong>很多次的循环，而且每次循环之间没有相互影响</strong>（比如验证1万条url路径是否存在）；<ul><li>手段：开启50个线程，每个线程负责200条URL的验证；</li><li>特征：耗时比较短（砌墙的工人多了）</li></ul></li><li>5 希望获取到某个任务执行的进度（比如电影下载的进度条）；<ul><li>手段：不是很理解（做了Demo后回来补充 🚩）</li></ul></li></ul><h6 id="多线程的应用案例"><a href="#多线程的应用案例" class="headerlink" title="多线程的应用案例"></a>多线程的应用案例</h6><ul><li><p>1 Tomcat这个Web服务器就是采用多线程的方式来<strong>处理并发请求</strong>的;</p><ul><li>原理：<ul><li>1 每次有新的客户端向Web应用发起请求，Tomcat都会创建一个新的线程来处理它；</li><li>2 这个新线程最后会调用到程序员编写的Servlet代码-比如doGet()；</li></ul></li></ul></li><li><p>2 需要<strong>同时执行多个任务</strong>的场景（aka 异步处理）；</p><ul><li>手段：<ul><li>1 手动为每个任务创建一个线程；</li><li>2 通过JVM的线程调度来实现<strong>同时执行多个任务</strong>；</li></ul></li></ul><blockquote><p>单核CPU的电脑是不可能同时执行多个任务的。所以如果电脑只有一个核心，会使用一种技术，让每个线程都能够获取到CPU时间执行（这样看起来像是“<strong>同时执行</strong>”）</p></blockquote></li></ul><p>总结：多线程开发的目的是，<strong>尽量充分利用CPU资源</strong>；</p><p>SO， 如果某个业务逻辑执行非常耗时/效率低，就可以考虑使用多线程处理它。  </p>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;Java基础-2&quot;&gt;&lt;a href=&quot;#Java基础-2&quot; class=&quot;headerlink&quot; title=&quot;Java基础(2)&quot;&gt;&lt;/a&gt;Java基础(2)&lt;/h4&gt;&lt;h5 id=&quot;Java中的接口相关的内容&quot;&gt;&lt;a href=&quot;#Java中的接口相关的内容&quot; class=&quot;headerlink&quot; title=&quot;Java中的接口相关的内容&quot;&gt;&lt;/a&gt;Java中的接口相关的内容&lt;/h5&gt;</summary>
    
    
    
    <category term="Java Basic" scheme="https://henryinshanghai.github.io/categories/Java-Basic/"/>
    
    
    <category term="Java stuff" scheme="https://henryinshanghai.github.io/tags/Java-stuff/"/>
    
  </entry>
  
  <entry>
    <title>java基础之快速复习</title>
    <link href="https://henryinshanghai.github.io/Java-Basic/2020/09/09/interview/20200909-java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BF%AB%E9%80%9F%E5%A4%8D%E4%B9%A0.html"/>
    <id>https://henryinshanghai.github.io/Java-Basic/2020/09/09/interview/20200909-java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BF%AB%E9%80%9F%E5%A4%8D%E4%B9%A0.html</id>
    <published>2020-09-09T02:30:00.000Z</published>
    <updated>2020-09-11T06:58:19.631Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Java常见知识（Common-Sense）"><a href="#Java常见知识（Common-Sense）" class="headerlink" title="Java常见知识（Common Sense）"></a>Java常见知识（Common Sense）</h4><a id="more"></a><h5 id="1-重写-amp-重载"><a href="#1-重写-amp-重载" class="headerlink" title="1 重写&amp;重载"></a>1 重写&amp;重载</h5><ul><li>重写；<ul><li>是：一种编程技术；</li><li>作用：对父类中的方法重新进行实现，以满足子类的具体需求；</li><li>特征：<ul><li>1 发生在子类型/实现类型中；</li><li>2 方法签名与父类中的方法签名相同，方法实现应该会不同；</li><li>3 不能对父类中的private方法进行重写；</li></ul></li></ul></li><li>重载；<ul><li>是：一种编程技术；</li><li>作用：为某一个功能的方法，提供不同的/新的具体实现；</li><li>特征：<ul><li>1 编写的重载方法与原始方法在同一个类中；</li><li>2 重载方法的方法名和原始方法的方法名相同（某一功能），其他的细节不要求相同；</li></ul></li></ul></li></ul><h5 id="String、StringBuffer、StringBuilder的区别"><a href="#String、StringBuffer、StringBuilder的区别" class="headerlink" title="String、StringBuffer、StringBuilder的区别"></a>String、StringBuffer、StringBuilder的区别</h5><ul><li><p><strong>String</strong>:</p><ul><li><p>特征：</p><ul><li>1 String实例是不可变的；</li><li>2 由于实例是不可变的，所以多线程下实例是安全的（只可读）；</li><li>3 由于实例是不可变的，所以每次修改实例时，其实都在内存中新建了一个String实例；</li></ul></li><li><p>原理：String的底层数据结构是一个<em>被final修饰的字符数组</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span>[] value;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>StringBuffer &amp; StringBuilder</strong>:</p><ul><li><p>特征：</p><ul><li><p>1 实例是可变的；</p><ul><li>原理：<ul><li>1 它们都继承自AbstractStringBuilder 类型；</li><li>2 AbstractStringBuilder类型的底层数据结构为<em>一个*</em>没有被final修饰*<em>的字符数组</em>；</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title">Appendable</span>, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] value; <span class="comment">// 底层数据结构：字符数组</span></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></li><li><p>2 StringBuffer是线程安全的，而StringBuilder不是线程安全的；</p><ul><li>原理：<ul><li>StringBuffer对所有操作字符串的方法都加了锁，StringBuilder没有这么做；</li></ul></li></ul></li><li><p>3 单线程情况下，StringBuilder的效率更高；</p></li></ul></li></ul></li><li><p>用法总结：</p><ul><li>操作少量字符串时，可以使用String类型；</li><li>单线程情况下，操作大量字符串数据时，使用StringBuilder类型；</li><li>多线程情况下，操作大量字符串数据时，使用StringBuffer类型；</li></ul></li></ul><h5 id="Java中的自动装箱与自动拆箱"><a href="#Java中的自动装箱与自动拆箱" class="headerlink" title="Java中的自动装箱与自动拆箱"></a>Java中的自动装箱与自动拆箱</h5><ul><li>自动装箱；<ul><li>是：JDK提供的一种技术；</li><li>作用：<ul><li>在需要使用包装类型（Integer等）的场合中，如果程序员使用了基本数据类型（int），自动装箱技术能够把基本类型封装成为其对应的包装类型——从而保证代码编译的正确性；</li></ul></li><li>特征：<ul><li>这项技术会自动发挥作用，而不需要任何显式的语法声明；</li></ul></li></ul></li><li>自动拆箱：<ul><li>作用：在xxx的场合，如果xxx，xxx能够把包装类型自动拆封成为其对应的基本类型——从而xxx；</li></ul></li></ul><h5 id="Java中的-与equals-方法"><a href="#Java中的-与equals-方法" class="headerlink" title="Java中的==与equals()方法"></a>Java中的==与equals()方法</h5><ul><li><p>==</p><ul><li>是：Java提供的操作符；</li><li>作用：<ul><li>当==左右两侧是同类型的操作数时，<ul><li>如果操作数是<strong>基本数据类型</strong>，则：比较<em>操作数的数值</em>是否相等；</li><li>如果操作数是<strong>引用数据类型</strong>，则：比较<em>操作数的内存地址</em>是否相等；</li></ul></li><li>当==左右两侧不是同类型的操作数时，直接编译报错；</li></ul></li><li>特征：<ul><li>不同情况下，==的具体作用会有不同；</li></ul></li></ul></li><li><p>equals()方法</p><ul><li><p>是：Object类的一个方法；</p></li><li><p>作用：</p><ul><li><p>默认实现是：比较当前对象与另外一个对象的<em>内存地址是否相等</em>；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>特征：</p><ul><li>1 程序员在编码时，可能会根据具体的需要在类型中重写equals()方法——指定新的判等规则；</li><li>2 一般重写的判等规则，会根据对象的某个属性值来判断对象是否相等；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String类型的equals()方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">            <span class="comment">// 实现不重要，关键是equals()方法被重写了</span></span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>应用：</p><ul><li><p>1 String类型中的equals()方法被重写了，所以判断两个字符串实例是否相等时，判断依据是<strong>对象的值是否相等（而不是内存地址）</strong></p><blockquote><p>知识卡</p><p>当代码中创建String实例时，JVM会从常量池中查找是不是已经存在<strong>值与预期要创建的字符串实例相同</strong>的实例：</p><ul><li>如果存在，则：不新建String实例，而是直接把实例赋值给新的变量/引用；</li><li>如果不存在，则：会在常量池中新创建一个String实例；</li></ul><p>注：JDK1.8版本中似乎有些变动，具体待考证（Mark🚩）</p></blockquote></li></ul></li></ul><h5 id="关于final关键字"><a href="#关于final关键字" class="headerlink" title="关于final关键字"></a>关于final关键字</h5><ul><li><p>是：Java提供的一个关键字；</p></li><li><p>作用：</p><ul><li>修饰一个成份，标识此成份<strong>不可变</strong>；</li></ul></li><li><p>用法：</p><ul><li>1 修饰一个变量；<ul><li>1 变量为基本数据类型，则：变量的值一旦初始化后，就不能再改变；</li><li>2 变量为引用数据类型，则：变量初始化后，不能再重新绑定到新的对象；</li></ul></li><li>2 修饰一个方法；<ul><li>标识此方法不能被子类重写；</li></ul></li><li>3 修饰一个类；<ul><li>标识此类不能被扩展/继承；</li><li>原理：final类中的所有成员方法都隐式地被final修饰；</li></ul></li></ul><blockquote><p>知识卡：</p><p>关键字是什么？它是怎么发挥作用的？</p><p>是：字符串；</p><p>作用：能够被编译器识别出来，并默认有特定的含义；</p><p>原理：</p><ul><li>在实现编译器时，就对这些关键字的功能进行了内置的定义；</li><li><strong>所以关键字的作用是由Java编译器支持的</strong></li></ul></blockquote></li></ul><h5 id="Object类的常用方法【×7-×5】"><a href="#Object类的常用方法【×7-×5】" class="headerlink" title="Object类的常用方法【×7 + ×5】"></a>Object类的常用方法【×7 + ×5】</h5><p>🐖：在Java中，Object类型是所有其他类型的父类；</p><ul><li>getClass()方法；<ul><li>作用：返回当前运行时对象的Class对象 ；</li><li>特征：<ul><li>1 使用final关键字修饰（不允许子类重写）；</li></ul></li><li>应用：Java反射机制中获取运行时对象的信息；</li></ul></li><li>hashCode()方法；<ul><li>作用：返回对象的hash码；</li><li>应用：JDK中HashMap求key的哈希值；</li></ul></li><li>equals()方法；<ul><li>作用：比较两个对象的内存地址是否相等（aka 是否为同一个对象）；</li><li>用法：在子类型中重写，以重新定义判等规则；</li><li>应用：String类型；</li></ul></li><li>clone()方法；<ul><li>作用：创建并返回当前对象的一个副本；</li><li>用法规则：一般情况下，对于任何对象 x，<ul><li>表达式 x.clone() != x 为true；（副本与原始对象是独立的不同对象）</li><li>x.clone().getClass() == x.getClass() 为true ；（副本的Class对象与原始对象的Class对象是同一个对象）；</li></ul></li></ul></li><li>toString()方法；<ul><li>作用：返回实例的一个字符串标识；</li><li>规则：<em>类的名字</em>@<em>实例的哈希码的16进制表示</em></li></ul></li><li>多线程通知相关的方法【×5】 简单记忆<ul><li>1 notify()方法<ul><li>作用：唤醒正在等待锁的某个线程；</li><li>特征：<ul><li>1 如果有多个线程正在等待<strong>当前线程所持有的锁</strong>，此方法只会随机唤醒一个线程；</li><li>2 此方法不能被重写（被final修饰）；</li><li>3 此方法为native方法（使用C语言实现，无法查看源码）；</li></ul></li><li>用法：<ul><li>在当前线程对象上调用notify()方法，以此释放锁，从而唤醒其他等待这个锁的线程；</li></ul></li></ul></li><li>2 notifyAll()方法<ul><li>作用：唤醒正在等待锁的所有线程；</li><li>特征：<ul><li>等待锁的所有线程都被会被唤醒（😕唤醒也只有一个锁呀，唤醒有啥用？）</li></ul></li></ul></li><li>3 wait(long timeout)方法<ul><li>作用：暂停线程的执行；</li><li>特征：<ul><li>1 线程会释放自己所持有的锁；</li><li>2 timeout参数指定的是线程的释放锁之前的等待时间；</li></ul></li></ul></li><li>4 wait(long timeout, int nanos)<ul><li>作用：更加精确地暂停线程的执行；</li><li>特征：<ul><li>1 添加了nano参数，用于表示超时的额外时间（单位为毫微秒）；</li></ul></li></ul></li></ul></li><li>finalize ()方法；<ul><li>作用：定义<strong>实例被垃圾回收时</strong>所预期执行的操作；</li></ul></li></ul><h5 id="Java中的异常处理机制"><a href="#Java中的异常处理机制" class="headerlink" title="Java中的异常处理机制"></a>Java中的异常处理机制</h5><blockquote><p>知识卡</p><p>异常；</p><ul><li>是：一个名词；</li><li>作用：描述那些程序执行过程中发生的<strong>预期之外的事情</strong>；</li><li>特征：<ul><li>1 异常可以是语句执行引发的，也可以由程序员手动抛出（比如xxx数据类型不支持remove()操作，但是为了API的一致性又需要实现删除的API方法，那么就可以通过抛出一个异常来表示不支持此操作）；</li><li>2 程序中会使用一个异常对象来封装异常，以便使用代码处理它们；</li></ul></li><li>说明：程序中发生异常时，如果不做任何处理，程序就会完全终止；</li><li>处理异常的手段：<ul><li>在语言实现中提供一整套的处理机制（Java采用的手段）；</li></ul></li></ul></blockquote><ul><li><p>作用：</p><ul><li>1 为程序员提供一种编码方式，能够在编码时就对<em>可能出现的异常**</em>进行针对性的处理**；</li><li>2 通过1的处理，使得程序尽可能恢复正常并继续执行；</li></ul></li><li><p>特征：</p><ul><li>1 Throwable类型是Java异常类的顶级父类；</li><li>2 程序的异常分为两类（它们都是Throwable的子类）：<ul><li>Excpetion(异常)；</li><li>Error(错误)；</li></ul></li></ul></li><li><p>原理：当出现异常对象时，JRE就会尝试寻找异常处理程序(程序员手动编写)来处理异常；</p></li><li><p>用法：</p><ul><li>1 当程序运行出现Error时，表示出现了非常严重的错误（一般是虚拟机发生问题，通过编码无法处理这些错误）；<ul><li>Error的具体类型：<ul><li>内存溢出错误、虚拟机运行错误、类定义错误等；</li></ul></li><li>处理手段：JVM终止线程的运行（程序员不需要做任何事情）；</li></ul></li><li>2 当程序运行出现Exception时，表示出现了一些问题，但是可以通过代码处理这些问题；<ul><li>Exception的具体类型：<ul><li>空指针异常、算术运算异常、下标越界异常；</li></ul></li><li>处理手段：程序员在编码时，手动通过try/catch语法来对异常进行处理；</li></ul></li></ul></li><li><p>用法模板（编程语法）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">// 可能出现异常的代码片段</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (预期出现的异常类型)&#123;</span><br><span class="line">    <span class="comment">// 对捕捉到的异常进行处理的代码</span></span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 不管是否发生异常都会被执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>finally代码块的特征：<ul><li>0 正常情况下，finally块中的语句肯定会被执行（除非发生异常，或者被强制退出）；</li><li>1 如果try/catch中有return语句，finally代码块会在return之前被执行；</li></ul></li></ul></li></ul><h5 id="Java中获取键盘输入的手段"><a href="#Java中获取键盘输入的手段" class="headerlink" title="Java中获取键盘输入的手段"></a>Java中获取键盘输入的手段</h5><ul><li><p>手段1：Scanner类型；</p><ul><li><p>用法：</p><ul><li><p>1 使用标准输入(<strong>System.in</strong>)作为参数，创建一个Scanner对象；</p></li><li><p>2 调用Scanner实例的API，来在代码中获取到<em>用户通过键盘输入的内容</em>；</p></li><li><p>3 用完Scanner实例之后，关闭该实例；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">String s = input.nextLine();</span><br><span class="line">input.close();</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>手段2：不常用Mark🚩</p></li></ul><h5 id="Java中接口与抽象类的区别"><a href="#Java中接口与抽象类的区别" class="headerlink" title="Java中接口与抽象类的区别"></a>Java中接口与抽象类的区别</h5><ul><li>本质区别；<ul><li>接口用于定义一组行为规范，而抽象类用于抽象某一个实体类型（是模板设计）；</li></ul></li><li>语法特征上的区别（抽象类 VS 接口）：<ul><li>1 接口中定义的方法一般都是抽象的（Java8之后也允许接口方法有默认实现），而抽象类中可以有具体的方法实现；</li><li>2 接口中的实例变量默认会用final修饰，而抽象类不会；</li><li>3 接口中的方法默认都是public的；</li></ul></li><li>语法特征上的区别（类 VS 接口）<ul><li>1 自定义类型能够实现多个接口，但只能实现/继承一个抽象类；</li><li>2 自定义类型实现接口时，必须实现接口中所有的抽象方法。但实现抽象类时，可以选择性地实现其中的抽象方法；</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;Java常见知识（Common-Sense）&quot;&gt;&lt;a href=&quot;#Java常见知识（Common-Sense）&quot; class=&quot;headerlink&quot; title=&quot;Java常见知识（Common Sense）&quot;&gt;&lt;/a&gt;Java常见知识（Common Sense）&lt;/h4&gt;</summary>
    
    
    
    <category term="Java Basic" scheme="https://henryinshanghai.github.io/categories/Java-Basic/"/>
    
    
    <category term="Java stuff" scheme="https://henryinshanghai.github.io/tags/Java-stuff/"/>
    
  </entry>
  
</feed>
