<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java垃圾回收机制</title>
    <url>/JVM/2020/09/07/interview/20200907-Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.html</url>
    <content><![CDATA[<h4 id="JVM之垃圾回收"><a href="#JVM之垃圾回收" class="headerlink" title="JVM之垃圾回收"></a>JVM之垃圾回收</h4><h5 id="为什么要进行垃圾回收？"><a href="#为什么要进行垃圾回收？" class="headerlink" title="为什么要进行垃圾回收？"></a>为什么要进行垃圾回收？</h5><ul>
<li>1 提高内存资源的利用率；</li>
<li>2 防止无用的垃圾挤占内存空间，影响程序的正常运行；</li>
</ul>
<a id="more"></a>

<h5 id="如何判断内存中的一个对象是不是垃圾？"><a href="#如何判断内存中的一个对象是不是垃圾？" class="headerlink" title="如何判断内存中的一个对象是不是垃圾？"></a>如何判断内存中的一个对象是不是垃圾？</h5><h6 id="知识卡"><a href="#知识卡" class="headerlink" title="知识卡"></a>知识卡</h6><ul>
<li>垃圾：不再被使用的资源；</li>
<li>程序中的垃圾：不再被使用的对象；</li>
</ul>
<h6 id="如何判断一个对象已经“不再被使用”（aka-成为垃圾）？"><a href="#如何判断一个对象已经“不再被使用”（aka-成为垃圾）？" class="headerlink" title="如何判断一个对象已经“不再被使用”（aka 成为垃圾）？"></a>如何判断一个对象已经“不再被使用”（aka 成为垃圾）？</h6><p>答：垃圾判定算法；</p>
<ul>
<li>手段1：引用计数法；<ul>
<li>具体方法：<ul>
<li>1 在内存中创建对象后，即为对象配置一个引用计数器；</li>
<li>2 如果对象通过某种方式（比如类A持有类B的实例对象）被引用，则引用计数器的值+1；</li>
<li>3 如果引用关系结束，则引用计数器的值-1（什么叫引用关系结束？😕）；</li>
</ul>
</li>
<li>作用：<ul>
<li>这样通过对象的引用计数器的值，就可以清楚对象是不是已经变成垃圾，从而决定是否回收此对象占用的空间；</li>
</ul>
</li>
<li>特征：<ul>
<li>1 执行效率高，对主程序影响小；</li>
<li>2 如果程序中出现了循环引用（a引用b，而b也引用a），则引用计数法无法处理这种类型的垃圾；</li>
</ul>
</li>
</ul>
</li>
<li>手段2：可达性分析算法；<ul>
<li>具体方法：<ul>
<li>1 使用<em>有向图中的一个顶点</em>来表示一个对象；</li>
<li>2 使用<em>有向图中的一条边</em>来表示“<em>一个对象对另一个对象的引用</em>”；</li>
<li>3 从特定的顶点（GC Root）开始进行搜索指定的对象（待审判的对象defendant），<ul>
<li>如果搜索到了defendant,则它不是垃圾；</li>
<li>如果没能搜索到defendant,则它已经变成了垃圾（不可达对象）；</li>
</ul>
</li>
</ul>
</li>
<li>作用：<ul>
<li>通过指定对象defendant在有向图中是否可以到达，就可以清楚对象是不是已经变成垃圾；</li>
</ul>
</li>
<li>特征：<ul>
<li>1 能够处理“循环引用的垃圾对象”；</li>
<li>2 这是JVM垃圾回收所选择的手段；</li>
<li>3 可以被作为GC Root的对象有：虚拟机栈中所引用的对象…</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="找到哪些对象是垃圾后，怎么回收它们占用的内存？"><a href="#找到哪些对象是垃圾后，怎么回收它们占用的内存？" class="headerlink" title="找到哪些对象是垃圾后，怎么回收它们占用的内存？"></a>找到哪些对象是垃圾后，怎么回收它们占用的内存？</h5><p>答：垃圾回收算法；</p>
<h6 id="知识卡-1"><a href="#知识卡-1" class="headerlink" title="知识卡"></a>知识卡</h6><p>Java中提供了4种垃圾回收的手段：</p>
<ul>
<li>标记-清除算法；<ul>
<li>SOP过程：<ul>
<li>1 遍历内存中所有的对象；</li>
<li>2 标记出哪些对象是垃圾（使用垃圾判定算法）；</li>
<li>3 清理掉所有垃圾对象；</li>
</ul>
</li>
<li>特征：<ul>
<li>1 这种清除方式会导致<em>清除出来的内存空间</em>不连续地分布在内存中，aka，一堆的<strong>内存碎片</strong>；</li>
<li>2 过多的内存碎片会导致内存的使用率降低，因为清理出的空间可能<em>不足够创建一个新的对象</em>；</li>
</ul>
</li>
</ul>
</li>
<li>复制算法；<ul>
<li>SOP过程：<ul>
<li>1 把内存空间划分成两个区域：空闲区域A + 用于存储对象的区域B；</li>
<li>2 当区域B空间用完的时候，则：<ul>
<li>1 把区域B中的非垃圾对象复制一份，拷贝/复制到区域A中；</li>
<li>2 清除区域B中的所有对象（垃圾 + 非垃圾）；</li>
</ul>
</li>
</ul>
</li>
<li>特征：<ul>
<li>1 内存中不会出现内存碎片；</li>
<li>2 整体内存使用率低，因为只有一半的内存被用来存储对象；</li>
<li>3 复制对象的过程比较耗时；</li>
</ul>
</li>
<li>应用：<ul>
<li>回收JVM新生代（<font size=2>注：JVM内存区域的划分需要另一篇博客了</font>）中存活率低的对象；</li>
</ul>
</li>
</ul>
</li>
<li>3 标记 - 整理算法；<ul>
<li>SOP过程：<ul>
<li>1 找到内存中所有的垃圾对象；</li>
<li>2 把1中找到的所有垃圾对象移动到一个连续的空间（dumping area）中；</li>
<li>3 把dumping area中的对象全部清除；</li>
</ul>
</li>
<li>特征：<ul>
<li>1 不会产生内存碎片；</li>
<li>2 不会导致内存空间的浪费；</li>
<li>3 移动垃圾对象是一个耗时的过程；</li>
</ul>
</li>
<li>应用：<ul>
<li>对象存活率比较高的场合；</li>
</ul>
</li>
</ul>
</li>
<li>4 分代收集算法（博采众长，为我所用）<ul>
<li>SOP过程：<ul>
<li>1 把JVM内存分成3个区域：新生代、老年代、永久代；</li>
<li>2 对不同区域中的对象，采用不同的垃圾回收算法：<ul>
<li>新生代（用于存放生命周期短的对象）：使用复制算法【标记-复制到空闲区-整体删除】；</li>
<li>老年代（用于存放生命周期长的对象）：使用标记-整理算法【标记-整理-集中删除】；</li>
</ul>
</li>
</ul>
</li>
<li>特征：<ul>
<li>1 对JVM的内存空间进行了逻辑划分；</li>
<li>2 针对不同区域采用了不同的清除算法；</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="清除垃圾的工作具体是谁来完成的？"><a href="#清除垃圾的工作具体是谁来完成的？" class="headerlink" title="清除垃圾的工作具体是谁来完成的？"></a>清除垃圾的工作具体是谁来完成的？</h5><p>答：垃圾收集器；</p>
<p>知识卡：</p>
<p>​    对于JVM中不同的内存区域，具体执行垃圾清除工作的垃圾收集器也是不一样的；</p>
<p>​    原因：因为不同的<strong>垃圾收集器</strong>实现了不同的<strong>垃圾回收算法</strong>；</p>
<p>具体分类：</p>
<ul>
<li>新生代区域（同一个回收算法的不同实现结果）：<ul>
<li>1 Serial收集器；</li>
<li>2 ParNew收集器；</li>
<li>3 Parallel收集器；</li>
</ul>
</li>
</ul>
<blockquote>
<p>虽然不清楚为什么有这么些个收集器，但是它们都是某一个算法的具体实现结果。只是在实现时新增了独特的特性…</p>
</blockquote>
<ul>
<li>老年代区域：<ul>
<li>1 Serial Old收集器；</li>
<li>2 ParNew Old收集器；</li>
<li>3 CMS收集器；</li>
</ul>
</li>
</ul>
<blockquote>
<p>好歹记住一个收集器吧，Serial收集器。<strong>单线程串行(Serial)执行</strong>垃圾回收，<strong>(1)</strong>不需要切换线程，<strong>(2)</strong>但是回收时会终止程序的执行；</p>
</blockquote>
<blockquote>
<p>alright, until next time.😄</p>
</blockquote>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Garbage Collection</tag>
      </tags>
  </entry>
  <entry>
    <title>岛屿问题</title>
    <url>/Algorithm/2020/09/04/interview/20200904-%E5%B2%9B%E5%B1%BF%E9%97%AE%E9%A2%98.html</url>
    <content><![CDATA[<h5 id="题设与条件"><a href="#题设与条件" class="headerlink" title="题设与条件"></a>题设与条件</h5><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p>
<p>岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。</p>
<p>此外，你可以假设该网格的四条边均被水包围。</p>
<blockquote>
<p>注：这是字节跳动第二次面试时给的题目。当时面试官说求出相互不联通的湖泊的数量</p>
<p>现在想想，要是相互连通的话，不就是同一个湖泊了吗？😔</p>
</blockquote>
<a id="more"></a>

<p><img src="https://s1.ax1x.com/2020/09/04/wkC3Dg.png" alt="题设示例"></p>
<h5 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h5><p>一个岛屿可以沿着上下左右方向不断扩展（直到遇到湖泊），扩展得到的是一个大的岛屿；</p>
<p>这本质上是一个搜索问题，只不过这里是在m×n的网格中搜索；</p>
<p>在网格中搜索，这是一个典型的DFS应用场景；</p>
<h6 id="二叉树的DFS"><a href="#二叉树的DFS" class="headerlink" title="二叉树的DFS"></a>二叉树的DFS</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">	<span class="comment">// 递归结束条件</span></span><br><span class="line">	<span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">// 递归遍历两个相邻的节点：左孩子、右孩子</span></span><br><span class="line">	TreeNode(root.left);</span><br><span class="line">	TreeNode(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二叉树DFS的两个要点：</p>
<ul>
<li>1 访问相邻节点：二叉树的相邻节点就只有左子节点 + 右子节点；由于二叉树本身是一个递归结构，所以遍历过程就只需要递归地调用左右子树即可</li>
<li>2 递归终结条件：<ul>
<li>一般地，二叉树 DFS 的结束条件是 root == null；</li>
<li>作用：<ul>
<li>1  root 指向的子树为空，不需要再往下遍历了；</li>
<li>2 在 root == null 的时候及时返回，让后面的 root.left 和 root.right 不会出现空指针异常；</li>
</ul>
</li>
</ul>
</li>
</ul>
<h6 id="类比出网格的DFS遍历："><a href="#类比出网格的DFS遍历：" class="headerlink" title="类比出网格的DFS遍历："></a>类比出网格的DFS遍历：</h6><ul>
<li>1 访问相邻节点：在网格（二维数组/矩阵）中，当前节点（r, c）的相邻节点为- (r-1, c)、(r+1, c)、(r, c-1)、(r, c+1)；</li>
<li>2 递归结束条件：当前网格已经是数组的边界。aka，DFS 的递归结束条件就是网格的四个边界；</li>
</ul>
<p>网格DFS遍历的模板：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">	<span class="comment">// 递归结束条件：如果坐标(r, c)超出网格，直接返回</span></span><br><span class="line">	<span class="keyword">if</span>(!inArea(grid, r, c))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	dfs(grid, r - <span class="number">1</span>, c);<span class="comment">// 上</span></span><br><span class="line">	dfs(grid, r + <span class="number">1</span>, c);<span class="comment">// 下</span></span><br><span class="line">	dfs(grid, r, c - <span class="number">1</span>);<span class="comment">// 左</span></span><br><span class="line">	dfs(grid, r, c + <span class="number">1</span>);<span class="comment">// 右</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">inArea</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 合法的网格范围</span></span><br><span class="line">	<span class="keyword">return</span> r &gt;= <span class="number">0</span> &amp;&amp; r &lt; grid.length &amp;&amp; c &gt;= <span class="number">0</span> &amp;&amp; c &lt; grid[<span class="number">0</span>].length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="避免搜索时，搜索到重复的网格；"><a href="#避免搜索时，搜索到重复的网格；" class="headerlink" title="避免搜索时，搜索到重复的网格；"></a>避免搜索时，搜索到重复的网格；</h6><p>手段：</p>
<ul>
<li>标记搜索过的网格；</li>
<li>然后在搜索前，先判断网格是不是已经搜索过了（如果是，跳过此网格）；</li>
</ul>
<p>具体方法：更新搜索过的网格中的值（不是岛屿的网格不会被搜索到）；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">	<span class="comment">// 递归结束条件：如果坐标(r, c)超出网格，直接返回</span></span><br><span class="line">	<span class="keyword">if</span>(!inArea(grid, r, c))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 如果这个格子不是岛屿，直接返回</span></span><br><span class="line">	<span class="keyword">if</span>(grid[r][c] != <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	grid[r][c] = <span class="number">2</span>;<span class="comment">// 标记已经遍历的格子</span></span><br><span class="line">	</span><br><span class="line">	dfs(grid, r - <span class="number">1</span>, c);<span class="comment">// 上</span></span><br><span class="line">	dfs(grid, r + <span class="number">1</span>, c);<span class="comment">// 下</span></span><br><span class="line">	dfs(grid, r, c - <span class="number">1</span>);<span class="comment">// 左</span></span><br><span class="line">	dfs(grid, r, c + <span class="number">1</span>);<span class="comment">// 右</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">inArea</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> r &gt;= <span class="number">0</span> &amp;&amp; r &lt; grid.length &amp;&amp; c &gt;= <span class="number">0</span> &amp;&amp; c &lt; grid[<span class="number">0</span>].length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法问题一旦有了模板，接下来就只是填写代码的工作了</p>
<h6 id="使用模板解决当前问题"><a href="#使用模板解决当前问题" class="headerlink" title="使用模板解决当前问题"></a>使用模板解决当前问题</h6><ul>
<li>从网格的左上角开始进行 DFS。</li>
<li>走到一个格子，若该格子不是陆地，则跳过该格子继续搜索；</li>
<li>若该格子是陆地，就往它的上下左右四个方向进行搜索；<ul>
<li>直至搜索到边界处或者搜索到已经遍历过的格子，说明一个岛屿成功找出，则把岛屿数量 count + 1。</li>
</ul>
</li>
</ul>
<h5 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                    dfs(grid, i, j);</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 递归结束条件：如果坐标(r, c)超出网格，直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(!inArea(grid, r, c))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 如果这个格子不是岛屿，直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(grid[r][c] != <span class="string">'1'</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        grid[r][c] = <span class="string">'2'</span>;<span class="comment">// 标记已经遍历的格子</span></span><br><span class="line">        </span><br><span class="line">        dfs(grid, r - <span class="number">1</span>, c);<span class="comment">// 上</span></span><br><span class="line">        dfs(grid, r + <span class="number">1</span>, c);<span class="comment">// 下</span></span><br><span class="line">        dfs(grid, r, c - <span class="number">1</span>);<span class="comment">// 左</span></span><br><span class="line">        dfs(grid, r, c + <span class="number">1</span>);<span class="comment">// 右</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">inArea</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">	    <span class="keyword">return</span> r &gt;= <span class="number">0</span> &amp;&amp; r &lt; grid.length &amp;&amp; c &gt;= <span class="number">0</span> &amp;&amp; c &lt; grid[<span class="number">0</span>].length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="代码分解步骤"><a href="#代码分解步骤" class="headerlink" title="代码分解步骤"></a>代码分解步骤</h5><blockquote>
<p>1 从最左上角的网格开始遍历二维数组中的所有网格</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.length; i++)&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">            ...</span><br></pre></td></tr></table></figure>

<blockquote>
<p>2 如果当前网格是一个陆地网格，开始在二维数组中进行DFS搜索</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(grid[i][j] == <span class="string">'1'</span>)&#123;</span><br><span class="line">	dfs(grid, i, j);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>3 搜索结束后，就找到了一个岛屿。对找到的岛屿进行计数</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">...</span><br><span class="line">	count++;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>4 实现二维数组中网格的DFS遍历算法</p>
</blockquote>
<ul>
<li><p>1 递归终结条件</p>
<ul>
<li><p>1 如果坐标(r, c)超出网格，则停止搜索；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(!inArea(grid, r, c))</span><br><span class="line">	<span class="keyword">return</span>; <span class="comment">// 手段：直接返回</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>2 如果遇到非岛屿的网格，则停止搜索；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果这个格子不是岛屿，直接返回</span></span><br><span class="line"><span class="keyword">if</span>(grid[r][c] != <span class="string">'1'</span>)</span><br><span class="line">	<span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>2 本级递归需要做的事情</p>
<ul>
<li><p>1 标记已经被搜索到的格子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">grid[r][c] = <span class="string">'2'</span>;<span class="comment">// 标记已经遍历的格子</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>2 向上下左右四个方向继续执行搜索；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dfs(grid, r - <span class="number">1</span>, c);<span class="comment">// 上</span></span><br><span class="line">dfs(grid, r + <span class="number">1</span>, c);<span class="comment">// 下</span></span><br><span class="line">dfs(grid, r, c - <span class="number">1</span>);<span class="comment">// 左</span></span><br><span class="line">dfs(grid, r, c + <span class="number">1</span>);<span class="comment">// 右</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>3 定义方格所允许的合法边界</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">inArea</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">	    <span class="keyword">return</span> r &gt;= <span class="number">0</span> &amp;&amp; r &lt; grid.length &amp;&amp; c &gt;= <span class="number">0</span> &amp;&amp; c &lt; grid[<span class="number">0</span>].length;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>如果使用非法边界表示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(r &lt; <span class="number">0</span> || r &gt;= grid.length || c &lt; <span class="number">0</span> || c &gt;= grid[<span class="number">0</span>].length || grid[r][c] != <span class="string">'1'</span>)&#123;...&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h5 id="代码重现"><a href="#代码重现" class="headerlink" title="代码重现"></a>代码重现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取到二维数组中所有的岛屿数量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 从最左上角的网格开始遍历，搜索存在的岛屿</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;grid.length; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;grid[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">            <span class="comment">// 如果当前网格是陆地...</span></span><br><span class="line">            <span class="keyword">if</span>(grid[i][j] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                <span class="comment">// 开始进行DFS搜索，以找到完整的当前岛屿</span></span><br><span class="line">                dfs(grid, i, j);</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二维数组中网格的DFS遍历	</span></span><br><span class="line"><span class="comment">// 0 递归方法的作用与返回值	作用：</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1递归终结条件</span></span><br><span class="line">    <span class="comment">// 1-1   当前网格超出合法边界</span></span><br><span class="line">    <span class="keyword">if</span>(r&lt;<span class="number">0</span> || c&lt;<span class="number">0</span> || r &gt;= grid.length || c &gt;=grid[<span class="number">0</span>].length)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1-2 当前网格为湖泊网格</span></span><br><span class="line">    <span class="keyword">if</span>(grid[i][j] != <span class="string">'1'</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2 本级递归需要做的事情</span></span><br><span class="line">    <span class="comment">// 标记已经搜索过的网格</span></span><br><span class="line">    grid[r][c] = <span class="string">'2'</span>; <span class="comment">// 注：这里是字符，而不是数字</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 开始搜索当前网格相邻的网格</span></span><br><span class="line">    dfs(grid, r-<span class="number">1</span>, c);</span><br><span class="line">    dfs(grid, r+<span class="number">1</span>, c);</span><br><span class="line">    dfs(grid, r, c-<span class="number">1</span>);</span><br><span class="line">    dfs(grid, r, c+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="参考：二维数组DFS框架"><a href="#参考：二维数组DFS框架" class="headerlink" title="参考：二维数组DFS框架"></a>参考：<a href="https://blog.csdn.net/weixin_45594025/article/details/106095271?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param">二维数组DFS框架</a></h6><blockquote>
<p> until next time 🐷</p>
</blockquote>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>DFS in 2-dimensional-array</tag>
      </tags>
  </entry>
  <entry>
    <title>java基础之MyBatis</title>
    <url>/MyBatis/2020/09/04/interview/20200904-java%E5%9F%BA%E7%A1%80%E4%B9%8BMyBatis%EF%BC%88%E6%8E%A5%E5%8F%A3%E6%98%A0%E5%B0%84%E5%8E%9F%E7%90%86%EF%BC%89.html</url>
    <content><![CDATA[<h4 id="既然是自己看的，就不用一套一套的。直接攻击要点吧"><a href="#既然是自己看的，就不用一套一套的。直接攻击要点吧" class="headerlink" title="既然是自己看的，就不用一套一套的。直接攻击要点吧"></a>既然是自己看的，就不用一套一套的。直接攻击要点吧</h4><a id="more"></a>

<h6 id="Q1-MyBatis中Dao接口的工作原理（从Dao中的接口方法映射到XML中的SQL语句）"><a href="#Q1-MyBatis中Dao接口的工作原理（从Dao中的接口方法映射到XML中的SQL语句）" class="headerlink" title="#Q1 MyBatis中Dao接口的工作原理（从Dao中的接口方法映射到XML中的SQL语句）"></a>#Q1 MyBatis中Dao接口的工作原理（从<em>Dao中的接口方法</em>映射到<em>XML中的SQL语句</em>）</h6><blockquote>
<p>前置知识卡：</p>
<p>1 Dao层接口是一个Mapper类型的接口(程序员不会为此接口编写实现类)；</p>
<p>2 接口方法与XML映射文件的对应规则；</p>
<ul>
<li>接口的全限定名，就是XML映射文件的namespace属性绑定的值；</li>
<li>接口的方法名，就是XML映射文件中Statement的id属性所绑定的值；</li>
<li>接口方法的参数，就是SQL语句中传入的变量；</li>
</ul>
<p>3 在MyBatis中，XML映射文件的每一个语句（<insert>、<select>等）都会被解析成为一个Statement对象；</p>
</blockquote>
<p>答：当程序员在代码中调用接口中的方法时，</p>
<ul>
<li>1 使用<strong>接口全限定名 + 方法名</strong>的字符串作为key来定位到XML映射文件中唯一的MapperStatement对象；</li>
<li>2 执行MapperStatement对象所封装的SQL语句；</li>
<li>3 返回SQL语句的执行结果。</li>
</ul>
<p>举例：</p>
<p>​    使用<code>cn.mybatis.mappers.StudentDao.findStudentById</code>作为key，可以唯一地找到：</p>
<ul>
<li><code>namespace</code>为 <code>com.mybatis.mappers.StudentDao</code>下面</li>
<li><code>id</code>为 <code>findStudentById</code>的 MapperStatement。</li>
</ul>
<h6 id="Q2-Dao中方法的参数不同时，可以进行方法重载吗？"><a href="#Q2-Dao中方法的参数不同时，可以进行方法重载吗？" class="headerlink" title="#Q2:Dao中方法的参数不同时，可以进行方法重载吗？"></a>#Q2:Dao中方法的参数不同时，可以进行方法重载吗？</h6><p>答：Mapper接口里的方法，是不能重载的，因为是使用 <strong>全限名+方法名</strong> 的保存和寻找策略</p>
<p>Mapper接口的工作原理：JDK动态代理；</p>
<p>工作流程：</p>
<ul>
<li>1 Mybatis运行时会使用<strong>JDK动态代理</strong>为Mapper接口生成<strong>代理对象proxy</strong>；</li>
<li>2 代理对象会拦截<strong>接口方法</strong>，转而执行<strong>MapperStatement所代表的sql</strong>；</li>
<li>3 最后将<strong>sql执行结果</strong>返回；</li>
</ul>
]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>Java stuff</tag>
      </tags>
  </entry>
  <entry>
    <title>java基础之Redis</title>
    <url>/Redis/2020/09/03/interview/20200903-java%E5%9F%BA%E7%A1%80%E4%B9%8BRedis.html</url>
    <content><![CDATA[<h4 id="Java应用之Redis（快速记忆）"><a href="#Java应用之Redis（快速记忆）" class="headerlink" title="Java应用之Redis（快速记忆）"></a>Java应用之Redis（快速记忆）</h4><h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><ul>
<li>是：数据库；</li>
<li>作用：存储数据；</li>
</ul>
<a id="more"></a>

<ul>
<li>特征：<ul>
<li>1 数据存储在内存中（所以读写速度很快）；</li>
<li>2 支持事务；</li>
<li>3 支持持久化；</li>
<li>4 支持LUA脚本（能够方便地定制与扩展功能）；</li>
<li>5 支持多种集群方案（所以可以在分布式环境下使用）；</li>
</ul>
</li>
<li>应用：<ul>
<li>1 缓存；</li>
<li>2 分布式锁；</li>
</ul>
</li>
</ul>
<h5 id="为什么要用缓存？"><a href="#为什么要用缓存？" class="headerlink" title="为什么要用缓存？"></a>为什么要用缓存？</h5><ul>
<li>1 能够更快地对查询进行响应；</li>
<li>2 由于缓存是存在内存中地，因此可以支持更高的并发量；</li>
</ul>
<h5 id="Redis比起Map-guava有什么不一样？"><a href="#Redis比起Map-guava有什么不一样？" class="headerlink" title="Redis比起Map/guava有什么不一样？"></a>Redis比起Map/guava有什么不一样？</h5><ul>
<li>map/guava：<ul>
<li>是：本地缓存；</li>
<li>作用：在本地机器上为数据在内存中创建缓存；</li>
<li>特征：<ul>
<li>1 轻量快速；</li>
<li>2 生命周期随着JVM的销毁而结束（aka 无法持久化）；</li>
<li>3 多态机器之间的缓存数据没有办法保持一致（aka 多实例时，缓存不一致）；</li>
</ul>
</li>
</ul>
</li>
<li>Redis/memcached：<ul>
<li>是：分布式缓存；</li>
<li>作用：为多台机器提供统一的缓存数据；</li>
<li>特征：<ul>
<li>1 当有多台机器/服务器/电脑时，多台机器能够共用一份缓存数据（aka 多实例时，缓存具有一致性）；</li>
<li>2 为了缓存能够稳定地服务于多台机器，需要做很多其他的准备；</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="Redis-VS-Memcached"><a href="#Redis-VS-Memcached" class="headerlink" title="Redis VS Memcached"></a>Redis VS Memcached</h5><ul>
<li>支持的数据类型：<ul>
<li>Redis支持更多的数据类型（String, list, hash, set等），Memcached只支持简单的数据类型；</li>
</ul>
</li>
<li>数据持久化：<ul>
<li>Redis支持数据持久化（aka 把缓存数据保存到磁盘中，以备后用），Memcached不支持持久化；</li>
</ul>
</li>
<li>对集群的支持：<ul>
<li>Redis天生支持集群(aka 实现服务器集群非常简单)，但Memcached并不是原生支持集群的；</li>
</ul>
</li>
<li>运行原理：<ul>
<li>Redis是单线程 + 多路IO复用； Memcached是多线程 + 非阻塞IO复用【😵】</li>
</ul>
</li>
</ul>
<p>综上，现在Redis的使用率斩杀Memcached（太难读了）</p>
<h5 id="Redis常见的数据结构-amp-数据结构关联的使用场景"><a href="#Redis常见的数据结构-amp-数据结构关联的使用场景" class="headerlink" title="Redis常见的数据结构 &amp; 数据结构关联的使用场景"></a>Redis常见的数据结构 &amp; 数据结构关联的使用场景</h5><ul>
<li><p>String类型</p>
<ul>
<li>常用命令：set,get,decr（值减一）,incr（值加一）,mget（获取多个指定key的值）等  </li>
<li>应用场景：<ul>
<li>key-value中，key就是String类型的；</li>
<li>常规计数：微博数、粉丝数；</li>
</ul>
</li>
</ul>
</li>
<li><p>Hash类型（存储key-value集合）</p>
<ul>
<li><p>作用：用于存储对象；</p>
</li>
<li><p>常用命令：hget（获取对象指定属性的值）,hset（设置对象指定属性的值）,hgetall （查看对象中所有的属性与其绑定的值）等</p>
</li>
<li><p>应用：</p>
<ul>
<li>存储用户信息</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">key=JavaUser293847</span><br><span class="line">value=&#123;</span><br><span class="line">“id”: 1,</span><br><span class="line">“name”: “SnailClimb”,</span><br><span class="line">“age”: 22,</span><br><span class="line">“location”: “Wuhan, Hubei”</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>list类型</p>
<ul>
<li>是：双向链表；</li>
<li>作用：存储一堆的String数据类型；</li>
<li>常用命令：lpush（在链表左端添加元素）,rpush,lpop（移除链表左边的第一个元素）,rpop,lrange （获取链表中指定范围的key-value集合）</li>
<li>特征：<ul>
<li>支持反向查找与遍历；</li>
</ul>
</li>
<li>应用：<ul>
<li>实现分页查询（lrange），aka，从某个元素开始读取指定个数的元素；</li>
</ul>
</li>
</ul>
</li>
<li><p>Set类型</p>
<ul>
<li><p>是：一个集合类型；</p>
</li>
<li><p>作用：存储一堆的String类型数据；</p>
</li>
<li><p>特征：</p>
<ul>
<li>1 可以自动去重；</li>
<li>2 能够方便地实现集合操作（交集、差集、并集）</li>
</ul>
</li>
<li><p>用法：sadd,spop,smembers（返回指定key对应的集合中的所有元素）,sunion,sismember(判断指定key中指定value是否存在集合中，返回 0 或 1) 等  </p>
</li>
<li><p>应用：</p>
<ul>
<li>1 微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合；</li>
<li>2 实现共同关注、共同粉丝、共同喜好等功能 （求交集）；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sinterstore key1 key2 key3 将交集存在key1内</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>SortedSort类型</p>
<ul>
<li>作用：同Sort类型；</li>
<li>特征：集合中的元素能够按score进行有序排列  ；</li>
<li>原理：sorted set增加了一个权重参数score；</li>
<li>用法：zadd,zrange,zrem（从排序的集合中删除一个或多个成员）,zcard（获取一个排序的集合中的成员数量）等  </li>
<li>应用：<ul>
<li>直播系统中的时时排行榜（用户列表、礼物排行榜、弹幕消息等）</li>
</ul>
</li>
</ul>
<blockquote>
<p>this is nuts!</p>
</blockquote>
</li>
</ul>
<h5 id="Redis中设置数据的过期时间"><a href="#Redis中设置数据的过期时间" class="headerlink" title="Redis中设置数据的过期时间"></a>Redis中设置数据的过期时间</h5><ul>
<li>作用：保证缓存数据是最新的；</li>
<li>应用：项目中的 token 或者一些登录信息、短信验证码等</li>
<li>用法：set key 的时候，指定一个 expire time ；</li>
<li>原理（过期之后，Redis如何删除过期数据）<ul>
<li>1 <strong>定期删除</strong><ul>
<li>redis默认是每隔 100ms 就<strong>随机抽取</strong>一些设置了过期时间的key，检查其是否过期，如果过期就删<br>除 ；（注意这里是随机抽取的，因为数据量很大）</li>
</ul>
</li>
<li>2 *<em>惰性删除 *</em><ul>
<li>过期key在定期删除时没有被删除掉（还停留在内存里），只有重新查询该过期的key，它才会被redis给删除 ；</li>
</ul>
</li>
<li>遗留问题：过期的key可能会堆积在内存中，影响缓存的正常工作；</li>
<li>解决方案：Redis内存淘汰机制；</li>
</ul>
</li>
</ul>
<h5 id="Redis内存淘汰机制"><a href="#Redis内存淘汰机制" class="headerlink" title="Redis内存淘汰机制"></a>Redis内存淘汰机制</h5><ul>
<li>作用：保证Redis中存储的数据都是热门数据（经常被查询到的数据）；</li>
<li>数据淘汰策略：<ul>
<li>从设置了过期时间的数据集中删除：<ul>
<li>最近最少使用的数据（LRU）；</li>
<li>即将要过期的数据（TTL）；</li>
<li>随机的数据（random）；</li>
</ul>
</li>
<li>当内存空间不够用时，在键空间中，移除最近最少使用的key；【最常用】</li>
<li>从数据集中任意选择数据进行删除；</li>
<li>不删除旧的缓存数据，如果空间不够用，而又有新的数据要写入缓存，就拒绝新的数据；</li>
</ul>
</li>
</ul>
<h5 id="Redis的持久化原理"><a href="#Redis的持久化原理" class="headerlink" title="Redis的持久化原理"></a>Redis的持久化原理</h5><ul>
<li>持久化：把内存中的数据写入硬盘（相当于永久存储）；</li>
<li>作用：备份数据；</li>
<li>手段：<ul>
<li>1 快照（snapshotting/rdb文件）<ul>
<li>是：一个文件；</li>
<li>作用：存储内存中某一时刻的数据；</li>
<li>特征：<ul>
<li>1 rdb文件可以在多台机器上复制与同步，从而保持备份数据的一致性；</li>
<li>2 这是Redis默认使用的持久化方式；</li>
<li>3 快照的细节可以在redis.conf中进行配置；</li>
</ul>
</li>
<li>原理：在某些时刻自动触发创建快照的操作；</li>
</ul>
</li>
<li>2 AOF持久化<ul>
<li>是：一个文件；</li>
<li>作用：记录数据的变化过程（被执行的写命令）；</li>
<li>特征：<ul>
<li>0 备份数据的实时性更好（所以是主要使用的持久化方案）；</li>
<li>1 默认情况下，AOF持久化没有开启；</li>
<li>2 开启AOF后，每次执行写入操作时，写入命令就会被追加到AOF文件中；</li>
<li>3 AOF存储的细节可以在redis.conf文件中进行配置；</li>
</ul>
</li>
<li>原理：写操作发生后，以一定的规律向AOF文件中追加写操作命令；</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h5><blockquote>
<p>事务；</p>
<p>是：一个规范；</p>
<p>作用：提供了一种将多个命令请求打包，然后一次性、按顺序地执行多个命令的机制  ；</p>
<p>特征：</p>
<p>​        1 执行事务期间，服务器不会中断事务而去执行其他客户端的请求；</p>
<p>​        2 如果事务执行到一半时发生意外情况，服务器会把之前执行的事务部分撤销操作；</p>
</blockquote>
<ul>
<li>是：Redis对事务的具体实现；</li>
<li>手段：使用MULTI、EXEC、WATCH 等命令来实现事务(transaction)功能 ；</li>
<li>特征：<ul>
<li>1 Redis事务总能保证事务的ACI(Atomicity  、Consistency  、Isolation)；</li>
<li>2 在设置了持久化模式之后，Redis事务也能保证事务的D（Durability ）；</li>
</ul>
</li>
</ul>
<p>ACID：原子性、连续性、隔离性、持久性；</p>
<h5 id="缓存雪崩-amp-缓存穿透（及解决方案）"><a href="#缓存雪崩-amp-缓存穿透（及解决方案）" class="headerlink" title="缓存雪崩&amp;缓存穿透（及解决方案）"></a>缓存雪崩&amp;缓存穿透（及解决方案）</h5><p>缓存雪崩</p>
<ul>
<li>是：一个现象；</li>
<li>作用：描述缓存在短时间内大量失效（缓存的数据不再是热点数据了）</li>
<li>特征：请求都会落在数据库服务器上，数据库压力很大</li>
<li>解决手段：<ul>
<li>事前：建立Redis集群，保证缓存机器集群的可用性；</li>
<li>事中：利用各种手段防止MySQL崩掉（ehcache缓存 + hystrix限流/降级等）；</li>
<li>事后：使用Redis持久化备份的数据尽快恢复缓存；</li>
</ul>
</li>
</ul>
<p>缓存穿透</p>
<ul>
<li>是：一个现象；</li>
<li>作用：描述客户端故意请求缓存中不存在的数据，使得请求总是落在数据库服务器上；</li>
<li>解决手段：<ul>
<li>1 使用布隆过滤器；<ul>
<li>原理：如果请求的数据在数据库中一定不存在，布隆过滤器就会拦截掉这个请求；</li>
</ul>
</li>
<li>2 把查询为空的结构也添加到缓存中；<ul>
<li>原理：这样即便客户端请求不存在的数据，缓存也能发挥作用；</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="Redis并发竞争Key的问题"><a href="#Redis并发竞争Key的问题" class="headerlink" title="Redis并发竞争Key的问题"></a>Redis并发竞争Key的问题</h5><ul>
<li>是：一种现象；</li>
<li>作用：描述多个系统同时操作一个key，而执行的顺序不是预期执行的顺序。最终导致了非预期的结果</li>
<li>解决手段：分布式锁（首选Zookeeper）；<ul>
<li>是：一种技术；</li>
<li>作用：解决分布式（多台机器上都有相同的实例）场景下，多台机器同时操作相同资源的并发问题；</li>
<li>特征：有点子像多线程并发操作资源的情况；</li>
<li>手段：使用zookeeper的临时有序节点；</li>
<li>原理：<ul>
<li>1 当客户端对某个方法加锁时，在zookeeper上的<strong>与该方法对应的指定节点的目录</strong>下，生成一个唯一的瞬时有序节点  ;</li>
<li>2 当机器要获取资源的锁时，只需要判断有序节点中序号最小的一个  ；【😵】</li>
<li>3 当机器要释放锁时，只需将这个瞬时节点删除即可 ；</li>
</ul>
</li>
<li>用法：<ul>
<li>完成业务流程后，删除对应的子节点来释放锁 ；</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="数据写入数据库-amp-缓存时，保证双写一致"><a href="#数据写入数据库-amp-缓存时，保证双写一致" class="headerlink" title="数据写入数据库&amp;缓存时，保证双写一致"></a>数据写入数据库&amp;缓存时，保证双写一致</h5><p>双写一致：</p>
<ul>
<li>是：一个要求；</li>
<li>作用：要求缓存中的数据与数据库中的数据保持一致；</li>
<li>特征：多数情况下，系统并不必须要保持双写一致（串行化会导致系统处理请求的能力大大降低）；</li>
<li>手段：把读请求&amp;写请求串行化放到一个队列中；</li>
<li>原理：请求串行化后，Redis就会同步数据库中新写入的数据。从而保证从缓存中读取的数据总是正确的；</li>
</ul>
<p>​    </p>
<h5 id="参考：JavaGuide《面试突击》"><a href="#参考：JavaGuide《面试突击》" class="headerlink" title="参考：JavaGuide《面试突击》"></a>参考：JavaGuide《面试突击》</h5><blockquote>
<p>until next time 😳</p>
</blockquote>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Java stuff</tag>
      </tags>
  </entry>
  <entry>
    <title>java基础之HashMap</title>
    <url>/JDK-source-type/2020/09/01/interview/20200901-java%E5%9F%BA%E7%A1%80%E4%B9%8BHashMap.html</url>
    <content><![CDATA[<h4 id="java集合类型之HashMap"><a href="#java集合类型之HashMap" class="headerlink" title="java集合类型之HashMap"></a>java集合类型之HashMap</h4><p>对于JDK源码来说，它有点像吉他谱中的F和弦。第一道坎，跨过去就会是另一番风景</p>
<a id="more"></a>

<blockquote>
<p>bear in mind</p>
<p>1 HashMap是用来存储键值对的容器；</p>
<p>2 HashMap能够实现O(1)时间复杂度的查找（根据key来查找对应的键值对）；</p>
<p>3 HashMap底层的数据结构为：数组 + 链表 + 红黑树；</p>
</blockquote>
<h5 id="前置说明：为了表述的统一-amp-简化表达"><a href="#前置说明：为了表述的统一-amp-简化表达" class="headerlink" title="前置说明：为了表述的统一&amp;简化表达"></a>前置说明：为了表述的统一&amp;简化表达</h5><ul>
<li>把底层结构中的数组叫做散列数组/桶数组；</li>
</ul>
<blockquote>
<p>鉴于只有文字说明时，写得没劲，看得也没劲。所以这次会配合源码+图解</p>
</blockquote>
<h5 id="HashMap的特性"><a href="#HashMap的特性" class="headerlink" title="HashMap的特性"></a>HashMap的特性</h5><p><em>注：刚开始学这些容器类型时，发现它们有着各种不同的特性，多到无从记忆。其实所有这些特性都是容器类型实现的具体结果，所以要记住这些个特性，看一看源码就好了</em></p>
<ul>
<li>1 默认的初始容量为16；</li>
<li>2 默认的装载因子为0.75;</li>
<li>3 只有在链表中的节点数量 &gt; =8 并且 HashMap中的键值对数量 &gt; 64时，才会对链表进行树化；</li>
<li>4 当树化与扩容冲突时，应该优先扩容。这样能够从更高层面解决问题；</li>
</ul>
<h5 id="原理（存储键值对的过程）"><a href="#原理（存储键值对的过程）" class="headerlink" title="原理（存储键值对的过程）"></a>原理（存储键值对的过程）</h5><ul>
<li>1 计算key-value中key的散列值；</li>
<li>2 使用散列值来计算得到key-value应该插入到散列数组的哪个桶中；</li>
<li>3 判断桶是不是空的，如果是，直接插入key-value；</li>
<li>4 如果桶不是空的，说明不同的键值对被映射到了散列数组相同的桶中（aka 发生了散列冲突）。</li>
<li>5 发生散列冲突后，先判断桶中的key-value与预期插入的key-value的key是否相等，如果相等，直接更新桶中的key-value的value值；</li>
<li>6 如果不相等，把新的key-value以链表节点的形式连接到桶中已有的节点上；【Mark：一般面试时，回答到这里就已经足够了】</li>
<li>7 当链表中的节点数量大于8时，把链表转化成红黑树（以提升查询效率）；【具体手段比较复杂】</li>
<li>8 当哈希数组中的key-value数量大于阈值（阈值 = 容量 * 加载因子）时，需要对散列数组进行扩容，并对桶中的链表/红黑树上的key-value进行重新布局；【具体手段比较复杂】</li>
</ul>
<p>HashMap的key-value存储结果图：<a href="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15161231547335.jpg">田小波</a></p>
<p><img src="https://s1.ax1x.com/2020/09/02/wSwlKe.png" alt="HashMap存储节点的效果"></p>
<h5 id="HashMap源码分析"><a href="#HashMap源码分析" class="headerlink" title="HashMap源码分析"></a>HashMap源码分析</h5><h6 id="1-HashMap的特性"><a href="#1-HashMap的特性" class="headerlink" title="1 HashMap的特性"></a>1 HashMap的特性</h6><p><img src="https://s1.ax1x.com/2020/09/02/wSPg9e.png" alt="HashMap特性说明"></p>
<p>这些大段大段的介绍的确很吓人，这时候就需要点子耐心了。其实这只是你想象出来的无法跨越的人行道罢了 </p>
<p>上面的图片引用自<a href="https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&mid=2247484139&idx=1&sn=bb73ac07081edabeaa199d973c3cc2b0&chksm=ebd743eadca0cafc532f298b6ab98b08205e87e37af6a6a2d33f5f2acaae245057fa01bd93f4&scene=21#wechat_redirect">Java3y</a></p>
<p><font size="3">使用有道词典翻译了源码上的注释 &amp; 翻译了JDK提供的HashMap的接口文档。两者内容基本一致，建议参考接口文档（毕竟它就是用源码生成的）</font></p>
<blockquote>
<p>特性总结</p>
</blockquote>
<ul>
<li>允许空键与空值；</li>
<li>存储时，不保证key-value的顺序就是插入时的顺序；</li>
<li>装载因子对迭代key-value对的性能有很大影响；</li>
<li>当key-value对的数量 &gt; 散列数组的容量 * 装载因子时，会创建新的散列数组（大小是旧数组的两倍），并对key-value进行重哈希；</li>
<li>默认装载因子0.75是在时间与空间上妥协的结果，装载因子越大，越节省空间，但是访问key-value的时间就会随之增长。反之亦然</li>
<li>HashMap没有实现多线程同步的逻辑，所以多线程操作是不安全的；</li>
<li>遍历HashMap的迭代器时，如果有其他线程在修改哈希表，就会马上抛出并发修改的异常；</li>
</ul>
<blockquote>
<p>HashMap的类继承结构</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/09/02/wSw93T.png" alt="HashMap类继承结构"></p>
<p><font size=3>为什么要看它的类继承结构呢？</font></p>
<p>这样能够直观地知道HashMap预期会有哪些功能，然后可以在看源码的时候有的放矢地查看源码是如何实现这些功能的。</p>
<h6 id="2-HashMap的实例变量（包含底层数据结构）"><a href="#2-HashMap的实例变量（包含底层数据结构）" class="headerlink" title="2 HashMap的实例变量（包含底层数据结构）"></a>2 HashMap的实例变量（包含底层数据结构）</h6><p><font size=2>这里不想再借别人的图，但是却没有好用的截长图与截图标注工具。饶了些狗尾巴圈子😳</font></p>
<p>注：接口文档中没有关于成员属性的说明，因为接口文档是教会用户如何使用的，并不想把底层实现呈现出来；</p>
<ul>
<li><p>成员常量；</p>
<p>​    <img src="https://s1.ax1x.com/2020/09/02/wSDOzV.png" alt="成员常量"></p>
<ul>
<li>作用：各种场景下对应的默认值（通过常量的名称基本能了解其使用场合）</li>
</ul>
</li>
<li><p>成员变量；</p>
<p>​    <img src="https://s1.ax1x.com/2020/09/02/wSryOU.png" alt="成员变量"></p>
<ul>
<li>作用：作为底层的数据结构，以支持各种API的操作；<ul>
<li>table    作用：作为散列数组；</li>
<li>loadFacotr   作用：哈希表的加载因子（用于计算扩容时的门槛）；</li>
<li></li>
</ul>
</li>
</ul>
</li>
<li><p>成员内部类；</p>
<p><img src="https://s1.ax1x.com/2020/09/02/wSsanO.png" alt="HashMap成员内部类"></p>
<ul>
<li><p>作用：作为底层数据结构，支持各种API操作；</p>
<blockquote>
<p> 核心内部类说明；</p>
</blockquote>
<ul>
<li>Node    作用：封装key-value映射关系，表示哈希表中的一个节点；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key; <span class="comment">// 键值对中的key</span></span><br><span class="line">        V value; <span class="comment">// 键值对中的value</span></span><br><span class="line">        Node&lt;K,V&gt; next; <span class="comment">// 链表结构中下一个节点的指针</span></span><br><span class="line">    	...</span><br></pre></td></tr></table></figure>

<ul>
<li>TreeNode 作用：表示红黑树中的一个节点；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links	指向父节点的指针</span></span><br><span class="line">        TreeNode&lt;K,V&gt; left; <span class="comment">// 指向左子节点的指针</span></span><br><span class="line">        TreeNode&lt;K,V&gt; right; <span class="comment">// 指向右子节点的指针</span></span><br><span class="line">        TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion（删除后需要取消链接） </span></span><br><span class="line">        <span class="keyword">boolean</span> red; <span class="comment">// 是否为红色节点</span></span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h6 id="3-HashMap的构造方法"><a href="#3-HashMap的构造方法" class="headerlink" title="3 HashMap的构造方法"></a>3 HashMap的构造方法</h6><p>作用：</p>
<ul>
<li>规定程序员使用HashMap的语法；</li>
<li>创建出HashMap的实例对象；</li>
<li>强制程序员为某些成员属性绑定值；</li>
</ul>
<p>分析底层原理时，构造方法似乎并不重要。不管用户决定用哪种构造方法，核心API的逻辑不会受到任何影响。所以这里只分析最常用的构造方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里只是为loadFactor属性进行了初始化（绑定了值）；而哈希表都还没有创建与初始化——因为这个操作是在第一次插入key-value的时候实现的。</p>
<h6 id="4-常用常量分析"><a href="#4-常用常量分析" class="headerlink" title="4 常用常量分析"></a>4 常用常量分析</h6><ul>
<li>初始容量initialCapacity;<ul>
<li>作用：指定散列数组的初始容量大小；</li>
</ul>
</li>
<li>负载因子loadFactor；<ul>
<li>作用：计算散列（桶）数组的扩容门槛；</li>
</ul>
</li>
<li>扩容门槛threshold；<ul>
<li>作用：声明当前HashMap所能存储key-value对的最大数量；如果继续插入key-value，会引发散列数组的扩容操作；</li>
</ul>
</li>
</ul>
<p>三者之间的关系：threshold = initialCapacity * loadFactor;</p>
<h5 id="核心APIs"><a href="#核心APIs" class="headerlink" title="核心APIs"></a>核心APIs</h5><h6 id="从键值对集合中查询；（get-方法）"><a href="#从键值对集合中查询；（get-方法）" class="headerlink" title="从键值对集合中查询；（get()方法）"></a>从键值对集合中查询；（get()方法）</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">    	<span class="comment">// 计算key的hash值，并作为参数传入getNode()方法中</span></span><br><span class="line">        <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 准备需要的局部变量：tab-散列数组； first、e-节点、n-散列数组的长度、k-键的类型；</span></span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    	<span class="comment">// 如果散列数组不为空 &amp;&amp; key映射到的桶不为空...</span></span><br><span class="line">    	<span class="comment">// 任务：求出key所映射到的桶；	手段1：hash % n	手段2：(n-1) &amp; hash</span></span><br><span class="line">    	<span class="comment">// 说明：只有在n等于2的乘方时，才会有： hash % n &lt;=&gt; (n-1) &amp; hash</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 判断桶中的第一个节点是不是待查找的键值对</span></span><br><span class="line">            <span class="comment">// 手段：1 判断节点的hash值与key的hash值是否相等； 2 判断节点的key与key是否相等</span></span><br><span class="line">            <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">                ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="keyword">return</span> first;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 否则，从桶中继续查找</span></span><br><span class="line">            <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 判断桶中的节点是不是树节点...</span></span><br><span class="line">                <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">                <span class="comment">// 否则，桶中一定是一个链表</span></span><br><span class="line">                <span class="comment">// 遍历链表进行查找</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">return</span> e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">// 都没能找到，则返回null</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>流程</p>
</blockquote>
<ul>
<li>1 找到key所映射到的散列数组中桶的位置（桶就是散列数组中的一个位置）；</li>
<li>2 从桶中的链表/红黑树来查找是否存在键为key的节点；</li>
</ul>
<blockquote>
<p>关键操作</p>
</blockquote>
<ul>
<li>1 计算key会映射到的桶的位置；<ul>
<li>手段：(n - 1) &amp; hash；    </li>
<li>特征：1 高效的位运算； 2 n的值必须是2的乘方；3 等价于(hash % n);</li>
</ul>
</li>
<li>2 计算key的哈希值；<ul>
<li>手段: 内置的hash(Object key)方法；</li>
<li>SOP：1 调用key的hashCode()方法，初次获取到hash值；2 把h无符号右移16位得到一个新的二进制数字； 3 把1与2的值进行^（异或运算）；</li>
<li>原因（HashMap为什么这样计算哈希值）：<ul>
<li>移位操作-1：通过这种方式，让高位数据与低位数据进行异或，以此加大低位信息的随机性，变相的让高位数据参与到计算中；</li>
<li>移位操作-2：在 Java 中，hashCode 方法产生的 hash 是 int 类型，32 位宽。前16位为高位，后16位为低位，所以要右移16位;</li>
<li>异或操作：通过移位和异或运算，可以让 hash 变得更复杂，进而影响 hash 的分布性；</li>
</ul>
</li>
</ul>
</li>
</ul>
<h6 id="遍历HashMap中所有的key-value-（keySet-方法）"><a href="#遍历HashMap中所有的key-value-（keySet-方法）" class="headerlink" title="遍历HashMap中所有的key-value （keySet()方法）"></a>遍历HashMap中所有的key-value （keySet()方法）</h6><p><font size=3>注:遍历的操作分为两步——1 获取到键集合 / 键值对Entry集合； 2 使用迭代器模式来遍历键值对；</font></p>
<blockquote>
<p>用法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用法1-获取到所有的键组成的集合	然后使用迭代器模式进行遍历</span></span><br><span class="line"><span class="keyword">for</span>(Object key : map.keySet()) &#123;</span><br><span class="line">    <span class="comment">// 通过map.get(key)方法获取到关联的value</span></span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用法2-获取到所有的键值对组成的集合	然后使用迭代器模式进行遍历</span></span><br><span class="line"><span class="keyword">for</span>(HashMap.Entry entry : map.entrySet()) &#123;</span><br><span class="line">    <span class="comment">// Entry对象就是封装好的key-value</span></span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>迭代器模式是一种遍历集合的统一方式，aka，程序员可以使用确定的API来编写迭代的代码；</p>
<blockquote>
<p>流程（遍历键集合）</p>
</blockquote>
<ul>
<li>1 首先要获取键集合<code>KeySet</code>对象；</li>
<li>2 再通过 KeySet 的迭代器<code>KeyIterator</code>（继承自HashIterator）进行遍历；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 键集合的类型</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 迭代器模式	要求：返回一个迭代器对象；    </span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;K&gt; <span class="title">iterator</span><span class="params">()</span>     </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> KeyIterator(); &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 键-迭代器类型</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextNode().key; &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父类迭代器类型</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HashIterator</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; next;        <span class="comment">// next entry to return</span></span><br><span class="line">        Node&lt;K,V&gt; current;     <span class="comment">// current entry</span></span><br><span class="line">        <span class="keyword">int</span> expectedModCount;  <span class="comment">// for fast-fail</span></span><br><span class="line">        <span class="keyword">int</span> index;             <span class="comment">// current slot</span></span><br><span class="line"></span><br><span class="line">        HashIterator() &#123;</span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">            Node&lt;K,V&gt;[] t = table;</span><br><span class="line">            current = next = <span class="keyword">null</span>;</span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123; <span class="comment">// advance to first entry</span></span><br><span class="line">                <span class="comment">// 寻找第一个包含链表节点引用的桶</span></span><br><span class="line">                <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    	...</span><br><span class="line">        <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">nextNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">if</span> ((next = (current = e).next) == <span class="keyword">null</span> &amp;&amp; (t = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 寻找下一个包含链表节点引用的桶</span></span><br><span class="line">                <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p> 关键操作(在HashIterator中完成)</p>
</blockquote>
<ul>
<li>1 从桶数组中找到包含链表节点引用的桶；</li>
<li>2 对这个桶指向的链表进行遍历；</li>
<li>3 遍历完成后，再继续寻找下一个包含链表节点引用的桶.so on and so forth, till  can not find such a bucket;</li>
</ul>
<blockquote>
<p>操作过程图示</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/09/02/wp8nzj.png" alt="遍历键集合的过程"></p>
<blockquote>
<p>验证</p>
</blockquote>
<p>原理：如果在创建HashMap时指定容器的大小为16，并在插入key-value时根据16来选择合适的key。就能把key-value插入到预期的桶中，并最终预测遍历操作的打印顺序</p>
<p>举例：key=43 43%16=11.所以该key-value会存储在编号为11的桶中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span> <span class="comment">// 因为IDEA的集成工作做得太棒了，有时候你真弄不清楚到底是谁完成了哪些工作...😳</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTraversal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap(<span class="number">16</span>);</span><br><span class="line">        <span class="comment">// 可以预见这些key-value会被映射到什么地方吗？</span></span><br><span class="line">        map.put(<span class="number">7</span>, <span class="string">""</span>);</span><br><span class="line">        map.put(<span class="number">11</span>, <span class="string">""</span>);</span><br><span class="line">        map.put(<span class="number">43</span>, <span class="string">""</span>);</span><br><span class="line">        map.put(<span class="number">59</span>, <span class="string">""</span>);</span><br><span class="line">        map.put(<span class="number">19</span>, <span class="string">""</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="string">""</span>);</span><br><span class="line">        map.put(<span class="number">35</span>, <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"遍历结果："</span>);</span><br><span class="line">        <span class="keyword">for</span> (Integer key : map.keySet()) &#123;</span><br><span class="line">            System.out.print(key + <span class="string">" -&gt; "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// 预期输出结果：19 -&gt; 3 -&gt; 35 -&gt; 7 -&gt; 11 -&gt; 43 -&gt; 59 -&gt; </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="向容器中插入新的key-value（input-方法）"><a href="#向容器中插入新的key-value（input-方法）" class="headerlink" title="向容器中插入新的key-value（input()方法）"></a>向容器中插入新的key-value（input()方法）</h6><blockquote>
<p>流程</p>
</blockquote>
<ul>
<li>找到键值对预期插入的桶编号；</li>
<li>判断桶是否为空，为空则直接插入key-value;</li>
<li>如果不为空，判断桶中的节点是哪一种类型的节点；<ul>
<li>如果是链表节点，则执行“向链表中插入新节点”的操作；</li>
<li>如果是树节点，则执行“向红黑树中插入新节点”的操作；</li>
</ul>
</li>
<li>插入操作结束后，需要考虑两个问题——扩容、树化；</li>
</ul>
<blockquote>
<p>核心操作（源码)</p>
</blockquote>
<p><font size=3>源码中有很多保证健壮性的代码，但它们不是核心代码，可以跳过</font></p>
<p><img src="https://s1.ax1x.com/2020/09/02/wpwKl8.jpg" alt="put添加key-value的过程"></p>
<p>这里比较困惑的是找到key相同的节点后，源码把找到的节点存储到了变量e中；</p>
<p>其实只需要明确一点，如果找到了key相同的节点，接下来肯定需要执行覆盖操作，具体的手段就要看源码的具体实现了（这里是使用变量e记录了已经存在的key-value，然后用新的value进行更新）。</p>
<p><strong>注：覆盖旧值后，put()方法会把旧的value值返回给调用者</strong>👇</p>
<p><img src="https://s1.ax1x.com/2020/09/03/wC3rxH.png" alt="覆盖旧值后，会把旧的value返回"></p>
<h6 id="对散列表进行扩容操作（resize-）"><a href="#对散列表进行扩容操作（resize-）" class="headerlink" title="对散列表进行扩容操作（resize()）"></a>对散列表进行扩容操作（resize()）</h6><blockquote>
<p>预备知识</p>
</blockquote>
<ul>
<li>在 HashMap 中，桶数组的长度均是2的幂，阈值大小为桶数组长度与负载因子的乘积。</li>
<li>当 HashMap 中的键值对数量超过阈值时，就会进行扩容操作。</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/02/wpBtMT.jpg" alt="扩容方法"></p>
<blockquote>
<p>原理</p>
</blockquote>
<ul>
<li>按当前桶数组长度的2倍进行扩容，阈值也变为原来的2倍；</li>
<li>扩容之后，要重新计算键值对的位置，并把它们移动到合适的位置上去；</li>
</ul>
<blockquote>
<p>源码中的核心操作</p>
</blockquote>
<ul>
<li>1 计算新桶数组的容量 newCap 和新阈值 newThr</li>
<li>2 根据计算出的 newCap 创建新的桶数组，桶数组 table 也是在这里进行初始化的</li>
<li>3 将键值对节点重新映射到新的桶数组里。<ul>
<li>如果节点是 TreeNode 类型，则需要拆分红黑树。</li>
<li>如果是普通节点，则节点按原顺序进行分组。</li>
</ul>
</li>
</ul>
<blockquote>
<p>核心操作对应的代码- newCap 和 newThr 计算过程(分类讨论)</p>
</blockquote>
<p>​    this is way too much, Can not bear this right now.</p>
<blockquote>
<p>需要记忆的结论</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一个条件分支</span></span><br><span class="line"><span class="keyword">if</span> ( oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 嵌套条件分支</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;...&#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY) &#123;...&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) &#123;...&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二个条件分支</span></span><br><span class="line"><span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;...&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><p>#Q:initialCapacity 参数没有被保存下来，那么它怎么参与桶数组的初始化过程的呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">            newCap = oldThr; <span class="comment">// 把旧的阈值绑定到newCap上</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li>#A: 上述语句等价于<code>newCap = threshold = tableSizeFor(initialCapacity)</code>。aka 我们在初始化时传入的 initialCapacity 参数经过 threshold 中转最终赋值给了 newCap</li>
</ul>
<ul>
<li><p>#Q：嵌套分支的作用是什么？</p>
<ul>
<li>#A：<ul>
<li>1 处理容器容量达到极限的情况； </li>
<li>2 处理容器正常扩容的情况（但用户指定的loadFactor可能会导致移位/扩大两倍时发生溢出归零）</li>
</ul>
</li>
</ul>
</li>
<li><p>#Q：为什么需要第二个分支？</p>
<ul>
<li>#A：<ul>
<li>第一个条件分支未计算 newThr的情况（当旧容量=0，而旧的阈值大于0时，分支中只是用旧阈值更新了newCap） ;</li>
<li>嵌套分支在计算过程中导致 newThr 溢出归零的情况（这时候需要使用loadFactor * newCap的公式重新计算阈值）；</li>
</ul>
</li>
</ul>
</li>
<li><p>链表桶经过重新映射后，两条链表中的节点顺序并未发生变化，还是保持了扩容前的顺序。</p>
</li>
</ul>
<h6 id="桶中节点的重新映射（在resize-方法中实现）"><a href="#桶中节点的重新映射（在resize-方法中实现）" class="headerlink" title="桶中节点的重新映射（在resize()方法中实现）"></a>桶中节点的重新映射（在resize()方法中实现）</h6><div id="anchor1"></div>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">	...</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">            Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">            Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">            Node&lt;K,V&gt; next;</span><br><span class="line">            ...</span><br></pre></td></tr></table></figure>



<p>说明：对于不同的节点类型，重新映射的手段并不一样；</p>
<ul>
<li>对于树形节点，需先拆分红黑树再映射。</li>
<li>对于链表类型节点，则需先对链表进行分组，然后再映射（分组后，组内节点相对位置保持不变）。</li>
</ul>
<blockquote>
<p>对链表中的节点进行分组映射</p>
</blockquote>
<p>JDK1.7的手段：</p>
<ul>
<li>把链表中的节点重新插入到新的桶数组中；</li>
</ul>
<p>JDK1.8的手段:</p>
<ul>
<li>说明：扩容前被映射到同一个桶中的键值对，经过扩容后，可能会被映射到新的桶中；</li>
<li>原理：<ul>
<li>1 映射的过程是使用(n - 1) &amp; hash的方式来计算桶的位置;</li>
<li>2 扩容前，由于n=16，所以二进制表示的前四位是0000。真正参与&amp;运算的实际上只有hash的后四位——这会导致不同的哈希值被映射到同一个桶的位置；</li>
<li>3 扩容2倍后，n &gt; 16，所以参与&amp;运算的二进制数字位更多（多出的高位表示16）。不同的hash值会被映射到不同的桶位置；</li>
</ul>
</li>
<li>算法：<ul>
<li>1 依次遍历链表，并计算节点 <code>hash &amp; oldCap</code> 的值；</li>
<li>2 如果值为0，将 loHead 和 loTail 指向这个节点；<ul>
<li>如果后面还有节点 hash &amp; oldCap 为0的话，则将节点链入 loHead 指向的链表中，并将 loTail 指向该节点；</li>
</ul>
</li>
<li>3 如果值为非0的话，则让 hiHead 和 hiTail 指向该节点；</li>
<li>4 把分组后的两个链表存储到新的桶数组对应的桶中；</li>
</ul>
</li>
</ul>
<p>重新映射前的桶数组</p>
<p><img src="https://s1.ax1x.com/2020/09/03/wCNRds.png" alt="映射前"></p>
<p>重新映射算法得到的分组链表</p>
<p><img src="https://s1.ax1x.com/2020/09/03/wCUKOg.png" alt="分组后的链表"></p>
<p>重新映射后的桶数组</p>
<p><img src="https://s1.ax1x.com/2020/09/03/wCUwm4.png" alt="映射后的桶数组"></p>
<p>评论：相比于JDK1.7的做法，1.8的做法避免了插入操作的hash计算，效率有提高；</p>
<h6 id="链表树化-treeifyBin-方法"><a href="#链表树化-treeifyBin-方法" class="headerlink" title="链表树化(treeifyBin()方法)"></a>链表树化(treeifyBin()方法)</h6><p>the details is overwhelming, so we’ll just jump into the conclusion.</p>
<blockquote>
<p>流程</p>
</blockquote>
<ul>
<li>1 把链表中的普通节点，转化为树形节点(得到一个树形节点组成的链表)；</li>
<li>2 把树形节点组成的链表转换为红黑树（treeify()方法）；</li>
</ul>
<blockquote>
<p> 在扩容过程中，树化要满足两个条件：</p>
</blockquote>
<ul>
<li>链表长度大于等于 TREEIFY_THRESHOLD</li>
<li>桶数组容量大于等于 MIN_TREEIFY_CAPACITY<ul>
<li>原因：<ul>
<li>1 当桶数组容量比较小时，键值对节点 hash 的碰撞率可能会比较高，进而导致链表长度较长；</li>
<li>2 这个时候应该优先扩容，而不是立马树化——高碰撞率是因为桶数组容量较小引起的，这个是主因；</li>
<li>3 容量小时，优先扩容可以避免一些列的不必要的树化过程；</li>
<li>4 同时，桶容量较小时，扩容会比较频繁，而扩容时需要拆分红黑树并重新映射——所以在桶容量比较小的情况下，将长链表转成红黑树是一件吃力不讨好的事；</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>treeifyBin 方法-把链表转化为TreeNode类型节点组成的链表</p>
</blockquote>
<ul>
<li>TreeNode类型间接继承自Node类型，所以包含next指针/引用。aka 通过TreeNode就能保存原始链表中的节点顺序；</li>
</ul>
<blockquote>
<p>树化带来的问题与解决方案</p>
</blockquote>
<ul>
<li>问题：树化过程中需要比较键对象的大小，但是HashMap并没有强制要求键对象一定要实现Comparable接口。SO,如果键并没有实现Comparable接口，树化要怎么进行呢？</li>
<li>手段：<ul>
<li>1 比较键与键之间 hash 的大小，如果 hash 相同，继续往下比较</li>
<li>2 检测键类是否实现了 Comparable 接口，如果实现调用 compareTo 方法进行比较</li>
<li>3 如果仍未比较出大小，就需要进行仲裁了，仲裁方法为 tieBreakOrder（没看过具体实现）</li>
</ul>
</li>
</ul>
<p><font size=2>tieBreak(赛点)</font></p>
<blockquote>
<p>树化前后对比</p>
</blockquote>
<ul>
<li><p>树化前</p>
<p><img src="https://s1.ax1x.com/2020/09/02/wpLK3t.png" alt="桶中的链表结构"></p>
</li>
<li><p>树化后</p>
<p><img src="https://s1.ax1x.com/2020/09/02/wpOua4.png" alt="桶中的红黑树结构"></p>
<p>橙色的箭头表示 TreeNode 的 next 引用</p>
</li>
<li><p>特征：</p>
<ul>
<li>原链表的顺序仍旧保持（红黑树的根节点会被移动到链表的第一位），SO,可以按遍历链表的方式去遍历上面的红黑树;</li>
<li>这种结构非常有利于红黑树的切分 &amp; 红黑树转换为链表的操作</li>
</ul>
</li>
</ul>
<h6 id="红黑树拆分（split-方法）"><a href="#红黑树拆分（split-方法）" class="headerlink" title="红黑树拆分（split()方法）"></a>红黑树拆分（split()方法）</h6><blockquote>
<p>说明：散列数组扩容后，需要为先前存储的键值对重新找到存储位置（重新映射）。链表和红黑树上的节点要怎么重新映射呢？</p>
</blockquote>
<ul>
<li><p>链表：<a href="#anchor1">参考</a></p>
</li>
<li><p>红黑树：</p>
<ul>
<li><p>手段1（效率有点低）：</p>
<ul>
<li>1 先把红黑树转换成链表；</li>
<li>2 然后按照链表的方式对所有的键值对重新映射；</li>
</ul>
</li>
<li><p>手段2：</p>
<ul>
<li><p>原理：在将普通链表转成红黑树时，HashMap 通过两个额外的引用 next 和 prev 保留了原链表的节点顺序；</p>
</li>
<li><p>所以，在重新映射红黑树时，就能够按照映射链表的方式进行映射；</p>
</li>
<li><p>特征：</p>
<ul>
<li><p>1 重新映射红黑树的逻辑和重新映射链表的逻辑基本一致（代码结构基本相同）；</p>
</li>
<li><p>2 但是重新映射后，会将红黑树拆分成两条<em>由 TreeNode 组成的链表</em>（<em>中间状态</em>）；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TreeNode&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">  TreeNode&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>3 如果链表长度小于 UNTREEIFY_THRESHOLD，则</p>
<ul>
<li>将链表转换成普通链表（Node）；</li>
<li>否则根据条件重新将 TreeNode 链表树化（treeify）；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (loHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (lc &lt;= UNTREEIFY_THRESHOLD) <span class="comment">// 重新映射后的链表长度小于等于UNTREEIFY_THRESHOLD</span></span><br><span class="line">        tab[index] = loHead.untreeify(map); <span class="comment">// 转化为普通链表</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        tab[index] = loHead;</span><br><span class="line">        <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) <span class="comment">// (else is already treeified)</span></span><br><span class="line">            loHead.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>红黑树重新映射第一步后的结果👇</p>
<p><img src="https://s1.ax1x.com/2020/09/02/wpX3kQ.png" alt="RBT重新映射后"></p>
</li>
</ul>
<h6 id="红黑树链化（untreeify-方法）"><a href="#红黑树链化（untreeify-方法）" class="headerlink" title="红黑树链化（untreeify()方法）"></a>红黑树链化（untreeify()方法）</h6><ul>
<li><p>场景：当链表中的节点数比较少时，就把红黑树转化为普通链表以节省空间；</p>
</li>
<li><p>原理：红黑树中仍然保留了原链表节点顺序；</p>
</li>
<li><p>手段(Thus)：</p>
<ul>
<li>将 TreeNode 链表转成 Node 类型的链表（即可）；</li>
</ul>
</li>
</ul>
<p>I do not really understand how does this work, yet time is consuming…</p>
<h6 id="从容器中删除键值对（remove-方法）"><a href="#从容器中删除键值对（remove-方法）" class="headerlink" title="从容器中删除键值对（remove()方法）"></a>从容器中删除键值对（remove()方法）</h6><blockquote>
<p>流程</p>
</blockquote>
<ul>
<li>第一步是定位桶位置；</li>
<li>第二步遍历链表并找到键值相等的节点；</li>
<li>第三步删除节点。</li>
</ul>
<blockquote>
<p>源码</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/09/02/wpjDDf.jpg" alt="先找到后删除"></p>
<p><img src="https://s1.ax1x.com/2020/09/02/wpvCIe.jpg" alt="删除流程"></p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ul>
<li>在JDK8中HashMap的底层数据结构为：<strong>数组+链表(散列表)+红黑树</strong>；</li>
<li>当初始容量 * 装载因子 &lt; HashMap中的键值对数量时，对散列数组/桶数组进行扩容；</li>
<li>装在因子loadFactor默认为0.75;【太大会容易产生散列冲突 VS 太小容易引起扩容】</li>
<li>初始容量默认为16；【空间 VS 时间】</li>
<li>计算key的hash值：将key的哈希值的高16位进行异或操作，以此来增加随机性；</li>
<li>并不是桶子上有8位元素的时候它就能变成红黑树，它得同时满足我们的散列表容量大于64才行；</li>
<li>使用构造方法指定initialCapacity时，这个参数不会直接初始化capacity，而是先绑定到threshold上，在初始化桶数组时，才会再绑定到newCap上；</li>
</ul>
<blockquote>
<p>what have I done?!</p>
</blockquote>
<h5 id="启示"><a href="#启示" class="headerlink" title="启示"></a>启示</h5><p>1 写文章时，需要一些其他工具。比如截长图与截图文字标注工具，否则文字会缺少一些表现力</p>
<p>2 需要想办法能够对JDK源码进行编辑，这种可望不可及的感觉不好。而且很容易遗忘</p>
<h5 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h5><p><a href="http://www.tianxiaobo.com/2018/01/18/HashMap-%E6%BA%90%E7%A0%81%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90-JDK1-8/#342-%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6">http://www.tianxiaobo.com/2018/01/18/HashMap-%E6%BA%90%E7%A0%81%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90-JDK1-8/#342-%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&amp;mid=2247484139&amp;idx=1&amp;sn=bb73ac07081edabeaa199d973c3cc2b0&amp;chksm=ebd743eadca0cafc532f298b6ab98b08205e87e37af6a6a2d33f5f2acaae245057fa01bd93f4&amp;scene=21#wechat_redirect">https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&amp;mid=2247484139&amp;idx=1&amp;sn=bb73ac07081edabeaa199d973c3cc2b0&amp;chksm=ebd743eadca0cafc532f298b6ab98b08205e87e37af6a6a2d33f5f2acaae245057fa01bd93f4&amp;scene=21#wechat_redirect</a></p>
]]></content>
      <categories>
        <category>JDK source type</category>
      </categories>
      <tags>
        <tag>Java stuff</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次面试（字节跳动）_java基础之线程池</title>
    <url>/interview/2020/08/28/interview/20200826-%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%9D%A2%E8%AF%95%EF%BC%88%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%EF%BC%89_java%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0.html</url>
    <content><![CDATA[<h4 id="关于线程池的初印象"><a href="#关于线程池的初印象" class="headerlink" title="关于线程池的初印象"></a>关于线程池的初印象</h4><p>由于接触到的项目都简单到只是CRUD，我并没有直接编码使用过线程池。所以感觉上非常生疏，甚至在被打击了一次之后，现在仍然觉得它就是个绣花枕头…</p>
<a id="more"></a>

<h5 id="预备知识：池化技术"><a href="#预备知识：池化技术" class="headerlink" title="预备知识：池化技术"></a>预备知识：池化技术</h5><ul>
<li>参考：<a href="https://mp.weixin.qq.com/s/_wP3w2sm0qzBaGC5O6heAg">能看得懂的文章</a></li>
<li>是：一种通用的技术思想；</li>
<li>作用：提前准备一些资源，以应对紧急的需求（紧急响应组）；</li>
<li>特征：<ul>
<li>提前准备资源（节省临时创建线程的开销）；</li>
<li>这些资源可以重复使用；</li>
</ul>
</li>
</ul>
<blockquote>
<p>知识卡：Java对象创建的过程；</p>
<ul>
<li>1 根据代码中<em>new关键字后面的参数</em>来在JVM常量池中找到<em>类的符号引用</em>；</li>
<li>2 如果没有找到，就把类的class文件加载到JVM中；</li>
<li>3 类加载完成后，JVM会执行一系列的操作：<ul>
<li>在堆空间中分配内存空间；</li>
<li>把分配的空间初始化为0[预初始化,尽量避免NPE]；</li>
<li>建立对象头的描述结构[<strong>耗时操作，因为在更新堆内存的状态</strong>]；</li>
</ul>
</li>
<li>4 调用对象的初始化方法，完成实例真正的初始化[<strong>耗时操作,因为有一系列的校验过程</strong>]；</li>
</ul>
<p>anyway, 创建一个类的实例对象是一个很耗时的过程；BUT,这和池化技术有什么关系呢？</p>
</blockquote>
<ul>
<li><p>应用：</p>
<ul>
<li><p>线程池；</p>
<p>原理：把线程池当作紧急响应组；</p>
<ul>
<li>池子中有多个沉睡的线程；</li>
<li>如果客户端来了一个请求，则唤醒池子中的一个线程；</li>
<li>线程对请求进行处理；</li>
<li>处理完成后，线程回到池子里继续睡觉；</li>
</ul>
<p>作用：在高并发的场景中，避免所有的CPU资源都耗费在创建线程的工作上（线程才能真正地处理请求）。</p>
</li>
<li><p>内存池；</p>
</li>
<li><p>数据库连接池等</p>
</li>
</ul>
</li>
<li><p>验证：使用线程池比起临时创建线程更高效；</p>
<ul>
<li><p>手段：创建两个方法，方法1使用线程池执行任务A，方法2临时创建线程执行任务A。比较方法1与方法2的执行耗时；</p>
</li>
<li><p>线程的用法；</p>
<ul>
<li><p>创建线程对象，创建时传入任务对象（任务类本身也是一个线程）；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread td = <span class="keyword">new</span> Thread(<span class="keyword">new</span> PerformanceRunnable()); <span class="comment">// 把要执行的任务添加到线程中</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>启动线程;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">td.start(); <span class="comment">// 启动线程</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>等待线程执行完成；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">td.join(); <span class="comment">// 确保线程执行完成</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>线程池的用法；</p>
<ul>
<li><p>创建线程池对象（构造方法有5个参数😄）；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadPoolExecutor tp = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">10</span>, <span class="number">10</span>, <span class="number">0</span>,</span><br><span class="line">                  TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingDeque&lt;&gt;());</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用线程池对象来执行任务；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">tp.execute(<span class="keyword">new</span> PerformanceRunnable());</span><br></pre></td></tr></table></figure>
</li>
<li><p>关停线程池对象；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">tp.shutdown(); <span class="comment">// 为什么任务还没有执行完，就要调用shutdown()?</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>等待线程池执行完成；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">tp.awaitTermination(<span class="number">1</span>, TimeUnit.SECONDS);  <span class="comment">// 等待线程池执行完成</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>运行耗时结果；</p>
<blockquote>
<p>线程执行时长：418 毫秒.<br>线程池执行时长：38 毫秒.</p>
</blockquote>
</li>
</ul>
<ul>
<li>结论：使用线程池能够大幅地提高程序性能；</li>
</ul>
<hr>
<h5 id="Java中的多线程与线程池"><a href="#Java中的多线程与线程池" class="headerlink" title="Java中的多线程与线程池"></a>Java中的多线程与线程池</h5><ul>
<li>应用场景：为了提高性能往往会在主线程里面开启一个新线程去执行；</li>
<li>事实：开启线程需要消耗很多资源；</li>
<li>issue：如果用户量上涨，如果每次任务都创建一个新的线程。服务器表示压力很大…</li>
<li>手段：使用线程池来预先创建线程，作为备用军团；</li>
</ul>
<h6 id="创建线程类的三种手段"><a href="#创建线程类的三种手段" class="headerlink" title="创建线程类的三种手段"></a>创建线程类的三种手段</h6><ul>
<li>1 继承Thread类；</li>
<li>2 实现Runnable接口；</li>
<li>3 实现Callable接口；</li>
</ul>
<h6 id="线程类的用法（启动）"><a href="#线程类的用法（启动）" class="headerlink" title="线程类的用法（启动）"></a>线程类的用法（启动）</h6><ul>
<li><p>如果是通过继承Thread类来创建的线程…</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  通过继承 thread 类</span></span><br><span class="line">Mytheard1 thread1 =  <span class="keyword">new</span> Mytheard1();</span><br><span class="line">thread1.start();</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果是通过实现Runnable接口来创建的线程…</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  通过实现 runnable 接口</span></span><br><span class="line">Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Mytheard2()); <span class="comment">// 把实例作为Thread构造器的参数</span></span><br><span class="line">thread2.start();</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果是通过实现Callable接口来创建的线程…</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  通过实现 callable 接口</span></span><br><span class="line">Mytheard3 th = <span class="keyword">new</span> Mytheard3();</span><br><span class="line">FutureTask&lt;Integer&gt; result = <span class="keyword">new</span> FutureTask&lt;&gt;(th); <span class="comment">// 把实例作为FutureTask构造器的参数</span></span><br><span class="line"><span class="keyword">new</span> Thread(result).start(); <span class="comment">// 把task对象再作为Thread构造器的参数</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h6 id="线程类的特征"><a href="#线程类的特征" class="headerlink" title="线程类的特征"></a>线程类的特征</h6><ul>
<li>1 不会直接调用自定义线程类中的run()方法；</li>
<li>2 而是调用Thread类型对象的start()方法；<ul>
<li>原理：Thread实例对象的start()方法，会调用本地系统方法，并最终导致自定义线程类的run()方法被调用；</li>
</ul>
</li>
</ul>
<h6 id="线程的分类"><a href="#线程的分类" class="headerlink" title="线程的分类"></a>线程的分类</h6><ul>
<li><p>1 守护线程；</p>
<ul>
<li><p>任务：设置一个线程为守护线程；</p>
</li>
<li><p>手段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">thread.setDaemon(<span class="keyword">true</span>)；</span><br></pre></td></tr></table></figure>
</li>
<li><p>特征：</p>
<ul>
<li>1 必须在start()方法被调用之前完成set操作（否则会抛出异常）；</li>
<li>2 在守护线程中开启的新线程也是守护线程；</li>
</ul>
</li>
<li><p>作用：为所有的非守护进程提供守护服务；</p>
</li>
<li><p>应用：JVM中的垃圾回收(GC)线程；</p>
</li>
</ul>
</li>
<li><p>2 用户线程/非守护线程；</p>
<ul>
<li><p>特征：</p>
<ul>
<li>Java线程默认是非守护线程；</li>
<li>主线程运行结束后，如果主线程中还有非守护线程，则JVM就不会退出；</li>
<li>只有在所有的非守护线程执行完成后，JVM才会退出。</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>JVM退出时，只会考虑非守护线程的状态；</p>
</blockquote>
<h6 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h6><ul>
<li>场景：如果有多个并发同时访问主线程,而主线程中又创建了多个子线程。则创建线程的开销巨大;</li>
<li>解决手段：使用线程池来提前预备线程，避免短时间大量创建线程的情形；</li>
<li>作用：<ul>
<li>1 减少在创建和销毁线程上所花的时间以及系统资源的开销;</li>
<li>2 如不使用线程池，有可能造成系统创建大量线程而导致消耗完系统内存;</li>
</ul>
</li>
</ul>
<h6 id="自定义线程池"><a href="#自定义线程池" class="headerlink" title="自定义线程池"></a>自定义线程池</h6><ul>
<li><p>手段：</p>
<ul>
<li><p>1 自定义类型中持有具体的线程池类型；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> MyPool myPool = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//单例线程池中有两种具体的线程池</span></span><br><span class="line">    <span class="keyword">private</span> ThreadPoolExecutor threadPool = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> ScheduledThreadPoolExecutor scheduledPool = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>2 以实例变量的方式来设置线程池的各项参数的大小；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置线程池的各个参数的大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> corePoolSize = <span class="number">10</span>;<span class="comment">// 池中所保存的线程数，包括空闲线程。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maximumPoolSize = <span class="number">20</span>;<span class="comment">// 池中允许的最大线程数。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> keepAliveTime = <span class="number">3</span>;<span class="comment">// 当线程数大于核心时，此为终止前多余的空闲线程等待新任务的最长时间。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> scheduledPoolSize = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>3 在私有的构造方法中：</p>
<ul>
<li>实例化线程池；</li>
<li>实例化“计划任务线程池”；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">MyPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//实例化线程池，这里使用的 LinkedBlockingQueue 作为 workQueue ，使用 DiscardOldestPolicy 作为 handler</span></span><br><span class="line">	<span class="keyword">this</span>.threadPool = <span class="keyword">new</span> ThreadPoolExecutor(corePoolSize, maximumPoolSize,</span><br><span class="line">			keepAliveTime, TimeUnit.SECONDS,</span><br><span class="line">			<span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(),</span><br><span class="line">			<span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());<span class="comment">//不在新线程中执行任务，而是由调用者所在的线程来执行</span></span><br><span class="line">	<span class="comment">//实例化计划任务线程池</span></span><br><span class="line">	<span class="keyword">this</span>.scheduledPool = <span class="keyword">new</span> ScheduledThreadPoolExecutor(scheduledPoolSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>4 定义静态方法，返回线程池对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MyPool <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (myPool == <span class="keyword">null</span>)</span><br><span class="line">    create();</span><br><span class="line">    <span class="keyword">return</span> myPool;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
<ul>
<li><p>创建线程池时传入的参数说明：</p>
<ul>
<li>1 <code>corePoolSize（int）</code>：线程池中保持的线程数量，包括空闲线程在内。</li>
<li>2 <code>maximumPoolSize（int）</code>: 线程池中能够容纳最大线程数量；</li>
<li>3 <code>keepAliveTime(long)</code>：当线程池中线程数量大于 corePoolSize 的时候,空闲线程保持在线程池中的时间;</li>
<li>4 <code>unit(TimeUnit枚举类)</code>: 上面参数时间的单位，可以是分钟，秒，毫秒等等;</li>
<li>5 <code>workQueue（BlockingQueue）</code>: 任务队列；<ul>
<li>作用：当线程任务提交到线程池以后…<ul>
<li>1 首先放入队列中;</li>
<li>2 然后线程池按照该任务队列依次执行相应的任务;</li>
</ul>
</li>
</ul>
</li>
<li>6 <code>threadFactory(ThreadFactory类)</code>: 新线程产生工厂类;</li>
<li>7 <code>handler（RejectedExecutionHandler类）</code>: 当提交线程拒绝执行、异常的时候，处理异常的类;<ul>
<li>取值范围：<ul>
<li>AbortPolicy：丢弃任务并抛出异常；</li>
<li>DiscardPolicy：丢弃任务但是不抛出异常；</li>
<li>DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务；</li>
<li>CallerRunsPolicy：由调用线程处理该任务（？？？）；</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>用法：获取线程池，并向其中添加任务；</p>
<ul>
<li><p>1 获取到线程池对象；</p>
<ul>
<li><p>手段1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadPoolExecutor pool1 = (ThreadPoolExecutor) Executors.newCachedThreadPool(); <span class="comment">// 调用Executors类的newCachedThreadPool()方法</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>手段2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadPoolExecutor pool2 = MyPool.getInstance().getThreadPool(); <span class="comment">// 自定义类的静态方法</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>2 调用线程池对象的execute()方法执行指定的任务;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">pool1.execute(() -&gt; System.out.println(<span class="string">"快捷线程池中的线程！"</span>));</span><br><span class="line"></span><br><span class="line">pool2.execute(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"pool2 普通线程池中的线程！"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">30</span>*<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;); <span class="comment">// 使用lambda表达式来表示待执行的任务</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>3 打印线程池的状态信息；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">"pool2 poolSize:"</span>+pool2.getPoolSize()); <span class="comment">// </span></span><br><span class="line">System.out.println(<span class="string">"pool2 corePoolSize:"</span>+pool2.getCorePoolSize()); <span class="comment">// 核心线程数</span></span><br><span class="line">System.out.println(<span class="string">"pool2 largestPoolSize:"</span>+pool2.getLargestPoolSize()); <span class="comment">// </span></span><br><span class="line">System.out.println(<span class="string">"pool2 maximumPoolSize:"</span>+pool2.getMaximumPoolSize()); <span class="comment">// ？？？</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>JDK中提供的几种常用线程池</p>
<ul>
<li><code>newFixedThreadPool</code> 创建固定大小数量线程池；</li>
<li><code>newSingleThreadExecutor</code> 创建容量为1的线程池——所有的线程依次执行；</li>
<li><code>newCachedThreadPool</code> 创建可缓存的线程池；<ul>
<li>特征：<ul>
<li>1 没有最大线程限制；</li>
<li>2 如果空闲线程等待时间超过1分钟，就关闭此线程；</li>
</ul>
</li>
</ul>
</li>
<li><code>newScheduledThreadPool</code> 创建计划 (延迟) 任务线程池；<ul>
<li>特征：可以设置线程池中线程的执行状态；<ul>
<li>1 使线程在特定的延迟时间后执行；</li>
<li>2 使线程周期性地执行；（作用等同于Timer）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h6 id="在SpringBoot中使用线程池"><a href="#在SpringBoot中使用线程池" class="headerlink" title="在SpringBoot中使用线程池"></a>在SpringBoot中使用线程池</h6><p>​    this is for further practice.</p>
<blockquote>
<p>全是文字，写着写着就没劲了。因为没有推理的过程，就只是照本宣科地陈列规则。<br>Plus,为什么一个构造方法需要有7个参数 OMG 🙃</p>
</blockquote>
]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>Java stuff</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次面试（字节跳动）_后续</title>
    <url>/interview/2020/08/28/interview/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%9D%A2%E8%AF%95%EF%BC%88%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%EF%BC%89_%E5%90%8E%E7%BB%AD.html</url>
    <content><![CDATA[<h4 id="ConcurrentHashMap的put-操作过程"><a href="#ConcurrentHashMap的put-操作过程" class="headerlink" title="ConcurrentHashMap的put()操作过程"></a>ConcurrentHashMap的put()操作过程</h4><p>这个问题在上次被问到后，我其实做了一番搜索。还搜索了一些文章，但都本着太长不看的原则跑进收藏夹里吃灰了</p>
<p>不过这次既然被同一个问题绊倒两次，还是坐下来跟它好好对付对付</p>
<a id="more"></a>

<h5 id="基本认识（5点认知）"><a href="#基本认识（5点认知）" class="headerlink" title="基本认识（5点认知）"></a>基本认识（5点认知）</h5><p>是：一个元素容器；</p>
<p>作用：对元素进行存储；</p>
<p>特征：</p>
<ul>
<li>与多线程相关；</li>
</ul>
<p>应用：xxx</p>
<p>用法：xxx</p>
<p>底层原理：散列表 + 红黑树；</p>
<h5 id="进一步认识"><a href="#进一步认识" class="headerlink" title="进一步认识"></a>进一步认识</h5><h6 id="底层数据结构（JDK1-8）"><a href="#底层数据结构（JDK1-8）" class="headerlink" title="底层数据结构（JDK1.8）"></a>底层数据结构（JDK1.8）</h6><p><img src="https://s1.ax1x.com/2020/08/28/dImSRf.md.png" alt="底层数据结构"></p>
<p>类的具体作用：参考源码中类上面的注释（不夸张的有两百行）；</p>
<p>简单概括（5点）：</p>
<ul>
<li>JDK1.8中的实现是散列表 + 红黑树；</li>
<li>ConcurrentHashMap支持高并发的访问与更新操作，因为它是线程安全的；</li>
<li>访问/检索操作不需要加锁；</li>
<li>get()方法是非阻塞的（啥意思？）；</li>
<li>key与value都不能为null；</li>
</ul>
<h6 id="WHY"><a href="#WHY" class="headerlink" title="WHY?"></a>WHY?</h6><ul>
<li>Hashtable实现线程安全的手段很直接（每个方法都添加了synchronized关键字），但是效率很低；</li>
<li>ConcurrentHashMap使用了更优的手段实现线程安全（部分加锁 + CAS算法）；</li>
</ul>
<h6 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h6><ul>
<li>CAS算法（compare and swap）<ul>
<li>作用：解决多个线程对变量的并发操作问题；</li>
<li>手段：规定对于任意一个线程，每次对变量进行修改操作时，都检查变量当前在主内存中的值 == 自己获取到的变量值；<ul>
<li>aka 判断主内存中的变量值是否被其他线程修改过了。</li>
<li>如果相等，说明没有其他线程修改主内存中的变量。则把修改过的值同步到主内存中；</li>
<li>如果不相等，说明已经有别的线程捷足先登，把主内存中的变量值修改了。则当前线程放弃自己计算的值，然后从主内存中重新获取变量的初始值，重新计算，然后再次尝试把计算结果同步到主内存中；</li>
</ul>
</li>
<li>知识卡：JMM(java内存模型 = CPU + 各个线程的工作内存 + 主内存；)</li>
</ul>
</li>
<li>volatile关键字<ul>
<li>作用：保证变量对所有线程的可见性（但是不保证原子性）；</li>
<li>原理-多线程环境下，变量对多个线程的可见性：一旦变量的值（主内存中）被某个线程修改，其他的线程都会看到修改后的变量；（从而重新获取、重新计算）</li>
<li>原理-无法保证变量操作的原子性：变量赋值的操作其实分成了多个步骤执行，而volatile没有对这一事实产生任何影响；</li>
</ul>
</li>
</ul>
<hr>
<h5 id="从源码认识类的实现原理"><a href="#从源码认识类的实现原理" class="headerlink" title="从源码认识类的实现原理"></a>从源码认识类的实现原理</h5><blockquote>
<p>bear this in mind：实现源码时，需要充分考虑底层数据结构被多个线程操作的可能性。以保证操作的线程安全</p>
</blockquote>
<h6 id="多线程下有哪些操作需要保证多线程安全呢？"><a href="#多线程下有哪些操作需要保证多线程安全呢？" class="headerlink" title="多线程下有哪些操作需要保证多线程安全呢？"></a>多线程下有哪些操作需要保证多线程安全呢？</h6><ul>
<li>增删改</li>
</ul>
<hr>
<h6 id="类的域对象（×10-不夸张的）"><a href="#类的域对象（×10-不夸张的）" class="headerlink" title="类的域对象（×10 不夸张的）"></a>类的域对象（×10 不夸张的）</h6><ul>
<li>Node&lt;K,V&gt;[] table; // 用于存储元素的散列表</li>
<li>其他域对象; // 为了其他API服务的</li>
<li>int sizeCtl; // 用于控制散列表的初始化与扩容； 规则：…</li>
</ul>
<h5 id="类的构造方法（×5-也不夸张）"><a href="#类的构造方法（×5-也不夸张）" class="headerlink" title="类的构造方法（×5 也不夸张）"></a>类的构造方法（×5 也不夸张）</h5><ul>
<li><p>构造方法的作用</p>
<ul>
<li>调用它，来创建实例对象；</li>
<li>强制调用者传入某些参数来初始化某些实例变量；</li>
</ul>
</li>
<li><p>选择一个构造方法进行代码分析</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* 参数判空代码... */</span></span><br><span class="line">    </span><br><span class="line">    	<span class="comment">// 为局部变量cap绑定一个值	手段：判断xxx条件是否成立：如果是，绑定ooo。否则绑定tableSizeFor()方法的调用结果		&gt;&gt;&gt;表示无符号右移操作</span></span><br><span class="line">        <span class="keyword">int</span> cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ?</span><br><span class="line">                   MAXIMUM_CAPACITY :</span><br><span class="line">                   tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>));</span><br><span class="line">    	<span class="comment">// 把cap的值绑定到sizeCtl属性上</span></span><br><span class="line">        <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>tableSizeFor()方法的作用？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = c - <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        ...</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">return</span> ...;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这个实现手段不是重点，重点是它的作用是：获取到大于且最接近指定容量的2的指数数值；</p>
</li>
<li><p>this.sizeCtl = cap; // 指定下次扩容时，散列表容量的大小</p>
</li>
</ul>
</li>
</ul>
<h5 id="类的API-put-方法"><a href="#类的API-put-方法" class="headerlink" title="类的API-put()方法"></a>类的API-put()方法</h5><blockquote>
<p>OS:这是面试官真正问到的方法，我没有细致地看过 只能硬着头皮说，和HashMap地put()方法实现过程类似，只是添加了synchronized关键字吧吧🐷</p>
<p>参考:<a href="https://mp.weixin.qq.com/s/r1ErR7EroJt4b83Pm7Xk6g">Java3y</a></p>
</blockquote>
<ul>
<li><p>看之前推测一下子，put()作为一个添加键值对的api，可能的实现过程是怎样的；</p>
<ul>
<li>找到键值对应该存放的位置；</li>
<li>把键值对绑定到这个位置上；Over~</li>
</ul>
</li>
<li><p>真实情况是，put()方法需要做更多的工作（一方面是为了”容器的底层数据结构”,另一方面是为了“多线程操作的正确性”）</p>
<ul>
<li>代码拆解（源码基本没有给注释 引用图片：Java3y）</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/08/28/do6lpn.png" alt="put()方法的工作"></p>
<p>这里面的步骤虽然多，但是层次还是能理清楚的。</p>
<ul>
<li><p>第一次插入键值对时，判断哈希表是否为空。如果是，就要先对哈希表进行初始化工作；</p>
</li>
<li><p>手段：调用initTable()方法，把方法的返回结果绑定到tab（在for循环中创建的局部变量）</p>
<p><img src="https://s1.ax1x.com/2020/08/28/dog6Fe.png" alt="初始化节点数组tab的代码"></p>
<ul>
<li>sizeCtl的规则：小于0时，表示有线程正在执行初始化操作。则，需要控制其他进程不能再次执行初始化的代码;</li>
<li>任务：对于多个线程，保证初始化的代码同一时刻就只能有唯一的线程在执行；</li>
<li>手段：<ul>
<li>1 在线程进入初始化的代码之前，先对sizeCtl属性进行判断；以决定线程能不能继续执行代码</li>
<li>2 如果线程能够执行初始化代码，在执行代码前，把sizeCtl设置为-1——支持1中的判断操作</li>
</ul>
</li>
<li>作用：多线程情况下，只会有一个线程取完成散列表的初始化操作；</li>
</ul>
</li>
</ul>
<blockquote>
<p>这种总结似乎缺了点意思 所以再从另一个角度补充下</p>
</blockquote>
</li>
</ul>
<h6 id="补充细节"><a href="#补充细节" class="headerlink" title="补充细节"></a>补充细节</h6><p>CAS操作的Java API：</p>
<ul>
<li><strong>tabAt</strong>    作用：获取 table 数组中索引为 i 的 Node 元素；</li>
<li><strong>casTabAt</strong>  作用：设置 table 数组中索引为 i 的元素</li>
<li><strong>setTabAt</strong>   作用：设置 table 数组中索引为 i 的元素</li>
</ul>
<h6 id="put-流程分析"><a href="#put-流程分析" class="headerlink" title="put()流程分析"></a>put()流程分析</h6><ul>
<li>1 计算出key应该在哈希表中插入的位置；<ul>
<li>手段：对key进行重哈希，以减少哈希冲突；</li>
</ul>
</li>
<li>2 判断当前数组是否为空，如果为空，就进行初始化操作intiTable();<ul>
<li>作用：只会有一个线程执行初始化的代码；</li>
</ul>
</li>
<li>3 判断key-value能不能直接添加到哈希表上；<ul>
<li>手段：<ul>
<li>1 计算key映射到的哈希表的索引； </li>
<li>2 调用CAS的tabAt()方法获取到该位置上的值； </li>
<li>3 如果当前值为null,直接调用casTabAt()完成插入操作；</li>
</ul>
</li>
</ul>
</li>
<li>4 如果预期插入哈希表的位置上的元素不为null,判断哈希表是不是正在扩容（多线程需要考虑的问题）<ul>
<li>手段：判断当前节点是不是特殊节点forwardingNode（这是ConcurrentHashMap中定义的一个内部类型，用于表示扩容操作状态下的节点）</li>
<li>具体方法：判断节点的hash值是不是等于-1（使用MOVED标识）；</li>
</ul>
</li>
<li>5 如果哈希表也没有在扩容中，说明可以执行插入节点的操作了（synchronzied加锁以实现线程安全性）</li>
<li>6 如果节点为链表的头节点：<ul>
<li>如果在链表中找到key相同的节点，则更新/覆盖节点的值</li>
<li>如果没有找到这样的节点，就直接在链表尾部添加一个新的节点</li>
</ul>
</li>
<li>7 如果节点为红黑树的根节点：<ul>
<li>说明：如果链表连接的节点长度太长的话，ConcurrentHashMap就会自动把链表转化成一个红黑树；</li>
<li>1 判断当前节点是不是红黑树的根节点；</li>
<li>2 判断红黑树中是否已经存在了键为key的节点；<ul>
<li>存在，则使用新的value来更新它；</li>
<li>不存在，则向红黑树中添加一个新的节点；</li>
</ul>
</li>
</ul>
</li>
<li>8 [<em>插入导致的结果</em>]根据当前链表的长度，来决定要不要把链表转化成一棵红黑树；</li>
<li>9 [<em>插入导致的结果</em>]插入新的键值对后，查看当前容量。如果超过临界值就进行扩容；</li>
</ul>
<h6 id="get-方法"><a href="#get-方法" class="headerlink" title="get()方法"></a>get()方法</h6><blockquote>
<p>get()的作用是取出数据</p>
</blockquote>
<ul>
<li>1 重hash；</li>
<li>2 找到节点在哈希表中的预期位置i；</li>
<li>3 如果哈希表的桶节点table[i]的key与待查找的key相等，则直接返回；</li>
<li>4 如果不相等，而根节点是红黑树节点。则<ul>
<li>在红黑树中查找</li>
</ul>
</li>
<li>5 如果不相等，而根节点是链表节点。则<ul>
<li>在链表中查找</li>
</ul>
</li>
</ul>
<blockquote>
<p>Java基础知识也挺繁杂的 until next time 😄</p>
</blockquote>
]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>Java stuff</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次面试（字节跳动）</title>
    <url>/interview/2020/08/26/interview/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%9D%A2%E8%AF%95%EF%BC%88%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%EF%BC%89.html</url>
    <content><![CDATA[<h3 id="字节跳动（视频面试一面）"><a href="#字节跳动（视频面试一面）" class="headerlink" title="字节跳动（视频面试一面）"></a>字节跳动（视频面试一面）</h3><hr>
<h4 id="关于面试官："><a href="#关于面试官：" class="headerlink" title="关于面试官："></a>关于面试官：</h4><p>​    面试官给我的感觉很好，年龄和我相仿，穿着也很随意。就不会让人产生紧张的情绪，而且问的问题也很有递进性。过程是挺轻松的，结果嘛…</p>
<a id="more"></a>

<h4 id="关于项目："><a href="#关于项目：" class="headerlink" title="关于项目："></a>关于项目：</h4><p>   这个主要问了做过项目中的一些难点问题。但实话讲，做过的项目有些头疼的问题，但都算不上技术难点。于是我先说了公司项目的特征：面向政府机构居多，所以不会存在什么高并发访问的情况。（这是真实情况，也算是降低面试官的期望，别一上来就问大流量情况下如何削峰、限流什么的）</p>
<p>   我说了两点：1 excel表格中大数据导入MySQL数据库的问题；2 后台上传多种格式的资料时的处理；富文本编辑器上传时的格式处理等等</p>
<p>   因为项目总是和业务强相关，面试官可能也不想纠结于细节问题。于是很快就跳到了Java基础的阶段</p>
<h4 id="关于Java基础："><a href="#关于Java基础：" class="headerlink" title="关于Java基础："></a>关于Java基础：</h4><p>这个据我推测，面试官面前可能有一个巨大的Xmind脑图，根据你简历上所写的内容。随机抽取一个点来问你，基本是要考察你对知识点了解的深度；具体问的问题如下：</p>
<h5 id="数据库联合索引与最左匹配原则"><a href="#数据库联合索引与最左匹配原则" class="headerlink" title="数据库联合索引与最左匹配原则"></a>数据库联合索引与最左匹配原则</h5><p>索引：为数据表中的指定字段添加的额外的数据结构；</p>
<p>作用：在查询时，能够通过某个字段的索引来快速定位到满足条件的记录行；</p>
<p>原理：</p>
<ul>
<li>索引一般使用树一类的结构进行存储，因此查询速度很快。</li>
<li>通过索引中的字段值，就能快速定位到数据表中对应的数据行；</li>
</ul>
<p>用法：在SQL查询语句中，使用添加了索引的字段作为查询条件（where xxx=???）。这样就能命中索引，从而实现快速查询；</p>
<p><strong>联合索引</strong>：使用数据表中的多个字段所创建的索引；</p>
<p>作用：在编写SQL语句时，就能够通过多个字段来命中索引——这会使得SQL语句的编写更加灵活；</p>
<p>规则：<strong>最左匹配原则</strong>；（这个我并没有答对）</p>
<p>示例：</p>
<ul>
<li>在创建联合索引时，选择了字段a、b、c；</li>
<li>在编写查询SQL时，<ul>
<li>如果查询的字段以a开头（a、a-b、a-b-c），则能够命中联合索引，从而加速查询；</li>
<li>如果查询的字段不是以a开头（准确的说，是不包含a字段），则无法命中联合索引，查询操作仍旧是遍历的方式；</li>
</ul>
</li>
</ul>
<p>（讲真，我只用Navicat这个可视化工具创建过索引。所以上面的这些东西都是事后找补的   印象分什么的基本就没了）</p>
<h5 id="volatile关键字："><a href="#volatile关键字：" class="headerlink" title="volatile关键字："></a>volatile关键字：</h5><p>（这个我两周之前很细致的看过，但是忘得永远比记住得要快）</p>
<p>是：Java提供的一个关键字；</p>
<p>作用：修饰一个变量，以保证多线程情况下，变量的可见性与有序性；</p>
<p>特征：</p>
<ul>
<li>volatile就只能修饰变量，不能修饰方法啥的；</li>
<li>volatile不能保证多线程操作下的原子性（可能线程A执行了一半后，线程B接管CPU时间片）——需要其他手段来保证；</li>
<li>真正在编码时，这个关键字用得并不多；</li>
</ul>
<p>原理：</p>
<ul>
<li><p>变量对多个线程的可见性：</p>
<ul>
<li><p>JMM（Java 内存模型）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> 每个线程都有自己的工作内存；</span><br><span class="line"><span class="number">2</span> 所有线程共享的变量都在主内存中；</span><br><span class="line"><span class="number">3</span> 线程操作变量时，先从主内存把变量的值拷贝到自己的工作内存中，操作结束后，再把变量的值更新到主内存</span><br><span class="line">中；</span><br></pre></td></tr></table></figure>
</li>
<li><p>结合JMM的3条规则，volatile关键字能够保证所有对变量的更新都即时地同步到主内存中；</p>
</li>
</ul>
</li>
<li><p>变量的有序性：</p>
<ul>
<li><p>JVM指令重排</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">为了提高代码执行的效率，CPU或者编译器可能会对程序员编写的代码进行重新排序；</span><br></pre></td></tr></table></figure>

<ul>
<li>规则：不管如何重新排序，JVM保证在单线程执行时，得到的结果总是相同的；</li>
<li>问题来了，多线程时，指令重排就可能导致程序出现非预期的执行结果；</li>
</ul>
</li>
<li><p>结合以上，volatile关键字能够保证变量的赋值过程（非原子操作）不会出现指令重排，aka，指令的有序性。</p>
</li>
</ul>
</li>
</ul>
<p>应用：实现双重检查锁的单例模式；</p>
<h5 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h5><p>是：Java提供的一个关键字；</p>
<p>作用：为一段代码加锁，从而限制此段代码同一时刻只能被一个线程访问；</p>
<p>特征：早期它的性能很低，但是JDK8中做了很多优化；</p>
<p>用法：</p>
<ul>
<li>修饰实例方法；<ul>
<li>作用：线程在执行实例方法之前，必须要获得当前实例的对象锁；</li>
</ul>
</li>
<li>修饰静态方法；（<em>这里面试官着重问了，但是我没能很好的区分实例锁与类锁</em>）<ul>
<li>作用：线程在执行静态方法之前，必须要获得当前类的对象锁；</li>
</ul>
</li>
<li>修饰代码块；<ul>
<li>作用：线程在执行代码块之前，必须要获得指定对象的锁；</li>
<li>特征：这里的对象可以由程序员手动指定；</li>
</ul>
</li>
</ul>
<p>应用：双重检查校验的单例模式（和volatile配合使用）；</p>
<p>原理：JVM层面的一些东西，在字节码上添加了一些独特的标识；</p>
<h5 id="synchronized关键字-与-ReentrantLock类型（这个面试官没问，可能是因为上面答得不好）"><a href="#synchronized关键字-与-ReentrantLock类型（这个面试官没问，可能是因为上面答得不好）" class="headerlink" title="synchronized关键字 与 ReentrantLock类型（这个面试官没问，可能是因为上面答得不好）"></a>synchronized关键字 与 ReentrantLock类型（这个面试官没问，可能是因为上面答得不好）</h5><p>作用：都能够为代码段加锁，从而限制多个线程对代码块的访问；</p>
<p>相同点：</p>
<ul>
<li>两者都是可重入锁（re-entree）;<ul>
<li>线程可以重复获取到对象的锁——当再次获取对象锁时，计数值+1；</li>
</ul>
</li>
</ul>
<p>不同点：</p>
<ul>
<li>实现层面<ul>
<li>synchronized关键字的实现是在JVM中，而ReentrantLock的实现在JDK的concurrent包中；</li>
</ul>
</li>
<li>用法层面<ul>
<li>synchronized是关键字，用法比较单一（无非修饰不同的成份），而ReentrantLock是一个类，用法就非常灵活了；</li>
</ul>
</li>
<li>功能层面<ul>
<li>ReentrantLock提供了更多的功能：<ul>
<li>1 使等待中的线程放弃等待（去做别的事情）；</li>
<li>2 指定锁的类型（是公平锁，还是非公平锁）；公平锁：等待最久的线程会在锁被释放时，优先获取到锁；</li>
<li>3 实现等待 - 通知机制；</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h5><p>参考：<a href="https://www.jianshu.com/p/f584799f1c77">公平🔒</a></p>
<p>必须：兔子喝水，黑狗看门；</p>
<p>结论：</p>
<ul>
<li>1、若在释放锁的时候总是没有新的兔子来打扰，则非公平锁等于公平锁；</li>
<li>2、若释放锁的时候，正好一个兔子来喝水，而此时位于队列头的兔子还没有被唤醒（因为线程上下文切换是需要不少开销的），此时后来的兔子则优先获得锁，成功打破公平，成为非公平锁；</li>
</ul>
<h5 id="类加载过程中的双亲委派模型"><a href="#类加载过程中的双亲委派模型" class="headerlink" title="类加载过程中的双亲委派模型"></a>类加载过程中的双亲委派模型</h5><p><strong>类加载过程</strong>：</p>
<p>是：一个过程；</p>
<p>作用：把编译器编译生成的class文件，以特定的格式加载到JVM内存中的特定区域；</p>
<p>特征：分为两类；</p>
<ul>
<li>预加载；<ul>
<li>在虚拟机启动时就会被加载到内存中的class文件；比如lang.*与util.*等；</li>
</ul>
</li>
<li>运行时加载；<ul>
<li>在运行程序时，虚拟机根据类的全限定名来去查找并加载对应的class文件；</li>
</ul>
</li>
</ul>
<p>SOP:</p>
<ul>
<li>通过类的全限定名获取到<em>类的二进制字节流</em>；</li>
<li>把<em>字节流所代表的静态存储结构</em>转化为<em>方法区的运行时数据结构</em>；</li>
<li>在JVM内存中生成<em>表示这个类的Class对象</em>——它包含类的一切信息，是反射机制的基础；</li>
</ul>
<p><strong>双亲委派模型</strong>：</p>
<p>是：一个使用类加载器时，推荐遵守的规则；</p>
<p>作用：保证核心类型都能够被安全地加载到内存中；防止不法分子写的String类型被JVM错误加载…</p>
<p>特征：</p>
<p>​    1 这不是一个强制遵守的规则；</p>
<p>​    2 每一层加载器都有自己能够加载的类型范围；</p>
<p>规则描述：</p>
<ul>
<li>当类加载器需要把一个类加载到内存中的时候，先尝试把加载的工作交给更高层的类加载器完成；</li>
<li>然后再转交给更高级的类加载器，so on and so forth,直到到达最高层的类加载器（Bootstrap）；</li>
<li>只有顶层类加载器无法加载的类型（每一层加载器都有自己所能加载的类型范围），才会交给底层的类加载器去加载；</li>
</ul>
<h5 id="Spring-IoC容器"><a href="#Spring-IoC容器" class="headerlink" title="Spring IoC容器"></a>Spring IoC容器</h5><p>是：一个管理对象 以及 对象之间依赖关系的第三方；</p>
<p><em>如何解决循环依赖的问题呢？</em></p>
<p><strong>循环依赖</strong>：</p>
<p>IoC容器中注入了实例a与实例b，实例a依赖于实例b，同时实例b也依赖于实例a；</p>
<p>issue：IoC容器在创建实例a时，需要先创建实例b。但是创建实例b时，又需要先创建实例a，狗咬尾巴</p>
<p>参考：<a href="https://segmentfault.com/a/1190000015221968">Spring对循环依赖的解决</a></p>
<p>解决方案：</p>
<p>1 尝试创建实例a，发现实例a依赖于实例b；</p>
<p>2 尝试创建实例b，发现实例b依赖于实例a；</p>
<p>3 获取到实例a的一个<strong>早期引用</strong>（属性未进行初始化的引用）；</p>
<p>4 把这个早期引用注入到实例b中，使得实例b完成初始化；</p>
<p>5 然后实例a再去获取到实例b的引用，得到实例a的<strong>完全引用</strong>；</p>
<h5 id="AOP（面向切面编程）"><a href="#AOP（面向切面编程）" class="headerlink" title="AOP（面向切面编程）"></a>AOP（面向切面编程）</h5><p>是：一种编程的方式；对标OOP</p>
<p>作用：能够把应用中一些公共的功能（事务、安全等）抽取出来单独实现，然后以声明的方式编织到需要它们的代码中；</p>
<p>特征：AOP是一种思想，不同框架对这种思想的实现会各有差异。比如Spring AOP与AspectJ；</p>
<p>用法：这个步骤比较多，不宜作为面试部分；</p>
<p>原理：Spring AOP的底层原理是动态代理+反射；</p>
<ul>
<li>代理类会封装目标类，并把<em>用于增强的切面类</em>添加到目标类的外围；</li>
<li>动态代理这种方式绝定了Spring AOP<em>只能对方法做一些增强（因为动态代理使用反射实现目标）</em>，而对字段等无能为力；</li>
<li>Java中的动态代理：JDK动态代理（要求被代理的类实现接口） 与 CGLib动态代理（不要求…）；</li>
</ul>
<h5 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h5><p>注：这是一个多线程安全的类型，我在简历中有写看过它的源码，但其实只看了分析的文章。时隔两周，就只记得“分段锁”这三个字了 😭</p>
<p>是：一个容器/集合；</p>
<p>作用：存储键值对；</p>
<p>特征：多线程安全；</p>
<p><strong>多线程安全原理</strong>：</p>
<p>​    JDK1.7的手段：</p>
<ul>
<li><p>把容器表示成多个数据段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcurrentHashMap</span></span>&#123;</span><br><span class="line">    <span class="comment">// Segment数组	Segment类型本身继承了ReentrantLock，可以当作锁</span></span><br><span class="line">    Segment[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>数据段中存储多个键值对：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Segment</span></span>&#123;</span><br><span class="line">    HashEntry[]; <span class="comment">// HashEntry就是一个封装了键值对的类型；</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<ul>
<li>为每个数据段Segment添加一把锁，这样如果多个线程访问的是不同的数据段，就不会出现并发访问；而如果访问的是同一个数据段，仍旧是获取到锁的执行，没有获取到锁的等待</li>
</ul>
<p>​    JDK1.8使用的手段：</p>
<ul>
<li>synchronized关键字 + CAS乐观锁【细节需要看源码】</li>
<li>synchronized关键字只会锁住链表或红黑二叉树的头节点，如果多线程操作没有发生哈希冲突，就不会出现并发访问；如果操作到了同一个哈希位置，仍旧是…;</li>
</ul>
<p><strong>底层结构</strong>：</p>
<p>​    JDK1.7 Segment[] + HashEntry[]；</p>
<p>​    JDK1.8 Node[] + 链表 + 红黑树；</p>
<p>用法：</p>
<p>​    put()方法，前后有8步。</p>
<p>​    get()方法，就是按图索骥的过程，与多线程关系不大（毕竟它只是一个访问操作）；</p>
<blockquote>
<p>in case I don’t see u again, good morning, good afternoon, and good evening!😄</p>
</blockquote>
<p>​    </p>
]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>Java stuff</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>奇偶链表_10</title>
    <url>/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8%EF%BC%88%E6%8A%8A%E5%A5%87%E6%95%B0%E4%BD%8D%E7%BD%AE%E4%B8%8E%E5%81%B6%E6%95%B0%E4%BD%8D%E7%BD%AE%E4%B8%8A%E7%9A%84%E8%8A%82%E7%82%B9%E8%BF%9E%E5%9C%A8%E4%B8%80%E8%B5%B7%EF%BC%89_10.html</url>
    <content><![CDATA[<h4 id="把链表中的奇数位置节点与偶数位置节点放在一起"><a href="#把链表中的奇数位置节点与偶数位置节点放在一起" class="headerlink" title="把链表中的奇数位置节点与偶数位置节点放在一起"></a>把链表中的奇数位置节点与偶数位置节点放在一起</h4><h4 id="题设-与-要求"><a href="#题设-与-要求" class="headerlink" title="题设 与 要求"></a>题设 与 要求</h4><p><img src="https://s1.ax1x.com/2020/08/15/dklpjK.md.png" alt="题设与要求"></p>
<a id="more"></a>

<h4 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h4><p><img src="https://s1.ax1x.com/2020/08/15/dkldDU.md.png" alt="测试用例"></p>
<h4 id="附加说明"><a href="#附加说明" class="headerlink" title="附加说明"></a>附加说明</h4><p><img src="https://s1.ax1x.com/2020/08/15/dklLKf.md.png" alt="提示信息"></p>
<h4 id="分析（问题的难点）"><a href="#分析（问题的难点）" class="headerlink" title="分析（问题的难点）"></a>分析（问题的难点）</h4><ul>
<li>如何把奇数/偶数位置的节点都连接起来？</li>
<li>如何把奇数位置节点的集合 与 偶数位置节点的集合连接起来？</li>
</ul>
<h4 id="思路（难点的解决方案）"><a href="#思路（难点的解决方案）" class="headerlink" title="思路（难点的解决方案）"></a>思路（难点的解决方案）</h4><ul>
<li>如何把奇数位置/偶数位置的节点都连接起来？<ul>
<li>答：使用两个指针odd、even，初始化指向第一个节点与第二个节点。然后去创建奇数位置节点链表与偶数位置节点链表；</li>
</ul>
</li>
<li>如何把奇数位置节点集合与偶数位置节点集合连接起来？<ul>
<li>答：只要把odd链表的尾节点连接到even链表的头节点就可以了</li>
</ul>
</li>
</ul>
<h4 id="根据思路进行编码（细节处理）"><a href="#根据思路进行编码（细节处理）" class="headerlink" title="根据思路进行编码（细节处理）"></a>根据思路进行编码（细节处理）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">oddEvenList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 鲁棒性代码</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1 定义需要的实例变量</span></span><br><span class="line">        ListNode odd = head; <span class="comment">// 奇数位置节点的指针	作用：连接奇数位置的节点</span></span><br><span class="line">        ListNode even = head.next; <span class="comment">// 偶数位置节点的指针	作用：连接偶数位置的节点</span></span><br><span class="line">        ListNode evenHead = even; <span class="comment">// 作用：记录偶数节点链表的头节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 遍历当前链表	在循环中：1 创建奇数位置节点链表； 2 创建偶数位置节点链表</span></span><br><span class="line">        <span class="keyword">while</span>(even != <span class="keyword">null</span> &amp;&amp; even.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 创建链表SOP： 1 建立连接； 2 更新指针；</span></span><br><span class="line">            odd.next = even.next;</span><br><span class="line">            odd = odd.next;</span><br><span class="line"></span><br><span class="line">            even.next = odd.next;</span><br><span class="line">            even = even.next; <span class="comment">// even会率先达到链表的尾部</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 把偶数链表连接到奇数链表的尾节点上</span></span><br><span class="line">        odd.next = evenHead;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 返回新链表的头节点（作图可知）</span></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="代码分解SOP"><a href="#代码分解SOP" class="headerlink" title="代码分解SOP"></a>代码分解SOP</h4><ul>
<li>定义需要的实例变量</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ListNode odd = head; <span class="comment">// 用于指向奇数位置的节点</span></span><br><span class="line">ListNode even = head.next; <span class="comment">// 用于指向偶数位置的节点</span></span><br></pre></td></tr></table></figure>

<ul>
<li>遍历当前链表中的所有节点    在循环中：1 创建奇数节点的链表； 2 创建偶数节点的链表</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(ture)&#123; <span class="comment">// 参考：画图</span></span><br><span class="line">    <span class="comment">// 创建连接</span></span><br><span class="line">    odd.next = even.next;</span><br><span class="line">    <span class="comment">// 更新指针</span></span><br><span class="line">    odd = odd.next;</span><br><span class="line">    </span><br><span class="line">    even.next = odd.next;</span><br><span class="line">    even = even.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s1.ax1x.com/2020/08/15/dkteIO.md.jpg" alt="遇事不决画个图"></p>
<ul>
<li>确定循环执行表达式</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据链表中的节点数的不同，循环终结会有两种情况</span></span><br><span class="line"><span class="comment">// 1 链表中的节点数目为偶数个	even.next == null</span></span><br><span class="line"><span class="comment">// 2 链表中的节点数目为奇数个	even == null</span></span><br><span class="line"><span class="comment">// 当这两种情况之一发生时，就要终止循环 所以</span></span><br><span class="line"><span class="keyword">while</span>(even == <span class="keyword">null</span> &amp;&amp; even.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>把偶数链表连接到奇数链表上</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">odd.next = evenHead; <span class="comment">// 连接到记录的最初的偶数链表的头节点</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Bingo! good morning,good afternoon,and good night 🌙</p>
</blockquote>
]]></content>
      <categories>
        <category>ListNode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>分隔链表得到子链表_09</title>
    <url>/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E6%8A%8A%E9%93%BE%E8%A1%A8%E5%88%86%E9%9A%94%E6%88%90k%E4%B8%AA%E5%AD%90%E9%93%BE%E8%A1%A8_09.html</url>
    <content><![CDATA[<h4 id="把链表分隔成k个子链表"><a href="#把链表分隔成k个子链表" class="headerlink" title="把链表分隔成k个子链表"></a>把链表分隔成k个子链表</h4><hr>
<h4 id="题设与要求"><a href="#题设与要求" class="headerlink" title="题设与要求"></a>题设与要求</h4><p><img src="https://s1.ax1x.com/2020/08/15/dFWppn.md.png" alt="题设与要求"></p>
<a id="more"></a>

<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p><img src="https://s1.ax1x.com/2020/08/15/dFICeP.md.png" alt="测试用例"></p>
<h4 id="提示信息"><a href="#提示信息" class="headerlink" title="提示信息"></a>提示信息</h4><p><img src="https://s1.ax1x.com/2020/08/15/dFoZtO.png" alt="提示信息"></p>
<h4 id="分析（题目中的难点）"><a href="#分析（题目中的难点）" class="headerlink" title="分析（题目中的难点）"></a>分析（题目中的难点）</h4><ul>
<li>根据题设，就是要把链表中的节点均分为k份；<ul>
<li>要如何处理(length % k)余下的这些个节点？</li>
</ul>
</li>
<li>k个连续的部分，每个部分相差不超过1；<ul>
<li>说明每个子链表中的节点数会有不一样。可以顺序的让靠前的子链表中多出一个节点，来消耗余下的节点</li>
<li>如何确定到哪一个子链表时，余下的节点已经被消耗完了呢？</li>
</ul>
</li>
<li>如果k &gt; length，缺少的部分补充null作为元素；</li>
</ul>
<h4 id="思路（对难点的解决方案）"><a href="#思路（对难点的解决方案）" class="headerlink" title="思路（对难点的解决方案）"></a>思路（对难点的解决方案）</h4><ul>
<li>定义一个大小为k数组，数组中的第i个元素表示：第i个子链表中应该包含的节点数目；</li>
<li>定义一个循环，每次循环都为数组中的一个元素绑定值<ul>
<li>先求出余数；</li>
<li>每次绑定值时，判断余数是否还大于0.如果是，就把要绑定的值+1； 同时余数-1</li>
<li>每个子节点要绑定的基础数值为：(length / k)</li>
</ul>
</li>
<li>定义一个子链表列表，用于存储分割后的子链表；</li>
<li>定义一个循环，每次循环<ul>
<li>从数组中取出当前子链表应该包含的节点数；</li>
<li>根据上面的节点数目来创建一个子链表，并把子链表绑定到子链表列表的一个元素上；</li>
<li>循环往复，直到链表中的所有节点都被安排了</li>
</ul>
</li>
</ul>
<h4 id="把思路翻译成代码（🙏）"><a href="#把思路翻译成代码（🙏）" class="headerlink" title="把思路翻译成代码（🙏）"></a>把思路翻译成代码（🙏）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode[] splitListToParts(ListNode root, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="comment">// 定义一个指针 作用：作为游标，计算链表的节点长度</span></span><br><span class="line">        ListNode cursor = root;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义一个链表列表 作用：存储分割后的多个子链表；</span></span><br><span class="line">        ListNode[] res = <span class="keyword">new</span> ListNode[k]; <span class="comment">// 默认每个元素绑定的都是一个null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 鲁棒性代码</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算链表长度</span></span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cursor != <span class="keyword">null</span>)&#123;</span><br><span class="line">            length++;</span><br><span class="line">            cursor = cursor.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 比较链表长度length 与 预期分割得到的子链表数目k</span></span><br><span class="line">        <span class="keyword">if</span>(k &gt;= length)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;length; i++)&#123; <span class="comment">// 使用root链表中的节点对res数组的元素进行重新初始化</span></span><br><span class="line">                res[i] = <span class="keyword">new</span> ListNode(root.val);</span><br><span class="line">                root = root.next;</span><br><span class="line">            &#125; <span class="comment">// 只初始化了length个元素。剩下的元素仍旧是null</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 计算出第N个子链表应该包含多少个节点</span></span><br><span class="line">            <span class="keyword">int</span> remainder = length % k;</span><br><span class="line">            <span class="keyword">int</span> part = length / k;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">                counts[i] = remainder &gt; <span class="number">0</span> ? part + <span class="number">1</span> : part;</span><br><span class="line">                remainder--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从原始链表中截取出k个子链表，并添加到链表数组中</span></span><br><span class="line">            ListNode p = root;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;k; i++)&#123;</span><br><span class="line"></span><br><span class="line">                res[i] = p;</span><br><span class="line">                <span class="comment">// 当前子链接中应该包含多少个节点</span></span><br><span class="line">                <span class="keyword">int</span> count = counts[i];</span><br><span class="line">                <span class="keyword">while</span>(--count &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    p = p.next;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 记录下一个节点</span></span><br><span class="line">                ListNode temp = p.next;</span><br><span class="line">                <span class="comment">// 为当前节点绑定null</span></span><br><span class="line">                p.next = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 更新当前节点</span></span><br><span class="line">                p = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回得到的子链表列表</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="代码分解步骤"><a href="#代码分解步骤" class="headerlink" title="代码分解步骤"></a>代码分解步骤</h4><ul>
<li>定义需要的实例变量</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ListNode cursor = head; <span class="comment">// 用于在链表的节点上遍历</span></span><br><span class="line">ListNode[] res = <span class="keyword">new</span> ListNode[k]; <span class="comment">// 一个大小为k的ListNode类型的数组	用于存储分割后的子链表</span></span><br></pre></td></tr></table></figure>



<ul>
<li>求出链表的长度</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(cursor != <span class="keyword">null</span>)&#123;</span><br><span class="line">	length++;</span><br><span class="line">    cursor = cursor.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>比较链表长度length与预期分隔得到的子链表数目k</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(k &gt; length)&#123;</span><br><span class="line">	<span class="comment">// 子链表数目比链表本身的节点还要多		手段：不足的部分补上null</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 子链表数目小于等于链表本身的节点数目	手段：平均分配，盈余的话可能要多分一个</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当子链表数目k比起链表本身的节点length还要多时</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化res数组中前面length个元素</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;length; i++)&#123;</span><br><span class="line">    <span class="comment">// 创建一个新的链表，并绑定到子链表中	为什么要新建链表？</span></span><br><span class="line">    res[i] = <span class="keyword">new</span> ListNode(root.val);</span><br><span class="line">    root = root.next;</span><br><span class="line">&#125; <span class="comment">// 没有绑定子链表的节点，值默认是null 符合题目要求</span></span><br></pre></td></tr></table></figure>

<ul>
<li>当子链表数目小于等于链表本身的节点length时<ul>
<li>Ⅰ 计算出每个子链表应该包含的节点数量，并存储到一个数组中；</li>
<li>Ⅱ 遍历原始链表：<ul>
<li>从中取出正确数量的节点添加到子链表中；</li>
<li>当前子链接添加完成后，截断子链表。并把指针移动到下一个子链表的起始处</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Ⅰ计算出每个子链表应该包含的节点数量，并存储到一个数组中；</span></span><br><span class="line"><span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> perPart = length / k; <span class="comment">// 每个子链表的基础节点数目</span></span><br><span class="line"><span class="keyword">int</span> remainder = (length % k); <span class="comment">// 均分k份之后，余下的节点数量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;k; i++)&#123;</span><br><span class="line">    <span class="comment">// 使用三目运算符来替代一个if/else逻辑</span></span><br><span class="line">    counts[i] = (remainder &gt; <span class="number">0</span>) : perPart + <span class="number">1</span> : perPart;</span><br><span class="line">    remainder--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Ⅱ 遍历原始链表,把原始列表分割成k个子链表</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; k; i++)&#123;</span><br><span class="line">	<span class="comment">/* ① 从原始链表中取出正确数量的节点添加到子链表中 */</span></span><br><span class="line">    <span class="comment">// 创建一个新的指针		指向头节点</span></span><br><span class="line">    ListNode p = root; </span><br><span class="line">    <span class="comment">// 把当前子链表的头节点绑定到res[]的元素上</span></span><br><span class="line">    res[i] = p;</span><br><span class="line">    <span class="comment">// 获取到当前子链接中应该包含的节点数</span></span><br><span class="line">    <span class="keyword">int</span> count = counts[i];</span><br><span class="line">    <span class="comment">// 获取到指定数量的节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;count; j++)&#123; <span class="comment">// 应该向后遍历(count - 1)次</span></span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 当前子链接添加完成后，截断子链表。并把指针移动到下一个子链表的起始处 */</span></span><br><span class="line">    <span class="comment">// 记录下一个节点</span></span><br><span class="line">    ListNode temp = p.next; </span><br><span class="line">    <span class="comment">// 截断当前链表</span></span><br><span class="line">    p.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 更新当前节点</span></span><br><span class="line">    p = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>返回添加了子链表元素的res数组</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure>



<h4 id="启示"><a href="#启示" class="headerlink" title="启示"></a>启示</h4><p>对于循环次数已知的情况，推荐使用for循环。因为它的表达式非常容易写</p>
<p>while循环语法适用于那些循环次数不确定的场合</p>
<blockquote>
<p>until next time 😄</p>
</blockquote>
]]></content>
      <categories>
        <category>ListNode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>回文链表(迭代)_08_2</title>
    <url>/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E9%93%BE%E8%A1%A8%E6%98%AF%E4%B8%8D%E6%98%AF%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8%EF%BC%88%E8%BF%AD%E4%BB%A3%E6%96%B9%E5%BC%8F%EF%BC%89_08_2.html</url>
    <content><![CDATA[<h3 id="判断一个链表是不是回文链表（迭代方式）"><a href="#判断一个链表是不是回文链表（迭代方式）" class="headerlink" title="判断一个链表是不是回文链表（迭代方式）"></a>判断一个链表是不是回文链表（迭代方式）</h3><h4 id="题设与要求"><a href="#题设与要求" class="headerlink" title="题设与要求"></a>题设与要求</h4><p><img src="https://s1.ax1x.com/2020/08/15/diX5I1.png" alt="题设与要求"></p>
<a id="more"></a>

<h4 id="分析（问题的难点）"><a href="#分析（问题的难点）" class="headerlink" title="分析（问题的难点）"></a>分析（问题的难点）</h4><ul>
<li><p>这里不再考虑使用递归的方式，因为上一篇中已经实现了递归的代码；</p>
</li>
<li><p>为了判断链表是不是回文链表，肯定要对其左半边与右半边的节点进行比较；</p>
<p><strong>难点1</strong>：如何确定链表的左半边与右半边？aka 链表的中间节点位置</p>
</li>
<li><p>假设现在已经找到了中间节点的位置，接下来要怎么逐个比较各个节点呢？</p>
<p>方式1 从两边到中间，逐个比较节点的值；</p>
<p>方式2 从中间到两边，逐个比较节点的值；</p>
<p>说明：不管哪一种方式，都会面临一个问题——指针无法逆着链表节点移动；</p>
<p><strong>难点2</strong>：如何能让指针逆着链表的方向移动？</p>
</li>
<li><p>如果上面两个难点都得到解决，接下来就只需要逐个比较节点的值，分分钟无障碍</p>
</li>
</ul>
<h4 id="思路（难点的解决手段）"><a href="#思路（难点的解决手段）" class="headerlink" title="思路（难点的解决手段）"></a>思路（难点的解决手段）</h4><ul>
<li><p>难点1 如何确定链表的中间节点位置？</p>
<p>手段：快慢指针。</p>
<p>具体方法：从head节点开始（具体需要画图确认最佳方案），快指针一次走两个节点，慢指针一次走一个节点。</p>
<p>原理：当快指针指向链表尾节点时，慢指针应该刚好指向链表的中间节点。（或者前面一个节点）</p>
</li>
<li><p>难点2 如何能让指针逆着链表方向移动？</p>
<p>说明：实现这个目标其实有多个手段，比如借助额外空间整一个新链表。但是题目要求O(1)的空间复杂度，so pass this</p>
<p>手段：对链表的左半部分/右半部分进行翻转；</p>
<p>具体方法：翻转链表所需要的3个指针——prev、curr、temp；</p>
<p>原理：如果翻转左半部分，从中间节点到两边的节点进行比较；如果翻转右半部分，则是从两边的节点向中间节点进行比较；</p>
<p>这里我们选择翻转左半部分</p>
</li>
</ul>
<h4 id="把思路翻译成代码"><a href="#把思路翻译成代码" class="headerlink" title="把思路翻译成代码"></a>把思路翻译成代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1 作用：判断一个链表是不是回文链表，并返回布尔值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 迭代方式</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 防止NPE的指针</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用于翻转链表的指针</span></span><br><span class="line">        ListNode prev = dummy;</span><br><span class="line">        ListNode curr = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用于定位到中点的指针</span></span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一边定位，一边创建新的链表   翻转三部曲：1 记录当前节点的下一个节点； 2 改变当前节点的连接   3 更新指针prev与curr</span></span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123; <span class="comment">// slow与curr的位置关系还需要考察</span></span><br><span class="line">            <span class="comment">// 注： 当前节点的下一个节点总是slow,所以第1步省略</span></span><br><span class="line">            curr = slow; <span class="comment">// 3-2 更新指针curr</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新快慢指针</span></span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 翻转链表</span></span><br><span class="line">            curr.next = prev; <span class="comment">// 2 改变连接</span></span><br><span class="line">            prev = curr; <span class="comment">// 3-1 更新指针prev</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据fast的特征判断slow的位置</span></span><br><span class="line">        <span class="keyword">if</span>(fast != <span class="keyword">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过逐个比较两个链表的节点来判断是否为回文链表</span></span><br><span class="line">        <span class="keyword">while</span>(slow != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(curr.val != slow.val)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            curr = curr.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="代码步骤分解"><a href="#代码步骤分解" class="headerlink" title="代码步骤分解"></a>代码步骤分解</h4><ul>
<li>定义需要的实例变量（包括指针变量）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方便定位链表头节点的指针</span></span><br><span class="line">      ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">      dummy.next = head;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 用于翻转链表的指针</span></span><br><span class="line">      ListNode prev = dummy;</span><br><span class="line">      ListNode curr = head;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 用于定位到中点的指针</span></span><br><span class="line">      ListNode slow = head;</span><br><span class="line">      ListNode fast = head;</span><br></pre></td></tr></table></figure>

<ul>
<li>循环中需要做的事情：Ⅰ 定位链表的中间节点；    </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123; <span class="comment">// 2 直到快指针指向链表的尾节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 手段SOP：1 不断更新快慢指针</span></span><br><span class="line">    slow = slow.next;</span><br><span class="line">    fast = fast.next.next;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Ⅱ 对左半部分链表进行翻转；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">    翻转三步曲	</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    // 1 记录当前节点的下一个节点；</span></span><br><span class="line"><span class="comment">    ListNode temp = curr.next;</span></span><br><span class="line"><span class="comment">    // 2 改变当前节点的连接</span></span><br><span class="line"><span class="comment">    curr.next = prev;</span></span><br><span class="line"><span class="comment">    // 3 更新指针prev与curr	把prev更新到curr，把curr更新到temp</span></span><br><span class="line"><span class="comment">    prev = curr;</span></span><br><span class="line"><span class="comment">    curr = temp;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 问题来了：1 当前节点的下一个节点是什么呢？</span></span><br><span class="line">    <span class="comment">// 问题2：左半边的链表应该结束于哪一个节点呢？</span></span><br><span class="line">    <span class="comment">// 解决手段：为了准确定位左半部分链表的边界，把“当前节点的下一个节点”设置为slow指向的节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 知道了“当前节点的下一个节点为slow”后，套用上面的翻转三步曲 */</span></span><br><span class="line">    <span class="comment">// 1 记录当前节点的下一个节点 	手段：直接获取slow就可以了</span></span><br><span class="line">    <span class="comment">// 2 更新当前节点的连接为前一个节点</span></span><br><span class="line">    curr.next = prev; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3 更新指针</span></span><br><span class="line">    prev = curr; </span><br><span class="line">    curr = slow; <span class="comment">// 更新当前指针</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s1.ax1x.com/2020/08/15/dFei4K.md.jpg" alt="翻转图示"></p>
<ul>
<li>确保curr总是落后于slow一个节点</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 手段：把更新curr的语句放在更新快慢指针的语句之前</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    curr = slow; <span class="comment">// 更新当前节点为temp</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更新快慢指针</span></span><br><span class="line">    slow = slow.next;</span><br><span class="line">    fast = fast.next.next;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 翻转链表中的节点</span></span><br><span class="line">    curr.next = prev;</span><br><span class="line">    prev = curr;</span><br><span class="line">    <span class="comment">// 更新curr指针的代码在第一行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>确定循环执行表达式</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参考图示可知，fast应该停留在尾节点 或者 null节点上</span></span><br><span class="line"><span class="comment">// 原则：刚好形成可以一一对比其节点的左半部分链表（已翻转）</span></span><br><span class="line"><span class="keyword">while</span>(fast != <span class="keyword">null</span> || fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>根据情况来移动slow指针——因为这时候左右链表的节点数可能不一样</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参考图示可知：当链表节点数为奇数个时，slow指在最中间节点的位置。这时候右半部分链表的节点多了一个</span></span><br><span class="line"><span class="keyword">if</span>(fast != <span class="keyword">null</span>)&#123; <span class="comment">// fast!=null是这种情况下的特征</span></span><br><span class="line">    slow = slow.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>逐个比较左右两个链表的节点，来判断总链表是不是回文链表</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(curr.val != slow.val)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    curr = curr.next;</span><br><span class="line">    slow = slow.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>确定循环执行表达式</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 由于左右两个链表的节点长度是一样的，所以只要任一一个链表到头，循环就结束</span></span><br><span class="line"><span class="keyword">while</span>(slow != <span class="keyword">null</span>)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>鲁棒性代码</li>
<li>测试用例</li>
</ul>
<h4 id="代码重现（拆解之后的组合）"><a href="#代码重现（拆解之后的组合）" class="headerlink" title="代码重现（拆解之后的组合）"></a>代码重现（拆解之后的组合）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 定义需要的指针</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 翻转所需要用到的指针</span></span><br><span class="line">        ListNode prev = dummy;</span><br><span class="line">        ListNode curr = head;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 寻找中间节点所需要用到的指针</span></span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123; <span class="comment">// 只要有一个为false，循环就会结束</span></span><br><span class="line">            <span class="comment">// 翻转节点 - 2 </span></span><br><span class="line">            curr = slow;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 更新快慢指针</span></span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 翻转节点 - 1</span></span><br><span class="line">            curr.next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果需要，更新slow指针的位置</span></span><br><span class="line">        <span class="keyword">if</span>(fast != <span class="keyword">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历左右链表的每个节点，逐一比较</span></span><br><span class="line">        <span class="keyword">while</span>(slow != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(curr.val != slow.val)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            curr = curr.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>this is loads of code. until next time 😓</p>
</blockquote>
]]></content>
      <categories>
        <category>ListNode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>回文链表_08</title>
    <url>/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E4%B8%BA%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8(%E9%80%92%E5%BD%92%E6%96%B9%E5%BC%8F)_08.html</url>
    <content><![CDATA[<h3 id="判断一个链表是否为回文链表"><a href="#判断一个链表是否为回文链表" class="headerlink" title="判断一个链表是否为回文链表"></a>判断一个链表是否为回文链表</h3><h4 id="题设与要求"><a href="#题设与要求" class="headerlink" title="题设与要求"></a>题设与要求</h4><p><img src="https://s1.ax1x.com/2020/08/15/diX5I1.png" alt="题设与要求"></p>
<a id="more"></a>

<h4 id="分析（问题的难点）"><a href="#分析（问题的难点）" class="headerlink" title="分析（问题的难点）"></a>分析（问题的难点）</h4><p>1 回文链表的定义:左半边与右半边完全对称——这样从左边读起与从右边读起来，读到的内容是相同的。</p>
<p>2 如果使用迭代的方式，比较直观的想法是：头尾节点各一个指针，然后指针向里走。指针每走一次，就要比较一次节点的值。</p>
<ul>
<li>难点：但是由于是单向链表，尾节点的指针没有办法直接向前走。所以在此之前需要把右半边的链表翻转，然后再进行迭代与比较操作。可以预见，需要确定诸多的细节：右半边链表的终点、循环终止条件等</li>
</ul>
<p>3 能不能使用递归的方式呢？</p>
<ul>
<li>把问题转换为更小规模的问题：head头节点 + 中间节点组成的链表 + tail尾节点；<ul>
<li>中间节点组成的链表是不是回文链表，这就是一个更小规模的问题；</li>
</ul>
</li>
<li>更小规模问题的处理结果，能用来解决问题本身吗？<ul>
<li>如果中间节点组成的链表middle是一个回文链表，就只需要判断head.val == tail.val。如果相等，则整个链表就是一个回文链表</li>
</ul>
</li>
</ul>
<h4 id="思路（优先使用递归）"><a href="#思路（优先使用递归）" class="headerlink" title="思路（优先使用递归）"></a>思路（优先使用递归）</h4><p>1 把方法定义为一个递归方法，确定方法的作用与返回值；</p>
<ul>
<li>方法作用：判断一个链表是否为回文链表；    返回值：true/false；</li>
</ul>
<p>2 确定递归的终止条件；</p>
<ul>
<li>链表为null/链表中只有一个节点；    这时候可以认为链表是一个回文链表</li>
</ul>
<p>3 确定本级递归要完成的事情；</p>
<ul>
<li>编码时再具体说明</li>
</ul>
<h4 id="把思路翻译成代码"><a href="#把思路翻译成代码" class="headerlink" title="把思路翻译成代码"></a>把思路翻译成代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ListNode类型的定义省略</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1 方法作用：判断一个链表是否为回文链表；	返回值：true/false；</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 2 递归终结条件</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3 本级递归要做的事情</span></span><br><span class="line">        <span class="comment">// ① 把链表视为：链表头节点head + 中间节点组成的链表middle + 尾节点tail</span></span><br><span class="line">        <span class="comment">// ② 获取到head与tail，判断头节点与尾节点的值是否相等。如果不相等，返回false</span></span><br><span class="line">        <span class="comment">// ③ 如果相等，并且middle也是一个回文链表。则返回true，否则返回false</span></span><br><span class="line">        ListNode cursor = head;</span><br><span class="line">        <span class="keyword">while</span>(cursor.next != <span class="keyword">null</span>)&#123; <span class="comment">// 循环终止时，希望cursor指向尾节点，而不是null</span></span><br><span class="line">            cursor = cursor.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断头节点与尾节点的值是否相等</span></span><br><span class="line">        <span class="keyword">if</span>(head.val != cursor.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 获取到中间节点组成的链表middle</span></span><br><span class="line">            cursor = head.next;</span><br><span class="line">            ListNode middle = cursor;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 删除尾节点：这样其实破坏了原始的链表结构，需要和面试官确认</span></span><br><span class="line">            <span class="keyword">while</span>(cursor != <span class="keyword">null</span> &amp;&amp; cursor.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(cursor.next.next = <span class="keyword">null</span>)&#123;</span><br><span class="line">                    cursor.next = <span class="keyword">null</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cursor = cursor.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 判断middle是不是一个回文链表</span></span><br><span class="line">            <span class="keyword">return</span> isPalindrome(middle);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：这里获取到middle的过程还是差了点意思。</p>
<h4 id="添加鲁棒性的代码"><a href="#添加鲁棒性的代码" class="headerlink" title="添加鲁棒性的代码"></a>添加鲁棒性的代码</h4><h4 id="使用不同的测试用例测试"><a href="#使用不同的测试用例测试" class="headerlink" title="使用不同的测试用例测试"></a>使用不同的测试用例测试</h4><ul>
<li>功能性测试（各种极端情况下的有效输入）</li>
<li>非法输入测试（对各种非法输入是否进行了合适的处理）</li>
</ul>
<blockquote>
<p>until next time😄</p>
</blockquote>
]]></content>
      <categories>
        <category>ListNode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>链表数相加_07</title>
    <url>/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E9%93%BE%E8%A1%A8%E8%A1%A8%E7%A4%BA%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%9B%B8%E5%8A%A0(%E8%BF%AD%E4%BB%A3%E6%96%B9%E5%BC%8F)_07.html</url>
    <content><![CDATA[<h3 id="链表表示的两个数相加"><a href="#链表表示的两个数相加" class="headerlink" title="链表表示的两个数相加"></a>链表表示的两个数相加</h3><h4 id="题设与要求"><a href="#题设与要求" class="headerlink" title="题设与要求"></a>题设与要求</h4><p><img src="https://s1.ax1x.com/2020/08/14/diKVtx.md.png" alt="题目条件与要求"></p>
<a id="more"></a>

<h4 id="分析（面临的核心问题）"><a href="#分析（面临的核心问题）" class="headerlink" title="分析（面临的核心问题）"></a>分析（面临的核心问题）</h4><p>两个数的加法算法，主要的特征：</p>
<ul>
<li>从低位到高位计算（个十百千…）;</li>
<li>计算除了个位以外的位数上的数字时，都需要加上来自后一位的进位（如果没有进位数，默认为0）</li>
<li>位数上的数字 = （第一个数 + 第二个数 + 进位数）% 10；</li>
<li>当前位向高位数提供的进位数 = (第一个数 + 第二个数 + 进位数) / 10；</li>
<li>如果最高位计算时，有进位数。则直接把这个进位数作为加和结果的最高位；</li>
</ul>
<p>问题1：我们需要从低位向高位计算，对于链表来说，就是从链表尾节点到头节点计算。BUT，访问链表中的节点只能从头节点到尾节点。</p>
<p>怎么办？</p>
<p>解决手段：使用栈来存储链表各个节点中的值；</p>
<p>原理：链表这种数据容器的存储特征是“先进后出”——这样在从栈中取出数值时，获取到的其实就是链表尾部节点中的数值；</p>
<p>问题2：两个链表的长度可能不一样，如果在同一个循环中通过pop()来取值的话，肯定会有一个栈调用pop()时会抛出”栈为空”的异常；</p>
<p>解决手段：在调用isEmpty()结果为true时（表示栈已经空了），手动为操作数绑定0；</p>
<p>问题3：如果使用循环，在短链表中的节点用完后，如何保证循环继续进行（继续计算加和）？</p>
<p>手段：循环条件 = （链表A节点 != null || 链表B节点 != null);</p>
<p>问题4：即便使用长链表的节点数来控制循环次数（循环中执行操作数的计算），但是最高位在得到进位后，可能会再产生一个进位。这个进位要怎么处理？</p>
<p>手段：把进位carry !=0 添加到循环执行表达式中。这样上述情况下，循环会再执行一次(0 + 0 + 进位1) 的计算。计算后carry==0，循环退出，进位数也被作为最高位添加到链表中</p>
<h4 id="思路SOP"><a href="#思路SOP" class="headerlink" title="思路SOP"></a>思路SOP</h4><p>1 使用两个栈分别存储两个链表中的所有节点；</p>
<p>2 定义一个循环：</p>
<ul>
<li>从栈中弹出值进行计算。得到数位上的数与进位数；</li>
<li>把位数上的数封装到一个节点，并添加到链表中(使用头插法，即最新的节点总是头节点)； head - xxx - null</li>
</ul>
<p>3 循环结束后，循环中创建的链表就是加和结果；</p>
<h4 id="根据思路SOP来进行编码"><a href="#根据思路SOP来进行编码" class="headerlink" title="根据思路SOP来进行编码"></a>根据思路SOP来进行编码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ListNode类型的定义省略</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 鲁棒性代码</span></span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(l2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 定义两个栈</span></span><br><span class="line">        Stack&lt;Integer&gt; stack_l1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Stack&lt;Integer&gt; stack_l2 = <span class="keyword">new</span> Stack&lt;&gt;(); <span class="comment">// 作用：用于分别存储各个链表中的节点</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用栈来存储对应链表中的节点</span></span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack_l1.push(l1.val);</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack_l2.push(l2.val);</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 定义一个循环 循环中：1 得到位数上的数字； 2 使用1中的数字创建节点，并添加到新链表中</span></span><br><span class="line">        ListNode first = <span class="keyword">null</span>; </span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!stack_l1.isEmpty() || !stack_l2.isEmpty() || carry != <span class="number">0</span>)&#123; <span class="comment">// 循环执行条件:</span></span><br><span class="line">            <span class="comment">// 1 获取到操作数</span></span><br><span class="line">            <span class="keyword">int</span> num1 = stack_l1.isEmpty() ? <span class="number">0</span> : stack_l1.pop();</span><br><span class="line">            <span class="keyword">int</span> num2 = stack_l2.isEmpty() ? <span class="number">0</span> : stack_l2.pop();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 2 进行计算，得到数位上的数值remainder 与 进位数字carry</span></span><br><span class="line">            <span class="keyword">int</span> remainder = (num1 + num2 + carry) % <span class="number">10</span>;</span><br><span class="line">            carry = (num1 + num2 + carry) / <span class="number">10</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 3 使用数位上的数值来创建一个新的节点，并添加到first链表中</span></span><br><span class="line">            ListNode curr = <span class="keyword">new</span> ListNode(remainder);</span><br><span class="line">            curr.next = first;</span><br><span class="line">            first = curr;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回创建的新链表的头节点first</span></span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="编码步骤分解"><a href="#编码步骤分解" class="headerlink" title="编码步骤分解"></a>编码步骤分解</h4><ul>
<li>定义两个栈，并把链表中节点的值添加到对应的栈中</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stack&lt;Integer&gt; stack_l1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">Stack&lt;Integer&gt; stack_l2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把链表节点中的值添加到栈中</span></span><br><span class="line"><span class="keyword">while</span>(l1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">    stack_l1.push(l1.val);</span><br><span class="line">    l1 = l1.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">    stack_l2.push(l2.val);</span><br><span class="line">    l2 = l2.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>定义一个循环 循环中：1 得到位数上的数字；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> carry = <span class="number">0</span>; <span class="comment">// 初始化进位数为0	作用：用于个位数的计算</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    <span class="comment">// 1 从栈中获取到当前的操作数</span></span><br><span class="line">    <span class="keyword">int</span> num1 = stack_l1.isEmpty() ? <span class="number">0</span> : stack_l1.pop();</span><br><span class="line">    <span class="keyword">int</span> num2 = stack_l2.isEmpty() ? <span class="number">0</span> : stack_l2.pop();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2 计算操作数，得到位数上的数字</span></span><br><span class="line">    <span class="keyword">int</span> remainder = (num1 + num2 + carry) % <span class="number">10</span>;</span><br><span class="line">    carry = (num1 + num2 + carry) / <span class="number">10</span>; <span class="comment">// 这里需要计算出新的进位数，这样下次遍历时计算结果才能正确</span></span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>2 使用1中的数字创建节点，并添加到新链表中</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">ListNode first = <span class="keyword">null</span>; <span class="comment">// 一个头节点	作用：作为计算结果的链表容器；	特征：头插法</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 头插法</span></span><br><span class="line">    <span class="comment">// 1 创建新节点</span></span><br><span class="line">    ListNode curr = <span class="keyword">new</span> ListNode(remainder);</span><br><span class="line">    <span class="comment">// 2 连接到first指针所指向的节点</span></span><br><span class="line">    curr.next = first;</span><br><span class="line">    <span class="comment">// 3 更新first指针</span></span><br><span class="line">    first = curr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>确定循环执行的表达式</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 由于栈中的每个数字都需要参与计算，所以最终两个栈要都为空</span></span><br><span class="line"><span class="comment">// 对应于表达式: !satck_l1.isEmpty() || !stack_l2.isEmpty()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最高位计算后，可能会有一个进位————这就要求循环体再执行一次，以便把新的进位添加到链表中。</span></span><br><span class="line"><span class="comment">// 进位添加到链表中后，需要对进位进行更新，以便终止循环</span></span><br><span class="line"><span class="comment">// 更新手段：现有代码 carry = (num1 + num2 + carry) / 10; // 这里需要计算出新的进位数，这样下次遍历时计算结果才能正确</span></span><br><span class="line"><span class="comment">// 此时，由于栈都已经空了。所以num1 = 0、num2 = 0、carry = 1（最高位的进位只会为1）</span></span><br><span class="line"><span class="comment">// 更新后carry的值 = 1 / 10; carry = 0</span></span><br><span class="line"><span class="comment">// 从而应该添加新的条件：carry != 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 综上有：循环执行表达式(!stack_l1.isEmpty() || !stack_l2.isEmpty() || carry != 0)</span></span><br><span class="line"><span class="keyword">while</span>(!stack_l1.isEmpty() || !stack_l2.isEmpty() || carry != <span class="number">0</span>)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>返回循环中创建的链表的头节点</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> first;</span><br></pre></td></tr></table></figure>

<ul>
<li>添加鲁棒性代码（或者叫防御性编程代码）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 鲁棒性代码</span></span><br><span class="line"><span class="keyword">if</span>(l1 == <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> l2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(l2 == <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> l1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用设计的测试用例进行功能测试 &amp; 非法输出测试</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 作用：</span></span><br><span class="line"><span class="comment">// 1 保证代码涵对所有可能的合法输入都有效；</span></span><br><span class="line"><span class="comment">// 2 保证对那些个非法输入，代码都做了合适的处理————不会导致程序崩溃；</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p> this is whole loads of thing. until next time 😄</p>
</blockquote>
]]></content>
      <categories>
        <category>ListNode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>交换链表节点_06_2</title>
    <url>/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9%EF%BC%88%E9%80%92%E5%BD%92%E6%96%B9%E5%BC%8F%EF%BC%89_06_2.html</url>
    <content><![CDATA[<h4 id="两两交换链表中的节点（递归方式）"><a href="#两两交换链表中的节点（递归方式）" class="headerlink" title="两两交换链表中的节点（递归方式）"></a>两两交换链表中的节点（递归方式）</h4><hr>
<h4 id="题设与要求"><a href="#题设与要求" class="headerlink" title="题设与要求"></a>题设与要求</h4><p><img src="https://s1.ax1x.com/2020/08/14/dPzGHH.md.png" alt="题设与要求"></p>
<a id="more"></a>

<h4 id="分析（递归的可行性）"><a href="#分析（递归的可行性）" class="headerlink" title="分析（递归的可行性）"></a>分析（递归的可行性）</h4><ul>
<li>问题能够拆解成更小的同类问题吗？<ul>
<li>答：对链表来说，总是可以把链表拆分成: 头节点head + 剩余节点组成的rest链表（这个链表还可以根据情况再去拆分）</li>
</ul>
</li>
<li>更小同类问题的返回值能够用来帮助解决大问题本身吗？<ul>
<li>答：对rest执行swapParis操作后，返回的是一个节点已经两两交换后的新链表。它可以和剩余的节点连接起来，从而得到一个所有节点都已经两两交换的新链表——大问题；</li>
</ul>
</li>
</ul>
<p>结论：这个问题可以使用递归进行解决；</p>
<h4 id="使用递归实现的SOP"><a href="#使用递归实现的SOP" class="headerlink" title="使用递归实现的SOP"></a>使用递归实现的SOP</h4><ul>
<li>1 明确方法的作用与返回值；</li>
<li>2 明确递归的终结条件（根据方法的作用推理）；</li>
<li>3 描述本次递归需要完成的工作</li>
</ul>
<h4 id="按照SOP进行编码"><a href="#按照SOP进行编码" class="headerlink" title="按照SOP进行编码"></a>按照SOP进行编码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1 方法作用：把链表中的节点两两进行交换，并返回节点交换后的新链表	参考：示例</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">swapParis</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 2 递归的终结条件 链表为null、链表中就只有一个节点</span></span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3 本级递归需要完成的事情</span></span><br><span class="line">    <span class="comment">// ① 把链表拆分为：头节点head + 第二个节点second + 剩余节点组成的链表rest</span></span><br><span class="line">    <span class="comment">// 原因：交换节点需要至少两个节点参与，而且我们不能改变swapPair(rest)的返回值</span></span><br><span class="line">    <span class="comment">// ② 对rest执行swapParis()的操作，并获取到返回值swapedRest</span></span><br><span class="line">    <span class="comment">// ③ 对head、second以及swapedRest进行必要的操作，以得到所有节点都已经两两交换的链表</span></span><br><span class="line">    ListNode second = head.next;</span><br><span class="line">    ListNode swapedRest = swapPairs(second.next);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 交换head与second节点</span></span><br><span class="line">    head.next = swapedRest;</span><br><span class="line">    second.next = head;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>启示</p>
</blockquote>
<p>递归大法好，不像递归那样。循环终止条件就能让人💫</p>
<blockquote>
<p>until next time😄</p>
</blockquote>
]]></content>
      <categories>
        <category>ListNode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>倒数第k个节点_05_2</title>
    <url>/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E8%8A%82%E7%82%B9%EF%BC%88%E4%B8%80%E6%AC%A1%E9%81%8D%E5%8E%86%EF%BC%89_05_2.html</url>
    <content><![CDATA[<h3 id="删除链表中的倒数第n个节点（一次遍历）"><a href="#删除链表中的倒数第n个节点（一次遍历）" class="headerlink" title="删除链表中的倒数第n个节点（一次遍历）"></a>删除链表中的倒数第n个节点（一次遍历）</h3><h4 id="题设-amp-要求"><a href="#题设-amp-要求" class="headerlink" title="题设 &amp; 要求"></a>题设 &amp; 要求</h4><p><img src="https://s1.ax1x.com/2020/08/14/dCLxyj.png" alt="题设 &amp; 要求"></p>
<a id="more"></a>

<h4 id="分析（难点）"><a href="#分析（难点）" class="headerlink" title="分析（难点）"></a>分析（难点）</h4><p>如何能找到倒数第N个节点（预期节点：此节点的上一个节点）？</p>
<h4 id="思路2（难点的解决方案）"><a href="#思路2（难点的解决方案）" class="headerlink" title="思路2（难点的解决方案）"></a>思路2（难点的解决方案）</h4><ul>
<li>定义两个指针front与back，设置两个指针之间的初始间距。</li>
<li>然后把两个指针同时向后移动，直到front指针到达了链表的尾节点。</li>
<li>这时候back指针就会指在某一个可以计算的位置——通过设置指针间的初始间距，就能确定back指针停下的具体位置。</li>
</ul>
<h4 id="实现SOP"><a href="#实现SOP" class="headerlink" title="实现SOP"></a>实现SOP</h4><ul>
<li>1 定义所需要的指针front与back与dummy（并初始化）；    注：画图分析指针初始化的位置；    原则：方便编码；&amp; 避免NPE；</li>
<li>2 画图分析，front指针与back指针之间的初始间距span与n的关系（span = n）；</li>
<li>3 把front与back指针初始化指向dummy节点(这里引入dummy节点只是为了方便计算指针应该移动的距离)；</li>
<li>4 把front指针向前移动n个节点；</li>
<li>5 把front与back指针同时向后移动，直到front指针指向链表的尾节点；</li>
<li>6 back指向预期节点后，对待删除节点进行删除；</li>
</ul>
<h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 实践证明：在删除的时候使用栈不是一个好主意</span></span><br><span class="line">        <span class="comment">// 鲁棒性代码</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 需要的实例变量</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line"></span><br><span class="line">        ListNode front = dummy;</span><br><span class="line">        ListNode back = dummy;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 先让front向前走n个节点   如果只有一个节点，然后要删除倒数第一个节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123; <span class="comment">// 注：front的初始化值会决定循环执行的次数</span></span><br><span class="line">            front = front.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 再让front与back一起先前移动，直到front到达尾节点</span></span><br><span class="line">        <span class="keyword">while</span>(front != <span class="keyword">null</span> &amp;&amp; front.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            front = front.next;</span><br><span class="line">            back = back.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 这里得到的back就是预期删除的节点的前一个节点</span></span><br><span class="line">        <span class="comment">// 执行删除</span></span><br><span class="line">        back.next = back.next.next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="启示"><a href="#启示" class="headerlink" title="启示"></a>启示</h4><p>1 代码的鲁棒性编码在实现了基本功能后，再进行添加；</p>
<p>2 对于循环执行次数已知的情况，使用for语法来实现循环——这样能避免令人纠结的循环执行/终止条件；</p>
<p>3 编写while循环执行表达式的参考：节点的最终状态； &amp;  避免代码中的NPE；</p>
]]></content>
      <categories>
        <category>ListNode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>交换链表节点(迭代)_06</title>
    <url>/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9(%E8%BF%AD%E4%BB%A3%E6%96%B9%E5%BC%8F)_06.html</url>
    <content><![CDATA[<h3 id="两两交换链表中的节点"><a href="#两两交换链表中的节点" class="headerlink" title="两两交换链表中的节点"></a>两两交换链表中的节点</h3><hr>
<h4 id="题设与要求"><a href="#题设与要求" class="headerlink" title="题设与要求"></a>题设与要求</h4><p><img src="https://s1.ax1x.com/2020/08/14/dP37xf.png" alt="题设与要求"></p>
<a id="more"></a>

<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>要求进行节点之间的两两交换。</p>
<p>如果使用迭代的方式，可以每次处理两个相邻节点之间的连接关系；</p>
<p>然后在下次迭代时，再去处理下一批的两个节点之间的连接关系；</p>
<p>还要处理每个区间（2个节点）之间的连接关系，来保证连接的正确性；</p>
<p>说明：</p>
<p>1 当通过这种分析无法得到有效的突破点时，就只好画图来找找规律了，对自己的想象力不要太自信；</p>
<p>2 翻转操作需要3个指针：两个指针用于指向需要交换的节点，一个指针用于迭代链表；</p>
<blockquote>
<p>画图大法(画图找规律)</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/08/14/dPU7kD.md.jpg" alt="节点的交换过程"></p>
<ul>
<li>通过画图可以看出,可以通过连续翻转节点来实现题设中的“两两节点交换”；</li>
<li>节点翻转需要3个指针：curr指向当前节点、temp指向当前节点的下一个节点；prev指向当前节点的前驱节点（用于更新这三个连续的指针）</li>
<li>可以根据预期的指针情况（图3）与当前的指针情况（图2）来推理出指针更新的手段；prev = curr;</li>
</ul>
<h4 id="代码实现的SOP："><a href="#代码实现的SOP：" class="headerlink" title="代码实现的SOP："></a>代码实现的SOP：</h4><p>1 定义所需要的指针，并初始化指针的原始位置；</p>
<p>2 定义一个循环，在循环中完成以下工作：</p>
<ul>
<li>对指针指向的当前节点区间进行翻转；</li>
<li>更新指针，以便进行下一次的翻转操作；</li>
</ul>
<h4 id="代码实现（虽然SOP不复杂，但是代码实现还是挺讲究的）"><a href="#代码实现（虽然SOP不复杂，但是代码实现还是挺讲究的）" class="headerlink" title="代码实现（虽然SOP不复杂，但是代码实现还是挺讲究的）"></a>代码实现（虽然SOP不复杂，但是代码实现还是挺讲究的）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1 定义需要的指针</span></span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>); <span class="comment">// 作用：指向链表的头节点</span></span><br><span class="line">    dummy.next = head;</span><br><span class="line">    </span><br><span class="line">    ListNode prev = dummy; <span class="comment">// </span></span><br><span class="line">    ListNode curr = head;</span><br><span class="line">    <span class="comment">// ListNode temp = curr.next; // 有点不对劲，因为temp都是在遍历过程中临时更新的		参考：翻转链表的操作</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2 定义一个循环，在循环中： 1 完成当前区间内节点的翻转； 2 更新到下一个翻转区间</span></span><br><span class="line">    <span class="keyword">while</span>(curr != <span class="keyword">null</span> &amp;&amp; curr.next != <span class="keyword">null</span>)&#123; <span class="comment">// 循环终止条件：curr == null(对应于奇数个节点) OR curr.next == null (对应于偶数个节点)</span></span><br><span class="line">        <span class="comment">// 1 获取到当前节点的下一个节点 [curr-temp]</span></span><br><span class="line">        ListNode temp = curr.next;</span><br><span class="line">        </span><br><span class="line">         <span class="comment">// 2 完成当前区间内节点的翻转(需要借助temp节点才能实现)</span></span><br><span class="line">        prev.next = temp;</span><br><span class="line">        curr.next = temp.next;</span><br><span class="line">        temp.next = curr;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3 更新到下一个翻转区间[prev-curr]</span></span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = prev.next;</span><br><span class="line">        <span class="comment">// temp = curr.next;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3 返回链表的头节点</span></span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="代码实现过程SOP分解"><a href="#代码实现过程SOP分解" class="headerlink" title="代码实现过程SOP分解"></a>代码实现过程SOP分解</h4><ul>
<li>定义所需要的指针</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">dummy.next = head;	<span class="comment">// 作用：指向链表的头节点</span></span><br><span class="line"></span><br><span class="line">ListNode prev = dummy; <span class="comment">// 作用：翻转区间内的第一个节点</span></span><br><span class="line">ListNode curr = prev.next; <span class="comment">// 作用：翻转区间内的第二个节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 所需要的辅助节点temp（当前节点的下一个节点），在循环中再临时获取</span></span><br></pre></td></tr></table></figure>

<ul>
<li>定义一个循环，在循环中完成<ul>
<li>当前节点区间的节点翻转；</li>
<li>更新当前节点区间；</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    <span class="comment">// 对当前节点区间中的节点进行翻转</span></span><br><span class="line">    <span class="comment">// ① 获取到当前节点的下一个节点	作用：防止链表断裂</span></span><br><span class="line">    ListNode temp = curr.next;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ② 按照下图流程来实现节点的翻转		参考：👇图</span></span><br><span class="line">    prev.next = temp; </span><br><span class="line">    curr.next = temp.next;</span><br><span class="line">    temp.next = curr;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更新当前的区间节点</span></span><br><span class="line">    prev = curr; <span class="comment">// 更新后的翻转区间第一个节点 参考：“分析”部分</span></span><br><span class="line">    curr = prev.next; <span class="comment">// 更新后的翻转区间第二个节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s1.ax1x.com/2020/08/14/dPLV7q.md.jpg" alt="节点翻转流程"></p>
<ul>
<li><p>确定循环执行的条件</p>
<ul>
<li>循环终止条件（直接根据代码不能NPE来反推）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ListNode temp = curr.next;	<span class="comment">// 因此curr != null</span></span><br><span class="line">...</span><br><span class="line">curr.next = temp.next; <span class="comment">// 因此temp != null aka curr.next != null</span></span><br></pre></td></tr></table></figure>

<p>r u kidding me?</p>
<ul>
<li>循环终止条件（极端情况）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 极端情况：prev为倒数第二个节点、curr为尾节点 此时需要翻转prev与curr之间的指向</span></span><br><span class="line"><span class="comment">// 特征:curr.next == null aka 循环执行条件 curr.next != null</span></span><br><span class="line"><span class="comment">// 为了避免循环中的更新操作导致curr为null SO</span></span><br><span class="line"><span class="keyword">while</span>(curr != <span class="keyword">null</span> &amp;&amp; curr.next != <span class="keyword">null</span>)</span><br></pre></td></tr></table></figure>

<p>不很满意这种说法😳</p>
</li>
<li><p>返回新链表的头节点</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 由于每个节点都只有一个next指针，所以dummy其实连接到了新的链表头部</span></span><br><span class="line"><span class="keyword">return</span> dummy.next;</span><br></pre></td></tr></table></figure>

<ul>
<li>添加鲁棒性代码</li>
<li>编写各种测试用例，测试代码：1 功能是否可用； 2 对于各种非法输出是否有合理的输出/提示信息；</li>
</ul>
<h4 id="代码默写-重现"><a href="#代码默写-重现" class="headerlink" title="代码默写/重现"></a>代码默写/重现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1 定义需要用到的指针</span></span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    dummy.next = head; <span class="comment">// 指向链表的头节点</span></span><br><span class="line">    </span><br><span class="line">    ListNode prev = dummy; <span class="comment">// 翻转区间的第一个节点</span></span><br><span class="line">    ListNode curr = prev.next; <span class="comment">// 翻转区间的第二个节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(curr != <span class="keyword">null</span> &amp;&amp; curr.next != <span class="keyword">null</span>)&#123; <span class="comment">// 烦人的循环执行条件</span></span><br><span class="line">        <span class="comment">// 翻转区间中节点的指向</span></span><br><span class="line">        ListNode temp = curr.next;</span><br><span class="line">        </span><br><span class="line">        prev.next = temp;</span><br><span class="line">        curr.next = temp.next;</span><br><span class="line">        temp.next = curr;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 更新翻转区间</span></span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = curr.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>until next time 😄</p>
</blockquote>
]]></content>
      <categories>
        <category>ListNode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>倒数第k个节点_05</title>
    <url>/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9(%E4%B8%A4%E6%AC%A1%E9%81%8D%E5%8E%86)_05.html</url>
    <content><![CDATA[<h3 id="删除链表中的倒数第N个节点"><a href="#删除链表中的倒数第N个节点" class="headerlink" title="删除链表中的倒数第N个节点"></a>删除链表中的倒数第N个节点</h3><h4 id="分析（找到问题的难点）："><a href="#分析（找到问题的难点）：" class="headerlink" title="分析（找到问题的难点）："></a>分析（找到问题的难点）：</h4><ul>
<li>对于单向链表，只能从前往后地查找节点；</li>
<li>删除链表节点的常用手段: curr.next = curr.next.next; // 这样就能把curr后面的一个节点从链表中删除掉</li>
</ul>
<a id="more"></a>

<h4 id="思路（解决问题难点）："><a href="#思路（解决问题难点）：" class="headerlink" title="思路（解决问题难点）："></a>思路（解决问题难点）：</h4><p>如果链表的长度已知，就能通过公式（length - N）来求出待删除节点的正向位置。这样就可以执行删除操作了</p>
<p>可能犯错的地方：找错了节点；</p>
<p>根据分析的第二点，我们应该找到的是待删除节点的上一个节点（预期节点）；</p>
<h4 id="实现SOP"><a href="#实现SOP" class="headerlink" title="实现SOP:"></a>实现SOP:</h4><ul>
<li>1 先计算出链表中的节点的总长度；</li>
<li>2 根据公式(length - N)计算出待删除节点的正向位置索引；</li>
<li>3 找到预期节点，然后删除“待删除的节点”；</li>
</ul>
<h4 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ListNode类型的定义省略</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 0 鲁棒性代码</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1 定义需要的指针</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>); <span class="comment">// 备用</span></span><br><span class="line">        dummy.next = head;</span><br><span class="line">        </span><br><span class="line">        ListNode cursor = head;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2 计算链表中节点的总长度</span></span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cursor != <span class="keyword">null</span>)&#123;</span><br><span class="line">            length++;</span><br><span class="line">            cursor = cursor.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3 计算预期节点的位置</span></span><br><span class="line">        <span class="keyword">int</span> expect_postion = length - n;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4 通过迭代的方式找到预期节点</span></span><br><span class="line">        cursor = head; <span class="comment">// 把游标拨回链表头节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i &lt; expect_position; i++)&#123;</span><br><span class="line">            cursor = cursor.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 5 找到预取节点后，对待删除节点执行删除操作</span></span><br><span class="line">        cursor.next = cursor.next.next; <span class="comment">// 由于题设已经保证n是有效的，所以这里不会出现NPE</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 6 返回删除节点后的链表</span></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="添加鲁棒性代码"><a href="#添加鲁棒性代码" class="headerlink" title="添加鲁棒性代码"></a>添加鲁棒性代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">参考 <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>



<h4 id="算法特征"><a href="#算法特征" class="headerlink" title="算法特征"></a>算法特征</h4><p>1 需要两次遍历：第一次遍历用来计算链表中的节点总长度；第二次遍历用来找到“预期的节点”，以便执行删除</p>
<h4 id="优化（只需要进行一次遍历）"><a href="#优化（只需要进行一次遍历）" class="headerlink" title="优化（只需要进行一次遍历）"></a>优化（只需要进行一次遍历）</h4><p>原理：通过前后指针来找到预期位置，而不是用（length - N）的方式。</p>
<blockquote>
<p>until NEXT time 😄</p>
</blockquote>
]]></content>
      <categories>
        <category>ListNode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>链表去重_04_2</title>
    <url>/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%EF%BC%88%E9%80%92%E5%BD%92%E6%96%B9%E5%BC%8F%EF%BC%89_04_2.html</url>
    <content><![CDATA[<h3 id="删除有序链表中的重复元素（递归方式）"><a href="#删除有序链表中的重复元素（递归方式）" class="headerlink" title="删除有序链表中的重复元素（递归方式）"></a>删除有序链表中的重复元素（递归方式）</h3><h4 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h4><p><img src="https://s1.ax1x.com/2020/08/14/dCTVln.png" alt="题设与要求"></p>
<a id="more"></a>

<h4 id="分析（确定思路）"><a href="#分析（确定思路）" class="headerlink" title="分析（确定思路）"></a>分析（确定思路）</h4><ul>
<li><p>使用递归的可行性；</p>
<ul>
<li>问题能够被分解为规模更小的问题吗？</li>
</ul>
<p>答：可以。手段：把链表视为：头节点head + 剩余节点组成的链表rest;</p>
<ul>
<li>可以在更小的问题上应用当前操作，并用它的返回值来帮助解决大问题吗？</li>
</ul>
<p>答：可以。对递归调用的返回值做一些额外的处理，就能得到整个链表删除重复元素之后的结果。</p>
</li>
</ul>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> val)&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1 递归方法的作用：删除链表中的重复元素并返回更新后的链表/头节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 2 递归终结条件 链表为空 OR 链表中就只有一个节点</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3 本级递归需要做的事情</span></span><br><span class="line">        <span class="comment">// ① 把链表视为：头节点head + 剩余节点构成的链表rest；</span></span><br><span class="line">        <span class="comment">// ② 对rest链表执行删除重复节点的操作（假设已经有一个功能可用的API）；</span></span><br><span class="line">        <span class="comment">// ③ 对返回值进行必要的处理</span></span><br><span class="line">        ListNode rest = deleteDuplicates(head.next); <span class="comment">// ② </span></span><br><span class="line">        <span class="keyword">if</span>(head.val == rest.val)&#123; <span class="comment">// 头节点的值与rest头节点的值相等... 重复了</span></span><br><span class="line">             <span class="comment">// 更新head指针</span></span><br><span class="line">             head = rest;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 把rest连接到head上</span></span><br><span class="line">            head.next = rest;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回新链表的头节点</span></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="代码实现步骤SOP分解"><a href="#代码实现步骤SOP分解" class="headerlink" title="代码实现步骤SOP分解"></a>代码实现步骤SOP分解</h4><ul>
<li>确定递归的可行性</li>
<li>确定递归方法的作用与返回值</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1 递归方法的作用：删除链表中的重复元素并返回更新后的链表/头节点</span></span><br></pre></td></tr></table></figure>



<ul>
<li>确定递归方法的终结条件</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2 递归终结条件 链表为空 OR 链表中就只有一个节点</span></span><br><span class="line"><span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br></pre></td></tr></table></figure>

<ul>
<li>确定本级递归需要完成的事情</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 3 本级递归需要做的事情</span></span><br><span class="line"><span class="comment">// ① 把链表视为：头节点head + 剩余节点构成的链表rest；</span></span><br><span class="line"><span class="comment">// ② 对rest链表执行删除重复节点的操作（假设已经有一个功能可用的API）；</span></span><br><span class="line"><span class="comment">// ③ 对返回值进行必要的处理</span></span><br><span class="line">ListNode rest = deleteDuplicates(head.next); <span class="comment">// ② </span></span><br><span class="line"><span class="keyword">if</span>(head.val == rest.val)&#123; <span class="comment">// 头节点的值与rest头节点的值相等... 重复了</span></span><br><span class="line">    <span class="comment">// 更新head指针</span></span><br><span class="line">    head = rest;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 把rest连接到head上</span></span><br><span class="line">    head.next = rest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>返回正确链表的头指针（最好画图确认）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回新链表的头节点</span></span><br><span class="line"><span class="keyword">return</span> head;</span><br></pre></td></tr></table></figure>



<h4 id="启示"><a href="#启示" class="headerlink" title="启示"></a>启示</h4><p>在分析递归可行的情况下，对递归调用的返回值还需要进一步处理。</p>
<p>基本的原则是：使用递归调用的返回值来解决本级递归所需要解决的问题；</p>
<blockquote>
<p>until next time 😄</p>
</blockquote>
]]></content>
      <categories>
        <category>ListNode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>链表去重_04</title>
    <url>/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0(%E8%BF%AD%E4%BB%A3%E6%96%B9%E5%BC%8F)_04.html</url>
    <content><![CDATA[<h3 id="删除排序链表中的重复元素"><a href="#删除排序链表中的重复元素" class="headerlink" title="删除排序链表中的重复元素"></a>删除排序链表中的重复元素</h3><hr>
<h4 id="题目要求："><a href="#题目要求：" class="headerlink" title="题目要求："></a>题目要求：</h4><p><img src="https://s1.ax1x.com/2020/08/14/dCy9C8.png" alt="题目要求"></p>
<p><img src="https://s1.ax1x.com/2020/08/14/dCguPP.png" alt="测试用例示例"></p>
<a id="more"></a>

<h4 id="题设分析："><a href="#题设分析：" class="headerlink" title="题设分析："></a>题设分析：</h4><ul>
<li>1 链表已经是有序的了，aka，重复的元素会相邻在一起；</li>
<li>2 删除元素时，只需要删除重复多次的部分，使元素只会出现一次；</li>
</ul>
<h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>最直观的方式：</p>
<ul>
<li>遍历整个链表，逐个比较当前节点curr与当前节点的下一个节点next的值。</li>
<li>如果curr.val == next.val,就想办法删除掉当前节点；</li>
<li>如果不相等，就更新curr指针，以便迭代下一个节点；</li>
</ul>
<h4 id="代码实现的SOP"><a href="#代码实现的SOP" class="headerlink" title="代码实现的SOP"></a>代码实现的SOP</h4><ul>
<li>创建一个指针curr，初始化为链表的头节点head；    作用：用于迭代链表；</li>
<li>创建一个指针dummy,初始化为null； 作用：用于指向链表的头节点，方便返回更新后的链表；</li>
<li>循环链表中的每一个节点，判断节点是否是重复节点；<ul>
<li>如果是，删除此节点；</li>
<li>如果不是，继续执行循环，直到所有节点都已经被遍历了</li>
</ul>
</li>
</ul>
<h4 id="完整的代码实现"><a href="#完整的代码实现" class="headerlink" title="完整的代码实现"></a>完整的代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    </span><br><span class="line">    ListNode(<span class="keyword">int</span> val)&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 1 定义需要的指针</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        </span><br><span class="line">        ListNode curr = head;</span><br><span class="line">        <span class="comment">// 2 遍历链表中的每一个节点，判断是否为重复节点，并执行相应的操作</span></span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="keyword">null</span> &amp;&amp; curr.next != <span class="keyword">null</span>)&#123; <span class="comment">// 循环执行条件：当前节点与当前节点的下一个节点都不为null	根据画图的边界条件推导 并使用代码中可能的NPE来验证</span></span><br><span class="line">            <span class="keyword">if</span>(curr.val == curr.next.val)&#123;</span><br><span class="line">                curr.next = curr.next.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                curr = curr.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3 遍历完成后，返回新链表的头节点</span></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="实现过程SOP"><a href="#实现过程SOP" class="headerlink" title="实现过程SOP"></a>实现过程SOP</h4><ul>
<li><p>定义需要的指针</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1 定义需要的指针</span></span><br><span class="line">ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);	</span><br><span class="line">dummy.next = head; <span class="comment">// dummy指针	作用：指向链表的头节点，方便无脑地返回链表的头节点</span></span><br><span class="line"></span><br><span class="line">ListNode curr = head; <span class="comment">// 作用：在链表中遍历所有节点（结合循环）</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>定义一个循环，在循环中执行判重与删除操作 &amp; 迭代链表的操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">	<span class="keyword">if</span>(curr.val == curr.next.val)&#123; <span class="comment">// 判重</span></span><br><span class="line">        <span class="comment">// 删除</span></span><br><span class="line">        curr.next = curr.next.next; <span class="comment">// 把当前节点连接到下下个节点上</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        curr = curr.next; <span class="comment">// 更新指针	作用：实现遍历链表</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>确定循环()表达式的内容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 临界情况：比较倒数第一与倒数第二个节点，判断倒数第一个节点是否需要删除</span></span><br><span class="line"><span class="comment">// curr为倒数第二个节点，curr.next为倒数第一个节点</span></span><br><span class="line"><span class="comment">// 为了循环能够正常执行，要求两个节点均不为null</span></span><br><span class="line"><span class="keyword">while</span>(curr != <span class="keyword">null</span> &amp;&amp; curr.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>确定方法的返回值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 由于定义了指向原始链表头节点的指针dummy,而且没有改变链表中的连接方向，SO</span></span><br><span class="line"><span class="keyword">return</span> dummy.next; <span class="comment">// 直接返回dummy的下一个节点 aka 链表的头节点</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="代码重现"><a href="#代码重现" class="headerlink" title="代码重现"></a>代码重现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicats</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1 定义所需要的指针</span></span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    dummy.next = head;</span><br><span class="line">    </span><br><span class="line">    ListNode curr = dummy;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2 迭代链表中的节点，并完成必要的操作</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(curr.val == curr.next.val)&#123;</span><br><span class="line">            curr.next = curr.next.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 这里必须要有else字句，因为链表中可能出现连续重复的节点</span></span><br><span class="line">            <span class="comment">// 更新指针指向下一个节点</span></span><br><span class="line">            curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3 返回更新后的节点</span></span><br><span class="line">    <span class="keyword">return</span> dummy.next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>until next time 😄</p>
</blockquote>
]]></content>
      <categories>
        <category>ListNode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>合并链表_03_2</title>
    <url>/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%EF%BC%88%E9%80%92%E5%BD%92%E6%96%B9%E5%BC%8F%EF%BC%89_03_2.html</url>
    <content><![CDATA[<h3 id="合并两个有序链表（递归方式）"><a href="#合并两个有序链表（递归方式）" class="headerlink" title="合并两个有序链表（递归方式）"></a>合并两个有序链表（递归方式）</h3><hr>
<p><img src="https://s1.ax1x.com/2020/08/11/aOHNlD.png" alt="题目要求"></p>
<a id="more"></a>

<h4 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h4><ul>
<li><p>使用递归的可行性；</p>
<p>把第一个链表叫做l1，第二个链表叫做l2。可以把 l1 分解为（head + rest）,然后拿rest与l2进行合并操作，合并得到的结果再连接到head；</p>
<p>结论：可行</p>
</li>
<li><p>递归三部曲回顾：</p>
<p>1 方法的作用与返回值；</p>
<p>2 递归的终结条件（根据方法的作用推演）；</p>
<p>3 本级递归需要完成的工作（假设已经有了一个功能完整实现的API）；</p>
</li>
</ul>
<hr>
<h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>一旦确定是可以递归的，这种方式需要关注的细节其实很少</p>
<hr>
<h4 id="完整实现"><a href="#完整实现" class="headerlink" title="完整实现"></a>完整实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ListNode定义的代码省略（参考其他文章）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1 作用：合并两个有序的列表，并返回合并后的列表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 2 递归终结条件</span></span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(l2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3 本级递归需要做的事情</span></span><br><span class="line">        <span class="comment">// ① 比较两个原始链表的头节点谁更小，对更小的那个链表进行拆分；</span></span><br><span class="line">        <span class="comment">// ② 把拆分后的rest链表与原始链表中的另一个进行合并操作，得到新的链表tempMerge</span></span><br><span class="line">        <span class="comment">// ③ 再对head头节点与tempMerge进行合并</span></span><br><span class="line">        <span class="keyword">if</span>(l1.val &lt; l2.val)&#123;</span><br><span class="line">            l1.next = mergeTwoLists(l1.next, l2); <span class="comment">// 把得到的新链表直接连接到头节点上</span></span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l2.next = mergeTwoLists(l2.next, l1);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h4><p>参考代码中的1、2、3</p>
<hr>
<h4 id="启示"><a href="#启示" class="headerlink" title="启示"></a>启示</h4><p>递归的代码真的非常简洁（不需要考虑很多的边界细节），而且只要确定可行性，代码一般不会太复杂</p>
<blockquote>
<p>until next time😄</p>
</blockquote>
]]></content>
      <categories>
        <category>ListNode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>合并链表_03</title>
    <url>/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8-%E5%BE%97%E5%88%B0%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%EF%BC%88%E8%BF%AD%E4%BB%A3%E6%96%B9%E5%BC%8F%EF%BC%89_03.html</url>
    <content><![CDATA[<h3 id="合并两个有序链表，得到一个新的有序链表（迭代方式）"><a href="#合并两个有序链表，得到一个新的有序链表（迭代方式）" class="headerlink" title="合并两个有序链表，得到一个新的有序链表（迭代方式）"></a>合并两个有序链表，得到一个新的有序链表（迭代方式）</h3><a id="more"></a>



<h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>1 创建一个链表就只需要想某个节点上不断连接其他节点就行了；</p>
<p>2 对两个链表对应位置节点的值进行比较，把较小的节点先连接到链表中；</p>
<p>3 如果出现某一个链表中的节点比较多（另一个链表中的节点已经用完了），直接把链表剩余的节点连接到正在创建的链表上就行了（因为剩余的这些节点都已经是有序的了，并且值也更大）</p>
<hr>
<h4 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h4><p>1 创建链表就只需要一个指针就可以；    </p>
<p>创建链表的SOP:</p>
<ul>
<li>1 连接到下一个节点；</li>
<li>2 更新当前指针到下一个节点；以便重复步骤1</li>
</ul>
<p>2 为了方便比较两个链表对应位置上的节点，这里需要添加一个假节点dummy；它总是指向链表的头节点</p>
<hr>
<h4 id="根据上面的分析尝试写代码"><a href="#根据上面的分析尝试写代码" class="headerlink" title="根据上面的分析尝试写代码"></a>根据上面的分析尝试写代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> val)&#123; <span class="keyword">this</span>.val = val;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 准备指针，用于生成链表</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>); <span class="comment">// 指向链表的头节点</span></span><br><span class="line">        ListNode cursor = dummy; <span class="comment">// 用于不管更新链表的指针</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 迭代并比较两个链表中节点的大小，并根据比较结果把节点连接到链表中</span></span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>)&#123; <span class="comment">// 循环执行条件：haed to describe</span></span><br><span class="line">            <span class="keyword">if</span>(l1.val &lt; l2.val)&#123;</span><br><span class="line">                <span class="comment">// 创建链表step1：连接到下一个节点</span></span><br><span class="line">                cursor.next = l1;</span><br><span class="line">                <span class="comment">// 更新l1链表的指针到下一个位置	作用：实现迭代</span></span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 作用同上</span></span><br><span class="line">                cursor.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 创建链表step2：更新链表的指针	作用：方便连接到下一个节点</span></span><br><span class="line">            cursor = cursor.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// always safe to use this to refer the ListNode, cus it always point to the first node of the ListNode</span></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h4><p>step1 定义需要的指针</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>); <span class="comment">// 方便新链表的创建</span></span><br><span class="line">ListNode cursor = dummy; <span class="comment">// cursor的意思是游标，我感觉比起指针更形象一些	用于创建新链表</span></span><br></pre></td></tr></table></figure>



<p>step2 通过迭代的方式，遍历两个子链表中的指针，并连接到新链表中；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">	<span class="keyword">if</span>(l1.val &lt; l2.val)&#123;</span><br><span class="line">		<span class="comment">// 为新链表连接到下一个节点	扩展新链表</span></span><br><span class="line">		cursor.next = l1;</span><br><span class="line">		<span class="comment">// 找到原始链表中的下一个节点 用于比较两个原始链表之间的节点</span></span><br><span class="line">		l1 = l1.next;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		cursor.next = l2;</span><br><span class="line">		l2 = l2.next;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 更新cursor指针	用于扩展链表</span></span><br><span class="line">	cursor = cursor.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>step3 确定循环执行条件的表达式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1 当表达式的值为true时，循环执行；</span></span><br><span class="line"><span class="comment">// 2 循环的作用：为新链表连接一个新节点，并且做一些方便连接下一个节点的操作</span></span><br><span class="line"><span class="comment">// 3 当某个链表的节点用尽时，应该终止循环：因为这时候不再需要进行节点间的比较</span></span><br><span class="line"><span class="comment">// 4 链表节点用尽的情况：l1 == null、l2 == null</span></span><br><span class="line"><span class="comment">// 这两种情况之间的逻辑关系是什么？只要有一个成立，循环就应该终止。对应地，为了让循环执行，应该两者都不为null aka l1 != null &amp;&amp; l2 != null</span></span><br><span class="line"><span class="keyword">while</span>(l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>)&#123; ... &#125;  <span class="comment">// this is truly a piece of work</span></span><br></pre></td></tr></table></figure>



<p>step4 处理某个原始链表中没有添加进新链表的节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 为什么出现节点没有被添加的情况？ 因为另外一个链表中的节点已经用完了，它里面的节点值都比较小</span></span><br><span class="line"><span class="comment">// 如何确定是哪一个链表的节点没有被用完？ 没有被用完的链表指针不为null</span></span><br><span class="line"><span class="comment">// 如何处理没有被添加的节点？ 直接连接到新链表中即可 找对节点</span></span><br><span class="line"><span class="comment">// 这时候最好边看着操作图，边编写代码 	因为某些边界条件很容易弄错</span></span><br><span class="line"><span class="keyword">if</span>(l1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">    cursor.next = l2;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span>(l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">    cursor.next = l1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>step5 返回创建的新链表的头节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> dummy.next;</span><br></pre></td></tr></table></figure>



<p>step6 编写基础测试用例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">main()&#123;</span><br><span class="line">	<span class="comment">// 测试用例代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>step7 添加鲁棒性代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 鲁棒性代码一般添加在开始的地方，来对参数进行校验</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>until next time😄</p>
</blockquote>
]]></content>
      <categories>
        <category>ListNode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>翻转链表_02_2</title>
    <url>/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E9%93%BE%E8%A1%A8%E7%BF%BB%E8%BD%AC%E4%B9%8B%E9%80%92%E5%BD%92%E8%A7%A3%E6%B3%95_02_2.html</url>
    <content><![CDATA[<h3 id="链表翻转之递归解法"><a href="#链表翻转之递归解法" class="headerlink" title="链表翻转之递归解法"></a>链表翻转之递归解法</h3><a id="more"></a>

<hr>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>并不是所有的情况都能使用递归解决，能用递归解决的问题需要有两个特征：</p>
<ul>
<li>1 能够通过某种方式把问题的规模变小；</li>
<li>2 对于1中更小规模的问题，可以使用同样的操作去处理它；</li>
</ul>
<p>现在先看看“翻转链表”这样的操作是不是符合上面的两个特征：</p>
<h5 id="能够通过某种方式把问题的规模变小"><a href="#能够通过某种方式把问题的规模变小" class="headerlink" title="能够通过某种方式把问题的规模变小"></a>能够通过某种方式把问题的规模变小</h5><p>由于链表本身就是递归的结构，所以总是可以把链表分为：头节点head + 剩余节点所组成的链表rest；</p>
<h5 id="对于更小规模的问题，可以使用同样的操作去处理它"><a href="#对于更小规模的问题，可以使用同样的操作去处理它" class="headerlink" title="对于更小规模的问题，可以使用同样的操作去处理它"></a>对于更小规模的问题，可以使用同样的操作去处理它</h5><p>在对rest做翻转操作后，我们就能得到一个已经翻转了的链表。接下来就只要想办法把头节点head连接进来即可</p>
<hr>
<h4 id="使用递归的三部曲"><a href="#使用递归的三部曲" class="headerlink" title="使用递归的三部曲"></a>使用递归的三部曲</h4><ul>
<li><p>1 明确方法的作用与返回值；</p>
</li>
<li><p>2 找到递归的终结条件——这个条件会停止递归，并开始弹出调用栈；</p>
</li>
<li><p>3 确定本级递归需要完成的工作；（这时候要假设已经有了功能可用的API给自己调用）</p>
</li>
</ul>
<p>注：一般而言，递归方法可以按照这3步来编写。但不尽然，有些递归方法的实现可能会surprise us</p>
<hr>
<h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 0 作用：翻转指定的链表，并返回链表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1 递归的终结条件</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 本级递归需要做的事情</span></span><br><span class="line">        <span class="comment">// ① 把链表视为：头节点 + 剩下节点组成的链表rest</span></span><br><span class="line">        <span class="comment">// ② 对rest中的节点执行翻转操作————翻转后，rest指向新链表的头节点</span></span><br><span class="line">        ListNode rest = reverseList(head.next);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ③ 把原始的头节点连接到新链表的尾节点</span></span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rest;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="代码重现"><a href="#代码重现" class="headerlink" title="代码重现"></a>代码重现</h4><blockquote>
<p>step0 画个图，理清思路；需要什么东西，应该做怎样的操作；</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/08/11/aOaGT0.md.jpg" alt="递归下的链表"></p>
<blockquote>
<p>step1 确定方法的作用与返回值；</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法作用：翻转链表，并返回翻转后的链表；</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>step2 编写递归终结条件；</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实现翻转链表的最简情况是什么？ 答：空链表或者只有一个节点的链表</span></span><br><span class="line"><span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head; <span class="comment">// 这两种情况可以分开写，一起写只是为了让代码简洁一些</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>step3 本级递归需要做的事情；</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	① 把链表拆分为：头节点head + 剩下的节点所组成的链表rest;</span></span><br><span class="line"><span class="comment">	② 对rest链表执行“翻转”操作————翻转后的链表头节点为旧链表的尾节点；</span></span><br><span class="line"><span class="comment">	③ 处理head节点与rest链表，使得整个链表中的所有节点都被翻转；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 对rest链表执行“翻转”操作</span></span><br><span class="line">ListNode rest = reverseList(head.next);</span><br><span class="line"><span class="comment">// 把head节点添加到rest链表的末尾</span></span><br><span class="line">head.next.next = head;</span><br><span class="line"><span class="comment">// 为head连接一个null——表示链表结束</span></span><br><span class="line">head.next = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<h4 id="测试用例（检查代码功能与代码的健壮性）"><a href="#测试用例（检查代码功能与代码的健壮性）" class="headerlink" title="测试用例（检查代码功能与代码的健壮性）"></a>测试用例（检查代码功能与代码的健壮性）</h4><ul>
<li>极端情况下，功能是否正常工作； 传入的链表为空/只有一个节点</li>
</ul>
<h4 id="启示"><a href="#启示" class="headerlink" title="启示"></a>启示</h4><p>链表节点之间的关系，最好画张图比较容易弄清楚。</p>
<p>比如“把head连接到rest链表的末尾”这一步，刚开始我是想沿着链表找到rest的尾节点，然后再连接到head</p>
<p>但如果画图就能看出来，获取rest链表尾节点可以用head.next；</p>
<p>拆解一下head.next.next = head;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取到rest的尾节点</span></span><br><span class="line">ListNode lastOfRest = head.next;</span><br><span class="line"><span class="comment">// 把获取到的尾节点连接到head上</span></span><br><span class="line">lastOfRest.next = head;</span><br><span class="line"><span class="comment">// 把head连接到一个null	这一步必须有，否则head与lastOfRest节点之间就会有环出现 这会导致报错</span></span><br><span class="line">head.next = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>until next time 😄</p>
</blockquote>
]]></content>
      <categories>
        <category>ListNode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>交换链表节点_02_1</title>
    <url>/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E5%AF%B9%E9%93%BE%E8%A1%A8%E8%BF%9B%E8%A1%8C%E7%BF%BB%E8%BD%AC(%E8%BF%AD%E4%BB%A3%E6%96%B9%E5%BC%8F)_02_1.html</url>
    <content><![CDATA[<h3 id="对链表进行翻转（使用迭代的方式）"><a href="#对链表进行翻转（使用迭代的方式）" class="headerlink" title="对链表进行翻转（使用迭代的方式）"></a>对链表进行翻转（使用迭代的方式）</h3><hr>
<p><img src="https://s1.ax1x.com/2020/08/11/aLKOne.png" alt="翻转链表"></p>
<a id="more"></a>

<hr>
<h3 id="分析-👇👇👇"><a href="#分析-👇👇👇" class="headerlink" title="分析:👇👇👇"></a>分析:👇👇👇</h3><h4 id="节点翻转示意图"><a href="#节点翻转示意图" class="headerlink" title="节点翻转示意图"></a>节点翻转示意图</h4><p><img src="https://s1.ax1x.com/2020/08/11/aL1MgP.md.jpg" alt="节点翻转示意图"></p>
<p>1 既然是要翻转链表，那每个节点的连接方向都会发生变化；</p>
<p>2 每个节点都只能有一个连接。当它指向自己的前一个节点时，它就不能再指向自己的下一个节点；</p>
<p>3 需要处理链表中的每一个节点，但是根据2可知，节点连接方向改变后，无法再沿着链表获取到下一个节点；</p>
<p>解决手段：在改变节点的连接方向之前，使用一个临时变量保存当前节点的下一个节点；</p>
<blockquote>
<p>实现SOP</p>
</blockquote>
<p>1 为了能够遍历链表，我们需要一个指针；</p>
<p>2 为了能够改变节点的连接方向，我们需要另一个指针来指向当前节点的前一个节点；</p>
<blockquote>
<p>完整代码(不包含测试用例，可以自己编写main()函数作为测试用例)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 链表/节点的类定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val; <span class="comment">// 节点中存储的值</span></span><br><span class="line">    ListNode next; <span class="comment">// 节点连接到的下一个节点</span></span><br><span class="line">    ListNode(<span class="keyword">int</span> x) &#123;val = x;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 0 作用：翻转指定的链表，并返回链表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 迭代的方式</span></span><br><span class="line">        ListNode prev = <span class="keyword">null</span>; </span><br><span class="line">        ListNode curr = head; <span class="comment">// 翻转链表需要前后两个指针：一个用于更新头节点，一个用于创建链表的连接</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 记录原始的下一个节点 防止链表断掉</span></span><br><span class="line">            ListNode temp = curr.next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 建立链表的连接</span></span><br><span class="line">            curr.next = prev;</span><br><span class="line">            <span class="comment">// 更新两个指针</span></span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="实现过程☕☕☕"><a href="#实现过程☕☕☕" class="headerlink" title="实现过程☕☕☕"></a>实现过程☕☕☕</h3><h4 id="step1-定义两个指针，用来遍历和翻转链表；"><a href="#step1-定义两个指针，用来遍历和翻转链表；" class="headerlink" title="step1 定义两个指针，用来遍历和翻转链表；"></a>step1 定义两个指针，用来遍历和翻转链表；</h4><p>问题：如何初始化这两个指针？/这两个指针最开始应该指向什么位置？</p>
<p>答：参考上面的 [链表翻转示意图](#### 节点翻转示意图)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ListNode prev = <span class="keyword">null</span>; <span class="comment">// 初始化指向一个null节点</span></span><br><span class="line">ListNode curr = head; <span class="comment">// 初始化指向链表的头节点（head与curr一样，都是头节点的一个指针）</span></span><br></pre></td></tr></table></figure>



<h4 id="step2-遍历链表中的节点，并进行节点间的翻转；（每次翻转两个节点的连接）"><a href="#step2-遍历链表中的节点，并进行节点间的翻转；（每次翻转两个节点的连接）" class="headerlink" title="step2 遍历链表中的节点，并进行节点间的翻转；（每次翻转两个节点的连接）"></a>step2 遍历链表中的节点，并进行节点间的翻转；（每次翻转两个节点的连接）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123; <span class="comment">// 循环终止条件一般是比较容易出错的地方，所以放在最后再完成</span></span><br><span class="line">	<span class="comment">// 1 保存当前节点的下一个节点		作用：这样在遍历时才能直到下一个节点是哪一个</span></span><br><span class="line">    Node temp = curr.next;</span><br><span class="line">    <span class="comment">// 2 把当前节点连接到当前节点的前一个节点		说明：这个相邻节点的关系需要手动维护</span></span><br><span class="line">    curr.next = prev;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3 维护相邻节点的关系	作用：支持2</span></span><br><span class="line">    prev = curr;</span><br><span class="line">    <span class="comment">// 4 更新当前节点为当前节点的下一个节点		作用：实现遍历链表操作</span></span><br><span class="line">    curr = curr.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="step3-确定循环终止条件"><a href="#step3-确定循环终止条件" class="headerlink" title="step3 确定循环终止条件"></a>step3 确定循环终止条件</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">分析极端情况：</span></span><br><span class="line"><span class="comment">	1 当前节点指针指向链表的尾节点（非null）时，还需要一次循环来翻转last与其上一个节点之间的连接方向；</span></span><br><span class="line"><span class="comment">	2 当前节点指针指向null时，所有翻转都已经完成，循环结束；</span></span><br><span class="line"><span class="comment">	所以循环终止条件为：curr == null;		相应地，(表达式)就应该为curr != null</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">while</span>(curr != <span class="keyword">null</span>)&#123;...&#125;</span><br></pre></td></tr></table></figure>



<h4 id="step4-确定返回值"><a href="#step4-确定返回值" class="headerlink" title="step4 确定返回值"></a>step4 确定返回值</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原则：总是应该返回预期链表的头节点</span></span><br><span class="line"><span class="comment">// 手段：查看循环终止时，各个指针的指向情况		翻转后链表的头节点应该是prev</span></span><br><span class="line"><span class="keyword">return</span> prev;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="代码重现-🦇🦇🦇"><a href="#代码重现-🦇🦇🦇" class="headerlink" title="代码重现 🦇🦇🦇"></a>代码重现 🦇🦇🦇</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    </span><br><span class="line">    ListNode(<span class="keyword">int</span> x)&#123; <span class="keyword">this</span>.val = x&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> <span class="title">Solution</span>(<span class="title">ListNode</span> <span class="title">head</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 定义两个指针并初始化	作用：用于连接与遍历</span></span><br><span class="line">    ListNode prev = <span class="keyword">null</span>;</span><br><span class="line">    ListNode curr = head;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 开始遍历，并在遍历的过程中进行节点连接的翻转</span></span><br><span class="line">    <span class="keyword">while</span>(curr != <span class="keyword">null</span>)&#123; <span class="comment">// 循环执行条件</span></span><br><span class="line">        <span class="comment">// 记录当前节点（开始时是头节点）的下一个节点	作用：实现遍历</span></span><br><span class="line">        ListNode temp = curr.next;</span><br><span class="line">        <span class="comment">// 更新当前节点的连接</span></span><br><span class="line">        curr.next = prev; <span class="comment">// 连接到前一个节点	说明：需要维护这种节点的相邻关系</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 维护节点的相邻关系 &amp; 实现遍历</span></span><br><span class="line">        prev = curr; <span class="comment">// 1 把prev指向curr所指向的节点</span></span><br><span class="line">        curr = temp; <span class="comment">// 2 更新curr到链表的下一个节点	由于节点的连接方向已经变化，所以不能使用curr.next 使用预先存储的节点temp</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回链表的头节点</span></span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="启示"><a href="#启示" class="headerlink" title="启示"></a>启示</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">知道为什么这么写后，才能把思路翻译成代码。不然就是在背代码了</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>ListNode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>两个链表的交点_01</title>
    <url>/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E6%B1%82%E4%B8%A4%E4%B8%AA%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E4%BA%A4%E7%82%B9_01.html</url>
    <content><![CDATA[<h3 id="求两个相交链表的交点"><a href="#求两个相交链表的交点" class="headerlink" title="求两个相交链表的交点"></a>求两个相交链表的交点</h3><hr>
<p><img src="https://s1.ax1x.com/2020/08/11/aLZ7UP.png" alt="图片无法显示"></p>
<a id="more"></a>

<p><strong>要求</strong></p>
<ul>
<li>如果两个链表没有交点，返回null</li>
<li>返回结果后，两个链表必须仍保持原有的结构；</li>
<li>默认链表中不存在环；</li>
<li>尽量满足O(n)的时间复杂度与O(1)的空间复杂度。</li>
</ul>
<hr>
<p>思路：</p>
<p>既然两个链表有长度差异，计算出差出来的长度，想办法消除这个多余长度的影响。就可以一一比较节点了</p>
<p>手段SOP：</p>
<p>1 为两个链表的头节点分别添加一个指针；</p>
<p>2 计算出链表之间的长度差异，然后让较长的那个链表的游标向后移动等长的节点；</p>
<p>3.再让两个游标同步移动，并比较所指向节点是否相等。直到找到相等/相交的节点或者到达链表的末端</p>
<hr>
<p>把上述SOP翻译成代码：</p>
<ol>
<li>先定义表示链表的类型；</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以直接作为一个内部类与Solution类定义在同一个文件中</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x)&#123;</span><br><span class="line">        val = x;</span><br><span class="line">        next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="2">
<li>实现上述SOP（完整实现 + 分解动作）</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123; <span class="comment">// 两个链表结构</span></span><br><span class="line">        <span class="comment">// 最优解法（目前）：1 先计算出两个链表直接的长度差距； 2 再使用两个前后指针解决问题</span></span><br><span class="line">        <span class="comment">// 原理：1 起点相同的两个人，沿同一个方向以相同的速度移动。每时每刻，两个人都在同一个位置上；</span></span><br><span class="line">        <span class="comment">// 2 当两个链表相遇时，节点就重合了</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 鲁棒性代码</span></span><br><span class="line">        <span class="keyword">if</span>(headA == <span class="keyword">null</span> || headB == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode cursorA = headA;</span><br><span class="line">        ListNode cursorB = headB;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算headA与headB的长度</span></span><br><span class="line">        <span class="keyword">int</span> lengthA = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cursorA!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            lengthA++;</span><br><span class="line">            cursorA = cursorA.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> lengthB = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cursorB!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            lengthB++;</span><br><span class="line">            cursorB = cursorB.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算出两个链表之间的距离差————这个就是哨兵指针需要前进的节点数</span></span><br><span class="line">        <span class="keyword">int</span> diff = lengthA - lengthB; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里问题来了，我们需要确定一个信息：哪个链表更长？（这样才能正确地设置指针）</span></span><br><span class="line">        <span class="comment">// 手段：先假设A更长，然后根据真实情况进行更新</span></span><br><span class="line">        ListNode fronter = headA;</span><br><span class="line">        ListNode follower = headB;</span><br><span class="line">        <span class="keyword">if</span>(diff &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            fronter = headB;</span><br><span class="line">            follower = headA;</span><br><span class="line"></span><br><span class="line">            diff = lengthB - lengthA;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 让fronter指针先向前走diff个节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; diff; i++)&#123;</span><br><span class="line">            fronter = fronter.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 让fronter和follwer同时沿着节点先前移动，并比较节点是否为同一个节点</span></span><br><span class="line">        ListNode firstCommon = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(follower != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fronter == follower)&#123;</span><br><span class="line">                firstCommon = fronter;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fronter = fronter.next;</span><br><span class="line">            follower = follower.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> firstCommon;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<ol start="3">
<li>分解实现过程</li>
</ol>
<p>step1 定义两个指针，分别指向两个链表的头节点；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ListNode cursorA = headA;</span><br><span class="line">ListNode cursorB = headB;</span><br></pre></td></tr></table></figure>



<p>step2 计算headA链表与headB链表的长度；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> lengthA = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(cursorA != <span class="keyword">null</span>)&#123;</span><br><span class="line">	lengthA++;</span><br><span class="line">	cursorA = cursorA.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> lengthB = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(cursorB != <span class="keyword">null</span>)&#123;</span><br><span class="line">	lengthB++;</span><br><span class="line">	cursorB = cursorB.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>step3 计算两个链表之间的节点数量差;这个值就是长链表的指针需要前进的距离</p>
<blockquote>
<p>问题来了，怎么知道哪个链表更长呢？为了向前移动指针，一定需要一个正数；</p>
<p>手段：先绑定值，再通过判断来更新值；（其实就是if/else）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> diff = lengthA - lengthB;</span><br><span class="line"></span><br><span class="line">ListNode fronter = headA;</span><br><span class="line">ListNode follower = headB;</span><br><span class="line"><span class="keyword">if</span>(diff &lt; <span class="number">0</span>)&#123;</span><br><span class="line">	fronter = headB;</span><br><span class="line">	follower = headA;</span><br><span class="line">	</span><br><span class="line">	diff = lengthB - lengthA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>step4 把长链表的指针沿着链表向前移动diff个节点；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 让fronter指针先向前走diff个节点</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; diff; i++)&#123;</span><br><span class="line">   	fronter = fronter.next;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<p>step5 同时移动长链表的指针fronter与短链表的指针follower，并比较指针指向的节点是否是同一个节点；</p>
<p>直到（这个循环终止的条件）：1 找到了两个链表的第一个交点； 2 迭代到了链表的尾部，没有任何交点；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ListNode firstCommon = <span class="keyword">null</span>; <span class="comment">// 用于存储找到的第一个节点</span></span><br><span class="line"><span class="keyword">while</span>(fronter != <span class="keyword">null</span>)&#123;</span><br><span class="line">	<span class="keyword">if</span>(fronter == follower)&#123;</span><br><span class="line">		firstCommon = fronter;</span><br><span class="line">		<span class="keyword">break</span>; <span class="comment">// 找到了第一个交点</span></span><br><span class="line">	&#125;</span><br><span class="line">	fronter = fronter.next;</span><br><span class="line">	follower = follower.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>step6 把找到的交点节点返回；（如果没有交点，firstCommon的值不会被更新，也就是为null）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> firstCommon;</span><br></pre></td></tr></table></figure>



<p>step7 检查所有的变量名拼写；（在编辑器没有智能提示的情况下，拼写很容易出错）</p>
<p>step8 添加鲁棒性代码，增强代码的健壮性；最常见的就是参数判空</p>
<blockquote>
<p>启示：虽然把所有的成员变量写在一起看上去很规整，但是看代码的时候却不能重现写代码时的思路；</p>
<p>所以最好在需要变量的时候才添加这些变量，并且写在需要的地方。这会增加可读性</p>
</blockquote>
]]></content>
      <categories>
        <category>ListNode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Web应用第一谈（请求处理的中枢DispatcherServlet）</title>
    <url>/uncategorized/2020/05/17/Spring%20Web%E5%BA%94%E7%94%A8%E7%AC%AC%E4%B8%80%E8%B0%88%EF%BC%88%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E7%9A%84%E4%B8%AD%E6%9E%A2DispatcherServlet%EF%BC%89.html</url>
    <content><![CDATA[<p>Spring Web应用第一谈（请求处理的中枢DispatcherServlet）</p>
<hr>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Web应用？</span><br><span class="line">是：一个能够提供CURD功能的程序；</span><br><span class="line">作用：为用户提供服务；</span><br><span class="line">特征：</span><br><span class="line">	<span class="number">1</span> 用户通过浏览器来访问应用中的功能；</span><br><span class="line">	<span class="number">2</span> 程序需要运行在一个Web容器中（这样它才能被用户访问到）；</span><br><span class="line">	<span class="number">3</span> 用户不需要安装任何东西，他只需要一个能够访问网络的浏览器；</span><br></pre></td></tr></table></figure>



<h4 id="1-SpringMVC框架对一个URL请求的处理流程"><a href="#1-SpringMVC框架对一个URL请求的处理流程" class="headerlink" title="1.SpringMVC框架对一个URL请求的处理流程"></a>1.SpringMVC框架对一个URL请求的处理流程</h4><hr>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">SpringMVC处理URL请求的流程：</span><br><span class="line">1 请求发送给DispatcherServlet；</span><br><span class="line">	作用：DS作为一个前端控制器，把请求委托给应用程序的其他组件</span><br><span class="line">2 DispatcherServlet查询处理器映射（<span class="keyword">Handler</span> <span class="keyword">Mapping</span>）来确定把请求发送给哪一个映射器(Hanlder)进行处理；</span><br><span class="line">	</span><br><span class="line"><span class="number">3</span> 根据查询的结果，DS把请求发送给指定的映射器(<span class="keyword">Handler</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">4</span> 控制器把处理后的<span class="keyword">model</span>数据与视图名称(<span class="keyword">View</span>)发送给DS；</span><br><span class="line"></span><br><span class="line"><span class="number">5</span> DispatcherServlet使用视图解析器（ViewResolver）来通过视图名称找到对应的视图文件；</span><br><span class="line"></span><br><span class="line"><span class="number">6</span> DS把<span class="keyword">model</span>渲染到视图文件中，并最终返回到用户浏览器上;</span><br></pre></td></tr></table></figure>

<h5 id="Q1-不就是处理个请求吗？不应该最多两步吗？SpringMVC怎么一下搞了这么多有的没的，设计者是咋想的？-○´･д･-ﾉ"><a href="#Q1-不就是处理个请求吗？不应该最多两步吗？SpringMVC怎么一下搞了这么多有的没的，设计者是咋想的？-○´･д･-ﾉ" class="headerlink" title="#Q1 不就是处理个请求吗？不应该最多两步吗？SpringMVC怎么一下搞了这么多有的没的，设计者是咋想的？(○´･д･)ﾉ"></a>#Q1 不就是处理个请求吗？不应该最多两步吗？SpringMVC怎么一下搞了这么多有的没的，设计者是咋想的？(○´･д･)ﾉ</h5><h5 id="A1-DS其实在这个过程中，相当于是一个前端控制器。作用就是委托请求，有点子想Nginx"><a href="#A1-DS其实在这个过程中，相当于是一个前端控制器。作用就是委托请求，有点子想Nginx" class="headerlink" title="#A1 DS其实在这个过程中，相当于是一个前端控制器。作用就是委托请求，有点子想Nginx"></a>#A1 DS其实在这个过程中，相当于是一个前端控制器。作用就是委托请求，有点子想Nginx</h5><p>配张图，描述整个过程：</p>
<p>​    Web 请求 —&gt; DispatcherServlet - (!@#$%^)</p>
<hr>
<h4 id="2-创建SpringMVC的请求处理系统"><a href="#2-创建SpringMVC的请求处理系统" class="headerlink" title="2.创建SpringMVC的请求处理系统"></a>2.创建SpringMVC的请求处理系统</h4><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">--</span><br><span class="line"><span class="number">1</span> 配置DispatcherServlet；</span><br><span class="line">作用：把URL请求路由到具体的Spring组件中；</span><br><span class="line">手段<span class="number">1</span>：在web.xml中对DS进行配置</span><br><span class="line">手段<span class="number">2</span>：使用java类对DS进行配置（aka 在Servlet容器中声明前端控制器）</span><br><span class="line">参考：HelloWorldInitializer.java</span><br><span class="line"></span><br><span class="line">--</span><br><span class="line"><span class="number">2</span> 启用SpringMVC,并添加视图解析器的配置</span><br><span class="line">手段：添加注解@EnableWebMvc</span><br><span class="line">参考：WebConfig.java</span><br><span class="line"></span><br><span class="line"><span class="number">3</span> 创建管理其他非Web组件的上下文contextLoaderListener</span><br><span class="line">参考：RootConfig.java</span><br><span class="line"></span><br><span class="line">注：RootConfig先于WebConfig执行，所以：</span><br><span class="line">	<span class="number">1</span> 预期交给WebConfig管理的组件需要在RootConfig中过滤掉；</span><br><span class="line">	<span class="number">2</span> WebConfig中的Bean所依赖的组件可以在RootConfig中先行声明；</span><br></pre></td></tr></table></figure>

<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">说明：直接导入书上的源码到IDEA中运行会各种报错（百度无果的报错）；</span><br><span class="line">最终按照外网上的一个教程，搭建Web项目运行成功。</span><br><span class="line">参考链接：<span class="keyword">http</span>://websystique.com/springmvc/spring<span class="number">-4</span>-mvc-helloworld-tutorial-annotation-javaconfig-full-example/</span><br><span class="line"></span><br><span class="line">然后按照Spring实战书上的代码对项目进行更新，发现书上的代码是可以工作的。</span><br><span class="line">踩坑报错：xxx</span><br><span class="line">原因：一般测试某种手段是否可行时，我都会把原有文件拷贝一份，命名为xxx_backup.java。这样才测试方案不可行时能够快速恢复到初始状态。</span><br><span class="line">但是对Controller类来说，这种做法会导致<span class="built_in">URL</span>的歧义性</span><br><span class="line">参考:Servlet规范<span class="title">_05</span>(本地文件 如何引用？)</span><br><span class="line">引用：既然应用的上下文路径决定了Web应用中内容的<span class="built_in">URL</span>命名空间，Web容器必须要拒绝web应用定义一个在此<span class="built_in">URL</span>命名空间中可能导致冲突的上下文路径</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-1-按照控制器的方式来对控制器进行测试"><a href="#2-1-按照控制器的方式来对控制器进行测试" class="headerlink" title="2.1 按照控制器的方式来对控制器进行测试"></a>2.1 按照控制器的方式来对控制器进行测试</h5><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">需求：按照控制器的方式来测试控制器：</span><br><span class="line">SOP：</span><br><span class="line">    <span class="number">1</span> 创建控制器对象；</span><br><span class="line">    手段：<span class="built_in">new</span></span><br><span class="line">    <span class="number">2</span> 创建SpringMvc mock对象；</span><br><span class="line">    手段：standaloneSetup(xxx).build()		这是Spring框架test模块中的一个静态方法</span><br><span class="line">    <span class="number">3</span> 使用mock对象发起请求并验证响应结果；</span><br><span class="line">    手段：<span class="keyword">perform</span>()方法[执行] + andExcept()方法[断言预期结果]		同样是test框架提供的方法</span><br><span class="line">特征：不需要启动Tomcat就能能够对控制器进行测试；</span><br><span class="line">参考：HomeControllerTest.java</span><br><span class="line">结果：报错“java.lang.NoSuchMethodError: org.springframework.util.StreamUtils.emptyInput()Ljava/io/InputStream;”</span><br><span class="line">解决参考：https://blog.csdn.net/weixin_30487317/article/details/<span class="number">95601425</span></span><br><span class="line">原因：test的版本与spring-mvc版本不一致</span><br><span class="line">解决手段：test的版本参考spring-mvc的版本</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-2-把模型数据传递到视图中"><a href="#2-2-把模型数据传递到视图中" class="headerlink" title="2.2 把模型数据传递到视图中"></a>2.2 把模型数据传递到视图中</h5><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">需求：把模型数据传递到视图中</span></span><br><span class="line"><span class="attr">SOP</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">1</span> <span class="string">定义用来与数据库交互的接口SpittleRepository；</span></span><br><span class="line">    <span class="attr">2</span> <span class="string">定义域数据表对应的实体类Spittle；</span></span><br><span class="line">    <span class="attr">3</span> <span class="string">编写针对于新的Controller控制器的测试类；</span></span><br><span class="line">    <span class="attr">参考：SpittleControllerTest.java</span></span><br><span class="line">    <span class="attr">4</span> <span class="string">编写新的控制器Controller</span></span><br><span class="line"><span class="attr">为什么先编写测试类，后编写控制器？？？😳</span></span><br></pre></td></tr></table></figure>

<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">编写完成后，重启Tomcat时，项目启动失败；</span><br><span class="line">报错：找不到指定的bean；</span><br><span class="line">原因：</span><br><span class="line">    原理：</span><br><span class="line">    Spring对不同类型的组件，创建的时机会不一样；</span><br><span class="line">        <span class="number">1</span> 对于Web相关的组件（aka 控制器对象），由DispatcherServlet所创建的上下文(WebConfig)管理；</span><br><span class="line">        <span class="number">2</span> 其他类型的组件（比如dao层的对象），由ContextLoaderListener所创建的上下文（RootConfig）进行管理；</span><br><span class="line">        <span class="number">3</span> RootConfig先于WebConfig执行，它服务于整个项目；</span><br><span class="line">    具体原因：</span><br><span class="line">        在RootConfig扫描的时候就扫描到controller中的类：</span><br><span class="line">            <span class="number">1</span> bean初始化就要找自动装填的 实现SpitterRepository接口的对象(A)，</span><br><span class="line">            <span class="number">2</span> 但我把A放在WebConfig里了，环境中找不到这个Bean，于是报错。</span><br><span class="line">        所以我在RootConfig中的ComponentScan里添加了过滤，不扫描spittr.web，这样controller中的bean就不会在NoSuchBean的情况下提前初始化了，启动成功。</span><br><span class="line">    同样的原因，SpittleRepository的声明应该放在RootConfig中，否则控制器初始化时也会找不到依赖Bean而报错</span><br><span class="line">参考：https:<span class="comment">//blog.csdn.net/q5738415/article/details/78197508</span></span><br></pre></td></tr></table></figure>

<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line">这里虽然有dao层的执行方法，但是却并没有配置数据库。它是怎么实现的呢？</span><br><span class="line"><span class="params">...</span> <span class="keyword">to</span> be continue <span class="params">...</span></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-3-向控制器方法发送请求时携带参数"><a href="#2-3-向控制器方法发送请求时携带参数" class="headerlink" title="2.3 向控制器方法发送请求时携带参数"></a>2.3 向控制器方法发送请求时携带参数</h5><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">需求：向控制器发送请求时携带参数；</span><br><span class="line">参数类型（按功能分类）：</span><br><span class="line">    <span class="number">1</span> 查询参数；</span><br><span class="line">    <span class="number">2</span> 表单参数；</span><br><span class="line">    <span class="number">3</span> 路径变量；</span><br></pre></td></tr></table></figure>



<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--</span></span><br><span class="line">1 控制器接收查询参数： /spittles/<span class="keyword">show</span>?spittle_id=<span class="number">12345</span></span><br><span class="line">需求：分页列表展示xxx</span><br><span class="line">手段：调用控制器方法时，传入两个参数————页面中第一个xxx的<span class="keyword">ID</span> + 页面中xxx的总条数；</span><br><span class="line">    <span class="keyword">before</span>参数：当前页面xxx列表的左边界；</span><br><span class="line">    <span class="keyword">count</span>参数：当前页面中要包含的xxx数量</span><br><span class="line">实现方法： com.websystique.springmvc.controller.SpittleController.spittles()方法</span><br><span class="line">测试:shouldShowPagedSpittles()</span><br></pre></td></tr></table></figure>



<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">--</span><br><span class="line"><span class="number">2</span> 控制器接收路径参数：/spittles/<span class="number">12345</span></span><br><span class="line">特征：</span><br><span class="line">    <span class="number">1</span> 这种描述方式更加面向资源：<span class="number">12345</span>就是要查询的资源</span><br><span class="line">    <span class="number">2</span> 查询参数的描述方式表示：这是一个带有参数的操作；（通过HTTP发起的RPC）</span><br><span class="line">-</span><br><span class="line">先编写测试方法：</span><br><span class="line">参考：testSpittle()</span><br><span class="line">测试方法fail？？？</span><br><span class="line"></span><br><span class="line">项目访问URL：失败<span class="number">400</span></span><br><span class="line">这都是因为热部署延迟 😳</span><br><span class="line"></span><br><span class="line">-</span><br><span class="line">进入方法后，跳转视图页面时。报错<span class="number">404.</span>..</span><br><span class="line">/spring_mvc/spittles/WEB-INF/views/spittle.jsp</span><br><span class="line">在其他的控制器方法中都可以正常跳转，为什么这个方法就不行？</span><br><span class="line">原因：在配置视图解析器时，没有添加前缀/</span><br><span class="line">参考：https:<span class="comment">//blog.csdn.net/xujin_chen/article/details/53557463</span></span><br><span class="line">原理：不晓得😵[又是半夜无眠]</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-4-向控制器方法发送请求时携带表单参数"><a href="#2-4-向控制器方法发送请求时携带表单参数" class="headerlink" title="2.4 向控制器方法发送请求时携带表单参数"></a>2.4 向控制器方法发送请求时携带表单参数</h5><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">需求：向控制器发送请求时携带表单数据；</span><br><span class="line">实现手段：</span><br><span class="line">    <span class="number">1</span> 处理用户通过表单提交的数据；</span><br><span class="line">    参考：show<span class="constructor">RegistrationForm()</span>方法</span><br><span class="line">    完整流程SOP:</span><br><span class="line">        <span class="number">1</span> 编写控制器方法的测试方法：<span class="module-access"><span class="module"><span class="identifier">SpitterController</span>.</span></span>show<span class="constructor">RegistrationForm()</span></span><br><span class="line">        <span class="number">2</span> 编写视图文件；registerForm.jsp</span><br><span class="line">        <span class="number">3</span> 编写表单提交到的控制器方法 aka 保存表单的控制器方法；<span class="module-access"><span class="module"><span class="identifier">SpitterController</span>.</span></span>processRegistration</span><br><span class="line">        <span class="number">4</span> 编写保存表单的方法的测试方法：should<span class="constructor">ProcessRegistration()</span></span><br><span class="line">        <span class="number">5</span> 编写保存表单后所跳转到的控制器方法；  show<span class="constructor">SpitterProfile()</span></span><br><span class="line">        <span class="number">6</span> 编写控制器方法跳转到的对应页面：profile.jsp</span><br><span class="line">访问链接：http:<span class="comment">//localhost:8088/spring_mvc/spitter/jbauer</span></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-5-对表单中的字段值进行校验"><a href="#2-5-对表单中的字段值进行校验" class="headerlink" title="2.5 对表单中的字段值进行校验"></a>2.5 对表单中的字段值进行校验</h5><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">需求：对表单中的字段值进行校验；</span><br><span class="line">校验类型：</span><br><span class="line">    <span class="number">1</span> 字段值不能为空；</span><br><span class="line">    <span class="number">2</span> 字段值的长度不能超过指定边界；</span><br><span class="line">手段<span class="number">1</span>：在控制方法中对用户提交的表单字段进行逐一验证；</span><br><span class="line">手段<span class="number">2</span>：java校验API接口（SpringMVC框架支持此接口）；</span><br><span class="line">具体方法SOP：</span><br><span class="line">    <span class="number">1</span> 在类路径下包含Java校验API接口的具体实现（比如Hibernate Validator）：</span><br><span class="line">        手段：引用jar包</span><br><span class="line">    <span class="number">2</span> 在java类的属性上添加所需要的注解；</span><br><span class="line">        手段：@NotNull、@Size</span><br><span class="line">    <span class="number">3</span> 在控制器方法中启用校验功能；</span><br><span class="line">        手段：为方法的POJO类型参数添加 @Valid 注解————通知Spring对此参数进行校验；</span><br><span class="line">    <span class="number">4</span> 在控制器方法中处理校验未通过的错误</span><br><span class="line">        手段：使用Errors对象来获取到校验失败的具体信息；</span><br><span class="line">特征：</span><br><span class="line">    <span class="number">1</span> 即便校验没有通过，用户仍旧能够提交表单。aka 控制器方法仍旧会被调用</span><br><span class="line">    <span class="number">2</span> 为了使Errors对象能够获取到校验失败的信息，需要让Errors参数紧跟在@Valid注解的参数后面</span><br><span class="line">    <span class="number">3</span> 在控制器方法中，第一步就应该查看是否出现校验错误————如果校验有错，后面的逻辑就不用再执行了</span><br><span class="line">参考：SpitterController.processRegistration()</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-6-java校验API"><a href="#2-6-java校验API" class="headerlink" title="2.6 java校验API"></a>2.6 java校验API</h5><figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">Java校验API：</span><br><span class="line">作用：对Java类的属性进行校验；</span><br><span class="line">手段：提供多个用于特定校验规则的注解；</span><br><span class="line">用法：把特定的注解放到属性上，就能够限制属性的值。</span><br><span class="line">特征：所有的这些个注解都在javax.validation.constraints包中提供；</span><br><span class="line">常用的校验注解：</span><br><span class="line">    <span class="symbol">@NotNull</span>：限制被注解的属性的值不能为<span class="literal">null</span></span><br><span class="line">    <span class="symbol">@Size</span>：限制被注解的属性的值必须是<span class="built_in">String</span>、数组或者集合，并且长度要符合给定的范围；</span><br><span class="line">参考：Spitter类 （这是Spittr应用的用户）</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-额外收获"><a href="#3-额外收获" class="headerlink" title="3.额外收获"></a>3.额外收获</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">有趣的点：</span></span><br><span class="line">    <span class="number">1</span> <span class="string">SpitterRepository接口的实现类是在WebConfig中配置Bean的时候实现的：</span></span><br><span class="line">        <span class="string">如果没提供这个实现类。创建Controller时注入依赖就会失败</span></span><br><span class="line">    <span class="number">2</span> <span class="string">这里的save()方法并没有把值存储到数据库中，而是添加到一个map对象中。</span></span><br><span class="line">        <span class="string">尽管对象会在每次重启JVM时消失，但是作为一个容器，它是可以当成临时数据库来使用的</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">小结：</span><br><span class="line">大需求：编写应用程序的Web部分；</span><br><span class="line">手段：使用SpringMVC框架（这是Spring框架的一个模块）；</span><br><span class="line">特征：</span><br><span class="line">    <span class="number">1</span> 这种开发方式几乎就是在写POJO类；</span><br><span class="line">    <span class="number">2</span> 编写控制器方法与编写普通java方法无异，唯一的区别在于————你要想办法让方法能够接收到页面发来的参数</span><br><span class="line">    <span class="number">3</span> SpringMVC编写的控制器非常容易测试；</span><br><span class="line">    手段：Mockito框架 + Spring test模块</span><br><span class="line">NexT？</span><br><span class="line">Spring视图相关的一堆东西</span><br></pre></td></tr></table></figure>













]]></content>
  </entry>
  <entry>
    <title>Spring AOP第二谈（与AspectJ AOP的对比）</title>
    <url>/uncategorized/2020/05/11/Spring%20AOP%E7%AC%AC%E4%BA%8C%E8%B0%88%EF%BC%88%E4%B8%8EAspectJ%20AOP%E7%9A%84%E5%AF%B9%E6%AF%94%EF%BC%89.html</url>
    <content><![CDATA[<p>Spring AOP第二谈（与AspectJ AOP的对比）</p>
<hr>
<h4 id="1-AOP的实现方案"><a href="#1-AOP的实现方案" class="headerlink" title="1.AOP的实现方案"></a>1.AOP的实现方案</h4><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">方案<span class="number">1</span>：Spring AOP；</span><br><span class="line">方案<span class="number">2</span>：AspectJ；</span><br><span class="line">特征：AspectJ提供了很多其他的切点类型（Spring AOP只能提供方法调用的切点类型）</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="2-在创建对象时应用指定的通知"><a href="#2-在创建对象时应用指定的通知" class="headerlink" title="2. 在创建对象时应用指定的通知"></a>2. 在创建对象时应用指定的通知</h4><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">需求：在创建对象时应用指定的通知；</span><br><span class="line">说明：创建对象需要调用<span class="keyword">Bean的构造器，但是Spring </span>AOP无法指定这样的连接点/切点类型</span><br><span class="line">为什么Spring AOP实现不了呢？</span><br><span class="line">答：因为它基于代理实现，只能做一些方法层面的操作；</span><br><span class="line">手段：使用AspectJ提供的AOP功能；</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="3-管理由AspectJ创建的切面bean所依赖的Spring组件"><a href="#3-管理由AspectJ创建的切面bean所依赖的Spring组件" class="headerlink" title="3. 管理由AspectJ创建的切面bean所依赖的Spring组件"></a>3. 管理由AspectJ创建的切面bean所依赖的Spring组件</h4><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">说明：一个通知方法可能需要依赖其他的类来实现功能。</span><br><span class="line">需求：管理通知方法所依赖的其他类</span><br><span class="line">手段：把通知方法所依赖的<span class="keyword">Bean注入到切面类中</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">--</span></span><br><span class="line"><span class="keyword">需求：为演出创建一个评论员的角色；</span></span><br><span class="line"><span class="keyword">功能：观看演出，并在观看完成后提出一些批评意见</span></span><br><span class="line"><span class="keyword">参考：CriticAspect </span>+ CriticismEngine + CriticismEngineImpl + <span class="keyword">bean_declare_xmlconfig</span></span><br><span class="line"><span class="keyword">特征：</span></span><br><span class="line"><span class="keyword"> </span>   <span class="number">1</span> AspectJ切面不需要Spring就可以织入到我们的应用中<span class="comment">;</span></span><br><span class="line">    <span class="number">2</span> 但是如果想要使用Spring来管理AspectJ的一些个依赖，就需要把AspectJ切面来声明成一个Spring <span class="keyword">bean</span></span><br><span class="line"><span class="keyword"> </span>   参考：<span class="keyword">bean_declare_xmlconfig.xml</span></span><br><span class="line"><span class="keyword"> </span>   <span class="number">3</span> AspectJ切面<span class="keyword">bean不是Spring容器创建的，而是AspectJ在运行时创建的；</span></span><br><span class="line"><span class="keyword"> </span>   <span class="number">4</span> 为了能够在Spring中获取到AspectJ切面的实例，需要调用切面类的aspectOf()方法————此方法返回切面类的一个单例</span><br></pre></td></tr></table></figure>



<h4 id="4-AOP小结"><a href="#4-AOP小结" class="headerlink" title="4.AOP小结"></a>4.AOP小结</h4><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line"><span class="comment">------</span></span><br><span class="line">AOP：</span><br><span class="line">是：一种编程方式；</span><br><span class="line">作用：把分散在应用各处的行为集中在一个模块中（方便管理），并作为重用模块（方便引用）</span><br><span class="line">特征：</span><br><span class="line">    <span class="number">1</span> 使程序员编写的类更加简洁、准确；</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">需求：支持AOP形式的编程风格；</span><br><span class="line">Spring提供的手段：Spring AOP；</span><br><span class="line">原理：</span><br><span class="line">    在程序员进行必要的操作后，Spring AOP会创建一个代理类，在代理类中把切面插入到目标方法执行的周围；</span><br><span class="line">必要的操作：</span><br><span class="line">    <span class="number">1</span> 程序员通过自定义切面来声明预期插入到目标类/方法中的功能；</span><br><span class="line">    <span class="number">2</span> 程序员通过编写切点表达式来声明应用切面中的通知；</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">应用：</span><br><span class="line">    <span class="number">1</span> 把通知织入/应用前置、后置和环绕方法的调用中；</span><br><span class="line">    <span class="number">2</span> 为异常处理添加自定义的行为————抛出异常时的通知方法；</span><br><span class="line">    <span class="number">3</span> 与DI一起，支持程序员创建松散耦合的应用</span><br><span class="line">用法SOP:</span><br><span class="line">    <span class="number">1</span> 声明切面类；</span><br><span class="line">    <span class="number">2</span> 配置切面类中的通知方法（when + where + what）</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>SpringAOP第一谈（术语 &amp; SOP）</title>
    <url>/uncategorized/2020/05/11/SpringAOP%E7%AC%AC%E4%B8%80%E8%B0%88%EF%BC%88%E6%9C%AF%E8%AF%AD%20&amp;%20SOP%EF%BC%89.html</url>
    <content><![CDATA[<p>面向切面编程AOP第一谈：术语 &amp; Java配置方式 &amp; XML配置方式</p>
<hr>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">面向切面编程；</span><br><span class="line"></span><br><span class="line">是：一种编程方式；</span><br><span class="line"></span><br><span class="line">作用：</span><br><span class="line"></span><br><span class="line">​	<span class="number">1</span> 分离应用程序中的业务逻辑点与横切关注点；</span><br><span class="line"></span><br><span class="line">​	<span class="number">2</span> 使业务逻辑点的代码更加简洁清晰；</span><br><span class="line"></span><br><span class="line">​	<span class="number">3</span> 使所有的横切关注点能够集中起来，方便管理；</span><br><span class="line"></span><br><span class="line">特征：</span><br><span class="line"></span><br><span class="line">​	<span class="number">1</span> 通过声明的方式来引用切面中的通知方法到指定的目标方法；</span><br><span class="line"></span><br><span class="line">​	<span class="number">2</span> 切面类是一个POJO类；</span><br></pre></td></tr></table></figure>





<hr>
<h4 id="1-切点"><a href="#1-切点" class="headerlink" title="1.切点"></a>1.切点</h4><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">切点：</span><br><span class="line">作用：定义切面实际作用到的代码位置；</span><br><span class="line">原理：选择切点表达式所匹配到的连接点；</span><br><span class="line">手段：使用AspectJ的切点表达式定义切点；</span><br><span class="line">特征：</span><br><span class="line">    <span class="number">1</span> Spring仅仅支持AspectJ切点指示器的一个子集；</span><br><span class="line">    <span class="number">2</span> Spring所支持的指示器中：</span><br><span class="line">        只有execution指示器是用来执行匹配的；</span><br><span class="line">        其他的指示器都只是限制匹配的；</span><br><span class="line">    <span class="number">3</span> execution指示器是编写切点时，最常使用到的指示器；</span><br></pre></td></tr></table></figure>



<p>1.1 定义切点</p>
<p>手段：编写切点表达式；</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="comment">---</span></span><br><span class="line">任务：编写切点表达式；</span><br><span class="line">前提：需要一个主题————应用切面的目标；</span><br><span class="line">参考：Performance.java</span><br><span class="line"></span><br><span class="line"><span class="comment">--</span></span><br><span class="line">连接点：Performance接口中的<span class="keyword">perform</span>()方法</span><br><span class="line">需求：当<span class="keyword">perform</span>()被调用时，触发自定义的通知；</span><br><span class="line">手段：编写一个切点表达式；</span><br><span class="line">execution(* concert.Performance.<span class="keyword">perform</span>(..))</span><br><span class="line">语义：在方法执行时触发 不关心方法的返回值类型 方法的全限定名(任意参数)</span><br><span class="line">作用：通过此切点表达式，选择了连接点为Performance的<span class="keyword">perform</span>()方法</span><br><span class="line"></span><br><span class="line"><span class="comment">--</span></span><br><span class="line">需求：通过切点表达式的多个规则来选择多个连接点</span><br><span class="line">手段：切点表达式A &amp;&amp; 切点表达式B</span><br><span class="line">具体表达式：execution(* concert.Performance.<span class="keyword">perform</span>(..)) &amp;&amp; <span class="keyword">within</span>(concert.*)</span><br><span class="line"><span class="keyword">within</span>()指示器用来限制连接点匹配指定的类型</span><br><span class="line">&amp;&amp;/<span class="keyword">and</span> 表示连接点必须匹配所有的指示器</span><br><span class="line"></span><br><span class="line"><span class="comment">--</span></span><br><span class="line">任务：在切点中选择指定的Bean</span><br><span class="line">原理：使用bean ID或bean名称来选择指定的bean</span><br><span class="line">需求：执行Performance的<span class="keyword">perform</span>()方法时来应用通知，但是仅限于bean ID为woodstock的bean实例上的方法调用</span><br><span class="line">手段：bean()指示器</span><br><span class="line">切点表达式：</span><br><span class="line">    execution(* concert.Performance.<span class="keyword">perform</span>(..)) <span class="keyword">and</span> bean(<span class="string">'woodstock'</span>)</span><br><span class="line"></span><br><span class="line">需求：限制bean ID不为woodstock的bean实例上，执行xxx方法时，应用通知；</span><br><span class="line">切点表达式：</span><br><span class="line">    execution(* concert.Performance.<span class="keyword">perform</span>(..)) <span class="keyword">and</span> !bean(<span class="string">'woodstock'</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-定义切面（通知-切点）"><a href="#2-定义切面（通知-切点）" class="headerlink" title="2.定义切面（通知 + 切点）"></a>2.定义切面（通知 + 切点）</h4><p>手段：编写切面类；</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">任务：编写切面类；</span><br><span class="line">手段：编写POJO类，然后使用AspectJ5提供的注解声明它是一个切面类；</span><br><span class="line">默念：插入切面、应用/织入通知、选择连接点、匹配切点</span><br><span class="line">应用：对于一场演出来说，观众就可以视为一个切面（可以单独分离出来的功能）；</span><br><span class="line">SOP:</span><br><span class="line">    Ⅰ 声明切面类及通知细节</span><br><span class="line">    <span class="number">1</span> 通过@Aspect注解来声明一个作为切面的类；</span><br><span class="line">    <span class="number">2</span> 在类中定义通知方法：功能实现 + 应用时机；</span><br><span class="line">    <span class="number">3</span> 如果出现了同一个切点表达式被多次书写的情况，把切点表达式单独使用@Pointcut注解定义为一个方法————导出调用</span><br><span class="line">    参考：Audience.java</span><br><span class="line">    ---</span><br><span class="line">    Ⅱ 告诉Spring为定义为切面的类创建代理：</span><br><span class="line">    手段：启用自动代理功能；</span><br><span class="line">    具体方法<span class="number">1</span>：如果使用java类来配置的话，注解@EnableAspectJAutoProxy</span><br><span class="line">        参考：ConcertConfig.java</span><br><span class="line">    具体方法<span class="number">2</span>：使用xml文件配置，aop:aspectj-<span class="built_in">auto</span>proxy标签</span><br><span class="line">        参考：aspect-audience-config.xml</span><br><span class="line">    作用：</span><br><span class="line">        <span class="number">1</span> AspectJ自动代理会给bean创建一个代理————这个代理会包围切点所匹配的bean，以提供切面的功能</span><br><span class="line">        <span class="number">2</span> Audience切面类中的通知方法会在切点所指定的连接点perform()方法调用的前后执行[<span class="keyword">this</span> <span class="keyword">is</span> the <span class="keyword">final</span> propose]</span><br></pre></td></tr></table></figure>



<hr>
<p>Spring对AOP的实现：Spring AOP</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">特征：</span><br><span class="line">    <span class="number">1</span> 使用@AspectJ来声明切面类；</span><br><span class="line">    <span class="number">2</span> 只能够对方法调用这样的操作进行通知；因为代理类就只能对方法的调用进行代理</span><br><span class="line">原理：为被通知的类创建一个代理类，在代理类中实现目标对象的增强（通知方法）</span><br></pre></td></tr></table></figure>



<h5 id="1-为目标方法创建一个环绕通知"><a href="#1-为目标方法创建一个环绕通知" class="headerlink" title="1.为目标方法创建一个环绕通知"></a>1.为目标方法创建一个环绕通知</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">创建环绕通知（round</span> <span class="string">advice）</span></span><br><span class="line"><span class="string">作用：使用自定义的逻辑包围被通知的目标方法；</span> <span class="string">aka</span> <span class="string">前置通知</span> <span class="string">+</span> <span class="string">后置通知</span></span><br><span class="line"><span class="string">应用参考：aop.Audience.watchPerformance()环绕通知方法</span></span><br></pre></td></tr></table></figure>



<h5 id="2-在通知方法中使用目标方法中的参数"><a href="#2-在通知方法中使用目标方法中的参数" class="headerlink" title="2.在通知方法中使用目标方法中的参数"></a>2.在通知方法中使用目标方法中的参数</h5><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">issue：当被通知的目标方法有参数时，通知方法要怎样才能使用这些参数呢？</span><br><span class="line">需求：记录光盘中某个磁道被播放的次数</span><br><span class="line">手段<span class="number">1</span>：在play<span class="constructor">Track()</span>方法中添加一个计数器————每次play<span class="constructor">Track()</span>方法被调用后，都更新计数器的值；</span><br><span class="line">手段<span class="number">2</span>：既然这个需求与播放磁道是不同的任务，把这个需求放在切面中来完成；</span><br><span class="line">参考：<span class="module-access"><span class="module"><span class="identifier">TrackCounter</span>.</span></span>java</span><br><span class="line">验证：</span><br><span class="line">	<span class="number">1</span> 通过代码显式地播放某个磁道多次（play<span class="constructor">Track()</span>）;</span><br><span class="line">	<span class="number">2</span> 然后调用计数器counter的get<span class="constructor">PlayCount()</span>来判断记录的次数是否正确</span><br><span class="line">特征：get<span class="constructor">PlayCount()</span>并没有在CD的方法中，但是同样获取到了方法的调用次数</span><br></pre></td></tr></table></figure>



<h5 id="3-为目标类添加新的方法"><a href="#3-为目标类添加新的方法" class="headerlink" title="3.为目标类添加新的方法"></a>3.为目标类添加新的方法</h5><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">任务：为目标对象添加新的方法：</span><br><span class="line">实现手段：代理对象在实现目标类接口的同时，再实现新添加的接口； aka 为目标对象引入（<span class="built_in">int</span>roduce）新的接口方法</span><br><span class="line">原理：代理会把对目标对象的所有方法调用都委托到底层的具体实现；</span><br><span class="line">特征：</span><br><span class="line">    <span class="number">1</span> 对客户端程序员来说，他只是在一个对象上调用方法（他用的其实是一个代理对象）；</span><br><span class="line">    <span class="number">2</span> 在底层，其实把这一个bean实例的实现分散到了多个类中；</span><br><span class="line">应用：</span><br><span class="line">    在不改动类的原始代码的情况下，灵活地为现有类添加新方法</span><br><span class="line">SOP:</span><br><span class="line">    <span class="number">1</span> 创建一个新的切面类；</span><br><span class="line">    参考：EncoreableIntroducer</span><br><span class="line">    <span class="number">2</span> 在IoC容器中，把切面类声明为一个Spring Bean；</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="3-使用XML来实现上面的所有任务-需求"><a href="#3-使用XML来实现上面的所有任务-需求" class="headerlink" title="3.使用XML来实现上面的所有任务/需求"></a>3.使用XML来实现上面的所有任务/需求</h4><h5 id="3-1-声明一个类为切面；"><a href="#3-1-声明一个类为切面；" class="headerlink" title="3.1 声明一个类为切面；"></a>3.1 声明一个类为切面；</h5><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">特征：</span><br><span class="line">    <span class="number">1</span> 能够在没有组件源码的情况下（比如说使用的第三方组件），能够对组件进行插入切面的操作；</span><br><span class="line">    <span class="number">2</span> 相比于“java配置类”的手段，使用XML配置没有侵入性。也就是说，这种方式不要求你对原始代码做出任何的改动 </span><br><span class="line">实现手段：Spring的aop命名空间下的多个元素；</span><br><span class="line">    例：</span><br><span class="line">        aop:aspectj-autoproxy</span><br><span class="line">        作用：自动创建代理对象————代理由<span class="meta">@AspectJ</span>所注解的通知类</span><br><span class="line">SOP:</span><br><span class="line">    <span class="number">1</span> 去掉添加在切面类上的所有AspectJ提供的注解：<span class="meta">@AspectJ</span>、<span class="meta">@Before</span>、<span class="meta">@After</span>、<span class="meta">@Around</span></span><br><span class="line">    现在有的只是一个单纯的POJO类</span><br><span class="line"></span><br><span class="line">    <span class="number">2</span> 在XML中声明这个类为一个通知类（通知 + 切点 = 切面）</span><br><span class="line">    通知是一个类、切点是一个表达式、切面是一个概念（<span class="keyword">when</span>、<span class="keyword">where</span>、what）</span><br><span class="line">    参考：announce-audience-via-xmlconfig.xml</span><br><span class="line">    使用切点方法对切点表达式的usage进行简化</span><br></pre></td></tr></table></figure>

<h5 id="3-2-在XML声明环绕通知"><a href="#3-2-在XML声明环绕通知" class="headerlink" title="3.2 在XML声明环绕通知"></a>3.2 在XML声明环绕通知</h5><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">环绕通知：</span><br><span class="line">原理：通知方法会包装目标方法，然后在目标方法调用前后添加一些功能；</span><br><span class="line">特征：</span><br><span class="line">    <span class="number">1</span> 等同于前置通知方法 + 后置通知方法；</span><br><span class="line">    <span class="number">2</span> 能够省去前置通知方法 与 后置通知方法中的通信问题（多线程时，方法之间使用成员变量进行通信会有线程安全的问题）</span><br><span class="line">环绕通知方法：watchPerformance()</span><br><span class="line">手段：aop命名空间中的aop:around元素</span><br><span class="line">参考：announce-audience-via-xmlconfig.xml</span><br></pre></td></tr></table></figure>



<h5 id="3-3-在通知方法中使用目标方法中的参数"><a href="#3-3-在通知方法中使用目标方法中的参数" class="headerlink" title="3.3 在通知方法中使用目标方法中的参数"></a>3.3 在通知方法中使用目标方法中的参数</h5><figure class="highlight less"><table><tr><td class="code"><pre><span class="line">手段：为“通知方法”传递参数;</span><br><span class="line">特征：为通知方法所传递的参数应该是目标方法中的参数</span><br><span class="line"><span class="attribute">SOP</span>:</span><br><span class="line">    <span class="number">1</span> 去掉切面类上添加的<span class="variable">@AspectJ</span>注解</span><br><span class="line">    参考：TrackCounterWithoutAnnotation</span><br><span class="line">    <span class="number">2</span> 通过XML配置的方式把TrackCounter声明为一个切面类</span><br><span class="line">    参考：announce-trackcounter-as-aspect-via-xmlconfig.xml</span><br></pre></td></tr></table></figure>



<h5 id="3-4-为目标类添加-引入新的方法"><a href="#3-4-为目标类添加-引入新的方法" class="headerlink" title="3.4 为目标类添加/引入新的方法"></a>3.4 为目标类添加/引入新的方法</h5><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">手段：Spring</span> <span class="string">aop命名空间中的&lt;aop:declare-parents&gt;元素；</span></span><br><span class="line"><span class="attr">参考：add_new_methods_into_target_via_xmlconfig.xml</span></span><br><span class="line"><span class="attr">SOP</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">1</span> <span class="string">在aop:config中声明一个切面类的配置</span></span><br><span class="line">    <span class="attr">2</span> <span class="string">指定预期会被通知的Bean</span></span><br><span class="line">    <span class="attr">3</span> <span class="string">指定预期会为Bean的父类结构所添加的新接口</span></span><br><span class="line">    <span class="attr">4</span> <span class="string">指定为添加的新接口所编写的具体实现</span></span><br><span class="line"><span class="meta">that'a</span> <span class="string">all.</span></span><br></pre></td></tr></table></figure>





]]></content>
  </entry>
  <entry>
    <title>更高级的bean装配第五谈</title>
    <url>/uncategorized/2020/05/05/%E6%9B%B4%E9%AB%98%E7%BA%A7%E7%9A%84bean%E8%A3%85%E9%85%8D%E7%AC%AC%E4%BA%94%E8%B0%88.html</url>
    <content><![CDATA[<p>更高级的bean装配第五谈</p>
<hr>
<h4 id="在运行时向方法中装配-注入值"><a href="#在运行时向方法中装配-注入值" class="headerlink" title="在运行时向方法中装配/注入值"></a>在运行时向方法中装配/注入值</h4><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">需求：避免在声明bean时使用硬编码；</span><br><span class="line">手段：使原来硬编码的值推迟到运行时再确定；</span><br><span class="line">具体方法：Spring提供的再运行时求值的方式</span><br><span class="line">    <span class="number">1</span> 属性占位符（<span class="keyword">Property</span><span class="title"> </span>placeholder）</span><br><span class="line">    <span class="number">2</span> Spring表达式语言（SpEL）</span><br></pre></td></tr></table></figure>

<h5 id="使用属性表达式来动态注入值"><a href="#使用属性表达式来动态注入值" class="headerlink" title="使用属性表达式来动态注入值"></a>使用属性表达式来动态注入值</h5><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">手段SOP：</span><br><span class="line">    <span class="number">1</span> 把属性单独定义到一个properties文件中（外部文件）</span><br><span class="line">    <span class="number">2</span> 在java配置类中加载属性文件到Spring的Environment中</span><br><span class="line">    <span class="number">3</span> 在java代码中从Environment中获取到属性值————用于替换占位符所占的位置</span><br><span class="line">参考：EnvironmentConfig</span><br></pre></td></tr></table></figure>

<hr>
<p>Spring中的Environment实例：getProperty()方法的各种重载</p>
<hr>
<h6 id="在xml配置文件中使用属性占位符"><a href="#在xml配置文件中使用属性占位符" class="headerlink" title="在xml配置文件中使用属性占位符"></a>在xml配置文件中使用属性占位符</h6><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">SOP:</span><br><span class="line">	<span class="number">1</span> 在java配置类中声明PropertySourcesPlaceholderConfigurer这个bean；</span><br><span class="line">    或者在xml配置文件中，使用context命名空间中的<span class="keyword">property</span>-placeholder元素</span><br><span class="line">	<span class="number">2</span> 在需要属性值的地方使用属性占位符</span><br><span class="line">作用：用于解析占位符；</span><br><span class="line">特征：</span><br><span class="line">    <span class="number">1</span> 把值得注入操作推迟到运行时；</span><br><span class="line">    <span class="number">2</span> 属性表达式需要放在$&#123;xxx&#125;中</span><br><span class="line">原理：根据名称来解析来自于Spring Environment和属性源中的属性值</span><br></pre></td></tr></table></figure>

<hr>
<h6 id="使用SpEL表达式来动态注入值"><a href="#使用SpEL表达式来动态注入值" class="headerlink" title="使用SpEL表达式来动态注入值"></a>使用SpEL表达式来动态注入值</h6><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">作用：把一个变量装配到bean的方法中</span><br><span class="line">特征：变量的值在运行时才会计算出来</span><br><span class="line">用法：</span><br><span class="line">    <span class="number">1</span> SpEL表达式要放在#&#123;xxx&#125;中</span><br><span class="line">    <span class="number">2</span> 引用字面量的值</span><br><span class="line">    <span class="number">3</span> 引用bean、属性以及方法</span><br><span class="line">    <span class="number">4</span> 访问类作用域的方法与常量：T()运算符   语法：T(java类型)</span><br><span class="line">    <span class="number">5</span> 使用运算符来创建复杂的表达式</span><br><span class="line">        使用三目运算符来检查<span class="literal">null</span>值</span><br><span class="line">    <span class="number">6</span> 匹配正则表达式的模式</span><br><span class="line">    <span class="number">7</span> 计算集合</span><br><span class="line">太强不记 有点子像正则表达式哈</span><br></pre></td></tr></table></figure>

<p>it’s running late,call it a day~</p>
]]></content>
  </entry>
  <entry>
    <title>更高级的bean装配第四谈</title>
    <url>/uncategorized/2020/05/05/%E6%9B%B4%E9%AB%98%E7%BA%A7%E7%9A%84bean%E8%A3%85%E9%85%8D%E7%AC%AC%E5%9B%9B%E8%B0%88.html</url>
    <content><![CDATA[<p>更高级的bean装配第四谈</p>
<hr>
<h4 id="Spring中bean实例的作用域"><a href="#Spring中bean实例的作用域" class="headerlink" title="Spring中bean实例的作用域"></a>Spring中bean实例的作用域</h4><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">说明：Spring应用上下文中的<span class="keyword">bean默认都是单例的；</span></span><br><span class="line"><span class="keyword">单例：一个类就只会创建一个bean实例；</span></span><br><span class="line"><span class="keyword">特征：</span></span><br><span class="line"><span class="keyword"> </span>   <span class="number">1</span> <span class="keyword">bean实例没有状态，对所有的其他bean都是一样的；</span></span><br><span class="line"><span class="keyword"> </span>   <span class="number">2</span> 能够在应用中反复使用；</span><br></pre></td></tr></table></figure>

<p>pickle：如果对象需要保持自己的状态，这时候再反复重用就行不通了（单例作用域也就不适用了）</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">解决手段：</span><br><span class="line">Spring为bean实例提供了多种作用域；</span><br><span class="line">    <span class="number">1</span> 单例：整个应用中，就只有一个bean实例；[这是默认的作用域]</span><br><span class="line">    <span class="number">2</span> 原型：</span><br><span class="line">        <span class="number">01</span> 每次注入/装配时，</span><br><span class="line">        <span class="number">02</span> 每次通过Spring容器获取时，都会创建一个新的bean实例</span><br><span class="line">    <span class="number">3</span> 会话：</span><br><span class="line">        为web应用中的每一个会话创建一个bean实例；</span><br><span class="line">        特征：适用于购物车需求</span><br><span class="line">    <span class="number">4</span> 请求：</span><br><span class="line">        在Web应用中，为每个请求创建一个bean实例；</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">需求：在配置Bean时，手动指定bean实例的作用域；</span><br><span class="line">手段：使用<span class="meta">@Scope</span>注解声明bean实例的作用域</span><br><span class="line">参见：Notepad.java</span><br><span class="line">    <span class="comment">// 获取可配置的bean工厂的静态常量xxx作为注解的参数</span></span><br><span class="line">    <span class="meta">@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span> <span class="comment">// 手动指定bean实例的作用域</span></span><br></pre></td></tr></table></figure>



<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">需求：Web应用中的购物车；</span><br><span class="line">参考：<span class="module-access"><span class="module"><span class="identifier">ShoppingCart</span>.</span></span>java</span><br><span class="line">作用：每个会话中，只会有一个购物车实例；</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">需求：把会话&#x2F;请求作用域的bean注入到单例bean中；</span><br></pre></td></tr></table></figure>

<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="string">//</span> 单例Bean</span><br><span class="line">	<span class="string">...</span> <span class="string">//</span> 装配/注入一个会话域的bean作为参数</span><br><span class="line"></span><br><span class="line"><span class="string">//</span> 会话作用域的Bean</span><br><span class="line">@Scope<span class="params">(<span class="attr">value</span>=WebApplicationContext.SCOPE_SESSION, <span class="attr">proxyMode</span>=ScopedProxyMode.INTERFACES)</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure>

<h5 id="pickle-one"><a href="#pickle-one" class="headerlink" title="pickle one:"></a>pickle one:</h5><p>1 storeService是一个单例的bean实例——它会在Spring应用上下文被加载的时候创建；<br>2 在创建1中的bean实例时，Spring会尝试把ShoppingCart bean实例注入到方法中。但是此时shoppingCart bean实例还不存在<br>说明：会话作用域的bean实例在用户登录系统创建了会话之后才会创建；</p>
<hr>
<h5 id="pickle-two"><a href="#pickle-two" class="headerlink" title="pickle two:"></a>pickle two:</h5><p>3 应用中会包含多个shoppingCart的Bean实例，注入setter方法的时候。使用任何一个具体的bean都不好</p>
<h4 id="Spring给出的解决方案：proxyMode属性"><a href="#Spring给出的解决方案：proxyMode属性" class="headerlink" title="Spring给出的解决方案：proxyMode属性"></a>Spring给出的解决方案：proxyMode属性</h4><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">原理：不装配/注入某个具体的bean实例，而是注入一个bean的代理；</span><br><span class="line">特征：</span><br><span class="line">        <span class="number">1</span> 客户端可以无差别地像使用目标对象一样使用代理</span><br><span class="line">        <span class="number">2</span> 当调用shoppingCart的方法时，代理会对此调用进行懒加载</span><br><span class="line">        <span class="number">3</span> 代理会把调用委托给会话作用域中真正的bean</span><br></pre></td></tr></table></figure>



<hr>
<p>proxyMode语义说明：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="attribute">proxyMode</span>=ScopedProxyMode.INTERFACES</span><br><span class="line">语义：声明代理需要实现xxx接口； 基于xxx接口的代理</span><br><span class="line">这里的xxx就是方法的返回值</span><br></pre></td></tr></table></figure>

<p>如果方法的返回值不是接口类型，而是具体类型呢？</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">手段：以生成目标类扩展的方式创建代理；</span><br><span class="line">具体方法：<span class="selector-tag">ScopedProxyMode</span><span class="selector-class">.TARGET_CLASS</span></span><br></pre></td></tr></table></figure>

<hr>
<p>ProxyMode是如何解决上面的pickle one + two的？</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">pickle1</span>：进行注入时，购物车的<span class="keyword">bean实例还不存在；</span></span><br><span class="line"><span class="keyword">解决手段：对方法调用进行懒解析，从而延迟注入的操作</span></span><br></pre></td></tr></table></figure>



<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">pickle2</span>：注入<span class="keyword">bean时，不应该注入具体的bean。而应该注入当前会话中的bean实例</span></span><br><span class="line"><span class="keyword">解决手段：不是注入具体的bean实例，而是注入一个代理对象</span></span><br></pre></td></tr></table></figure>



<h4 id="XML的替换方案"><a href="#XML的替换方案" class="headerlink" title="XML的替换方案"></a>XML的替换方案</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">使用xml来配置会话作用域/请求作用域的bean：</span></span><br><span class="line"><span class="number">1</span> <span class="string">配置bean为会话作用域；</span></span><br><span class="line"><span class="string">手段：bean元素的scope属性；</span></span><br><span class="line"><span class="number">2</span> <span class="string">如何设置代理模式呢？</span></span><br><span class="line"><span class="string">手段：Spring</span> <span class="string">aop命名空间的&lt;aop:scoped-proxy&gt;元素</span></span><br><span class="line"><span class="string">作用：告诉Spring为bean创建一个作用域代理；</span></span><br><span class="line"><span class="string">特征：</span></span><br><span class="line">    <span class="number">1</span> <span class="string">默认情况下会使用CGLib来创建目标类的代理；</span></span><br><span class="line">    <span class="number">2</span> <span class="string">通过添加proxy-target-class=false，可以指定Spring生成基于接口的代理；</span></span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>更高级的bean装配第三谈</title>
    <url>/uncategorized/2020/05/05/%E6%9B%B4%E9%AB%98%E7%BA%A7%E7%9A%84bean%E8%A3%85%E9%85%8D%E7%AC%AC%E4%B8%89%E8%B0%88.html</url>
    <content><![CDATA[<p>更高级的bean装配第三谈</p>
<hr>
<p>自动装配面临的问题：进行装配时，如果有多个bean实例满足需求，装配进来哪一个呢？</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line">场景：</span><br><span class="line">自动装配一个setter()方法，装配进一个接口类型的参数；</span><br><span class="line">该接口类型有多个实现类；</span><br><span class="line">所有的实现类都添加了<span class="meta">@Component</span>注解；</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">说明：注入Bean时出现歧义的情况是非常罕见的；</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="当出现多个满足需求的bean实例时，可以有下面这些个解决方案："><a href="#当出现多个满足需求的bean实例时，可以有下面这些个解决方案：" class="headerlink" title="当出现多个满足需求的bean实例时，可以有下面这些个解决方案："></a>当出现多个满足需求的bean实例时，可以有下面这些个解决方案：</h5><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">手段<span class="number">1</span> 标志出首选的bean</span><br><span class="line">具体方法：使用@Primary注解标识一个指定的bean</span><br></pre></td></tr></table></figure>



<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">手段<span class="number">2</span>：使用Spring提供的限定符@Qualifier(<span class="string">"bean id"</span>)</span><br><span class="line">特征：</span><br><span class="line">    <span class="number">1</span> 能够把满足条件的bean限定到只有一个</span><br><span class="line">    <span class="number">2</span> 依赖于String类型的参数，所以无法应对Bean的类名被重构的情况</span><br></pre></td></tr></table></figure>



<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">手段<span class="number">3</span>：创建并使用自定义的限定符注解</span><br><span class="line">特征：</span><br><span class="line">    <span class="number">1</span> 在注入依赖的位置，可以使用多个自定义的限定符————把目标Bean的可选范围缩小到<span class="number">1</span>个</span><br><span class="line">    <span class="number">2</span> 不再显式指定依赖关系，而是使用自定义的特性限定符来指定；</span><br><span class="line">    <span class="number">3</span> setter()方法与具体的Dessert实现进行解耦；</span><br></pre></td></tr></table></figure>



]]></content>
  </entry>
  <entry>
    <title>更高级的Bean装配第二谈</title>
    <url>/uncategorized/2020/05/05/%E6%9B%B4%E9%AB%98%E7%BA%A7%E7%9A%84Bean%E8%A3%85%E9%85%8D%E7%AC%AC%E4%BA%8C%E8%B0%88.html</url>
    <content><![CDATA[<p>更高级的Bean装配第二谈</p>
<hr>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">对<span class="keyword">Bean进行条件化地管理</span></span><br><span class="line"><span class="keyword">根据指定条件是否成立来决定是否创建某个bean实例；</span></span><br></pre></td></tr></table></figure>



<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">什么叫条件化地管理？</span><br><span class="line">    只有在满足特定条件后，才会创建对应的bean</span><br><span class="line">常见的条件：</span><br><span class="line">    <span class="number">1</span> 应用类路径下包含特定的库；</span><br><span class="line">    <span class="number">2</span> 另一个相关bean被声明为Spring组件；</span><br><span class="line">    <span class="number">3</span> 某个特定的环境变量绑定了值；</span><br><span class="line">    ...</span><br><span class="line">实现手段：@<span class="constructor">Conditional(<span class="params">xxx</span>)</span></span><br><span class="line"></span><br><span class="line">应用案例：对于MagicBean类，只有当magic环境属性绑定值后，才创建它的bean实例；否则不创建bean实例</span><br><span class="line">参考：<span class="module-access"><span class="module"><span class="identifier">MagicConfig</span>.</span></span>java</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">@Conditional(xxx)的参数说明:</span><br><span class="line">    <span class="number">1</span> xxx是实现了Condition接口的一个具体实现类的Class对象；</span><br><span class="line">    <span class="number">2</span> Condition接口中，只有一个抽象方法<span class="built_in">bool</span>ean matches(ConditionContext context, AnnotatedTypeMetadata metadata);</span><br><span class="line">    <span class="number">3</span> 从context参数中就能得到所有期望的条件参数...</span><br><span class="line">    太多不看</span><br><span class="line">注：使用IDEA能够快捷地追踪源码,但源码一般比较抽象。能看出大概是在做什么就可以了</span><br></pre></td></tr></table></figure>

<p><img src="C:%5CUsers%5CHenryInSH%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200505175236602.png" alt="image-20200505175236602"></p>
<p><img src="C:%5CUsers%5CHenryInSH%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200505175305356.png" alt="image-20200505175305356"></p>
<p><img src="C:%5CUsers%5CHenryInSH%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200505175341452.png" alt="image-20200505175341452"></p>
<p><img src="C:%5CUsers%5CHenryInSH%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200505175452986.png" alt="image-20200505175452986"></p>
<hr>
<p>extra bonus</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">Spring4中,@Profile()注解是使用@Conditional()注解来实现的</span></span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>更高级的bean配置第一谈</title>
    <url>/uncategorized/2020/05/05/%E6%9B%B4%E9%AB%98%E7%BA%A7%E7%9A%84bean%E9%85%8D%E7%BD%AE%E7%AC%AC%E4%B8%80%E8%B0%88.html</url>
    <content><![CDATA[<p>更高级的bean配置第一谈</p>
<hr>
<p>应用：根据那个激活的profile来决定是否要创建某个bean；</p>
<p>说明：同一个项目，在不同的阶段，某个bean实例的获取方式可能是不一样的；</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">开发时的常见操作（表示没用过）：</span><br><span class="line">    使用嵌入式数据库；</span><br><span class="line">    作用：快速获取到一个dataSource，并预先加载测试数据；</span><br><span class="line">    参考：EmbeddedDatabaseBuilder</span><br><span class="line"></span><br><span class="line">生产环境中的常见操作：</span><br><span class="line">    使用<span class="keyword">JNDI从容器中获取一个DataSource；</span></span><br><span class="line"><span class="keyword"> </span>   作用：由容器决定如何创建这个DataSource；</span><br><span class="line">    特征：</span><br><span class="line">        有一定的复杂性</span><br><span class="line"></span><br><span class="line">QA环境中的常见操作：</span><br><span class="line">    其他获取dataSource的方式</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="Problem-amp-Solution"><a href="#Problem-amp-Solution" class="headerlink" title="Problem &amp; Solution"></a>Problem &amp; Solution</h4><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">现象说明：不同环境中的某一个<span class="keyword">bean实例可能会有所不同。</span></span><br><span class="line"><span class="keyword">解决思路：通过某种技术，使得dataSource能够在不同的环境下选择对应的配置；</span></span><br><span class="line"><span class="keyword">实现手段1：单独配置每一种bean实例，然后在构建时决定把哪一个bean实例的配置编译到可部署的应用中</span></span><br><span class="line"><span class="keyword">特征：</span></span><br><span class="line"><span class="keyword"> </span>   需要重复地构建应用</span><br><span class="line"></span><br><span class="line">实现手段<span class="number">2</span>：Spring提供的profile <span class="keyword">bean；</span></span><br><span class="line"><span class="keyword">作用：根据环境来决定该创建哪一个bean；</span></span><br><span class="line"><span class="keyword">特征：</span></span><br><span class="line"><span class="keyword"> </span>   <span class="number">1</span> 在运行时才确定使用哪一个<span class="keyword">bean的配置；</span></span><br><span class="line"><span class="keyword"> </span>   <span class="number">2</span> 这使得同一个部署包适用于所有的环境，部署时不需要重新进行构建；</span><br></pre></td></tr></table></figure>



<hr>
<p>Spring提供的profile bean用法SOP：</p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">用法SOP:</span><br><span class="line">    <span class="number">1</span> 把所有的bean定义添加到/绑定到一个<span class="keyword">profile</span>中；</span><br><span class="line">    手段：在配置类/方法上添加@Profile(<span class="string">"dev"</span>)注解；</span><br><span class="line">    作用：告诉Spring，当前配置类中的bean/方法所绑定的bean[使用@Bean声明]只有在dev <span class="keyword">profile</span>激活时才会创建</span><br><span class="line">    参考：DataSourceConfig.java</span><br><span class="line">    特征：</span><br><span class="line">        <span class="number">1</span> 对于添加了@Profile的bean：当指定的<span class="keyword">profile</span>被激活时，它修饰的bean才会被创建</span><br><span class="line">        <span class="number">2</span> 没有添加@Profile的bean：总是会被创建</span><br><span class="line">        <span class="number">3</span> 通过XML配置文件能完成同样的功能（略）</span><br><span class="line"></span><br><span class="line">    <span class="number">2</span> 在把应用部署到指定环境时，确保该环境对应的<span class="keyword">profile</span>处于激活状态</span><br><span class="line">    手段：设置 spring.profiles.active / spring.<span class="keyword">profile</span>.<span class="keyword">default</span> 这个属性的值；</span><br><span class="line">    如何设置这两个属性的值呢？</span><br><span class="line">    推荐方式：使用DispatcherServlet的参数来把spring.<span class="keyword">profile</span>.<span class="keyword">default</span>设置为开发环境的<span class="keyword">profile</span></span><br><span class="line">    具体方法<span class="number">1</span>：在servlet上下文（web.xml）中进行设置</span><br><span class="line">        参考：web.xml</span><br><span class="line">            <span class="variable">&lt;servlet&gt;</span></span><br><span class="line">                <span class="variable">&lt;init-param&gt;</span></span><br><span class="line">                    <span class="variable">&lt;param-name&gt;</span>xxx&lt;/param-name&gt;</span><br><span class="line">                ...</span><br><span class="line">            ...</span><br><span class="line">        特征：</span><br><span class="line">            <span class="number">1</span> 项目中的所有成员拉取代码后，都能使用开发环境的设置来运行代码。不需要任何额外的配置</span><br><span class="line">            <span class="number">2</span> 在部署项目到其他环境时，部署人员可以再对应设置spring.profiles.active属性的值</span><br></pre></td></tr></table></figure>

<hr>
<p>启示：xml文件可以在项目上直接进行改动。不需要对项目进行重新构建</p>
<hr>
<p>功能测试： </p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">测试说明：</span><br><span class="line">在我指定激活了某个<span class="keyword">profile</span>后：</span><br><span class="line">	<span class="number">1</span> 绑定到此<span class="keyword">profile</span>上的bean是否被正常创建；</span><br><span class="line">	<span class="number">2</span> 绑定到其他<span class="keyword">profile</span>上的bean是否符合预期——没有被创建；</span><br><span class="line">	<span class="number">3</span> 没有绑定任何<span class="keyword">profile</span>的bean是否仍旧正常创建；</span><br></pre></td></tr></table></figure>



<p>需求：在运行测试代码时，指定要激活的某个profile；</p>
<p>手段：Spring提供的<strong>@ActiveProfiles(“dev”)</strong>注解</p>
<hr>
<p>see this in a higher view</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">任务：根据<span class="string">"那个激活的profile"</span>来决定是否要创建某个<span class="keyword">bean；</span></span><br><span class="line"><span class="keyword">手段：1 </span>把<span class="keyword">bean添加到某个profile中； </span><span class="number">2</span> 在web.xml中声明被激活的profile；</span><br><span class="line"></span><br><span class="line">任务扩展：根据<span class="string">"指定的条件"</span>来决定是否要创建某个<span class="keyword">bean；</span></span><br><span class="line"><span class="keyword">手段：条件化的bean</span></span><br></pre></td></tr></table></figure>



<p>emoji: 😄</p>
]]></content>
  </entry>
  <entry>
    <title>Spring中bean的创建&amp;装配（第三谈）</title>
    <url>/uncategorized/2020/05/05/Spring%E4%B8%ADbean%E7%9A%84%E5%88%9B%E5%BB%BA&amp;%E8%A3%85%E9%85%8D%EF%BC%88%E7%AC%AC%E4%B8%89%E8%B0%88%EF%BC%89.html</url>
    <content><![CDATA[<p>Spring中bean的创建&amp;装配（第三谈）</p>
<hr>
<h4 id="方式3：使用xml文件进行配置"><a href="#方式3：使用xml文件进行配置" class="headerlink" title="方式3：使用xml文件进行配置"></a>方式3：使用xml文件进行配置</h4><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">SOP</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">1</span> <span class="string">创建一个xml文件；</span></span><br><span class="line">    <span class="attr">2</span> <span class="string">在文件顶部声明多个XML模式文件（XSD）————这些文件指定了在xml文件中的可用标签</span></span><br><span class="line">    <span class="attr">3</span> <span class="string">在spring-bean模式下添加beans元素————作为所有bean配置的根元素；</span></span><br><span class="line">    <span class="attr">4</span> <span class="string">在beans中声明所有需要Spring bean实例的配置</span></span><br></pre></td></tr></table></figure>



<h5 id="实现手段1：构造器方式注入-装配-DI"><a href="#实现手段1：构造器方式注入-装配-DI" class="headerlink" title="实现手段1：构造器方式注入/装配/DI"></a>实现手段1：构造器方式注入/装配/DI</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">声明构造器方式的DI（注入引用）</span></span><br><span class="line">    <span class="string">ref属性</span></span><br><span class="line">    <span class="string">ConstructorArgReferenceTest-context.xml</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">使用c命名空间声明构造器DI(注入引用)</span></span><br><span class="line">    <span class="string">c:xx-ref="bean</span> <span class="string">id"</span></span><br><span class="line">    <span class="string">CNamespaceReferenceTest-context.xml</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">声明构造器方式的DI(注入字面量值)：</span></span><br><span class="line">    <span class="string">value="xxx"</span></span><br><span class="line"><span class="string">说明：c命名空间会有另一套规则</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">构造器方式的DI(装配字面量集合):</span></span><br><span class="line">    <span class="string">&lt;constructor-arg&gt;</span></span><br><span class="line">        <span class="string">&lt;list&gt;</span></span><br><span class="line">            <span class="string">&lt;value&gt;...&lt;/value&gt;</span></span><br><span class="line">            <span class="string">...</span></span><br><span class="line">        <span class="string">&lt;/list&gt;</span></span><br><span class="line">    <span class="string">&lt;...&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">构造器方式的DI(装配引用集合)</span></span><br><span class="line">    <span class="string">...</span></span><br><span class="line">        <span class="string">...</span></span><br><span class="line">            <span class="string">&lt;ref&gt;...&lt;/ref&gt;</span></span><br><span class="line"><span class="string">说明：在装配集合时，constructor-arg原生元素比c命名空间更好用</span></span><br></pre></td></tr></table></figure>



<hr>
<h5 id="实现手段2：属性设置方式的注入-装配-DI"><a href="#实现手段2：属性设置方式的注入-装配-DI" class="headerlink" title="实现手段2：属性设置方式的注入/装配/DI"></a>实现手段2：属性设置方式的注入/装配/DI</h5><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">通过setter方法注入依赖</span><br><span class="line">原则：对强依赖使用构造器注入，对可选性的依赖使用setter注入；</span><br><span class="line">用法：</span><br><span class="line">    &lt;<span class="keyword">property</span> <span class="built_in">name</span>=<span class="string">"属性名"</span> <span class="keyword">ref</span>=<span class="string">"bean id"</span>/&gt;</span><br><span class="line"></span><br><span class="line">setter注入的替换方案：p-命名空间</span><br><span class="line">又是一套烦人的语法</span><br></pre></td></tr></table></figure>



<hr>
<p>多种配置方式的共用</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line"><span class="comment">-----------</span></span><br><span class="line">多种装配方式的混用mix</span><br><span class="line">说明：显式的xml配置总是必不可少，因为自动扫描+装配的方式需要先启动注解扫描<span class="keyword">context</span>:<span class="keyword">component</span>-sacn；</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>Spring中Bean的创建&amp;装配（第二谈）</title>
    <url>/uncategorized/2020/05/05/Spring%E4%B8%ADBean%E7%9A%84%E5%88%9B%E5%BB%BA&amp;%E8%A3%85%E9%85%8D%EF%BC%88%E7%AC%AC%E4%BA%8C%E8%B0%88%EF%BC%89.html</url>
    <content><![CDATA[<p>Spring中Bean的创建与装配（第二谈）</p>
<hr>
<p>方式2：使用java配置类</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="attribute">SOP</span>:</span><br><span class="line">    <span class="number">1</span> 声明一个配置类</span><br><span class="line">    手段：<span class="variable">@Configuration</span></span><br><span class="line">    <span class="number">2</span> 在配置类中声明bean</span><br><span class="line">    手段：编写一个方法，方法会返回需要类型的bean实例；</span><br><span class="line">    <span class="number">3</span> 声明方法的返回对象要作为Spring组件；</span><br><span class="line">    手段：<span class="variable">@Bean</span></span><br><span class="line">特征：方法体中可以使用任意的java语法</span><br></pre></td></tr></table></figure>

<p>bean的引用id</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">默认情况下，bean实例的ID与<span class="meta">@Bean</span>所注解的方法名相同；</span><br><span class="line">需求：手动指定bean实例的ID</span><br><span class="line">手段：<span class="meta">@Bean(name=<span class="meta-string">"《预期为bean实例指定的ID》"</span>)</span></span><br></pre></td></tr></table></figure>

<p>对bean实例进行装配</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">对声明的<span class="keyword">bean进行装配：</span></span><br><span class="line"><span class="keyword">手段01：通过“引用创建bean的方法”来装配；</span></span><br><span class="line"><span class="keyword">特征：</span></span><br><span class="line"><span class="keyword"> </span>   <span class="number">1</span> 每次方法调用得到的都是同一个<span class="keyword">bean实例；</span></span><br><span class="line"><span class="keyword"> </span>   <span class="number">2</span> 不推荐使用</span><br><span class="line">原理：</span><br><span class="line">    Spring会拦截对方法的调用：</span><br><span class="line">        如果Spring容器中已经存在了对应的<span class="keyword">bean实例，就直接返回。</span></span><br><span class="line"><span class="keyword"> </span>       如果不存在<span class="keyword">bean实例，才对方法进行调用。从而创建bean实例</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">手段02：在声明Bean时，通过方法参数指定要装配的bean；</span></span><br><span class="line"><span class="keyword">说明：这是DI的一种方式</span></span><br><span class="line"><span class="keyword">特征：</span></span><br><span class="line"><span class="keyword"> </span>   <span class="number">1</span> 由于使用方法参数，所以要装配的<span class="keyword">bean可以从外部注入；</span></span><br><span class="line"><span class="keyword"> </span>   <span class="number">2</span> 由于从外部注入，待装配的<span class="keyword">bean可以使用其他方式配置（自动扫描 </span><span class="keyword">OR </span>XML配置）</span><br><span class="line">    <span class="number">3</span> 这是推荐的方式</span><br></pre></td></tr></table></figure>

<p>DI的几种方式</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">DI（注入依赖）的几种实现方式：</span><br><span class="line"><span class="number">1</span> 构造器注入</span><br><span class="line"><span class="number">2</span> setter()方法注入</span><br><span class="line"><span class="number">3</span> 其他注入方式</span><br><span class="line"></span><br><span class="line">注入的本质上都是给bean属性绑定值</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>Spring中的Bean创建&amp;装配</title>
    <url>/uncategorized/2020/05/05/Spring%E4%B8%AD%E7%9A%84Bean%E5%88%9B%E5%BB%BA&amp;%E8%A3%85%E9%85%8D.html</url>
    <content><![CDATA[<h3 id="Spring中的Bean创建-amp-装配"><a href="#Spring中的Bean创建-amp-装配" class="headerlink" title="Spring中的Bean创建&amp;装配"></a>Spring中的Bean创建&amp;装配</h3><hr>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">装配（wiring）：建立应用中不同bean之间的依赖关系/关联关系；</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">任务：完成装配的工作；</span></span><br><span class="line"><span class="string">实现手段：DI</span></span><br><span class="line"><span class="string">具体方法：</span></span><br><span class="line">    <span class="number">1</span> <span class="string">在XML显示配置装配关系</span></span><br><span class="line">    <span class="number">2</span> <span class="string">在java中显示配置装配关系</span></span><br><span class="line">    <span class="number">3</span> <span class="string">使用Spring的bean发现</span> <span class="string">&amp;</span> <span class="string">自动装配技术</span></span><br></pre></td></tr></table></figure>



<p>方式1 自动发现 + 自动装配</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> Spring的自动化装配<span class="keyword">bean技术</span></span><br><span class="line"><span class="keyword">原理：① </span>发现<span class="keyword">bean </span>+ ② 建立<span class="keyword">bean之间的依赖关系</span></span><br><span class="line"><span class="keyword">手段：</span></span><br><span class="line"><span class="keyword"> </span>   ① 组件扫描（component <span class="keyword">scanning）：Spring框架通过扫描操作来发现由Spring容器/应用上下文所创建的bean</span></span><br><span class="line"><span class="keyword"> </span>   ② 自动装配（autowiring）：Spring框架根据发现的<span class="keyword">bean来建立bean之间的依赖关系</span></span><br><span class="line"><span class="keyword">疑问：</span></span><br><span class="line"><span class="keyword"> </span>   <span class="number">1</span> 有哪些工作是Spring完成的？</span><br><span class="line">    <span class="number">2</span> 我作为一个程序员，需要做哪些操作？</span><br><span class="line">    <span class="number">3</span> 我做的这些个操作具体是什么作用？</span><br><span class="line"></span><br><span class="line">用法：</span><br><span class="line">    参考：对音响系统中的组件进行装配；</span><br><span class="line">    CompactDisc.<span class="keyword">java </span>压缩碟片 CD</span><br></pre></td></tr></table></figure>



<h4 id="验证Spring上下文是否为Spring组件创建了bean"><a href="#验证Spring上下文是否为Spring组件创建了bean" class="headerlink" title="验证Spring上下文是否为Spring组件创建了bean"></a>验证Spring上下文是否为Spring组件创建了bean</h4><hr>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">音响系统的组件列表：</span></span><br><span class="line">    <span class="number">1</span> <span class="string">CD：音乐容器</span></span><br><span class="line">    <span class="string">参考：CompactDisc</span></span><br><span class="line">    <span class="number">2</span> <span class="string">CD</span> <span class="string">Player：播放CD的工具</span></span><br><span class="line"></span><br><span class="line"><span class="string">Spring要完成的工作：</span></span><br><span class="line">    <span class="number">1</span> <span class="string">发现项目中有@Component注解的类；</span></span><br><span class="line">    <span class="number">2</span> <span class="string">为这些个类创建其Spring</span> <span class="string">bean；</span></span><br><span class="line">    <span class="number">3</span> <span class="string">装配这些bean的依赖关系？</span></span><br><span class="line"></span><br><span class="line"><span class="string">程序员要做的工作：</span></span><br><span class="line">    <span class="number">1</span> <span class="string">为预期会交给Spring管理的类添加@Component注解</span></span><br><span class="line">        <span class="string">参考：SgtPeppers.java</span></span><br><span class="line">    <span class="number">2</span> <span class="string">在Spring配置文件中，手动开启组件扫描</span></span><br><span class="line">        <span class="string">手段1：CDPlayerConfig.java</span> <span class="string">[这是通过java配置类来开启组件扫描]</span></span><br><span class="line">        <span class="string">手段2：soundsystem.xml</span> <span class="string">[这是通过xml的方式来开启组件扫描]</span></span><br><span class="line">    <span class="number">3</span> <span class="string">需要装配的时候，使用@Autowired来声明依赖关系/注入依赖</span></span><br></pre></td></tr></table></figure>



<p>测试过程</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">测试：</span><br><span class="line">    在把CompactDisc声明为Spring组件后，Spring容器/上下文有没有创建出这个组件的实例呢？</span><br><span class="line">手段：Junit单元测试</span><br><span class="line">参考：<span class="module-access"><span class="module"><span class="identifier">CDPlayerTest</span>.</span></span>java</span><br><span class="line">SOP:</span><br><span class="line">    <span class="number">1</span> 使用JUnit框架完成两件事：</span><br><span class="line">        Ⅰ 自动创建Spring上下文的实例</span><br><span class="line">        Ⅱ 指定在什么地方加载配置信息</span><br><span class="line">    <span class="number">2</span> 在Test中注入需要被测试的Spring组件：</span><br><span class="line">        @Autowired</span><br><span class="line">        xxx</span><br><span class="line">    <span class="number">3</span> 在测试方法中，查看这个Spring组件的bean实例有没有被创建出来</span><br><span class="line">        <span class="keyword">assert</span><span class="constructor">NotNull(<span class="params">cd</span>)</span>; <span class="comment">// Junit所提供的方法</span></span><br></pre></td></tr></table></figure>



<hr>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">拾遗：</span><br><span class="line">    声明Spring组件：<span class="meta">@Component</span></span><br><span class="line">    java配置类：<span class="meta">@Configuration</span></span><br><span class="line">    开启组件扫描：<span class="meta">@Component</span> + <span class="string">context:</span>component-scan</span><br><span class="line">    实现自动装配：<span class="meta">@Autowired</span></span><br><span class="line">目的：使Spring上下文能够：</span><br><span class="line">    ① 自动发现Spring组件；</span><br><span class="line">    ② 创建它们的bean实例；</span><br><span class="line">    ③ 管理这些bean实例之间的依赖关系（aka 装配工作）</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="更多注解相关的细节"><a href="#更多注解相关的细节" class="headerlink" title="更多注解相关的细节"></a>更多注解相关的细节</h4><h5 id="指定bean实例的引用"><a href="#指定bean实例的引用" class="headerlink" title="指定bean实例的引用"></a>指定bean实例的引用</h5><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">引用<span class="keyword">bean实例：</span></span><br><span class="line"><span class="keyword">对于Spring通过组件扫描所创建的bean实例————bean实例的默认id：类名的首字母小写；</span></span><br><span class="line"><span class="keyword">需求：手动指定bean实例的id：</span></span><br><span class="line"><span class="keyword">手段：@Component("《预期的id》")</span></span><br></pre></td></tr></table></figure>



<h5 id="自动装配的规则"><a href="#自动装配的规则" class="headerlink" title="自动装配的规则"></a>自动装配的规则</h5><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">建立组件之间的依赖关系：自动装配</span><br><span class="line">原理：Spring会根据指定规则,在Spring容器中查找bean01所需要的其他bean</span><br><span class="line">手段：@Autowired注解</span><br><span class="line">具体方法：</span><br><span class="line">    <span class="number">1</span> 在类A的有参构造方法上使用@Autowired注解</span><br><span class="line">    作用：Spring上下文在创建类A的实例bean时，会自动创建类B的实例bean。并注入到构造器中</span><br><span class="line"></span><br><span class="line">    <span class="number">2</span> 在setter方法上使用@Autowired注解</span><br><span class="line">    作用：Spring上下文在初始化时，会尽可能满足bean的依赖；</span><br><span class="line"></span><br><span class="line">    <span class="number">3</span> 用在其他方法上...</span><br><span class="line">说明：Spring会尝试满足方法参数所声明的依赖；</span><br><span class="line">注入成功的条件：Spring应用上下文中有且只有一个bean满足依赖需求；</span><br><span class="line">装配不成功：</span><br><span class="line">    <span class="number">1</span> Spring上下文中没有找到符合条件的依赖bean：</span><br><span class="line">        结果：抛出一个异常；</span><br><span class="line">        说明：使用required=<span class="literal">false</span>能够避免这种情况下抛出异常</span><br><span class="line">    <span class="number">2</span> Spring上下文中有多个bean满足依赖需求：</span><br><span class="line">        结果：Spring无法决定使用哪个实例bean进行注入，抛出异常</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>Spring初体验</title>
    <url>/uncategorized/2020/05/05/Spring%E5%88%9D%E4%BD%93%E9%AA%8C.html</url>
    <content><![CDATA[<h3 id="Spring初体验"><a href="#Spring初体验" class="headerlink" title="Spring初体验"></a>Spring初体验</h3><hr>
<p>降低bean之间的耦合程度：DI</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> 在配置文件中装配/声明bean之间的关系：</span><br><span class="line">    定义应用的多个组件之间的依赖关系/协作关系；</span><br><span class="line">Spring中实现装配的方式：</span><br><span class="line">    <span class="number">1</span> 使用XML配置文件；</span><br><span class="line">    参考：knight.xml</span><br><span class="line">    <span class="number">2</span> 使用java类来描述配置；</span><br><span class="line">    参考：KnightConfig.java</span><br></pre></td></tr></table></figure>



<hr>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span> 装载XML配置文件到Spring容器/上下文，然后启动应用</span><br><span class="line">任务：装载<span class="keyword">bean的定义到Spring容器并把多个bean按照指定关系组装起来；</span></span><br><span class="line"><span class="keyword">Spring提供的手段：应用上下文（Application </span>Context）；</span><br><span class="line">说明：Spring提供了多种应用上下文的具体实现————这些实现对应于不同的配置方式<span class="comment">;</span></span><br><span class="line">参考：KnightMain.java</span><br><span class="line">    Ⅰ 加载配置文件到应用上下文实例中</span><br><span class="line">    Ⅱ 从应用上下文实例中获取到配置的指定<span class="keyword">bean</span></span><br><span class="line"><span class="keyword"> </span>   Ⅲ 调用<span class="keyword">bean的方法</span></span><br><span class="line"><span class="keyword"> </span>   Ⅳ 关闭上下文对象</span><br><span class="line"></span><br><span class="line">装配的过程是使用DI实现的——DI能够使各个组件保持松散耦合</span><br></pre></td></tr></table></figure>



<hr>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">3</span> <span class="string">专注于业务逻辑————分离出横切关注点（面向切面编程）</span></span><br><span class="line"><span class="meta">常见的横切关注点（aka</span> <span class="string">大家都会用到的功能，最好能够单独提取出来。被所有方法复用）：</span></span><br><span class="line">    <span class="attr">1</span> <span class="string">日志；</span></span><br><span class="line">    <span class="attr">2</span> <span class="string">事务管理；</span></span><br><span class="line">    <span class="attr">3</span> <span class="string">安全；</span></span><br><span class="line"><span class="attr">手段：AOP；</span></span><br><span class="line"><span class="attr">用法：</span></span><br><span class="line">    <span class="attr">1</span> <span class="string">实现横切关注点；</span></span><br><span class="line">    <span class="attr">2</span> <span class="string">以声明的方式添加关注点/切面到指定连接点处；</span></span><br><span class="line"><span class="attr">特征：</span></span><br><span class="line">    <span class="attr">1</span> <span class="string">业务代码更加专注————代码中完全不需要处理任何的横切关注点；</span></span><br><span class="line">    <span class="attr">2</span> <span class="string">横切关注点可以添加在多个方法/连接点上；</span></span><br><span class="line"><span class="attr">参考：</span></span><br><span class="line">    <span class="attr">Minstrel</span> <span class="string">吟游诗人（一个POJO类）</span></span><br><span class="line">    <span class="attr">BraveKnight</span> <span class="string">游侠骑士</span></span><br><span class="line"><span class="attr">SOP</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">1</span> <span class="string">把minstrel声明为一个切面；</span></span><br><span class="line">    <span class="attr">参考：minstrel.xml</span></span><br><span class="line">        <span class="meta">添加aop</span>:<span class="string">aspect命名空间</span></span><br><span class="line">        <span class="attr">添加bean到Spring管理</span></span><br><span class="line">        <span class="attr">添加bean的切面相关信息：</span></span><br><span class="line">            <span class="attr">切点（多个连接点）、前置通知、后置通知</span></span><br><span class="line">    <span class="attr">特征：</span></span><br><span class="line">        <span class="attr">1</span> <span class="string">Minstrel仍旧是一个POJO类；</span></span><br><span class="line">        <span class="attr">2</span> <span class="string">在XML配置后，这个POJO类就成了Spring中的一个切面；</span></span><br><span class="line">        <span class="attr">3</span> <span class="string">Minstrel与Knight之间没有任何相互调用的代码 aka 没有直接耦合</span></span><br><span class="line">        <span class="attr">由于配置文件的存在，Knight与Minstrel组件之间被解除耦合了</span></span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">Spring简化<span class="keyword">java开发第4弹————消除样板(boilerplate)代码；</span></span><br><span class="line"><span class="keyword">手段：Spring内置的模板</span></span><br><span class="line"><span class="keyword">说明：尽管java </span>APIs提供了统一的编程规范，但是它同样也产生了大量重复的<span class="keyword">boilerplate代码</span></span><br><span class="line"><span class="keyword">参考：使用java </span><span class="keyword">JDBC原生提供的APIs编写代码操作数据库 </span>VS. 使用Spring提供的模板来操作数据库</span><br><span class="line">注：一般在项目中会直接集成第三方的框架（MyBatis等）</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p> Spring容器</p>
</blockquote>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">Spring</span>中的大管家：Spring容器</span><br><span class="line">作用：管理Spring中所有的<span class="keyword">bean对象（CRUD </span><span class="keyword">and </span>more~）</span><br><span class="line">特征：</span><br><span class="line">    <span class="number">1</span> Spring容器借助DI管理<span class="keyword">bean之间的关系；</span></span><br><span class="line"><span class="keyword"> </span>   <span class="number">2</span> Spring提供的容器实现有两种大类：<span class="keyword">beanFactory（基础容器） </span>VS. ApplicationContext（更高级的容器）</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">Spring中应用上下文的具体实现：</span><br><span class="line">    说明：这些实现类的不同在于————加载应用上下文的方式不同</span><br><span class="line">    <span class="number">1</span> AnnotationConfigApplicationContext<span class="comment">;   加载应用上下文的方式：java配置类</span></span><br><span class="line">    <span class="number">2</span> AnnotationConfigWebApplicationContext<span class="comment">;    加载Web应用上下文？？？</span></span><br><span class="line">    <span class="number">3</span> ClassPathXmlApplicationContext<span class="comment">;       加载应用上下文的方式：类路径中的xml配置文件</span></span><br><span class="line">    <span class="number">4</span> FileSystemXmlApplicationContext<span class="comment">;      加载应用上下文的方式：文件系统中的xml配置文件</span></span><br><span class="line">    <span class="number">5</span> XmlWebApplicationContext<span class="comment">;     加载应用上下文的方式：Web应用中的xml配置文件</span></span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">获取到应用上下文实例之后，如何使用这个容器来管理bean的声明周期呢？</span><br><span class="line">Spring容器管理下bean生命周期（比较费劲）：</span><br><span class="line">    <span class="number">1</span> 实例化；</span><br><span class="line">    <span class="number">2</span> 填充属性/初始化；</span><br><span class="line">    <span class="number">3</span> 调用BeanNameAware的setBeanName()方法；</span><br><span class="line">    <span class="number">4</span> 调用BeanFactoryAware的setBeanFactory()方法；</span><br><span class="line">    <span class="number">5</span> 调用ApplicationContextAware的setApplicationContext()方法；</span><br><span class="line">    ---</span><br><span class="line">    <span class="number">6</span> 调用BeanPostProcessor的预初始化方法；</span><br><span class="line">    <span class="number">7</span> 调用InitializingBean的afterPropertiesSet()方法；</span><br><span class="line">    <span class="number">8</span> 调用自定义的初始化方法；</span><br><span class="line">    <span class="number">9</span> 调用BeanPostProcessor的后初始化方法；</span><br><span class="line">    --- bean能够正常使用了</span><br><span class="line">    <span class="number">10</span> 容器关闭时，调用DisposableBean的destroy()方法</span><br><span class="line">    <span class="number">11</span> 调用自定义的销毁方法</span><br><span class="line">    注：程序员还可以根据自己需要再添加新的生命阶段</span><br></pre></td></tr></table></figure>



<p>源码备注：<a href="https://www.manning.com/books/spring-in-action-fourth-edition">https://www.manning.com/books/spring-in-action-fourth-edition</a></p>
<p>注：使用Gradle工具构建的项目，可能会踩一些莫名其妙的坑。这时候你需要了解一下Gradle的用法</p>
]]></content>
  </entry>
  <entry>
    <title>Spring的特征——面向切面</title>
    <url>/uncategorized/2020/05/04/Spring%E7%9A%84%E7%89%B9%E5%BE%81%E2%80%94%E2%80%94%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2.html</url>
    <content><![CDATA[<h3 id="Spring的特征——面向切面"><a href="#Spring的特征——面向切面" class="headerlink" title="Spring的特征——面向切面"></a>Spring的特征——面向切面</h3><hr>
<p>编程过程中的横切关注点：多个方法的公共需求</p>
<p>任务：在业务代码/方法上，添加横切关注点所代表的功能；</p>
<p>手段1：继承；</p>
<p>手段2：委托；</p>
<p>手段3：把公共的功能（横切关注点）处理成为一个切面类；</p>
<hr>
<p>用法SOP：</p>
<ol>
<li><p>定义通用的功能；</p>
</li>
<li><p>在某个地方声明此功能会被添加到什么地方；</p>
<p>特征：</p>
</li>
</ol>
<p>特征：</p>
<pre><code>1. 多个横切关注点/通用功能能够放在一起管理——这会极大地节省程序员维护代码所用的时间；
 2. 通用功能的代码不会混在逻辑代码中——这样逻辑代码会更易读；</code></pre><hr>
<p>AOP相关的术语：</p>
<p>通知（advice）：切面/横切关注点所表示的功能 &amp; 使用切面的时机；</p>
<p>通知有好几种类型，这个请查词典</p>
<p>连接点（Join point）：切面可以插入的代码位置 aka 程序运行的特定时刻；</p>
<p>切点（PointCut）：指定通知所添加到的连接点的规则——通知会作用到哪一些连接点；</p>
<p>切面（Aspect）：描述横切关注点的功能 &amp; 此功能发挥作用的时机 &amp; 应用此功能的地方； 切面 = 通知（what when） + 切点(where)</p>
<p>引入（introduction）：向现有类添加新方法或属性的行为；</p>
<p>织入（weaving）：把切面应用到目标对象，并创建新的代理对象的过程；</p>
<p>切面类在指定的连接点被织入目标对象中；</p>
<hr>
<p>编译期：切面在目标类编译时就被织入。</p>
<p>特征：这需要特殊的编译器。</p>
<p>类加载期： 切面在目标类加载到JVM时被织入；</p>
<p>特征：这需要特殊的类加载器；</p>
<p>运行期：切面在应用运行的某个时刻被织入；</p>
<p>特征：Spring AOP就是采用运行期织入的方式；</p>
<hr>
<p>Spring 对AOP的几种实现：</p>
<p>1 POJO切面；</p>
<p>把一个自定义的POJO类指定为切面类；</p>
<p>特征：</p>
<pre><code>1. POJO类只是定义了满足切点条件时会被调用的方法
 2. 需要使用XML进行一些需要的配置；</code></pre><p>2 注解驱动的AOP；</p>
<p>特征：这种方式不需要使用XML配置文件；</p>
<hr>
<p>关于Spring AOP框架的一些东西：</p>
<p>1 Spring通知（what &amp; when）</p>
<p>1.1 Spring框架创建的通知都是使用java类编写的；</p>
<p>SO?</p>
<pre><code>1. 可以像开发Java类一样来开发切面（开发AspectJ则需要学习新的内容）</code></pre><p>1.2 定义通知所应用到的切点（where）；</p>
<p>手段1：使用注解；</p>
<p>手段2：在Spring配置文件中使用XML编写；</p>
<p>2 Spring是在运行时把切面织入到目标对象中的；</p>
<p>原理：</p>
<p>​    2.1 Spring会给目标对象创建一个代理对象——这个代理</p>
<p>对象会使用切面包裹目标类（增强）</p>
<p>​    2.2 当程序员调用目标类的方法时，代理类会对此方法的调用</p>
<p>进行拦截，在真正执行目标对象的方法之前，先执行切面逻辑；</p>
<p>3 Spring只支持方法级别的连接点 aka 在方法调用时，可以织入</p>
<p>切面的方法增强</p>
<p>原因：Spring是基于动态代理来实现的AOP，因此只能对方法调用进行拦截；</p>
<hr>
<p>定义切点：指定应用切面的位置（where） aka 那些个匹配切点规则的连接点</p>
<p>手段：使用AspectJ的切点表达式；</p>
<p>特征：Spring支持的AspectJ切点有限，只是xxx的一个子集；</p>
<hr>
<p>编写切点：</p>
<p>该死，这一章既然没有源码…</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个用于织入切面的主题（主题上的各种方法操作都可以作为连接点）</span></span><br><span class="line"><span class="comment">// 表演类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Performance</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">perform</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">任务：在perform()方法被调用时，自动调用指定的通知（advice）</span><br><span class="line">手段：自定义一个切点表达式来声明规则；</span><br><span class="line">	execution(* concert.Performance.perform(..))</span><br><span class="line">    语法：AspectJ指示器(返回类型 方法所属的类.方法(连接点方法所使用的参数))</span><br><span class="line">    execution()指示器用来[what &amp; when]:匹配作为连接点的方法的执行操作；</span><br><span class="line">    * 表示不关心方法的返回值是啥</span><br><span class="line">    类全限定名.方法名(..) ..表示匹配任意入参的perform()方法</span><br></pre></td></tr></table></figure>



<p>this is for now,这种复杂的规则不是用来记忆的，而是用来查询的。</p>
]]></content>
  </entry>
  <entry>
    <title>drill01</title>
    <url>/uncategorized/2020/05/04/drill01.html</url>
    <content><![CDATA[<h3 id="如何使用java代码在控制台打印出hello-world"><a href="#如何使用java代码在控制台打印出hello-world" class="headerlink" title="如何使用java代码在控制台打印出hello world!"></a>如何使用java代码在控制台打印出hello world!</h3><hr>
<ol>
<li><p>创建一个类（Test.java文件）</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span>&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span>&#123;</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"Hello World!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<hr>
<ol start="2">
<li><p>参考文献</p>
<blockquote>
<p>java编程思想</p>
</blockquote>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>我的第二篇博客文章</title>
    <url>/uncategorized/2020/05/03/%E6%88%91%E7%9A%84%E7%AC%AC%E4%BA%8C%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0.html</url>
    <content><![CDATA[<h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><p>内容</p>
<hr>
<h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><p>内容</p>
]]></content>
  </entry>
  <entry>
    <title>我的第一篇博客文章</title>
    <url>/uncategorized/2020/04/12/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0.html</url>
    <content><![CDATA[<h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><p>内容</p>
<hr>
<h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><p>内容</p>
<hr>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="http://www.codepig.cn">www.codepig.cn</a></p>
]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/uncategorized/2020/04/12/hello-world.html</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
</search>
