<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Git在工作场景中的用法</title>
    <url>/Git/2021/02/06/%E6%95%99%E7%A8%8B%E7%B1%BB%E7%9A%84%E6%93%8D%E4%BD%9C%E4%B8%8E%E8%AE%A4%E8%AF%86/Github%E4%B8%8E%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/20210206-Git%E5%9C%A8%E5%B7%A5%E4%BD%9C%E5%9C%BA%E6%99%AF%E4%B8%AD%E7%9A%84%E7%94%A8%E6%B3%95.html</url>
    <content><![CDATA[<h4 id="Git的使用方式与用法理解"><a href="#Git的使用方式与用法理解" class="headerlink" title="Git的使用方式与用法理解"></a>Git的使用方式与用法理解</h4><h5 id="Git工作流程（宏观）"><a href="#Git工作流程（宏观）" class="headerlink" title="Git工作流程（宏观）"></a>Git工作流程（宏观）</h5><a id="more"></a>

<p><img src="https://s3.ax1x.com/2021/02/06/yYXLZQ.jpg" alt="本地仓库 &amp; 远程仓库之间的交互"></p>
<h6 id="terms（i-know-this-is-a-lot-just-bear-with-me）"><a href="#terms（i-know-this-is-a-lot-just-bear-with-me）" class="headerlink" title="terms（i know this is a lot, just bear with me）:"></a>terms（i know this is a lot, just bear with me）:</h6><blockquote>
<ul>
<li>远程仓库（Remote repo）一般在Github、Bitbucket这样的公共平台上的repository；</li>
<li>本地仓库(local repo) 是本地电脑上的一个文件夹，由于其中的/.git隐藏子文件夹而成为了git认识的repository——Git就是使用它来对文件夹中的文件进行有效的版本管理</li>
<li>提交(commit) n./v., 用于 汇总对一系列文件的改动——这样Git就能够把这些改动作为一个单位来管理<ul>
<li>每次commit操作都会有一个单独的ID，用来标识这一次的提交操作；</li>
</ul>
</li>
<li>分支（branch） 由一连串的commit所构成的链条——Git用它来记录/表示项目沿着时间轴不断变化的历史<ul>
<li>在Git中，每个分支都是一个独立的区域。aka 如果你自己创建了一个分支，在这个分支上不管你做了什么，都不会对别人产生影响</li>
</ul>
</li>
<li>master、feature 这是Git中比较通用的分支名称。比如master分支就是公共分支（所有开发者共同维护）、feature分支就是功能分支（由某个开发者负责具体实现）…<ul>
<li>分支的名字可以由程序员自己指定，但是在指定时应该遵守一定的规则（能够达到见名知意）</li>
</ul>
</li>
<li>～～～ 分隔本地环境 与 远端环境，这意味着它两边的单元交互/沟通需要通过网络;</li>
<li>git xxx 这是由Git提供的命令，通过这些命令你能够方便地执行一些自己想要的操作;</li>
<li>PR(pull request) 这是远端 请求把分支A 的commits合并到分支B 的操作。<ul>
<li>为啥不直接把本地的commits 直接push到分支B呢？<ul>
<li>你只是一个普通的开发者，能不能marge，管理员要检查的呀<ul>
<li>管理员怎么检查？<ul>
<li>Github/Bitbucket对git diff都进行了页面化的封装呀…</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h6 id="phaseⅠ-从远端拉取仓库到本地；"><a href="#phaseⅠ-从远端拉取仓库到本地；" class="headerlink" title="phaseⅠ 从远端拉取仓库到本地；"></a>phaseⅠ 从远端拉取仓库到本地；</h6><blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git clone &lt;remote_repo_address&gt; </span><br></pre></td></tr></table></figure>

<p> note that:</p>
<ul>
<li>1 you need ask the admin of this repo add you as the group name first, manually;</li>
<li>2 normally, with this executed. you will have all repo info in your local machine. but somehow, you only have one branch(the default branch) on your local 🙋</li>
</ul>
</blockquote>
<h6 id="phaseⅡ-使用默认分支来-在本地创建一个新的分支"><a href="#phaseⅡ-使用默认分支来-在本地创建一个新的分支" class="headerlink" title="phaseⅡ 使用默认分支来 在本地创建一个新的分支"></a>phaseⅡ 使用默认分支来 在本地创建一个新的分支</h6><blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git checkout -b &lt;newly_create_branch&gt;</span><br></pre></td></tr></table></figure>

<p>note that:</p>
<ul>
<li>1 weirdly, the git command used to create a new branch is ‘git checkout’. what the word ‘checkout’ even means?! there’s gotta be some bureaucrary here 😠</li>
<li>2 this <newly_create_branch> name should be decriptive. means you know what this branch is about by its name</li>
</ul>
</blockquote>
<h6 id="phaseⅢ-在你自己的分支上改动、再改动、喝杯咖啡🍻接着改动"><a href="#phaseⅢ-在你自己的分支上改动、再改动、喝杯咖啡🍻接着改动" class="headerlink" title="phaseⅢ 在你自己的分支上改动、再改动、喝杯咖啡🍻接着改动"></a>phaseⅢ 在你自己的分支上改动、再改动、喝杯咖啡🍻接着改动</h6><blockquote>
<p>这个是与业务有关的工作，与Git的流程没有直接关联</p>
</blockquote>
<h6 id="phaseⅣ-把你所做的改动放到一次commit中，然后push到远端的同名分支"><a href="#phaseⅣ-把你所做的改动放到一次commit中，然后push到远端的同名分支" class="headerlink" title="phaseⅣ 把你所做的改动放到一次commit中，然后push到远端的同名分支"></a>phaseⅣ 把你所做的改动放到一次commit中，然后push到远端的同名分支</h6><blockquote>
<p>桥豆麻袋，现在远端还没有叫我这个名字的分支(比如feature_generate_qr_code)，怎么办？</p>
<p>答：可以在推送分支到远端时，在远端创建一个名字相同的分支；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git push -u origin &lt;same_name_as_local_newly_created_branch&gt;</span><br></pre></td></tr></table></figure>

<p>note that:</p>
<ul>
<li>这里的-u是为了设置本地分支xxx与远程分支xxx的上下游关系，这样在下次push时就不需要指定远端的分支名字了</li>
<li>origin这里表示的就是 远端仓库地址(origin是一种被Git接受的简写形式)</li>
</ul>
</blockquote>
<h6 id="phaseⅤ-在远端的平台上，创建一个从-xxx分支-到-目标分支的PR，然后口头通知管理员"><a href="#phaseⅤ-在远端的平台上，创建一个从-xxx分支-到-目标分支的PR，然后口头通知管理员" class="headerlink" title="phaseⅤ 在远端的平台上，创建一个从 xxx分支 到 目标分支的PR，然后口头通知管理员"></a>phaseⅤ 在远端的平台上，创建一个从 xxx分支 到 目标分支的PR，然后口头通知管理员</h6><blockquote>
<p>note 这个功能其实不是Git提供的，而是由Github这样的管理网站提供的</p>
</blockquote>
<h5 id="Git工作流程-微观"><a href="#Git工作流程-微观" class="headerlink" title="Git工作流程(微观)"></a>Git工作流程(微观)</h5><p><img src="https://s3.ax1x.com/2021/02/06/ytkGxH.jpg" alt="在本地电脑上的git操作流程"></p>
<h6 id="terms"><a href="#terms" class="headerlink" title="terms"></a>terms</h6><blockquote>
<p>1 工作区(workspace)  你修改文件的工作空间（比如说IDEA，VS Code等）</p>
<p>2 暂存区(staging area) 一个用于临时存储被编辑文件的空间，用于定制化地批量处理多个文件；</p>
<p>3 版本库(git repo commit history) 一个管理得非常好的仓库，管理着每一次commit操作的结果；</p>
</blockquote>
<h6 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h6><blockquote>
<p>phaseⅠ 在编辑器中对代码疯狂CRUD，然后本地对功能进行测试；</p>
<ul>
<li>从开发安全性的角度，在本地建议使用小步提交的方式。这样能够细致地管理自己的实现过程</li>
<li>但是在推送到远端的时候，你可能并不想一下推送这么多微小功能的commit。怎么办？🙋</li>
</ul>
</blockquote>
<blockquote>
<p>phaseⅡ 在git-bash/编辑器中集成的terminal黑窗口中，把被改动的文件按照自己的预期添加到暂存区</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git add xxx ooo iii</span><br></pre></td></tr></table></figure>

<p>note that:</p>
<ul>
<li>1 you have loads of variation based on ‘git add’ to suit your need. just google them</li>
<li>2 for those files you never want to be managed by Git, there is some approach git provide named gitignore, please google it</li>
</ul>
</blockquote>
<blockquote>
<p>phaseⅢ 把暂存区中的文件列表 提交到 历史版本仓库中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git commit -m <span class="string">'&lt;descriptive message&gt;'</span> -m <span class="string">'&lt;if you are really proud of yourself&gt;'</span></span><br></pre></td></tr></table></figure>

<p>note that:</p>
<ul>
<li>1 you do not need specify any files here, since it would commit all the files in staging area;</li>
<li>2 -m is short for message;</li>
<li>3 that <message> part usually contains what you have done and why you done that</li>
</ul>
</blockquote>
<h5 id="Git工作流程-推荐做法"><a href="#Git工作流程-推荐做法" class="headerlink" title="Git工作流程(推荐做法)"></a>Git工作流程(推荐做法)</h5><p><img src="https://s3.ax1x.com/2021/02/06/ytZCy4.jpg" alt="保持本地的分支是最新的分支 aka 与master分支的最新提交保持一致"></p>
<h6 id="terms-1"><a href="#terms-1" class="headerlink" title="terms"></a>terms</h6><blockquote>
<p>there’s no new term in this diagram 😄</p>
</blockquote>
<h6 id="工作流程（保持本地代码最新）"><a href="#工作流程（保持本地代码最新）" class="headerlink" title="工作流程（保持本地代码最新）"></a>工作流程（保持本地代码最新）</h6><blockquote>
<p>phaseⅠ 从远端拉取 master分支最新的commit 到 本地的master分支；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git pull [origin master]</span><br></pre></td></tr></table></figure>

<p>note that:</p>
<ul>
<li>1 normally, the master branch’s upstream relationship is set as default. therefore, you do not type ‘origin master’;</li>
<li>2 if you do want to specify one perticular remote branch as the pull source, the grammar would go like ‘git pull origin <remote_branch>:<local_branch>‘</li>
</ul>
</blockquote>
<blockquote>
<p>phase Ⅱ 在本地，把master分支上的最新提交 合并到 feature分支;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git checkout &lt;feature_branch&gt; <span class="comment">// switch to feature branch</span></span><br><span class="line">xxx(feature)git diff master <span class="comment">// compare the difference between feature_branch and master_branch</span></span><br><span class="line">xxx(feature)git merge master <span class="comment">// merge all the newly commits in master_branch into feature_branch</span></span><br></pre></td></tr></table></figure>

<p>note that:</p>
<p>1 weirdly, to switch to another branch. you need to use ‘git checkout’, again, what ‘checkout’ even means? 😳</p>
<p>2 the later two command can be tricky for you may not sure which one is objective and which one is subjective. just remember, to whom -&gt; (whom) …</p>
</blockquote>
<h5 id="Merge-Confilct在Git工作流中出现的情况"><a href="#Merge-Confilct在Git工作流中出现的情况" class="headerlink" title="Merge Confilct在Git工作流中出现的情况"></a>Merge Confilct在Git工作流中出现的情况</h5><p><img src="https://s3.ax1x.com/2021/02/06/ytnATs.jpg" alt="henry对文件index.html第47行的改动做了一次提交 紧跟着quinta也对index.html第47行的改动做了一次提交"></p>
<h6 id="Statement"><a href="#Statement" class="headerlink" title="Statement"></a>Statement</h6><blockquote>
<p>出现冲突并不是Git的锅。在多人协作的场景下，就有可能出现多个人在相邻的提交中，修改了某一个文件中的同一行。这时候如果版本管理工具不分青红皂白地 直接覆盖掉 时间上比较靠前的commit 中的文件的改动，就可能导致 该commit的开发者的工作成果被抹掉 然后开发者就要大家 世界就不再和平了 </p>
<p>所以Git选择把冲突的细节抛出来，开发者们当面锣、对面鼓地合计合计用谁的代码更好 </p>
</blockquote>
<h6 id="场景重现"><a href="#场景重现" class="headerlink" title="场景重现"></a>场景重现</h6><blockquote>
<p>多人开发场景，现在有程序员henry、quinta以及cassie</p>
<p>phaseⅠ quinta实现了 feature_a, 其中包含了对 index.html文件第47行的改动。然后通过提PR的方式，把自己的commit(commit_quinta) 合并到了 远端的master分支；</p>
<p>phase Ⅱ henry正在实现 feature_b, 本地已经做了一次提交（commit_henry 其中也包含了对index.html文件第47行的改动）；</p>
<p>phase Ⅲ 为了让本地分支的代码最新，henry执行了命令git pull origin master（对否？？？）, 来 把远端master的最新提交 更新到自己本地的分支上</p>
<p>结果/现状：相邻的两个commit(commit_henry、commit_quinta)</p>
<ul>
<li>1 来自于两个不同的开发者henry、quinta；</li>
<li>2 并且两个commit中包含有对同一个文件同一行的改动(index.html文件的第47行)</li>
</ul>
<p>Git不知道该选择谁的代码，索性抛出问题，让henry与quinta去处理吧</p>
</blockquote>
<blockquote>
<p>处理手段：</p>
<ul>
<li>approach01：使用github的UI界面；</li>
<li>使用git-bash的黑窗口界面；</li>
<li>使用编辑器的编辑区解决冲突（推荐使用）；<ul>
<li>1 找到具体发生冲突的是哪一行代码；（How❓）</li>
<li>2 分析具体为什么发生冲突；</li>
<li>3 最终决定处理方案(使用henry的代码/使用quinta的代码/两个人的代码都留下，把一部分调整到其他行)</li>
<li>4 冲突处理完后，需要做一次提交(commit_henry_tackle_confilct)</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p>this is take a lot longer than I thought. until next time😄</p>
</blockquote>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Tools</tag>
        <tag>Git Related Info</tag>
      </tags>
  </entry>
  <entry>
    <title>Git官网信息</title>
    <url>/Git/2020/09/19/%E6%95%99%E7%A8%8B%E7%B1%BB%E7%9A%84%E6%93%8D%E4%BD%9C%E4%B8%8E%E8%AE%A4%E8%AF%86/Github%E4%B8%8E%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/20200919-Git%E5%AE%98%E7%BD%91%E4%BF%A1%E6%81%AF.html</url>
    <content><![CDATA[<h4 id="Git官网上的信息（第一手资料）"><a href="#Git官网上的信息（第一手资料）" class="headerlink" title="Git官网上的信息（第一手资料）"></a>Git官网上的信息（第一手资料）</h4><a id="more"></a>

<h5 id="主页面（官网的信息对初学者并不友好）"><a href="#主页面（官网的信息对初学者并不友好）" class="headerlink" title="主页面（官网的信息对初学者并不友好）"></a>主页面（官网的信息对初学者并不友好）</h5><ul>
<li><p>Git is a <a href="https://git-scm.com/about/free-and-open-source">free and open source</a> distributed version control system designed to handle everything from small to very large projects with speed and efficiency.</p>
<blockquote>
<p>Git是一个免费、开源的分布式版本控制系统，用于快速高效地处理小型-大型项目；</p>
</blockquote>
<blockquote>
<p>链接详情：</p>
<ul>
<li>Git开源遵守的是什么类型的许可证；<ul>
<li>作用：你可以拿Git做哪些事，又不至于违反规则；</li>
<li>特征：对你我这种不同的程序员不重要，别多想😳</li>
</ul>
</li>
</ul>
</blockquote>
</li>
<li><p>Git is <a href="https://git-scm.com/doc">easy to learn</a> and has a <a href="https://git-scm.com/about/small-and-fast">tiny footprint with lightning fast performance</a>. It outclasses SCM tools like Subversion, CVS, Perforce, and ClearCase with features like <a href="https://git-scm.com/about/branching-and-merging">cheap local branching</a>, convenient <a href="https://git-scm.com/about/staging-area">staging areas</a>, and <a href="https://git-scm.com/about/distributed">multiple workflows</a>.</p>
<blockquote>
<p>Git很容易学习并且占用空间很小（tiny footprint），速度快。</p>
<p>它超越了很多SCM（Software configuration management）工具（比如Subversion, CVS, 其他同类品）,具体原因在于<strong>快捷的本地分支</strong>、<strong>方便的暂存区</strong>、<strong>多个工作流</strong>；</p>
</blockquote>
</li>
</ul>
<h6 id="链接详情1：easy-to-learn"><a href="#链接详情1：easy-to-learn" class="headerlink" title="链接详情1：easy to learn"></a>链接详情1：<a href="https://git-scm.com/doc">easy to learn</a></h6><blockquote>
<ul>
<li>1 使用手册/cheat sheet；</li>
<li>2 书；</li>
<li>3 视频；</li>
</ul>
<p>我就纳闷了，要是容易学的话。还需要一本书吗？🙋</p>
</blockquote>
<h6 id="链接详情2：tiny-footprint-with-lightning-fast-performance"><a href="#链接详情2：tiny-footprint-with-lightning-fast-performance" class="headerlink" title="链接详情2：tiny footprint with lightning fast performance"></a>链接详情2：<a href="https://git-scm.com/about/small-and-fast">tiny footprint with lightning fast performance</a></h6><blockquote>
<p><strong>Git is fast</strong>. With Git, nearly all operations are performed locally, giving it a huge speed advantage on centralized systems that constantly have to communicate with a server somewhere.</p>
<p>Git was built to work on the Linux kernel, meaning that it has had to effectively handle large repositories from day one. Git is written in C, reducing the overhead of runtimes associated with higher-level languages. Speed and performance has been a primary design goal of the Git from the start.</p>
</blockquote>
<blockquote>
<p>翻译：</p>
<p>Git很快. 使用Git时,几乎所有的操作都是在本地执行的—比起集中式的系统，这给了Git一个巨大的速度优势（因为集中式的系统总是会与某个远程的服务器执行网络操作）</p>
<p>Git是为了在Linux内核上工作而创建的,这意味着它一开始就必须能够有效地处理大的仓库;</p>
<p>Git是用C语言写成的，这减少了使用高级语言时会产生的运行时开销；</p>
<p>速度与性能是设计Git时考虑的首要目标；</p>
</blockquote>
<hr>
<blockquote>
<p>Let’s see how common operations <strong>stack up against</strong> Subversion, a common centralized version control system that is similar to CVS or Perforce. <em>Smaller is faster.</em></p>
<p>翻译：让我们看一下Git在常用操作中与Subversion的比拼（Subxxx是一个常用的中心化版本控制系统,它与CVS或者Perforce这些个产品类似） 更小意味着更快</p>
</blockquote>
<p><font size=2>看不太懂的图片</font></p>
<p><img src="https://s1.ax1x.com/2020/09/19/wokO78.png" alt="对比图"></p>
<p>虽然不太清楚具体是啥意思，但是git的条状图明显低很多…</p>
<p>不过既然是在对Git和Subversion进行操作耗时比较,肯定需要准备相同的测试用例，然后进行同样的操作（初中物理之<strong>控制变量法</strong>）</p>
<blockquote>
<p>For testing, large AWS instances were set up in the same availability zone. Git and SVN were installed on both machines, the Ruby repository was copied to both Git and SVN servers, and common operations were performed on both.</p>
</blockquote>
<blockquote>
<p>测试条件：</p>
<p>1 在同一可用区域中设置了大型AWS实例；</p>
<p>2 Git和SVN都安装在这两台机器上；</p>
<p>3 Ruby存储库被复制到Git和SVN服务器上，并在这两台机器上执行常见操作。</p>
</blockquote>
<blockquote>
<p>In some cases the commands don’t match up exactly. Here, matching on the lowest common denominator was attempted. For example, the ‘commit’ tests also include the time to push for Git, though most of the time you would not actually be pushing to the server immediately after a commit where the two commands cannot be separated in SVN.</p>
</blockquote>
<blockquote>
<p>测试的不精确性说明：</p>
<p>在某些情况下，命令与预期操作并不完全匹配。所以在这里，尝试在最小公分母上进行匹配。<br>例如，“commit”测试还包括推送Git的时间——多数情况下您不会在<strong>提交</strong>之后立即<strong>推送到服务器</strong>（但是在SVN中两个命令不能分开）</p>
</blockquote>
<p>实验数据(单位为s)；</p>
<table>
<thead>
<tr>
<th>Operation</th>
<th></th>
<th align="center">Git</th>
<th align="center">SVN</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>Commit Files (A)</td>
<td>Add, commit and push 113 modified files (2164+, 2259-)</td>
<td align="center">0.64</td>
<td align="center">2.60</td>
<td>4x</td>
</tr>
<tr>
<td>Commit Images (B)</td>
<td>Add, commit and push a thousand 1 kB images</td>
<td align="center">1.53</td>
<td align="center">24.70</td>
<td>16x</td>
</tr>
<tr>
<td>Diff Current</td>
<td>Diff 187 changed files (1664+, 4859-) against last commit</td>
<td align="center">0.25</td>
<td align="center">1.09</td>
<td>4x</td>
</tr>
<tr>
<td>Diff Recent</td>
<td>Diff against 4 commits back (269 changed/3609+,6898-)</td>
<td align="center">0.25</td>
<td align="center">3.99</td>
<td>16x</td>
</tr>
<tr>
<td>Diff Tags</td>
<td>Diff two tags against each other (v1.9.1.0/v1.9.3.0)</td>
<td align="center">1.17</td>
<td align="center">83.57</td>
<td>71x</td>
</tr>
<tr>
<td>Log (50)</td>
<td>Log of the last 50 commits (19 kB of output)</td>
<td align="center">0.01</td>
<td align="center">0.38</td>
<td>31x</td>
</tr>
<tr>
<td>Log (All)</td>
<td>Log of all commits (26,056 commits – 9.4 MB of output)</td>
<td align="center">0.52</td>
<td align="center">169.20</td>
<td>325x</td>
</tr>
<tr>
<td>Log (File)</td>
<td>Log of the history of a single file (array.c – 483 revs)</td>
<td align="center">0.60</td>
<td align="center">82.84</td>
<td>138x</td>
</tr>
<tr>
<td>Update</td>
<td>Pull of Commit A scenario (113 files changed, 2164+, 2259-)</td>
<td align="center">0.90</td>
<td align="center">2.82</td>
<td>3x</td>
</tr>
<tr>
<td>Blame</td>
<td>Line annotation of a single file (array.c)</td>
<td align="center">1.91</td>
<td align="center">3.04</td>
<td>1x</td>
</tr>
</tbody></table>
<p><font size=2>同样这里的操作先不逐一解释，只是看实验数据</font></p>
<blockquote>
<p>Note that this is the best case scenario for SVN—a server with no load with a gigabit connection to the client machine. Nearly all of these times would be even worse for SVN if that connection was slower, while many of the Git times would not be affected.</p>
</blockquote>
<blockquote>
<p>留意对于SVN来说，这是最好的情况—一个与客户机有千兆位连接的无负载服务器。</p>
<p>如果这个允许链接的数量更低一些，那么：</p>
<ul>
<li>SVN几乎所有操作的时间数据都会变得更糟；</li>
<li>但是Git的许多操作都不会受到影响。</li>
</ul>
</blockquote>
<blockquote>
<p>Clearly, in many of these common version control operations, <strong>Git is one or two orders of magnitude faster than SVN</strong>, even under ideal conditions for SVN.</p>
</blockquote>
<blockquote>
<p>显然，在许多常见的版本控制操作中，Git比SVN快一到两个数量级，即使在SVN的理想条件下也是如此。</p>
</blockquote>
<blockquote>
<p>One place where Git is slower is in the initial clone operation. Here, Git is downloading the entire history rather than only the latest version. As seen in the above charts, it’s not considerably slower for an operation that is only performed once.</p>
</blockquote>
<blockquote>
<p>但是有一个操作Git会更慢一些（比起SVN）：初始的克隆操作；在这个操作中,Git会下载整个历史不只是当前的最新版本。</p>
<p>从上面的图表可以看出，对于一个只会执行一次的操作，它还不算太慢；</p>
</blockquote>
<table>
<thead>
<tr>
<th>Operation</th>
<th></th>
<th align="center">Git*</th>
<th align="center">Git</th>
<th align="center">SVN</th>
</tr>
</thead>
<tbody><tr>
<td>Clone</td>
<td>Clone and shallow clone(*) in Git vs checkout in SVN</td>
<td align="center">21.0</td>
<td align="center">107.5</td>
<td align="center">14.0</td>
</tr>
<tr>
<td>Size (MB)</td>
<td>Size of total client side data and files after clone/checkout (in MB)</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<blockquote>
<p>It’s also interesting to note that the size of the data on the client side is very similar even though Git also has every version of every file for the entire history of the project. This illustrates how efficient it is at compressing and storing data on the client side.</p>
</blockquote>
<blockquote>
<p>有趣的是，尽管Git还拥有项目整个历史中每个文件的每个版本，但客户端的数据大小非常相似。</p>
<p>这说明了它在客户端压缩和存储数据的效率。</p>
</blockquote>
<h6 id="链接详情3：-cheap-local-branching"><a href="#链接详情3：-cheap-local-branching" class="headerlink" title="链接详情3： cheap local branching"></a>链接详情3： <a href="https://git-scm.com/about/branching-and-merging">cheap local branching</a></h6><ul>
<li>分支与合并</li>
</ul>
<blockquote>
<p>The Git feature that really makes it <strong>stand apart from</strong> nearly every other SCM out there is its branching model.</p>
<p>Git allows and encourages you to have multiple local branches that can be entirely independent of each other. The creation, merging, and deletion of those lines of development takes seconds.</p>
</blockquote>
<blockquote>
<p>Git所以区别于其他的SCM(Software configuration management)工具的主要原因在于：它的分支模型；</p>
<p>Git允许/鼓励你持有多个相互独立的本地分支；</p>
<p>这些个分支（开发线）的创建、合并与删除都只是几秒钟的工作；</p>
</blockquote>
<ul>
<li>分支模型的作用</li>
</ul>
<blockquote>
<p>This means that you can do things like:</p>
<ul>
<li><strong>Frictionless Context Switching</strong>. <ul>
<li>Create a branch to try out an idea, commit a few times, switch back to where you branched from, apply a patch, switch back to where you are experimenting, and merge it in.</li>
</ul>
</li>
<li><strong>Role-Based Codelines</strong>. Have a branch that always contains only what goes to production, another that you merge work into for testing, and several smaller ones for day to day work.</li>
</ul>
</blockquote>
<blockquote>
<p>这意味着你可以做下面这样的事情:</p>
<ul>
<li>简单的上下文切换.<ul>
<li>创建一个分支来尝试一个新的想法，提交几次改动，然后切换回创建分支的地方，应用一个补丁（🚩），切换回你正在进行试验的地方，把实验的恭喜合并到主分支；</li>
</ul>
</li>
<li>基于角色的代码行；<ul>
<li>创建一个分支：这个分支中只包含会提交到生产环境中的代码；</li>
<li>创建另一个分支：这个分支用于用于合并新添加的功能后进行测试；</li>
<li>创建其他几个分支：这些个分支用于日常工作，aka，小功能的开发；</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><strong>Feature Based Workflow</strong>. Create new branches for each new feature you’re working on so you can seamlessly switch back and forth between them, then delete each branch when that feature gets merged into your main line.</li>
<li><strong>Disposable Experimentation</strong>. Create a branch to experiment in, realize it’s not going to work, and just delete it - abandoning the work—with nobody else ever seeing it (even if you’ve pushed other branches in the meantime).</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>基于功能特性的工作流.<ul>
<li>为每一个你正在开发的新功能创建一个新的分支，这样你可以在这些分支之间<strong>无缝地/无顾忌地</strong>来回切换。并且在把功能合并到代码主分支之后，就可以删除该功能对应的分支</li>
</ul>
</li>
<li>一次性的实验.<ul>
<li>创建一个分支用来试验一些想法，然后发现这个想法行不通，接着就可以把这个分支删除掉—放弃那些失败的尝试—甚至都不会有人看到它；</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/09/20/wouzy4.png" alt="Git中的分支模型"></p>
<blockquote>
<p>Notably, when you push to a remote repository, you do not have to push all of your branches. You can choose to share just one of your branches, a few of them, or all of them. This tends to free people to try new ideas without worrying about having to plan how and when they are going to merge it in or share it with others.</p>
<p>There are ways to accomplish some of this with other systems, but the work involved is much more difficult and <strong>error-prone</strong>. Git makes this process incredibly easy and it changes the way most developers work when they learn it.</p>
</blockquote>
<blockquote>
<p>值得注意的是，当你推送代码到远程仓库时，你不需要推送你的所有分支。</p>
<p>你可以选择分享你的某一个分支/其中几个分支或是所有的分支。</p>
<p>这样的话，团队中的其他成员在尝试新的想法时，就不需要担心应该在何时，以何种方式把新的想法合并或者分享给其他人；</p>
</blockquote>
<blockquote>
<p>在其他系统中,也有一些手段能够实现这些功能，但是所涉及的工作要困难得多，而且容易出错。</p>
<p>Git使这个过程非常简单，它改变了大多数开发人员学习它时的工作方式。</p>
</blockquote>
<h6 id="链接详情4：staging-areas"><a href="#链接详情4：staging-areas" class="headerlink" title="链接详情4：staging areas"></a>链接详情4：<a href="https://git-scm.com/about/staging-area">staging areas</a></h6><blockquote>
<p>Unlike the other systems, Git has something called the “staging area” or “index”. This is an intermediate area where commits can be formatted and reviewed before completing the commit.</p>
<p>One thing that <strong>sets Git apart from</strong> other tools is that it’s possible to quickly <strong>stage</strong> some of your files and commit them without committing all of the other modified files in your working directory or having to list them on the command line during the commit.</p>
</blockquote>
<blockquote>
<p>与其他系统不同，Git有一个叫做“临时区域”或“索引”的东西。这是一个中间区域，可以在完成提交之前,<strong>对提交的内容进行格式化和检查</strong>。</p>
<p>Git与其他工具不同的一点是，它可以<strong>快速暂存一些文件并提交它们</strong>，而无需：</p>
<ul>
<li>1 提交工作目录中的<strong>所有修改过的其他文件</strong>；</li>
<li>2 也不必在提交期间将<strong>它们</strong>列在命令行上。</li>
</ul>
</blockquote>
<p>暂存区的工作流程</p>
<p><img src="https://s1.ax1x.com/2020/09/20/woMT5q.png" alt="暂存区的SOP"></p>
<blockquote>
<p>This allows you to stage only portions of a modified file. Gone are the days of making two logically unrelated modifications to a file before you realized that you forgot to commit one of them. Now you can just stage the change you need for the current commit and stage the other change for the next commit. This feature scales up to as many different changes to your file as needed.</p>
</blockquote>
<blockquote>
<p>这允许您仅暂存<strong>已修改文件的部分内容</strong>。</p>
<p>对一个文件进行了两次逻辑上不相关的改动，然后你发现自己忘记了提交其中的某个改动。这样的事情再也不会发生了。</p>
<p>现在，您只需<strong>为当前提交准备所需的更改</strong>，并<strong>为下一次提交准备另一个更改</strong>。此功能可根据需要对文件进行多次不同的更改。</p>
</blockquote>
<blockquote>
<p>Of course, Git also makes it easy to ignore this feature if you don’t want that kind of control — just add a ‘-a’ to your commit command in order to add all changes to all files to the staging area.</p>
</blockquote>
<blockquote>
<p>当然，如果您不想要这种控制，Git还可以让您很容易忽略此功能—只需在commit命令中添加’-a’，以便将对所有文件的所有更改添加到临时区域。(这个貌似更常用吧<del>~</del>)</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/09/20/woQGLQ.png" alt="一次性提交文件中的所有改动"></p>
<h6 id="链接详情5：-multiple-workflows"><a href="#链接详情5：-multiple-workflows" class="headerlink" title="链接详情5： multiple workflows"></a>链接详情5： <a href="https://git-scm.com/about/distributed">multiple workflows</a></h6><p>Distributed(分配/分发)</p>
<blockquote>
<p>One of the nicest features of any Distributed SCM, Git included, is that it’s distributed. This means that instead of doing a “checkout” of <strong>the current tip of the source code</strong>, you do a “clone” of the entire repository.</p>
</blockquote>
<blockquote>
<p>分布式SCM工具（包括Git）的最好的一个特性就是：它是distributed的。</p>
<p>这意味着，不必对<strong>源代码的当前tip</strong>进行“签出”，而是对<strong>整个存储库</strong>进行“克隆”。</p>
</blockquote>
<blockquote>
<h6 id="Multiple-Backups"><a href="#Multiple-Backups" class="headerlink" title="Multiple Backups"></a>Multiple Backups</h6><p>This means that even if you’re using a centralized workflow, every user <strong>essentially</strong> has a full backup of the main server. Each of these copies could be pushed up to replace the main server in the event of a crash or corruption. In effect, there is no <strong>single point of failure</strong> with Git unless there is only a single copy of the repository.</p>
</blockquote>
<blockquote>
<h6 id="多个备份"><a href="#多个备份" class="headerlink" title="多个备份"></a>多个备份</h6><p>这意味着，即使您使用集中化的工作流，每个用户<strong>实际上</strong>都有主服务器的完整备份。在发生崩溃或损坏时，这些副本中的每一个都可以进行push操作以替换主服务器。实际上，Git不存在单点故障，除非存储库只有一个副本。</p>
</blockquote>
<blockquote>
<h6 id="Any-Workflow"><a href="#Any-Workflow" class="headerlink" title="Any Workflow"></a>Any Workflow</h6><p>Because of Git’s distributed nature and superb branching system, an almost endless number of workflows can be implemented with relative ease.</p>
</blockquote>
<blockquote>
<h6 id="任何工作流"><a href="#任何工作流" class="headerlink" title="任何工作流"></a>任何工作流</h6><p>由于<strong>Git的分布式特性</strong>和<strong>出色的分支系统</strong>，因此可以相对容易地实现<strong>几乎无止境的工作流</strong>。</p>
</blockquote>
<blockquote>
<h6 id="Subversion-Style-Workflow"><a href="#Subversion-Style-Workflow" class="headerlink" title="Subversion-Style Workflow"></a>Subversion-Style Workflow</h6><p>A centralized workflow is very common, especially from people transitioning from a centralized system. Git will not allow you to push if someone has pushed since the last time you fetched, so a centralized model where all developers push to the same server works just fine.</p>
</blockquote>
<blockquote>
<p>Subversion类别的工作流<br>集中化工作流是非常常见的，尤其是从集中化系统过渡的人员。</p>
<p>如果在你<strong>拉取代码</strong>之后，有其他人做了<strong>提交的操作</strong>，那么Git不允许你推送；所以一个<strong>所有开发人员都推到同一个服务器上</strong>的“集中式模型”其实就能够很好地工作。</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/09/20/wolY6O.png" alt="Subversion类别的工作流"></p>
<blockquote>
<h6 id="Integration-Manager-Workflow"><a href="#Integration-Manager-Workflow" class="headerlink" title="Integration Manager Workflow"></a>Integration Manager Workflow</h6><p>Another common Git workflow involves an integration manager — a single person who commits to the ‘blessed’ repository. A number of developers then clone from that repository, push to their own independent repositories, and ask the integrator to pull in their changes. This is the type of development model often seen with open source or GitHub repositories.</p>
</blockquote>
<blockquote>
<h6 id="Integration-Manager工作流"><a href="#Integration-Manager工作流" class="headerlink" title="Integration Manager工作流"></a>Integration Manager工作流</h6><p>另一个常见的Git工作流涉及到一个<strong>集成经理</strong>-一个提交到“受祝福”存储库的人。然后，许多开发人员<strong>从该存储库中克隆</strong>，推送到他们<strong>自己的独立存储库</strong>，并<strong>要求集成经理引入他们的更改</strong>。这是在开源或GitHub存储库中经常看到的开发模型类型。【clone - &lt;改动&gt; - pull request】</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/09/20/wo1CjO.png" alt="有一个审核经理的工作流模式"></p>
<blockquote>
<h6 id="Dictator-and-Lieutenants-Workflow"><a href="#Dictator-and-Lieutenants-Workflow" class="headerlink" title="Dictator and Lieutenants Workflow"></a>Dictator and Lieutenants Workflow</h6><p>For more massive projects, a development workflow like that of the Linux kernel is often effective. In this model, some people (‘lieutenants’) are in charge of a specific subsystem of the project and they merge in all changes related to that subsystem. Another integrator (the ‘dictator’) can pull changes from only his/her lieutenants and then push to the ‘blessed’ repository that everyone then clones from again.</p>
</blockquote>
<blockquote>
<h6 id="独裁者和中尉工作流"><a href="#独裁者和中尉工作流" class="headerlink" title="独裁者和中尉工作流"></a>独裁者和中尉工作流</h6><p>对于更大规模的项目，像<strong>Linux内核</strong>那样的开发工作流通常是有效的。在这个模型中，一些人（“副手”）负责项目的一个特定子系统，他们将与该子系统相关的所有变更合并在一起。另一个集成商（“独裁者”）可以只从他/她的副手那里获取更改，然后推送到“受祝福的”存储库，然后每个人都可以从中再次克隆。</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/09/20/wo1VUA.png" alt="Linux系统开发的工作流"></p>
<blockquote>
<p>I’m not satisfied, what is repository after all?</p>
<p>这就是我不满意官方网站的地方，就是我通读了整个网站，也是没有得到我需要了解的内容。Git到底是怎么工作的？</p>
</blockquote>
<h5 id="官网提供的视频资料"><a href="#官网提供的视频资料" class="headerlink" title="官网提供的视频资料"></a>官网提供的视频资料</h5><p>官网提供的视频是打不开的😳</p>
<h5 id="尝试搜索youtube上的学习资料"><a href="#尝试搜索youtube上的学习资料" class="headerlink" title="尝试搜索youtube上的学习资料"></a>尝试搜索youtube上的学习资料</h5><p>参考:<a href="https://www.youtube.com/watch?v=SWYqp7iY_Tc">Traversy Media</a></p>
<blockquote>
<p>个人还是更偏向英文的视频，可能有点偏见…</p>
<p>但是看视频有一个缺点（相比于看文本），你没办法快速定位到你想要的内容。所以很大可能你需要把了解过的内容重新看一遍…这时候的心态应该是”温故而知新”</p>
</blockquote>
<ul>
<li><p>什么叫分布式/非中心化的版本管理系统？</p>
<p>多个程序员合作同一个项目，而不需要呆在同一个局域网中。</p>
</li>
<li><p>Git常用命令</p>
<p><img src="https://s1.ax1x.com/2020/09/20/wog34I.png" alt="Git常用命令"></p>
</li>
<li><p>安装Git</p>
<ul>
<li>Linux系统；使用命令安装</li>
<li>Mac：官网/包管理工具HomeBrew;</li>
<li>Windows：官网（包含Git-Bash命令行工具）；/GUI工具（不推荐）</li>
</ul>
<blockquote>
<p>bear in mind:你不需要了解Git的方方面面，因为它会很复杂。Just Basics</p>
</blockquote>
</li>
</ul>
<ul>
<li><p>tips</p>
<ul>
<li>1 使用git bash命令行工具，而不是Windows自带的命令行工具（aka cmd黑窗口）；</li>
</ul>
</li>
<li><p>用法</p>
<ul>
<li><p>1 创建一个空的文件夹；</p>
</li>
<li><p>2 在文件夹中创建几个文件；</p>
</li>
<li><p>3 把文件夹初始化为一个仓库；</p>
</li>
<li><p>4 把特定的文件添加到暂存区(staging area)并查看当前缓存区的文件状态;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git add &lt;file&gt; <span class="comment">// 把文件添加到暂存区	用于后继提交</span></span><br><span class="line">git status <span class="comment">// 查看当前暂存区中的文件</span></span><br><span class="line">    暂存区中的文件状态：</span><br><span class="line">    	<span class="number">1</span> 待提交（Changes to be committed）；</span><br><span class="line">    	<span class="number">2</span> 未被追踪(Untracked files);</span><br><span class="line">git rm --cached &lt;file&gt; <span class="comment">// 把文件从暂存区中移除</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<p>在添加文件到暂存区时使用通配符*：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git add *.html <span class="comment">// 把所有后缀名为html的文件添加到暂存区</span></span><br></pre></td></tr></table></figure>

<p>在添加所有文件都添加到暂存区:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git add . <span class="comment">// .表示的是all</span></span><br></pre></td></tr></table></figure>

<p>声明那些在仓库中你不想要添加到版本控制系统中的文件（预期-git add也无法添加这些文件）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">在项目的根目录下创建.gitignore文件</span><br><span class="line">touch .gitignore</span><br><span class="line"></span><br><span class="line">然后编辑.gitignore文件，添加想要忽略的文件与目录</span><br><span class="line">log.txt</span><br><span class="line">/dir2</span><br></pre></td></tr></table></figure>

<ul>
<li><p>验证.gitignore中声明的<strong>被版本管理系统忽略的文件/目录</strong>是不是真的被忽略的；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> 在工作目录中做一些改动；</span><br><span class="line">    添加新的目录/dir1（目录中添加新的文件test1.txt）</span><br><span class="line">    添加新的目录/dir2(目录中添加新的文件test2.txt)</span><br><span class="line"><span class="number">2</span> 在.gitignore文件中添加“预期被忽略的文件/目录”</span><br><span class="line">    log.txt</span><br><span class="line">    /dir2</span><br><span class="line"><span class="number">3</span> 把所有文件添加到暂存区</span><br><span class="line">    git add .</span><br><span class="line"><span class="number">4</span> 查看暂存区中所有状态下的文件</span><br><span class="line">    git status</span><br><span class="line">预期：暂存区中没有记录新增的文件log.txt与新增的目录/dir;但是却记录了新增的目录/dir1</span><br><span class="line">结果：符合预期</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果你和其他几个开发者共同开发一个项目，并且你被分配了login功能这个任务。</p>
<blockquote>
<p>在功能没有完全开发完成之前，开发者不应该把自己做出的改动提交到主分支中；</p>
</blockquote>
<p>手段：</p>
<ul>
<li>1 创建一个叫做login的<strong>分支</strong>，然后把自己改动的代码提交到login分支中（而不是主分支）；</li>
<li>2 在login功能开发完成后，再把login分支<strong>合并到</strong>主分支中；</li>
</ul>
<p>用法：</p>
<ul>
<li><p>1 创建一个login分支；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git branch &lt;自定义的分支名称login&gt;</span><br></pre></td></tr></table></figure>

<p>注：这时只是创建了分支，但是开发环境仍旧处在master分支上；</p>
</li>
<li><p>2 切换开发环境到刚刚创建的login分支；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git checkout &lt;预期切换到的分支名称login&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>3 在新的分支上开发login功能；</p>
<p>xxx</p>
</li>
<li><p>4 验证在提交到login分支上的改动是否会影响到master分支；</p>
<ul>
<li><p>手段：切换回主分支，然后查看Git仓库中是否存在3中做出的改动；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git checkout &lt;预期切换到的分支名称master&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><p>5 在login功能开发完成后，希望把<strong>提交到login分支的改动</strong>合并到master分支上；</p>
<ul>
<li><p>手段：</p>
<ul>
<li>1 在master分支中，把login分支合并进来；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git merge &lt;预期合并进来的分支名称login&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>2 填写合并此分支到master分支的原因（这应该是master分支的管理者需要做的事情）；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">add the login function, blah blah blah...</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<hr>
</li>
<li><p>远程仓库；</p>
<p>用法：</p>
<ul>
<li><p>1 创建一个Github账号xxx；</p>
</li>
<li><p>2 在xxx账号下，创建一个公开仓库；</p>
</li>
<li><p>3 把<strong>在Github上创建的仓库</strong>作为<strong>本地仓库的远程仓库</strong>；</p>
<ul>
<li><p>查看本地仓库当前所有的远程仓库；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git remote <span class="comment">// 没有绑定远程仓库时，命令执行的结果为空</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>根据github项目中提供的命令行信息，把github项目作为本地项目的远程仓库；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git remote add origin git<span class="meta">@github</span>.com:henryinshanghai/my_webapp_sample.git</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>4 把本地仓库的内容推送到<strong>远程仓库的主分支</strong>中；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git push -u origin master <span class="comment">// 同样是github项目提供的命令，可以无脑复制</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>5 推送成功后，刷新github项目的页面就能够看到本地项目的内容已经推送到远程仓库中了；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">在github项目的网页上点击一下刷新按钮</span><br></pre></td></tr></table></figure>

<hr>
</li>
<li><p>6 为了让其他程序员更容易了解这个项目，为项目添加README.md文件（项目说明）</p>
<ul>
<li><p>0 通过git bash页面来在项目根目录下创建一个README.md文件；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">touch README.md <span class="comment">// 这是Linux系统的语法吧</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>1 然后编辑这个文件的内容（可以直接在命令行中使用命令来编辑，也可以通过文本编辑器软件进行编辑）；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">I<span class="string">'m the night!</span></span><br><span class="line"><span class="string">I'</span>m Vengeance!</span><br><span class="line">I<span class="string">'m batman</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>2 把所有工作区（working area）被改动的文件添加到暂存区(staging area);</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git add . <span class="comment">// .表示all的意思</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>3 把所有暂存区中待提交的文件，提交到本地仓库（local repository）；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git push <span class="comment">// 由于前面已经为本地项目指定了github项目作为远程仓库，所以这里直接push即可</span></span><br></pre></td></tr></table></figure>

<p><font size=2>注：首次推送到github项目时，可能需要登录github来验证用户的合法性;</font></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><p>在github上公开的仓库可以被其他程序员克隆到本地进行学习。这里模拟克隆github项目到本地的过程；</p>
<ul>
<li><p>说明：由于没有其他的程序员，所以这里<strong>自己来克隆自己的项目到自己的电脑上</strong>。只是为了熟悉流程</p>
</li>
<li><p>手段：</p>
<ul>
<li><p>1 在自己的电脑上创建一个新的文件夹/myapp2；</p>
</li>
<li><p>2 在/myapp2中打开git bash界面；</p>
</li>
<li><p>3 从github上拉取项目到自己电脑的文件夹中；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">语法：git clone &lt;github项目所提供的克隆地址&gt;</span><br><span class="line">特征：克隆项目时，由于是远程通信，所以有多个协议可以选择（https、ssh等）。这里选择https，因为它是第一个</span><br><span class="line">git clone https:<span class="comment">//github.com/henryinshanghai/my_webapp_sample.git</span></span><br><span class="line">结果：github项目中的所有内容都会被拷贝到本地文件夹中</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<p>在多个开发的情况下，如果其他开发者对远程仓库做了某些改动。在一天的工作开始之前，你需要把这些改动从远程仓库拉取到本地仓库中</p>
<ul>
<li><p>手段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git pull <span class="comment">// 拉取远程仓库的变动到本地仓库</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<blockquote>
<p>alright, can’t dwell on this forever. until next time 😄</p>
</blockquote>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Tools</tag>
        <tag>Git Related Info</tag>
      </tags>
  </entry>
  <entry>
    <title>从Github的操作到SSH协议的应用</title>
    <url>/Network/2020/09/18/%E6%95%99%E7%A8%8B%E7%B1%BB%E7%9A%84%E6%93%8D%E4%BD%9C%E4%B8%8E%E8%AE%A4%E8%AF%86/Github%E4%B8%8E%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/20200918-%E4%BB%8EGithub%E7%9A%84%E6%93%8D%E4%BD%9C%E5%88%B0SSH%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%BA%94%E7%94%A8.html</url>
    <content><![CDATA[<h4 id="Github与班级作业"><a href="#Github与班级作业" class="headerlink" title="Github与班级作业"></a>Github与班级作业</h4><h5 id="从一个大事件说起"><a href="#从一个大事件说起" class="headerlink" title="从一个大事件说起"></a>从一个大事件说起</h5><a id="more"></a>

<p>长期的CURD让小明同学陷入生活的土拨鼠漩涡，这个框架也只是要记忆更多的规则。每天都会生理不适到想要呕吐… 痛定思痛，于是他倒吸一口气，花了几千大洋从黑客空间上买下了一门算法课程。课程要过些天才正式开始，但是想象自己能够在leetcode上各种造，他的内心满是欢喜…</p>
<p>课程本身有各种安排和各种口号，按图索骥，为了能够以一种统一的方式让大家交作业。要求每个学生都创建自己的Github账号，然后做一通操作。操作都有截图教程，小明不多想，一通操作猛如虎，然后就遇到了一个经典的现象：操作时，电脑没有按照教程预期地成功执行对应的操作；</p>
<p>小明一阵心绞痛，TM我再也做这些我根本不知道在干嘛的操作了。于是，唰唰唰，3分钟里标签页就开了10多个…</p>
<h5 id="小明看到的教程：克隆Github上的项目到本地"><a href="#小明看到的教程：克隆Github上的项目到本地" class="headerlink" title="小明看到的教程：克隆Github上的项目到本地"></a>小明看到的教程：<a href="https://shimo.im/docs/m5rtM8K8rNsjw5jk/read">克隆Github上的项目到本地</a></h5><h6 id="step0：从黑客空间提供的Github项目地址（用来交作业的仓库），fork这个项目到自己的账号下；"><a href="#step0：从黑客空间提供的Github项目地址（用来交作业的仓库），fork这个项目到自己的账号下；" class="headerlink" title="step0：从黑客空间提供的Github项目地址（用来交作业的仓库），fork这个项目到自己的账号下；"></a>step0：从黑客空间提供的Github项目地址（用来交作业的仓库），<strong>fork</strong>这个项目到自己的账号下；</h6><ul>
<li><p>Github是什么？</p>
<p>是：一个互联网上的网站；</p>
<p>作用：</p>
<ul>
<li>1 超大存储空间的U盘；</li>
<li>2 为用户<strong>管理自己所存储的东西</strong>提供各种类型的操作；</li>
</ul>
<p>特征：</p>
<ul>
<li>1 只要有网络，就可以对自己存储的东西进行访问（类似于百度网盘）；</li>
<li>2 能够记录用户<strong>对自己所存储内容的各种改动</strong>（类似于???）;</li>
</ul>
<p>应用：</p>
<ul>
<li>1 使用者使用Github对自己的项目（可能是代码项目也可能是其他的资料）进行历史版本管理；</li>
</ul>
<p>用法：</p>
<p>​    <font size=2>这个我还不是很熟悉，Github主要的应用是代码托管。并且还有社交化的属性，难点就在于具体用法 🚩Mark 找到好的教程后回来填坑</font></p>
<hr>
</li>
<li><p>fork是什么意思？</p>
<p>fork的英文本意是叉子。一个叉子有多个分叉，这是fork操作所借用的词语特性</p>
<p>在上面的语境中，fork一个项目有两个含义：</p>
<ul>
<li>1 把原始项目拷贝一份，得到<strong>与当前时刻的原始项目完全相同</strong>的一个项目副本；</li>
<li>2 把拷贝得到的项目副本存储在你自己的github账号下；</li>
</ul>
</li>
</ul>
<blockquote>
<p> 内心OS:计算机行业层出不穷的新缩写有时候真是叫人心累。</p>
<p> 一方面那些达则兼济天下的奇才把各种工具封装到<strong>路人可用</strong>的程度，</p>
<p> 另一方面为了知道自己到底在做什么，<strong>作为路人的我等</strong>又要去了解具体的实现原理。</p>
</blockquote>
<ul>
<li>前置条件：在Github的网站上注册一个账号（类似于注册QQ）</li>
</ul>
<p><font size=2>评论：这一步操作我知道自己在做什么，而且操作也是成功的；😄</font></p>
<h6 id="step1-在你的电脑上创建一个空文件夹，然后执行git命令，把这个空文件夹变成一个被Git管理的仓库；"><a href="#step1-在你的电脑上创建一个空文件夹，然后执行git命令，把这个空文件夹变成一个被Git管理的仓库；" class="headerlink" title="step1:在你的电脑上创建一个空文件夹，然后执行git命令，把这个空文件夹变成一个被Git管理的仓库；"></a>step1:在你的电脑上创建一个空文件夹，然后执行git命令，把这个空文件夹变成一个被Git管理的仓库；</h6><ul>
<li><p>Git是什么？</p>
<p>是：一个工具；</p>
<p>作用：对特定类型的文件进行版本管理；</p>
<hr>
</li>
<li><p>版本管理是什么？</p>
<ul>
<li><p>是：一个过程；</p>
</li>
<li><p>作用：记录一个文件从初始版本到当前版本的变化过程；</p>
</li>
<li><p>应用：</p>
<ul>
<li>1 不断扩展一个文件的功能（今天没干完，保存一下，明天接着来）；</li>
<li>2 尝试扩展文件的某个功能，如果尝试失败，则回退到之前功能正常的版本（后悔药）；</li>
</ul>
</li>
<li><p>特征：</p>
<ul>
<li>1 该工具只能在命令行环境下使用；</li>
<li>2 这样的工作方式下，不存在<strong>中心仓库</strong>这样的概念，终端程序员对代码有更大的自主权；</li>
<li>3 Git中使用<strong>仓库</strong>来描述<strong>一个被Git工具管理的文件夹</strong>；</li>
</ul>
</li>
<li><p>用法：</p>
<ul>
<li>1 在预期被Git管理的文件夹下，执行git命令git init；<ul>
<li>作用：在文件夹中创建一个.git的子目录，用来保存版本信息。文件夹也就从普通的文件夹变成了<strong>Git中的一个仓库</strong>；（鸟枪换铳/老母鸡变鸭）</li>
</ul>
</li>
<li>参考:<a href="http://www.ruanyifeng.com/blog/2018/10/git-internals.html">Git操作入门</a></li>
</ul>
</li>
</ul>
</li>
<li><p>评论：这一步我也清楚在做什么，并且操作是成功的；</p>
</li>
<li><p>前置条件：在你的电脑上已经安装了Git这个工具（在官网上就能找到教程 请认准官网）；</p>
</li>
</ul>
<h6 id="step2：配置Git使用者的用户名和邮箱；"><a href="#step2：配置Git使用者的用户名和邮箱；" class="headerlink" title="step2：配置Git使用者的用户名和邮箱；"></a>step2：配置Git使用者的用户名和邮箱；</h6><blockquote>
<p>为什么Git这种工具类的产品还需要注册用户呢？😱</p>
<p>答：Git其实更多用于团队中的多个成员合作一个项目，为了能够记录项目的某些改动具体是由哪一个成员做出的，所以需要记录使用Git的成员。Thus，使用Git前需要注册用户名与邮箱；</p>
</blockquote>
<ul>
<li><p>手段:git config命令</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">"用户名"</span></span><br><span class="line">git config --global user.email <span class="string">"邮箱"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>特征：手动配置完成关于Git的属性后，需要验证自己进行的配置是否已经生效了；</p>
<ul>
<li><p>手段</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git config --global --list <span class="comment">// 列表显式当前所有的配置信息</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
<h6 id="step3：配置Git的密钥；"><a href="#step3：配置Git的密钥；" class="headerlink" title="step3：配置Git的密钥；"></a>step3：配置Git的密钥；</h6><blockquote>
<p>为什么Git这种工具类的产品还需要有密钥呢？</p>
<p>答：密钥是用于加密通信双方的通信内容的；</p>
</blockquote>
<blockquote>
<p>#Q 我使用Git来记录项目中的改动，为什么会有通信过程的出现呢？</p>
<p>答：因为具体的使用场景是-</p>
<ul>
<li><p>1 主线项目托管在github上（比如Redis项目的开源代码）；</p>
</li>
<li><p>2 各路程序员分别fork一个项目副本到自己的github账号下（这一步并不总是必要吧😒）；</p>
<p>作用：项目fork到自己的账号下，程序员就对这个项目副本<strong>有完全的权限</strong>了，aka，可以自由编码</p>
</li>
<li><p>3 程序员A把fork得到的项目副本克隆到本地，愉快地做各种各样的尝试（策马奔腾）</p>
</li>
</ul>
<p>所以，在本地对文件进行改动后，需要<strong>把本地做出的改动通过网络提交到远程仓库上</strong>。通信的过程就是这么来的</p>
</blockquote>
<ul>
<li><blockquote>
<p>为啥会有通信我清楚了，但为啥会需要密钥的？</p>
<p>答：对于网络间的通信，为了保证通信的安全。一般都需要一些额外的措施来保证安全性；</p>
</blockquote>
<ul>
<li><blockquote>
<p>任务：保证通信过程的安全性；</p>
<p>手段：在通信时，选择某个支持安全通信的通信协议；</p>
<p>特征：</p>
<ul>
<li>1 通信协议都已经实现了通信安全的细节；</li>
<li>2 不同的通信协议有不同的特性；</li>
<li>3 支持安全通信的协议往往都会需要密钥（参考：协议的原理）；</li>
</ul>
</blockquote>
</li>
</ul>
</li>
</ul>
<hr>
<p>说明：在这里<strong>使用SSH协议</strong>来支持从本地仓库到远程仓库之间的安全通信；</p>
<p>原因：在<strong>对通信进行校验</strong>时，SSH协议可以<strong>通过配置公私钥的方式</strong>实现校验（而不需要像其他协议那样每次输入密码进行校验）；</p>
<blockquote>
<p>SSH协议；</p>
<p>是：一种网络通信/传输协议；</p>
<p>作用：保证网络通信的安全性；</p>
<p>原理：在网络中创建<strong>安全隧道</strong>来实现SSH客户端与服务端的连接；</p>
<p>应用：</p>
<ul>
<li>1 远程登录到其他的电脑主机上；</li>
</ul>
<p>用法：</p>
<ul>
<li>在主流的操作系统中，都有封装了这些通信协议的软件可以直接使用（比如Windows中的Secure CRT）。</li>
</ul>
</blockquote>
<hr>
<blockquote>
<p>SSH协议用于远程登录的基本用法；</p>
<p>任务：以user作为用户名来登录到远程主机host上；</p>
<p>手段/命令：$ ssh user@host</p>
<p>特征：</p>
<ul>
<li>1 主机上SSH服务一般在22端口启动；</li>
<li>2 在命令中使用-p参数可以修改客户端所连接到的主机端口（这是两边的事情，需要相互兼顾）</li>
</ul>
</blockquote>
<hr>
<blockquote>
<p>SSH协议能够保证安全通信的原理；</p>
<p>手段：公钥加密；</p>
<p>SOP:</p>
<ul>
<li>0 客户端发出登录请求给远程主机host；</li>
<li>1 收到请求后，远程主机host把自己的公钥响应给客户端；</li>
<li>2 客户端使用拿到的公钥<strong>对登录信息进行加密</strong>，然后再次请求远程主机host；</li>
<li>3 远程主机host接受到请求后，使用自己的私钥<strong>对加密后的登录信息进行解密</strong>——在服务器端对比密码，根据密码是否正确决定用户能否登录成功。</li>
</ul>
<p>特征：</p>
<ul>
<li>1 SSH协议中的公钥是远程主机自己签发的，没有经过第三方认证（不像https协议那样）；<ul>
<li>既然没有经过认证，第三方就很容易对公钥进行伪造。aka <strong>中间人攻击</strong></li>
</ul>
</li>
</ul>
</blockquote>
<hr>
<blockquote>
<p>中间人攻击；</p>
<p>是：一个术语；</p>
<p>作用：描述“利用通信过程原理上的缺陷，通过伪装通信方，而达到欺骗通信方的目的”的过程；</p>
<p>原理：</p>
<ul>
<li>既然远程主机的公钥是没有第三方认证的，我就可以伪造一个公钥，用来冒充远程主机的公钥（假设我使用了主机fake自己签发的公钥）；</li>
<li>在步骤1中，主机fake把自己的公钥发送给客户端；</li>
<li>在步骤2中，主机fake拦截来自客户端的请求，并直接对加密的登录信息进行解密（毕竟客户端是使用自己提供的公钥加密的嘛）。然后伪装成客户端向远程主机host发起登录请求；</li>
<li>最终远程主机会校验登录信息通过，fake成功（伪装客户端）登录到了远程主机中（😳）</li>
</ul>
</blockquote>
<hr>
<ul>
<li><p>SSH协议解决中间人攻击的手段；</p>
<ul>
<li><p>手段1：口令登录（即密码登录）；</p>
</li>
<li><p>原理：客户端手动校验主机的公钥并选择新人；</p>
<blockquote>
<p>SOP:</p>
<ul>
<li><p>键入命令尝试直接登录；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ ssh user<span class="meta">@host</span> <span class="comment">// $是一个提示符，不是键入的内容</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>SSH协议会给出一个提示信息：您当前登录的主机公钥为xxx，但是不确定它是不是您想要登录的主机…</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">The authenticity of host <span class="string">'host (12.18.429.21)'</span> can<span class="string">'t be established.</span></span><br><span class="line"><span class="string">RSA key fingerprint is 98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d.</span></span><br><span class="line"><span class="string">Are you sure you want to continue connecting (yes/no)?</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>RSA key fingerprint:公钥指纹</p>
<p>是：对公钥字符串进行MD5计算的结果；</p>
<p>特征：</p>
<ul>
<li><p>1 RSA算法得到的公钥长度为1024位字符；</p>
</li>
<li><p>2 MD5计算后，得到的公钥指纹只有128位，且具有唯一性；</p>
<p>98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d</p>
</li>
</ul>
</blockquote>
</li>
<li><p>客户端拿到SSH协议提示的信息，再去远程主机的网站上找到它所公布出来的公钥。一一对照核对公钥是不是正确的；</p>
</li>
<li><p>经过核对后，客户端接受了当前主机的公钥；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Are you sure you want to <span class="keyword">continue</span> <span class="title">connecting</span> <span class="params">(yes/no)</span>? </span></span><br></pre></td></tr></table></figure>
</li>
<li><p>输入yes后，系统提示:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Warning: Permanently added <span class="string">'host,12.18.429.21'</span> (RSA) to the list of known hosts.</span><br></pre></td></tr></table></figure>

<p>警告：永久性地把主机xxx添加到认证主机的列表中；</p>
</li>
<li><p>然后系统提示输入密码（口令）；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Password:(enter password)</span><br></pre></td></tr></table></figure>
</li>
<li><p>密码正确，则登录成功👍</p>
</li>
</ul>
</blockquote>
</li>
<li><p>特征：</p>
<ul>
<li>再次登录时，很多步骤都会被简化（因为远程主机的公钥已经被存储在本地了）。会直接要求输入密码；</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><p>手段2：公钥登录；</p>
</li>
<li><p>原理：</p>
<ul>
<li>1 客户端把自己的公钥存在远程主机上；</li>
<li>2 客户端尝试登录请求时，服务器在给客户端的响应中包含一个随机字符串；</li>
<li>3 客户端使用自己的私钥对随机字符串进行加密，然后再次尝试发送登录请求（包含加密后的字符串信息）；</li>
<li>4 请求达到远程主机后，远程主机使用<strong>1中存储的公钥</strong>对加密字符串进行解密；<ul>
<li>如果解密得到的字符串与自己之前响应的字符串相同，则：客户端是可信的，允许登录；</li>
<li>否则，不允许登录</li>
</ul>
</li>
</ul>
</li>
<li><p>特征：</p>
<ul>
<li>1 客户端不需要每次登录时都使用口令/密码；</li>
<li>2 要求客户端必须要提供自己的公钥；</li>
</ul>
<blockquote>
<p>客户端从哪儿能获取到自己的公钥？</p>
<ul>
<li><p>手段：使用ssh协议提供的命令自己生成一个；</p>
</li>
<li><p>命令：ssh-keygen</p>
</li>
<li><p>用法：</p>
<ul>
<li>1 键入命令后，一路回车；</li>
<li>2 想办法把生成的公钥放到远程主机上；</li>
</ul>
</li>
<li><p>结果：命令执行结束后，在$HOME/.ssh/目录下，会新生成两个文件——id_rsa.pub（公钥）和id_rsa（私钥）</p>
</li>
</ul>
</blockquote>
<p>更多细节，参考:<a href="https://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html">SSH协议之远程登录</a></p>
</li>
</ul>
<hr>
<p>  按照图文教程提供的命令，执行下来没得动静。但现在我知道我在做什么了：<strong>生成客户端的公钥</strong>，然后<strong>把生成的公钥字符串添加到远程主机中</strong>；</p>
<blockquote>
<p>任务1：生成客户端的公钥；</p>
<p>手段：ssh-keygen命令；</p>
<p>用法：一路回车（不设置私钥）；</p>
</blockquote>
<blockquote>
<p>任务2：把生成的公添加到远程主机中；</p>
<p>手段：Github的仓库提供了一个页面字段（<strong>页面字段</strong>是一个封装地很好地设置某个属性值地方式了，因为它不需要使用者打开某种类型的shell窗口-这玩意挺吓人的），在页面中填入公钥文件的内容即可；</p>
</blockquote>
<p>  评论：这一通操作后，客户端被远程仓库成功授权。以后提交本地仓库的改动就再也不需要输入密码了😄</p>
<blockquote>
<p>验证Git密钥的配置（客户端 + 远程仓库）是否成功；</p>
<p>手段：ssh -T <a href="mailto:git@github.com">git@github.com</a>命令；</p>
<p>用法：</p>
<ul>
<li>1 键入命令直接回车；</li>
<li>2 预期出现successfully…</li>
</ul>
</blockquote>
<h6 id="step4-把自己github账号下的远程仓库克隆到-拉取到本地，放肆玩耍"><a href="#step4-把自己github账号下的远程仓库克隆到-拉取到本地，放肆玩耍" class="headerlink" title="step4: 把自己github账号下的远程仓库克隆到/拉取到本地，放肆玩耍"></a>step4: 把自己github账号下的远程仓库克隆到/拉取到本地，放肆玩耍</h6><ul>
<li>手段：git clone命令；</li>
<li>用法：git clone &lt;远程仓库在指定协议下的url&gt;;</li>
<li>实例：git clone <a href="mailto:git@github.com">git@github.com</a>:henryinshanghai/algorithm017.git</li>
<li>特征：如果项目比较大，从github远程仓库拉取到本地会比较慢；</li>
<li>解决手段：<a href="https://www.bilibili.com/video/BV1aE411p7Cd?from=search&seid=7922504800095438521">用gitee做跳板</a></li>
</ul>
<blockquote>
<p>上面短短的4个步骤，小明就花了一天的时间。但现在如果小花也要弄这些操作，小明半个小时既可以搞定了</p>
<p>🚩但是小明的脑壳上始终有一篇阴云：SSH加密过程中的公钥和私钥到底是什么说法，有点子混沌…</p>
</blockquote>
<h5 id="把本地仓库的改动弄到自己账号下的远程仓库中"><a href="#把本地仓库的改动弄到自己账号下的远程仓库中" class="headerlink" title="把本地仓库的改动弄到自己账号下的远程仓库中"></a>把本地仓库的改动<em>弄到</em>自己账号下的远程仓库中</h5><blockquote>
<p>明确任务的各个阶段；</p>
<p>Git中的概念：</p>
<ul>
<li><p>工作区（Working Directory）；</p>
<p>是：一个文件夹/目录；</p>
<p>作用：程序员能够直接对这个目录/目录下的文件进行各种操作；</p>
<p>特征：</p>
<ul>
<li>1 这个目录接受Git版本工具的管理；</li>
<li>2 程序员能够把工作区的变动提交到xxx；</li>
</ul>
</li>
<li><p>版本库（Repository）；</p>
<ul>
<li><p>是：一个隐藏目录/.git；</p>
</li>
<li><p>作用：支持Git对工作区进行版本管理；</p>
</li>
<li><p>特征：</p>
<ul>
<li>1 这个隐藏目录就是Git的版本库；</li>
<li>2 版本库中有很多东西（引用:<a href="https://www.liaoxuefeng.com/wiki/896043488029600/897271968352576">工作区与暂存区</a>）：<ul>
<li>01 stage暂存区；</li>
<li>02 仓库的第一个分支master；</li>
<li>03 指向master的一个指针HEAD;</li>
</ul>
</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/18/w5pNyF.png" alt="工作区与版本库"></p>
</li>
</ul>
</li>
<li><p>原理：Git版本库如何能够记录对文件的改动呢？</p>
<ul>
<li>step1：使用git add &lt;被修改的文件&gt;命令来<strong>把文件的变动添加stage暂存区</strong>；</li>
<li>step2：使用git commit xxx命令来提交改动，aka，<strong>把暂存区的内容提交到当前分支</strong>；</li>
</ul>
</li>
</ul>
<blockquote>
<p>这里廖雪峰的讲法似乎有很多人并不认同，明天还是要到官网上看看。see u tomorrow🌙</p>
</blockquote>
</blockquote>
<p>参考：<a href="https://git-scm.com/">Git官网</a></p>
<p>这个内容相对较多，分到下一篇吧</p>
<blockquote>
<p>until next time~ 😄</p>
</blockquote>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Network</tag>
        <tag>Github Operation</tag>
      </tags>
  </entry>
  <entry>
    <title>验证一棵二叉树是否是二叉搜索树</title>
    <url>/Binary-Search-Tree/2020/09/17/%E7%AE%97%E6%B3%95/%E6%A0%91/20200917-%E9%AA%8C%E8%AF%81%E4%B8%80%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%A0%91%E6%98%AF%E5%90%A6%E6%98%AF%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html</url>
    <content><![CDATA[<h4 id="LeetCode-98-验证一棵树是否是二叉搜索树"><a href="#LeetCode-98-验证一棵树是否是二叉搜索树" class="headerlink" title="LeetCode#98 验证一棵树是否是二叉搜索树"></a>LeetCode#98 验证一棵树是否是二叉搜索树</h4><h5 id="题设与要求"><a href="#题设与要求" class="headerlink" title="题设与要求"></a>题设与要求</h5><a id="more"></a>

<p><img src="https://s1.ax1x.com/2020/09/17/wfibon.png" alt="题设与要求"></p>
<h5 id="分析题目难点-amp-提出解决手段"><a href="#分析题目难点-amp-提出解决手段" class="headerlink" title="分析题目难点 &amp; 提出解决手段"></a>分析题目难点 &amp; 提出解决手段</h5><blockquote>
<p>什么是有效的二叉搜索树？</p>
<p>特征：</p>
<ul>
<li>1 左子树中的节点小于当前节点；</li>
<li>2 右子树中的节点大于当前节点；</li>
<li>3 左右子树都是BST；</li>
</ul>
</blockquote>
<blockquote>
<p>怎么能判断一棵树是不是同时满足这3条性质？</p>
<ul>
<li>左右子树都是BST；<ul>
<li>手段：在左右子树上递归调用用来判断的方法；</li>
</ul>
</li>
<li>左子树中的节点小于当前节点； &amp;&amp; 右子树中的节点大于当前节点；<ul>
<li>手段：对二叉树进行中序遍历（左 - 根 - 右），中序遍历时，判断当前节点是不是总大于上一个节点即可；</li>
</ul>
</li>
</ul>
</blockquote>
<h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><ul>
<li>1 准备一个变量，记录<strong>中序遍历序列中的上一个节点的值</strong>；</li>
<li>2 定义一个递归方法isValidBST(),方法作用：判断指定的二叉树是否为BST；<ul>
<li>2-1 定义递归终结条件；</li>
<li>2-2 定义本级递归需要做的事情；<ul>
<li>实现中序遍历，通过比较当前节点与<strong>序列中的前一个节点</strong>的值来判断是否满足特性1、2；</li>
<li>在左右子树上递归调用isValidBST(),以此来判断是否满足特性3；</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="把思路翻译成代码"><a href="#把思路翻译成代码" class="headerlink" title="把思路翻译成代码"></a>把思路翻译成代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 准备一个变量	用于绑定“中序序列中前一个节点的值”</span></span><br><span class="line"><span class="comment">// 之所以使用long类型，是因为测试用例中使用了一些对应类型的数据</span></span><br><span class="line"><span class="keyword">long</span> pre = Long.MIN_VALUE; <span class="comment">// -2的63次方	</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归方法作用：判断给定的二叉树是不是BST，并返回布尔值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1 递归终结条件</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2 本级递归需要做的事情</span></span><br><span class="line">    <span class="comment">// 2-1 实现中序遍历：左节点 - 根节点 - 右节点</span></span><br><span class="line">    <span class="comment">// 左节点root.left;	对于左节点，判断左节点是否是一个BST</span></span><br><span class="line">   	<span class="keyword">if</span>(!isValidBST(root.left))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根节点（当前节点）	对于当前节点，比较它与序列中的上一个节点的值，以判断二叉树是不是一个BST</span></span><br><span class="line">    <span class="keyword">if</span>(root.val &lt;= pre)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用当前节点来更新pre：中序序列中的前一个节点的值</span></span><br><span class="line">    pre = root.val;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> isValidBST(root.right); <span class="comment">// 三个特性都已经被判断，完满完成任务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="代码拆解SOP"><a href="#代码拆解SOP" class="headerlink" title="代码拆解SOP"></a>代码拆解SOP</h5><blockquote>
<p>1 以中序遍历规则遍历二叉树中的节点</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 中序遍历规则: 左节点 - 根节点 - 右节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 左节点</span></span><br><span class="line">	something(root.left);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根节点/当前节点</span></span><br><span class="line">    somethingElse(root);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 右节点</span></span><br><span class="line">    somethingOtherElse(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：<strong>以前序遍历的规则来执行遍历</strong>更像是一个执行框架；</p>
<blockquote>
<p>2 判断左右子树是否为BST；</p>
<p>手段：在左右子树上调用isValidBST()进行判断；</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 左子树</span></span><br><span class="line"><span class="keyword">if</span>(!isValidBST(root.left))&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 右子树</span></span><br><span class="line"><span class="keyword">if</span>(!isValidBST(root.right))&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="comment">// 这里其实可以简化为: return isValidBST(root.right);	因为代码的判断已经结束了</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>3 比较当前节点与序列中的前一个节点值的大小（判断是否为升序）；</p>
<p>手段：使用一个变量pre来记录“前一个节点的值”；</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> pre = Long.MIN_VALUE; <span class="comment">// 使用long类型是因为测试用例中有这种类型的数据	这里取long类型的最小值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">	<span class="comment">// 当前节点</span></span><br><span class="line">	<span class="keyword">if</span>(root.val &lt; pre)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用当前节点的值来更新pre的值	作用：使pre变量一直绑定“上一个被处理的节点的值（aka 序列中上一个节点的值）”</span></span><br><span class="line">    pre = root.val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="代码重现"><a href="#代码重现" class="headerlink" title="代码重现"></a>代码重现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> pre = Long.MIN_VALUE;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 递归终结条件 &amp; 鲁棒性代码</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 本级递归需要做的事情</span></span><br><span class="line">	<span class="comment">// 1 按照中序遍历的规则处理二叉树中的节点</span></span><br><span class="line">    <span class="comment">// root.left;</span></span><br><span class="line">    <span class="keyword">if</span>(!isValidBST(root.left))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// root;</span></span><br><span class="line">    <span class="keyword">if</span>(root.val &lt;= pre)&#123; <span class="comment">// 注：根据BST的规则，这里要包含等号</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pre = root.val;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// root.right;</span></span><br><span class="line">    <span class="keyword">return</span> isValidBST(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="启示-技巧"><a href="#启示-技巧" class="headerlink" title="启示/技巧"></a>启示/技巧</h5><p>对于<strong>多个条件同时成立</strong>时才能得出的判断结果（boolean类型），这里的<strong>多个条件</strong>都是<strong>必要条件</strong>。</p>
<p>在进行判断逻辑时，<strong>应该逐一判断违反规则导致false的情况</strong>。</p>
<p>当所有违反规则的情况都被排除后，就可以放心地返回true了；</p>
<blockquote>
<p>alright, this is henry. until next time 😄</p>
</blockquote>
]]></content>
      <categories>
        <category>Binary Search Tree</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Binary Search Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>计算二叉树的最大深度（递归写法）</title>
    <url>/Binary-Tree/2020/09/17/%E7%AE%97%E6%B3%95/%E6%A0%91/20200917-%E8%AE%A1%E7%AE%97%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6%EF%BC%88%E9%80%92%E5%BD%92%E5%86%99%E6%B3%95%EF%BC%89.html</url>
    <content><![CDATA[<h4 id="Leetcode-104-计算二叉树的最大深度"><a href="#Leetcode-104-计算二叉树的最大深度" class="headerlink" title="Leetcode#104 计算二叉树的最大深度"></a>Leetcode#104 计算二叉树的最大深度</h4><a id="more"></a>

<h5 id="题设与要求"><a href="#题设与要求" class="headerlink" title="题设与要求"></a>题设与要求</h5><p><img src="https://s1.ax1x.com/2020/09/17/wRTu0H.png" alt="题设与要求"></p>
<h5 id="分析难点-amp-提出解决手段"><a href="#分析难点-amp-提出解决手段" class="headerlink" title="分析难点 &amp; 提出解决手段"></a>分析难点 &amp; 提出解决手段</h5><blockquote>
<p>二叉树的深度到底是啥意思？</p>
<ul>
<li>1 从根节点到子节点会构成一条路径；</li>
<li>2 深度指的就是路径中节点的个数；</li>
<li>3 二叉树的最大深度：二叉树中存在的所有路径中，最长路径的节点个数；</li>
</ul>
</blockquote>
<blockquote>
<p>如何得到二叉树中的一条路径？</p>
<p>答：使用深度优先遍历，一头扎到底，直到遇到叶子节点时，就得到了一条完整的路径；</p>
</blockquote>
<blockquote>
<p>如何能从多个路径中找到最长路径？</p>
<p>手段1：在一个循环的过程中，不断更新最长路径maxLength；</p>
<p>手段2：利用二叉树结构本身的递归性，递归地处理左、右子树。然后加和出maxLength；</p>
</blockquote>
<h5 id="思路（递归）"><a href="#思路（递归）" class="headerlink" title="思路（递归）"></a>思路（递归）</h5><ul>
<li>1 定义一个方法，方法作用：计算给定的二叉树的最大深度并返回；</li>
<li>2 准备递归方法的递归终结条件 aka 递归调用触底返回的条件；</li>
<li>3 准备本级递归需要做的事情；<ul>
<li>1 在更小规模的二叉树中执行递归方法提供的操作；</li>
<li>2 利用1中的返回值来得到本级递归需要的返回值；</li>
</ul>
</li>
</ul>
<h5 id="把思路翻译成代码"><a href="#把思路翻译成代码" class="headerlink" title="把思路翻译成代码"></a>把思路翻译成代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1 递归方法；	作用：返回指定二叉树的最大深度</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">	<span class="comment">// 2 递归终结条件：当前节点为nil</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3 本级递归需要做的事情：</span></span><br><span class="line">    <span class="comment">// 3-1 对当前节点的左右子树求最大深度</span></span><br><span class="line">    <span class="keyword">int</span> leftDepth = maxDepth(root.left);</span><br><span class="line">    <span class="keyword">int</span> rightDepth = maxDepth(root.right);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3-2 使用子问题的结果来得到本级递归需要返回的值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + Math.max(leftDepth, rightDepth);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="几点疑问"><a href="#几点疑问" class="headerlink" title="几点疑问"></a>几点疑问</h5><ul>
<li><p>1 既然递归操作的终点是叶子节点（左右节点为nil），那么递归终结条件能不能改成:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>这样写会导致空指针异常，因为传入的参数root可以为null；相当于代码不够鲁棒</li>
</ul>
</li>
<li><p>2 if(root == null) return 0; 具体表示什么含义？</p>
<ul>
<li>1 作为递归终结条件，aka，在当前节点为nil节点时，递归调用开始返回（<strong>这不是最外层调用的返回，而只是上一级调用开始返回</strong>）</li>
<li>2 作为鲁棒性代码，aka，处理方法参数为null的情况；</li>
</ul>
</li>
</ul>
<h5 id="代码重现"><a href="#代码重现" class="headerlink" title="代码重现"></a>代码重现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 递归方法作用：计算给定二叉树的最大深度并返回</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 递归终止条件/鲁棒性代码</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 本级递归要完成的事情</span></span><br><span class="line">    <span class="keyword">int</span> leftDepth = maxDepth(root.left);</span><br><span class="line">    <span class="keyword">int</span> rightDepth = maxDepth(root.right);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + Math.max(leftDepth, rightDepth);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>until next time,mate 😄</p>
</blockquote>
]]></content>
      <categories>
        <category>Binary Tree</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的前序遍历（迭代方式）</title>
    <url>/Binary-Node/2020/09/16/%E7%AE%97%E6%B3%95/%E6%A0%91/20200916-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E8%BF%AD%E4%BB%A3%E6%96%B9%E5%BC%8F%EF%BC%89.html</url>
    <content><![CDATA[<h4 id="Leetcode-144-二叉树的前序遍历（迭代方式）"><a href="#Leetcode-144-二叉树的前序遍历（迭代方式）" class="headerlink" title="Leetcode#144 二叉树的前序遍历（迭代方式）"></a>Leetcode#144 二叉树的前序遍历（迭代方式）</h4><h5 id="题设与要求"><a href="#题设与要求" class="headerlink" title="题设与要求"></a>题设与要求</h5><a id="more"></a>

<p><img src="https://s1.ax1x.com/2020/09/16/w2qXjK.png" alt="题设与要求"></p>
<h5 id="分析问题难点-amp-提出解决手段"><a href="#分析问题难点-amp-提出解决手段" class="headerlink" title="分析问题难点 &amp; 提出解决手段"></a>分析问题难点 &amp; 提出解决手段</h5><blockquote>
<p>提出解决手段，有时候会需要giant leap😱</p>
</blockquote>
<blockquote>
<p>1 什么是二叉树的前序遍历？</p>
<p>答：以前序遍历的规则对二叉树这种非线性结构中的节点进行遍历；</p>
<p>前序遍历规则：对二叉树中的任意一棵子树，遍历的顺序总是—根节点、左节点、右节点；</p>
</blockquote>
<blockquote>
<p>2 如何才能按照这样的顺序来遍历树中的节点呢？</p>
<p>分析：因为遍历树中节点时，会有往回走的动作（aka 回溯），所以用栈结构应该可以实现</p>
<p>答：</p>
<ul>
<li>1 把当前节点存入一个栈中；</li>
<li>2 出栈当前节点，并按照特定顺序来入栈当前节点的子节点；</li>
<li>3 出栈预期的节点，并处理该节点的子节点（放到一个循环中进行）；</li>
</ul>
</blockquote>
<h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><ul>
<li>0 准备一个列表，用于存储当前遍历的节点；</li>
<li>1 准备一个栈，用于安排遍历二叉树节点的顺序；</li>
<li>2 把当前节点先入栈；</li>
<li>3 准备一个循环（栈不为空时执行循环体 aka 仍旧有未被处理的节点），在循环体中：<ul>
<li>1 弹出栈顶元素；</li>
<li>2 把栈顶元素的值添加到列表中；</li>
<li>3 把当前节点的子节点按照特定顺序添加到栈中（以便在遍历节点时，满足<strong>前序遍历所要求的顺序</strong>）</li>
<li>4 重复1-2-3，直到所有的节点都处理完成</li>
</ul>
</li>
</ul>
<h5 id="把思路翻译成代码"><a href="#把思路翻译成代码" class="headerlink" title="把思路翻译成代码"></a>把思路翻译成代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123; <span class="comment">// 树节点</span></span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">    </span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">        root = stack.pop();</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 先入栈右节点，以便出栈时得到的是左节点</span></span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="keyword">null</span>)&#123; <span class="comment">// 这里一定要进行判空，否则可能会NPE</span></span><br><span class="line">            stack.push(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(root.left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：其实就是N叉树前序遍历的一个变体啦</p>
</blockquote>
<blockquote>
<p>until next time 😄</p>
</blockquote>
]]></content>
      <categories>
        <category>Binary Node</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Binary Node</tag>
      </tags>
  </entry>
  <entry>
    <title>N叉树的前序遍历（迭代方式）</title>
    <url>/Node/2020/09/16/%E7%AE%97%E6%B3%95/%E6%A0%91/20200916-N%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E8%BF%AD%E4%BB%A3%E6%96%B9%E5%BC%8F%EF%BC%89.html</url>
    <content><![CDATA[<h4 id="Leetcode-589-N叉树的前序遍历（迭代方式）"><a href="#Leetcode-589-N叉树的前序遍历（迭代方式）" class="headerlink" title="Leetcode#589    N叉树的前序遍历（迭代方式）"></a>Leetcode#589    N叉树的前序遍历（迭代方式）</h4><h5 id="题设与要求"><a href="#题设与要求" class="headerlink" title="题设与要求"></a>题设与要求</h5><a id="more"></a>

<p><img src="https://s1.ax1x.com/2020/09/16/w2T2LQ.png" alt="题设与要求"></p>
<h5 id="分析难点-amp-提出解决手段"><a href="#分析难点-amp-提出解决手段" class="headerlink" title="分析难点&amp;提出解决手段"></a>分析难点&amp;提出解决手段</h5><blockquote>
<p>1 什么是N叉树的前序遍历？</p>
<p>答： 根节点 - 左子节点 - 中间节点（从左往右） - 右子节点</p>
</blockquote>
<blockquote>
<p>2 如何能够<strong>按照前序遍历的规则</strong>来遍历这样一个<strong>非线性数据结构</strong>中的节点呢？</p>
<ul>
<li>前序遍历的规则：根节点 - 左节点-…-右节点；</li>
<li>非线性数据结构：数据结构中有分叉的情况，因此如果使用不同的遍历规则，就会得到不同的结果（这些结果都是合理存在的）</li>
</ul>
<p>答：</p>
<ul>
<li>1 把当前节点存入一个栈中；</li>
<li>2 出栈当前节点，并按照特定顺序来入栈当前节点的子节点；</li>
<li>3 出栈预期的节点，并处理该节点的子节点（放到一个循环中进行）；</li>
</ul>
</blockquote>
<h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><ul>
<li><p>0 准备一个列表，用于在合适的位置存储节点；</p>
</li>
<li><p>1 准备一个栈，用于以特定顺序处理<strong>树结构中的节点</strong>；</p>
</li>
<li><p>2 把当前节点root入栈；</p>
</li>
<li><p>3 准备一个循环（栈不为空时执行循环体），在循环体中：</p>
<ul>
<li>1 出栈当前元素；</li>
<li>2 把当前元素的子节点以特定顺序入栈；</li>
<li>重复步骤12，以便按照预期的顺序来处理节点；</li>
</ul>
</li>
</ul>
<h5 id="把思路翻译成代码"><a href="#把思路翻译成代码" class="headerlink" title="把思路翻译成代码"></a>把思路翻译成代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Node类型的定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Node&gt; children;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> _val)</span> </span>&#123;</span><br><span class="line">        val = _val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> _val, List&lt;Node&gt; _children)</span> </span>&#123;</span><br><span class="line">        val = _val;</span><br><span class="line">        children = _children;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preOrder</span><span class="params">(Node root)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 准备一个列表</span></span><br><span class="line">	List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 鲁棒性代码</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 准备一个栈</span></span><br><span class="line">    Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 准备一个循环</span></span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">        root = stack.pop(); <span class="comment">// 注：此处出栈的元素必须绑定到root变量上，否则会超时</span></span><br><span class="line">        </span><br><span class="line">        res.add(root.val);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 把当前节点的子节点按照特定顺序入栈</span></span><br><span class="line">        <span class="comment">// 先入栈右边的节点，最后入栈左节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=root.children.size()-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123; <span class="comment">// 从右往左遍历</span></span><br><span class="line">            stack.push(root.children.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="代码重现"><a href="#代码重现" class="headerlink" title="代码重现"></a>代码重现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preOrder</span><span class="params">(Node root)</span></span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">    </span><br><span class="line">    Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">        <span class="comment">// 当前节点</span></span><br><span class="line">        root = stack.pop();</span><br><span class="line">        <span class="comment">// 以特定顺序入栈当前节点的子节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = root.children.size()-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">         	stack.push(root.children.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>alright here, until next time 😄</p>
</blockquote>
]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>N叉树的前序遍历</title>
    <url>/Node/2020/09/16/%E7%AE%97%E6%B3%95/%E6%A0%91/20200916-N%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86(%E9%80%92%E5%BD%92%E6%96%B9%E5%BC%8F).html</url>
    <content><![CDATA[<h4 id="对N叉树进行前序遍历（递归方式）"><a href="#对N叉树进行前序遍历（递归方式）" class="headerlink" title="对N叉树进行前序遍历（递归方式）"></a>对N叉树进行前序遍历（递归方式）</h4><h5 id="题设与要求"><a href="#题设与要求" class="headerlink" title="题设与要求"></a>题设与要求</h5><a id="more"></a>

<p><img src="C:%5CUsers%5CHenryInSH%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200916215515549.png" alt="题设与要求"></p>
<h5 id="分析题目的难点"><a href="#分析题目的难点" class="headerlink" title="分析题目的难点"></a>分析题目的难点</h5><blockquote>
<p>1 N叉树的前序遍历是到底是什么？</p>
<p>根据上面的题目示例，前序遍历 = 根节点 + 左节点 - … - 右节点；</p>
</blockquote>
<blockquote>
<p>2 要怎样才能以前序遍历的顺序遍历N叉树中的节点？</p>
<p>手段：深度优先遍历(DFS) + 递归调用（因为是在重复进行规模更小的问题）；</p>
</blockquote>
<blockquote>
<p>3 如何能够存储<strong>当前正在被遍历的节点</strong>？</p>
<p>手段：准备一个列表，在遍历时，把当前节点添加进去；</p>
</blockquote>
<h5 id="递归思路"><a href="#递归思路" class="headerlink" title="递归思路"></a>递归思路</h5><ul>
<li>1 先处理<strong>当前节点对应的子树</strong>；</li>
<li>2 然后依次遍历<strong>当前节点的子节点所对应的子树</strong>，并使用相同的方式来处理<strong>该子树中的节点</strong>；</li>
</ul>
<h5 id="把思路翻译成代码"><a href="#把思路翻译成代码" class="headerlink" title="把思路翻译成代码"></a>把思路翻译成代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// N叉树的定义（题目已给出）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Node&gt; children; <span class="comment">// 有一堆的孩子节点</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> _val)</span> </span>&#123;</span><br><span class="line">        val = _val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> _val, List&lt;Node&gt; _children)</span> </span>&#123;</span><br><span class="line">        val = _val;</span><br><span class="line">        children = _children;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编写的代码</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="comment">// 准备一个数组，用于存储当前正在被遍历的节点</span></span><br><span class="line">	List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定义前序遍历函数</span></span><br><span class="line">    <span class="comment">// 作用：以前序遍历的规则对N叉树中的节点进行遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 递归终结条件; / 递归调用触底返回的条件</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根节点（当前节点）</span></span><br><span class="line">        res.add(root.val);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按照顺序来遍历根节点的孩子节点</span></span><br><span class="line">        <span class="keyword">for</span>(Node child:root.children)&#123;</span><br><span class="line">            <span class="comment">// 对当前子节点进行递归调用（以在更小的规模上做同样的事情）</span></span><br><span class="line">            preorder(child);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="代码拆解SOP"><a href="#代码拆解SOP" class="headerlink" title="代码拆解SOP"></a>代码拆解SOP</h5><blockquote>
<p>1 准备一个列表，用来存储当前正在被遍历的节点；</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>2 使用递归的方式实现preOrder()方法；</p>
<ul>
<li>作用：按照前序遍历的规则把N叉树中的节点添加到列表中，并返回列表；</li>
<li>递归的手段：<ul>
<li>1 递归终结条件（递归调用触底返回条件）/ 鲁棒性代码；</li>
<li>2 定义本级递归需要完成的工作；<ul>
<li>1 缩小问题的规模，并对小规模的问题进行同样的处理；</li>
<li>2 使用小规模问题的处理结果来解决大问题；</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p>01 递归终止条件；</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 递归终结条件/递归调用触底返回的条件</span></span><br><span class="line"><span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>02 本级递归要做的事情；</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历当前节点的所有子节点</span></span><br><span class="line"><span class="keyword">for</span>(Node child : root.children)&#123;</span><br><span class="line">    <span class="comment">// 对子节点所表示的N叉树执行前序遍历操作</span></span><br><span class="line">    preOrder(child);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>3 在本级递归结束后，返回res列表</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure>

<h5 id="代码重现"><a href="#代码重现" class="headerlink" title="代码重现"></a>代码重现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preOrder</span><span class="params">(Node root)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 递归终止条件</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 本级递归的工作</span></span><br><span class="line">    <span class="keyword">for</span>(Node child:root.children)&#123;</span><br><span class="line">        preOrder(child);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 本级递归调用结束后的返回值</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>until next time😄</p>
</blockquote>
]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>盛水最多的容器</title>
    <url>/Array/2020/09/15/%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84/20200915-%E7%9B%9B%E6%B0%B4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AE%B9%E5%99%A8.html</url>
    <content><![CDATA[<h4 id="使用数组构造盛水最多的容器"><a href="#使用数组构造盛水最多的容器" class="headerlink" title="使用数组构造盛水最多的容器"></a>使用数组构造盛水最多的容器</h4><h5 id="题设与要求"><a href="#题设与要求" class="headerlink" title="题设与要求"></a>题设与要求</h5><a id="more"></a>

<p><img src="https://s1.ax1x.com/2020/09/15/w6GfeK.png" alt="题设与要求"></p>
<h5 id="分析要求（得到难点）"><a href="#分析要求（得到难点）" class="headerlink" title="分析要求（得到难点）"></a>分析要求（得到难点）</h5><blockquote>
<p>如何才能让容器盛放尽可能多的水呢？</p>
<p>分析：V = S * D;    S = length * height;</p>
<ul>
<li><p>获取到length；</p>
<p>手段：使用数组中两个指针来求取指针间距length；</p>
</li>
<li><p>获取到height；</p>
<p>手段：两个指针指向的元素值的较小者（因为面积是由短板决定的）</p>
</li>
</ul>
</blockquote>
<h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><ul>
<li><p>1 准备两个指针i、j，分别指向数组的头元素&amp;尾元素；</p>
</li>
<li><p>2 计算当前数组元素所围成的界面面积，并作为当前Smax；</p>
</li>
<li><p>3 准备一个循环，在循环中：</p>
<ul>
<li>1 按照<strong>特定规则</strong>来更新指针i/指针j，以使得面积S尽可能变大；</li>
<li>2 使用新的界面面积与旧的截面面积比较，从而更新Smax；</li>
</ul>
<hr>
<p>循环结束时得到的Smax就是数组元素可能围成的界面面积的最大值；</p>
</li>
<li><p>4 返回这个最大值即可；</p>
</li>
</ul>
<h5 id="把思路翻译成代码"><a href="#把思路翻译成代码" class="headerlink" title="把思路翻译成代码"></a>把思路翻译成代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span></span>&#123; <span class="comment">// 参数：一个由挡板高度作为元素所组成的数组</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 准备两个指针	作用：指向数组的头元素与尾元素</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = height.length - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 准备一个循环	作用：计算面积的最大值</span></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)&#123; <span class="comment">// 循环次数不可预期，使用while循环</span></span><br><span class="line">        <span class="comment">// 用旧的res 与 新的res中的较大者来更新res</span></span><br><span class="line">        res = Math.max(res, (j - i) * Math.min(height[i], height[j]));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 更新指针</span></span><br><span class="line">        <span class="keyword">if</span>(height[i] &lt; height[j])&#123; <span class="comment">// 如果指针指向的是一个短板，移动另一个指针肯定不会让Smax更大</span></span><br><span class="line">            i++; <span class="comment">// 所以这里移动表示短板的指针</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>until next time 😄</p>
</blockquote>
]]></content>
      <categories>
        <category>Array</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>删除数组中的重复项</title>
    <url>/Array/2020/09/15/%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84/20200915-%E5%88%A0%E9%99%A4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9.html</url>
    <content><![CDATA[<h4 id="删除数组中的重复项"><a href="#删除数组中的重复项" class="headerlink" title="删除数组中的重复项"></a>删除数组中的重复项</h4><h5 id="题设与要求"><a href="#题设与要求" class="headerlink" title="题设与要求"></a>题设与要求</h5><a id="more"></a>

<p><font size=2>没有找到截长图的好用工具，所以先用图片拼接吧</font></p>
<p><img src="https://s1.ax1x.com/2020/09/15/w6uQyD.png" alt="题设与要求"></p>
<p><img src="https://s1.ax1x.com/2020/09/15/w6uhXF.png" alt="示例2"></p>
<p><img src="https://s1.ax1x.com/2020/09/15/w6Km7j.png" alt="备注说明"></p>
<h5 id="分析（约束-与-难点）"><a href="#分析（约束-与-难点）" class="headerlink" title="分析（约束 与 难点）"></a>分析（约束 与 难点）</h5><ul>
<li>如何找到排序数组中的重复项？   <ul>
<li>在排序数组中，重复的项一定是相邻的。所以只需要比较相邻的两个元素是否相等即可</li>
</ul>
</li>
<li>找到重复的元素后，如何把元素删除掉？   <ul>
<li>数组中删除元素的方式就只有覆盖元素了</li>
</ul>
</li>
</ul>
<h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><ul>
<li>1 先找到数组中的重复元素；<ul>
<li>手段：比较两个指针指向的元素是否相等（因为可能同一个元素多次重复出现）</li>
</ul>
</li>
<li>2 然后删除掉重复多余的元素；<ul>
<li>手段：当出现新的元素/不重复元素时，把新元素覆盖到正确的位置上；</li>
</ul>
</li>
<li>3 处理数组中剩余的元素；<ul>
<li>既然我们只是要返回不重复的有序元素，后面的元素保留即可（如果需要可以填充为null）</li>
</ul>
</li>
</ul>
<h5 id="把思路翻译成代码"><a href="#把思路翻译成代码" class="headerlink" title="把思路翻译成代码"></a>把思路翻译成代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 准备两个指针，这样能够对数组元素进行预期的比较</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指针j作为数组的遍历指针即可</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;nums.length; j++)&#123;</span><br><span class="line">        <span class="comment">// 比较两个元素是否相等</span></span><br><span class="line">        <span class="comment">// 如果相等，说明出现了重复元素，则...	移动后指针即可：j++</span></span><br><span class="line">        <span class="keyword">if</span>(nums[i] == nums[j])&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果不相等,说明出现了新元素，则...	把新元素绑定到/覆盖到正确的位置上</span></span><br><span class="line">            <span class="comment">// 手段：把后指针指向的元素覆盖到前指针位置的下一个位置</span></span><br><span class="line">            <span class="comment">// 把前指针后移一位</span></span><br><span class="line">            i++; </span><br><span class="line">            <span class="comment">// 把新元素绑定到正确的位置</span></span><br><span class="line">            nums[i] = nums[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回nums[]数组的前N个元素（不重复）组成的子数组的长度</span></span><br><span class="line">    <span class="keyword">return</span> i+<span class="number">1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="代码分解"><a href="#代码分解" class="headerlink" title="代码分解"></a>代码分解</h5><blockquote>
<p>1 找到重复的元素；</p>
<p>手段：使用两个指针，比较数组中相邻的元素；</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>; <span class="comment">// like an anchor</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; nums.length; j++)&#123;</span><br><span class="line">        <span class="comment">// 比较相邻的两个元素	作用：找到重复的元素</span></span><br><span class="line">        <span class="keyword">if</span>(nums[i] == nums[j])&#123;</span><br><span class="line">            <span class="comment">// 找到重复元素之后，要怎么处理？</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>2 处理找到的重复元素；</p>
<p>手段：把重复元素后面的新元素覆盖到/绑定到正确的位置上；</p>
<p>特征：这并没有删除多余的重复元素，只是构造出了一个不重复元素的子数组；</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j &lt; nums.length; j++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums[j] == nums[i])&#123;</span><br><span class="line">        <span class="comment">// 只移动后指针即可 j++</span></span><br><span class="line">        <span class="comment">// 手段：跳过本次循环的其他代码</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 找到新的元素时...</span></span><br><span class="line">        <span class="comment">// 把新元素绑定到正确的位置</span></span><br><span class="line">        i++;</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// 循环结束后，会得到一个无重复元素的子数组</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>3 返回有序子数组的长度；</p>
<p>手段：使用指针i的值凑出子数组的长度len；</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> i+<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h5 id="代码重现"><a href="#代码重现" class="headerlink" title="代码重现"></a>代码重现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 这个鲁棒性代码和 if(nums == null) return 0;有差别吗</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; nums.length; j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[j] == nums[i])&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i++;</span><br><span class="line">            nums[i] = nums[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> i+<span class="number">1</span>; <span class="comment">// 返回有序子数组的长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>until next time 😄</p>
</blockquote>
]]></content>
      <categories>
        <category>Array</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>移动数组中的零到特定位置（双指针 + 交换操作）</title>
    <url>/Array/2020/09/15/%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84/20200915-%E7%A7%BB%E5%8A%A8%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%9B%B6%E5%88%B0%E7%89%B9%E5%AE%9A%E4%BD%8D%E7%BD%AE%EF%BC%88%E5%8F%8C%E6%8C%87%E9%92%88-+-%E4%BA%A4%E6%8D%A2%E6%93%8D%E4%BD%9C%EF%BC%89.html</url>
    <content><![CDATA[<h4 id="把数组中所有的零元素移动到数组末尾"><a href="#把数组中所有的零元素移动到数组末尾" class="headerlink" title="把数组中所有的零元素移动到数组末尾"></a>把数组中所有的零元素移动到数组末尾</h4><h5 id="题设与要求"><a href="#题设与要求" class="headerlink" title="题设与要求"></a>题设与要求</h5><a id="more"></a>

<p><img src="https://s1.ax1x.com/2020/09/15/wyITmt.png" alt="题设与要求"></p>
<h5 id="分析（约束-amp-难点）"><a href="#分析（约束-amp-难点）" class="headerlink" title="分析（约束 &amp; 难点）"></a>分析（约束 &amp; 难点）</h5><ul>
<li><p>约束；</p>
<blockquote>
<p> 如何把0移动到数组末尾？</p>
</blockquote>
<blockquote>
<p>如何保持非零元素的相对顺序？</p>
</blockquote>
</li>
<li><p>难点；</p>
<blockquote>
<p>有可能用一个操作同时满足两个约束吗？</p>
<p>这时候需要使用具体考察一个测试用例[0, 1, 0, 3, 12]，否则操作的过程非常不清晰（除非你可以图形化的调试）</p>
</blockquote>
</li>
<li><p>手段；</p>
<ul>
<li>把非零元素与<strong>指针指向的元素</strong>进行交换；<ul>
<li>如果<strong>指针指向的元素</strong>为0，则：<ul>
<li>交换后，0元素就会被交换到数组的后面（它还可能被继续交换到数组更靠后的位置）；</li>
</ul>
</li>
<li>如果指针指向的元素不为0，则：<ul>
<li>交换操作等同于什么都没有做。</li>
</ul>
</li>
</ul>
</li>
<li>执行完成交换后，需要把两个指针都向后移动一个位置；</li>
</ul>
</li>
</ul>
<h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><ul>
<li>1 准备两个指针：一个用于保持元素的相对顺序（anchor），一个用于遍历数组中的元素（explorer）；</li>
<li>2 对数组元素进行遍历，如果当前元素为非零元素，则：<ul>
<li>1 把当前元素与anchor指向的元素进行交换；<ul>
<li>作用：1 把非零元素绑定到了预期位置； 2 把0元素移动到了数组靠后的位置（这个0还可能继续向后移动）</li>
</ul>
</li>
<li>2 交换操作后，把anchor指针指向下一个位置；<ul>
<li>作用：使anchor指针指向<strong>非零元素预期被交换到的位置</strong>；</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>这个思路并不流畅，一点子都不流畅😳</p>
</blockquote>
<h5 id="把思路翻译成代码"><a href="#把思路翻译成代码" class="headerlink" title="把思路翻译成代码"></a>把思路翻译成代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeros</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 准备一个anchor指针；	作用：指向非零元素预期被交换到的位置；	</span></span><br><span class="line">    <span class="keyword">int</span> anchor = <span class="number">0</span>; <span class="comment">// 初始化指向数组的头元素；</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> explorer=<span class="number">0</span>; explorer &lt; nums.length; explorer++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[explorer] != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[anchor];</span><br><span class="line">            nums[anchor] = nums[explorer];</span><br><span class="line">            nums[explorer] = temp;</span><br><span class="line">            </span><br><span class="line">            anchor++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="添加鲁棒性代码"><a href="#添加鲁棒性代码" class="headerlink" title="添加鲁棒性代码"></a>添加鲁棒性代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(nums == <span class="keyword">null</span>)&#123;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="代码分解SOP"><a href="#代码分解SOP" class="headerlink" title="代码分解SOP"></a>代码分解SOP</h5><ul>
<li><p>1 准备anchor指针；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> anchor = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>2 遍历数组元素，找到非零元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> explorer=<span class="number">0</span>; explorer &lt; nums.length; explorer++)&#123;</span><br><span class="line">    <span class="comment">// 找到非零元素...</span></span><br><span class="line">    <span class="keyword">if</span>(nums[explorer] != <span class="number">0</span>)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>找到非零元素后…</p>
<ul>
<li><p>1 把非零元素交换到预期的位置；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> temp = nums[explorer];</span><br><span class="line">nums[explorer] = nums[anchor];</span><br><span class="line">nums[anchor] = temp;</span><br></pre></td></tr></table></figure>
</li>
<li><p>2 把anchor指针移动到下一个位置；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">anchor++;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<p>遍历结束后，所有的非零元素都已经被交换到了预期位置，所有的0元素都已经被交换到了数组末尾；</p>
</li>
</ul>
<h5 id="代码重现"><a href="#代码重现" class="headerlink" title="代码重现"></a>代码重现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeros</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> anchor = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> explorer=<span class="number">0</span>; explorer &lt; nums.length; explorer++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[explorer] != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[explorer];</span><br><span class="line">            nums[explorer] = nums[anchor];</span><br><span class="line">            nums[anchor] = temp;</span><br><span class="line">            </span><br><span class="line">            anchor++;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>一个老年人可能对她的孙子有着令人讨厌的耐心，甚至各种苦口婆心也变成了叨叨叨 不听不听 和尚念经🐢</p>
</blockquote>
]]></content>
      <categories>
        <category>Array</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>移动数组中的零到特定位置</title>
    <url>/Array/2020/09/15/interview/20200915-%E7%A7%BB%E5%8A%A8%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%9B%B6%E5%88%B0%E7%89%B9%E5%AE%9A%E4%BD%8D%E7%BD%AE(%E5%8F%8C%E6%8C%87%E9%92%88+%E8%A6%86%E7%9B%96).html</url>
    <content><![CDATA[<h4 id="把数组中所有的零都移动到数组尾部"><a href="#把数组中所有的零都移动到数组尾部" class="headerlink" title="把数组中所有的零都移动到数组尾部"></a>把数组中所有的零都移动到数组尾部</h4><h5 id="题设与要求"><a href="#题设与要求" class="headerlink" title="题设与要求"></a>题设与要求</h5><a id="more"></a>

<p><img src="https://s1.ax1x.com/2020/09/15/wyITmt.png" alt="题目与示例"></p>
<h5 id="分析出问题的难点"><a href="#分析出问题的难点" class="headerlink" title="分析出问题的难点"></a>分析出问题的难点</h5><blockquote>
<p>如何把0都移到数组的末尾？</p>
</blockquote>
<blockquote>
<p>如何能保持非零元素的相对顺序呢？</p>
</blockquote>
<blockquote>
<p>bear in mind:</p>
<p>对于一维数组这种数据结构，能够执行的操作有：</p>
<ul>
<li>遍历（需要一个指针）；</li>
<li>比较两个元素（需要两个指针）<ul>
<li>相邻元素；</li>
<li>指针指向的元素；</li>
</ul>
</li>
<li>交换两个位置上的元素</li>
</ul>
</blockquote>
<ul>
<li>手段1：<ul>
<li>1 依次找到所有的非零元素，然后<strong>向前覆盖</strong>到特定的位置（以<strong>保持非零元素的相对顺序</strong>）；</li>
<li>2 把数组中那些没有被覆盖的位置填充上0；</li>
</ul>
</li>
</ul>
<h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><ul>
<li><p>1 定义一个循环，顺序遍历数组中的每一个元素（遍历数组需要提供一个指针cursor）；</p>
</li>
<li><p>2 准备另一个指针expect_cover，用于指向<strong>当前非零元素预期覆盖的位置</strong>；</p>
<ul>
<li>初始化指向<strong>数组的头元素</strong>；</li>
</ul>
</li>
<li><p>3 当遇到非零元素时，则：</p>
<ul>
<li>1 把非零元素覆盖到<strong>expect_cover指针指向的位置</strong>；</li>
<li>2 把expect_cover指向向后移动一个位置；</li>
</ul>
<hr>
<p>遍历/循环结束后，所有的非零元素就已经按照相对顺序被绑定到了预期的位置；</p>
</li>
<li><p>4 把expect_cover指针指向的位置（&amp;后面的所有位置）上的元素都绑定0；</p>
</li>
</ul>
<h5 id="把思路翻译成代码"><a href="#把思路翻译成代码" class="headerlink" title="把思路翻译成代码"></a>把思路翻译成代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 准备一个指针 expect_cover	初始化指向数组的头元素  作用：指向非零元素要绑定到的位置</span></span><br><span class="line">    <span class="keyword">int</span> expect_cover = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 准备一个循环	作用：遍历数组，找到其中的非零元素以执行需要的操作</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> cursor = <span class="number">0</span>; cursor &lt; nums.length; cursor++) &#123;</span><br><span class="line">        <span class="comment">// 如果当前元素是非零元素,则：</span></span><br><span class="line">        <span class="keyword">if</span>(nums[cursor] != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 把元素覆盖到指定的位置</span></span><br><span class="line">            nums[expect_cover++] = nums[cursor]; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">/* 循环结束后，指针j指向最后一个非零元素的下一个位置 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把从expect_cover指针到数组末尾的所有位置都绑定0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> cursor = expect_cover; cursor &lt; nums.length; cursor++) &#123;</span><br><span class="line">        nums[expect_cover++] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="添加鲁棒性代码"><a href="#添加鲁棒性代码" class="headerlink" title="添加鲁棒性代码"></a>添加鲁棒性代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 鲁棒性代码</span></span><br><span class="line"><span class="keyword">if</span>(nums==<span class="keyword">null</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="使用不同的测试用例检查代码的正确性-amp-健壮性"><a href="#使用不同的测试用例检查代码的正确性-amp-健壮性" class="headerlink" title="使用不同的测试用例检查代码的正确性&amp;健壮性"></a>使用不同的测试用例检查代码的正确性&amp;健壮性</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">现在好像没有特别好的方式（只能在leetcode编辑器的控制台上修改测试用例）</span><br><span class="line"><span class="comment">// 修改测试用例的建议</span></span><br><span class="line">    <span class="number">1</span> 为空的情况；</span><br><span class="line">    <span class="number">2</span> 元素重复的情况；</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<h5 id="代码重现"><a href="#代码重现" class="headerlink" title="代码重现"></a>代码重现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeros</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 鲁棒性代码</span></span><br><span class="line">    <span class="keyword">if</span>(nums == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 不用做任何操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 准备一个指针expect_cover	作用：指向预期被当前非零元素覆盖的位置；</span></span><br><span class="line">    <span class="keyword">int</span> expect_cover = <span class="number">0</span>; <span class="comment">// 初始化指向数组的头元素</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 准备一个循环	作用：找到非零元素，并把它们按顺序绑定到预期的位置</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> cursor=<span class="number">0</span>; cursor &lt; nums.length; cursor++)&#123;</span><br><span class="line">        <span class="comment">// 如果当前元素为非零元素，则...</span></span><br><span class="line">        <span class="keyword">if</span>(nums[cursor] != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 把该元素绑定到预期的位置：如果一开始就是非零元素，这里其实就做了自己绑定到自己的操作</span></span><br><span class="line">            nums[expect_cover++] = nums[cursor];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 把expect_cover指针开始的所有位置都绑定0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> cursor=expect_cover; cursor &lt; nums.length; cursor++)&#123;</span><br><span class="line">        nums[cursor] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Array</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>移动数组中的零到特定位置</title>
    <url>/Array/2020/09/15/%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84/20200915-%E7%A7%BB%E5%8A%A8%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%9B%B6%E5%88%B0%E7%89%B9%E5%AE%9A%E4%BD%8D%E7%BD%AE(%E5%8F%8C%E6%8C%87%E9%92%88+%E8%A6%86%E7%9B%96).html</url>
    <content><![CDATA[<h4 id="把数组中所有的零都移动到数组尾部"><a href="#把数组中所有的零都移动到数组尾部" class="headerlink" title="把数组中所有的零都移动到数组尾部"></a>把数组中所有的零都移动到数组尾部</h4><h5 id="题设与要求"><a href="#题设与要求" class="headerlink" title="题设与要求"></a>题设与要求</h5><a id="more"></a>

<p><img src="https://s1.ax1x.com/2020/09/15/wyITmt.png" alt="题目与示例"></p>
<h5 id="分析出问题的难点"><a href="#分析出问题的难点" class="headerlink" title="分析出问题的难点"></a>分析出问题的难点</h5><blockquote>
<p>如何把0都移到数组的末尾？</p>
</blockquote>
<blockquote>
<p>如何能保持非零元素的相对顺序呢？</p>
</blockquote>
<blockquote>
<p>bear in mind:</p>
<p>对于一维数组这种数据结构，能够执行的操作有：</p>
<ul>
<li>遍历（需要一个指针）；</li>
<li>比较两个元素（需要两个指针）<ul>
<li>相邻元素；</li>
<li>指针指向的元素；</li>
</ul>
</li>
<li>交换两个位置上的元素</li>
</ul>
</blockquote>
<ul>
<li>手段1：<ul>
<li>1 依次找到所有的非零元素，然后<strong>向前覆盖</strong>到特定的位置（以<strong>保持非零元素的相对顺序</strong>）；</li>
<li>2 把数组中那些没有被覆盖的位置填充上0；</li>
</ul>
</li>
</ul>
<h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><ul>
<li><p>1 定义一个循环，顺序遍历数组中的每一个元素（遍历数组需要提供一个指针cursor）；</p>
</li>
<li><p>2 准备另一个指针expect_cover，用于指向<strong>当前非零元素预期覆盖的位置</strong>；</p>
<ul>
<li>初始化指向<strong>数组的头元素</strong>；</li>
</ul>
</li>
<li><p>3 当遇到非零元素时，则：</p>
<ul>
<li>1 把非零元素覆盖到<strong>expect_cover指针指向的位置</strong>；</li>
<li>2 把expect_cover指向向后移动一个位置；</li>
</ul>
<hr>
<p>遍历/循环结束后，所有的非零元素就已经按照相对顺序被绑定到了预期的位置；</p>
</li>
<li><p>4 把expect_cover指针指向的位置（&amp;后面的所有位置）上的元素都绑定0；</p>
</li>
</ul>
<h5 id="把思路翻译成代码"><a href="#把思路翻译成代码" class="headerlink" title="把思路翻译成代码"></a>把思路翻译成代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 准备一个指针 expect_cover	初始化指向数组的头元素  作用：指向非零元素要绑定到的位置</span></span><br><span class="line">    <span class="keyword">int</span> expect_cover = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 准备一个循环	作用：遍历数组，找到其中的非零元素以执行需要的操作</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> cursor = <span class="number">0</span>; cursor &lt; nums.length; cursor++) &#123;</span><br><span class="line">        <span class="comment">// 如果当前元素是非零元素,则：</span></span><br><span class="line">        <span class="keyword">if</span>(nums[cursor] != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 把元素覆盖到指定的位置</span></span><br><span class="line">            nums[expect_cover++] = nums[cursor]; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">/* 循环结束后，指针j指向最后一个非零元素的下一个位置 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把从expect_cover指针到数组末尾的所有位置都绑定0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> cursor = expect_cover; cursor &lt; nums.length; cursor++) &#123;</span><br><span class="line">        nums[expect_cover++] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="添加鲁棒性代码"><a href="#添加鲁棒性代码" class="headerlink" title="添加鲁棒性代码"></a>添加鲁棒性代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 鲁棒性代码</span></span><br><span class="line"><span class="keyword">if</span>(nums==<span class="keyword">null</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="使用不同的测试用例检查代码的正确性-amp-健壮性"><a href="#使用不同的测试用例检查代码的正确性-amp-健壮性" class="headerlink" title="使用不同的测试用例检查代码的正确性&amp;健壮性"></a>使用不同的测试用例检查代码的正确性&amp;健壮性</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">现在好像没有特别好的方式（只能在leetcode编辑器的控制台上修改测试用例）</span><br><span class="line"><span class="comment">// 修改测试用例的建议</span></span><br><span class="line">    <span class="number">1</span> 为空的情况；</span><br><span class="line">    <span class="number">2</span> 元素重复的情况；</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<h5 id="代码重现"><a href="#代码重现" class="headerlink" title="代码重现"></a>代码重现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeros</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 鲁棒性代码</span></span><br><span class="line">    <span class="keyword">if</span>(nums == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 不用做任何操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 准备一个指针expect_cover	作用：指向预期被当前非零元素覆盖的位置；</span></span><br><span class="line">    <span class="keyword">int</span> expect_cover = <span class="number">0</span>; <span class="comment">// 初始化指向数组的头元素</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 准备一个循环	作用：找到非零元素，并把它们按顺序绑定到预期的位置</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> cursor=<span class="number">0</span>; cursor &lt; nums.length; cursor++)&#123;</span><br><span class="line">        <span class="comment">// 如果当前元素为非零元素，则...</span></span><br><span class="line">        <span class="keyword">if</span>(nums[cursor] != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 把该元素绑定到预期的位置：如果一开始就是非零元素，这里其实就做了自己绑定到自己的操作</span></span><br><span class="line">            nums[expect_cover++] = nums[cursor];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 把expect_cover指针开始的所有位置都绑定0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> cursor=expect_cover; cursor &lt; nums.length; cursor++)&#123;</span><br><span class="line">        nums[cursor] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Array</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机基础（1）</title>
    <url>/Computer-Basic/2020/09/14/interview/20200914-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%EF%BC%881%EF%BC%89.html</url>
    <content><![CDATA[<h5 id="计算机中数据的表示方式"><a href="#计算机中数据的表示方式" class="headerlink" title="计算机中数据的表示方式"></a>计算机中数据的表示方式</h5><a id="more"></a>

<blockquote>
<p>知识卡：在计算机中，数据是使用二进制进行表示的；</p>
<p>原因：</p>
<ul>
<li>1 计算机内部是由IC（集成电路）构成的；</li>
<li>2 IC的每个引脚，只能表示两种状态——二进制与IC的特性非常吻合😄；</li>
</ul>
<p>手段：IC的一个引脚表示二进制数中的一位bit（<strong>计算机中信息的最小单位</strong>）；</p>
<p>特征：</p>
<ul>
<li>1 二进制数字的位数一般是8的倍数；<ul>
<li>原因：计算机处理信息的基本单元是8位二进制数（一个字节）；</li>
<li>应用：内存和磁盘使用<strong>字节单位</strong>来读写数据；</li>
<li>用法：<ul>
<li>1 如果被处理的数字小于存储它所使用的字节空间，则：在数字的高位上补0；</li>
</ul>
</li>
</ul>
</li>
<li>2 不同的处理器的引脚数量不相同，因此一次能够处理的二进制数据的位数也就不同（比如奔腾32位处理器，一次就可以处理32位的二进制数信息 🚩 不太懂）</li>
</ul>
<p>结论：计算机中，使用二进制数来表示一切信息；</p>
</blockquote>
<blockquote>
<p>知识卡：数字的位权；</p>
<ul>
<li>是：特定<strong>位数上的数字</strong>所表示的实际权重； </li>
<li>作用：描述<strong>当前位数上的数字</strong>所表示的实际数值大小；</li>
<li>特征：<ul>
<li>1 数字所在的位数不同，数字的权重也就不同；</li>
<li>2 不同的进制下，特定位数的权重是不一样的；</li>
</ul>
</li>
<li>应用：<ul>
<li>计算<strong>特定进制下</strong>，某个<strong>数据表示方式</strong>所表示的<strong>实际数值大小</strong><ul>
<li>十进制下123的实际大小 = 1 × 100（数字1的位权） + 2 × 10（数字2的位权） + 3 × 1（数字3的位权）；</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p>知识卡：N进制；</p>
<ul>
<li>是：一种记录大数值的技术；</li>
<li>作用：表示大的数值；</li>
<li>特征：<ul>
<li>1 N进制的基数为N aka 如果一个位数上的数字达到了N，就会发生进位操作；</li>
<li>2 数值 = SUM(位上的数字 × 当前位数的权重)；</li>
</ul>
</li>
</ul>
</blockquote>
<h6 id="二进制中的运算规则"><a href="#二进制中的运算规则" class="headerlink" title="二进制中的运算规则"></a>二进制中的运算规则</h6><ul>
<li><p>常见的四则运算：加、减、乘除？？？</p>
</li>
<li><p>二进制中特有的运算：</p>
<ul>
<li><p>1 移位运算；</p>
<ul>
<li><p>作用：把二进制数值的各个数位进行移动（shift）；</p>
</li>
<li><p>特征：</p>
<ul>
<li><p>1 移动时有两个方向：向高位移动 + 向低位移动；</p>
</li>
<li><p>2 移位操作可以一次性移动多个数位；</p>
</li>
<li><p>3 可以直接对10进制数字进行移位操作，因为它的底层表示仍旧是二进制数；</p>
<hr>
</li>
<li><p>移动操作会导致一些位上的数字位空，怎么办？</p>
<ul>
<li>1 如果是向左移动，说明低权重的位会空出来，而高权重的位会溢出边界。则：<ul>
<li>给低权重的位数上补0；</li>
<li>把高权位的位数丢弃； </li>
</ul>
</li>
<li>2 如果是向右移动，说明高权重的位会空出来。则：<font size=2>有点子复杂，单独认识🚩<a href="#rightMove">跳转</a></font></li>
</ul>
</li>
</ul>
</li>
<li><p>用法/语法：待操作的数字 &lt;&lt; 预期移动的位数量；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">39</span>;</span><br><span class="line"><span class="keyword">int</span> b = a &lt;&lt; <span class="number">2</span>; <span class="comment">// 把39的二进制数值向左移动两个位置，然后把移位之后的结果绑定到变量b上</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>应用：使用移位运算来代替乘法/除法；</p>
<ul>
<li>二进制数字左移一位，则其对应的十进制表示会变成原来的2倍；</li>
<li>二进制数字右移一位，则其对应的十进制表示会变成原来的1/2倍；</li>
</ul>
<p>由于CPU能够直接对二进制数字进行运算，所以移位运算的效率要比乘除法要高（CPU也不会计算乘除法😳）</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h6 id="二进制中，如何表示负数？"><a href="#二进制中，如何表示负数？" class="headerlink" title="二进制中，如何表示负数？"></a>二进制中，如何表示负数？</h6><ul>
<li><p>手段：把<strong>二进制数字的最高位</strong>作为<strong>符号位</strong>使用；</p>
</li>
<li><p>规则：</p>
<ul>
<li>1 符号位的数字是0时，表示正数；</li>
<li>2 符号位的数字是1时，表示负数；</li>
</ul>
</li>
<li><p>用法：</p>
<ul>
<li><p>任务：使用8位二进制数字来表示（-1）DEC;</p>
<ul>
<li><p>错误手段：</p>
<ul>
<li>1 把(1)DEC转化为其二进制表示(0000 0001)BIN;</li>
<li>2 为1中得到的二进制表示添加符号位，得到(1000 0001)BIN;</li>
</ul>
<p>原因：在表示负数时，需要使用<strong>二进制数字的补数</strong>；而不是单纯地添加一个符号位🌚</p>
<blockquote>
<p>知识卡：补数；</p>
<p>是：二进制中的一种性质；</p>
<p>作用：表示负数；</p>
<p>特征：</p>
<ul>
<li>它会使用正数来表示一个负数；（因为计算机只会做加法）；</li>
</ul>
<p>用法SOP：计算一个<strong>二进制数字的补数（用来表示负数）</strong>；</p>
<ul>
<li>1 把二进制数的各个数位上的数值全部取反；</li>
<li>2 把1中得到的结果+1；</li>
</ul>
<p>应用：<strong>求一个二进制数字的负数</strong>等价于<strong>求这个二进制数字的补数</strong>；</p>
</blockquote>
</li>
<li><p>正确手段：</p>
<ul>
<li><p>1 计算(-1)DEC的绝对值，得到(1)DEC；</p>
</li>
<li><p>2 求(1)DEC的补数，从而得到(-1)DEC的二进制表示；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 把十进制的正数转化为二进制</span></span><br><span class="line">(<span class="number">1</span>)DEC = (<span class="number">0000</span> <span class="number">0001</span>)BIN</span><br><span class="line"><span class="comment">// 求二进制数字的补数</span></span><br><span class="line">Ⅰ 取反；</span><br><span class="line">(<span class="number">0000</span> <span class="number">0001</span>)BIN =&gt; (<span class="number">1111</span> <span class="number">1110</span>)BIN</span><br><span class="line">Ⅱ +<span class="number">1</span>；</span><br><span class="line">(<span class="number">1111</span> <span class="number">1110</span>)BIN + <span class="number">1</span> =&gt; (<span class="number">1111</span> <span class="number">1111</span>)BIN</span><br></pre></td></tr></table></figure>

<p>所以(-1)正确的二进制表示为(1111 1111)BIN;</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>原理/证明其正确性：</p>
<ul>
<li><p>(1)DEC的二进制表示 与 (-1)DEC的二进制表示，相加的结果是否为0；</p>
<p>结论：当<strong>使用补数的方式来表示负数</strong>时，A + (-A) = 0这个表达式才是成立的；</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>二进制数字的运算法则：</p>
<p>把二进制数字<strong>取反后加1</strong>（得到其补数）的结果，与原来的值相加，结果为0；</p>
<p>简言之，一个二进制数的负数形式其实就是它的补数；</p>
</blockquote>
<h6 id="在任何运算场景中，总是可以使用补数来表示一个负数吗？"><a href="#在任何运算场景中，总是可以使用补数来表示一个负数吗？" class="headerlink" title="在任何运算场景中，总是可以使用补数来表示一个负数吗？"></a>在任何运算场景中，总是可以使用补数来表示一个负数吗？</h6><ul>
<li><p>结论：是的；</p>
</li>
<li><p>特征：</p>
<ul>
<li>如果计算结果是负数，那么计算结果的值<strong>也是用补数形式来表示的</strong>；</li>
</ul>
</li>
<li><p>计算示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">任务：求(<span class="number">3</span> - <span class="number">5</span>)的二进制表示；</span><br><span class="line"><span class="number">1</span>. 把减法转化为加法；</span><br><span class="line">    （<span class="number">3</span> - <span class="number">5</span>） =&gt; (<span class="number">3</span> + (-<span class="number">5</span>))</span><br><span class="line"><span class="number">2</span>. 把十进制数转化为二进制数；</span><br><span class="line">    <span class="number">3</span>的二进制数字：<span class="number">0000</span> <span class="number">0011</span></span><br><span class="line">    (-<span class="number">5</span>)的二进制数字：</span><br><span class="line">    	<span class="number">5</span>的二进制数字：<span class="number">0000</span> <span class="number">0101</span></span><br><span class="line">    	(-<span class="number">5</span>)的二进制数字：<span class="number">1111</span> <span class="number">1011</span></span><br><span class="line"><span class="number">3</span> 对转化后的二进制数字执行加法运算；</span><br><span class="line">    (<span class="number">3</span> + (-<span class="number">5</span>)) &lt;=&gt; <span class="number">0000</span> <span class="number">0011</span> + <span class="number">1111</span> <span class="number">1011</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h6 id="补数在编程语言中的应用？"><a href="#补数在编程语言中的应用？" class="headerlink" title="补数在编程语言中的应用？"></a>补数在编程语言中的应用？</h6><blockquote>
<p>知识卡：一个以1开头的二进制数总是负数吗？</p>
<p>答：No.只有在<strong>规定把第一个数位视为符号位</strong>时，以1开头的二进制数才会是一个负数；</p>
</blockquote>
<p>C语言中的整数数据类型：</p>
<ul>
<li><p>unsigned short类型；</p>
<ul>
<li>特征：<ul>
<li>1 不能够处理负数；</li>
<li>2 占用两个字节的内存空间；</li>
<li>3 所能够表示整数的数据范围：0~65535；</li>
</ul>
</li>
</ul>
</li>
<li><p>short类型；</p>
<ul>
<li>特征：<ul>
<li>1 能够处理负数；</li>
<li>2 占用两个字节的内存空间；</li>
<li>3 所能够表示的整数数据范围：-32768~32767；</li>
</ul>
</li>
</ul>
</li>
<li><p>原理：为什么特征上会有这些差异（① 能否表示负数？ ② 所能表示的整数的数据范围）</p>
<ul>
<li>1 是否把二进制数字的第一位作为符号位；<ul>
<li>unsigned short没有这么做，因此它只能够表示正整数；</li>
<li>short类型<strong>规定了二进制数字的第一位是符号位</strong>，所以它能够表示正整数 &amp; 负整数；</li>
</ul>
</li>
<li>2 数据类型占用的内存空间，决定了该数据类型能够表示多少种结果；<ul>
<li>两者都占据2个字节（16个bit），所以能够表示2的16次方个结果（65536）；</li>
</ul>
</li>
<li>3 short类型规定了符号位的存在，所以可以用补数来表示负数；<ul>
<li>1 最高位为0时（表示这是一个正数），可以使用剩下的15bit来表示数值。所以正数的范围为0~32767（共32768个结果 = 2的15次方）；</li>
<li>2 最高位为1时（表示这是一个负数），仍旧可以用剩下的15bit来表示数值。但是数值范围不需要包括0，所以负数的范围是-1~-32768(共32768个结果，不包含0)</li>
</ul>
</li>
</ul>
<h6 id="二进制数字的右移操作"><a href="#二进制数字的右移操作" class="headerlink" title="二进制数字的右移操作"></a>二进制数字的右移操作</h6></li>
</ul>
<p>二进制数字的应用：</p>
<ul>
<li><p>表示<strong>图形模式</strong>；</p>
<ul>
<li><p>这种情况下，进行右移操作时，就：只需要在移动后空出的高权重位上补0；</p>
</li>
<li><p>这种情况下的右移操作也叫做<strong>逻辑右移</strong>；</p>
<p><img src="https://s1.ax1x.com/2020/09/14/wr4Q7F.png" alt="逻辑右移，高位补零"></p>
</li>
</ul>
</li>
<li><p>表示<strong>带符号的数值</strong>；</p>
<ul>
<li><p>这种情况下，进行右移操作时，就：需要在移动后空出来的高权重位上补<strong>原始二进制数字符号位的值</strong>；</p>
<ul>
<li>如果原始的二进制数字为正数，则：在高权重位上补0；</li>
<li>如果原始的二进制数字为负数（补数表示），则：在高权重位上补1；</li>
</ul>
</li>
<li><p>这种情况下的右移操作也叫做<strong>算术移位</strong>；</p>
</li>
<li><p>应用示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">任务：对(-<span class="number">4</span>)DEC执行算术右移，计算右移两位后的结果；</span><br><span class="line">预期：(-<span class="number">4</span>)右移两位后，得到的结果 = (-<span class="number">4</span>) * (<span class="number">1</span>/<span class="number">2</span>) * (<span class="number">1</span>/<span class="number">2</span>) = (-<span class="number">1</span>)DEC</span><br><span class="line">手段：按照算术移位的规则进行移位操作；</span><br><span class="line">SOP:</span><br><span class="line">	<span class="number">1</span> 把(-<span class="number">4</span>)DEC转化为二进制数字；</span><br><span class="line">        <span class="number">4</span> =&gt; <span class="number">0000</span> <span class="number">0100</span></span><br><span class="line">        (-<span class="number">4</span>) =&gt; <span class="number">1111</span> <span class="number">1100</span></span><br><span class="line">	<span class="number">2</span> 对<span class="number">1</span>中得到的二进制数字执行算术右移，移动<span class="number">2</span>位；</span><br><span class="line">        规则：在空出的高权重位上补<span class="string">"原始二进制数字符号位的值"</span>；</span><br><span class="line">        <span class="number">1111</span> <span class="number">1100</span> =&gt; (右移两位) xx11 <span class="number">1111</span> =&gt;(高权重位补“👆”) <span class="number">1111</span> <span class="number">1111</span></span><br><span class="line">	<span class="number">3</span> 验证得到的二进制结果是否符合预期；</span><br><span class="line">        手段：把二进制数字转化为DEC进制数字；</span><br><span class="line">        注：这个二进制数字是规定了符号位的二进制数字；</span><br><span class="line">        具体方法（尝试）：求出补数的原始数值；</span><br><span class="line">        SOP:</span><br><span class="line">			<span class="number">1</span> 减<span class="number">1</span>； <span class="number">1111</span> <span class="number">1111</span> - <span class="number">0000</span> <span class="number">0001</span> = <span class="number">1111</span> <span class="number">1110</span></span><br><span class="line">			<span class="number">2</span> 取反；<span class="number">1111</span> <span class="number">1110</span> =&gt;(取反后) <span class="number">0000</span> <span class="number">0001</span></span><br><span class="line">			<span class="number">3</span> 把计算结果转化为DEC进制；(<span class="number">0000</span> <span class="number">0001</span>)BIN = (<span class="number">1</span>)DEC</span><br><span class="line">		SO:</span><br><span class="line">			补数对应的原始数字为<span class="number">1</span>，说明补数表示的DEC数字为(-<span class="number">1</span>);</span><br><span class="line">		结论：符合预期 😄；</span><br></pre></td></tr></table></figure>

<p>参考图示:<img src="https://s1.ax1x.com/2020/09/14/wrTAbV.png" alt="逻辑右移 VS 算术右移"></p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>只有在右移操作时，才需要考虑<strong>逻辑移位</strong>与<strong>算术移位</strong>的差别；</p>
<p>左移操作（图形模式下表示单纯地移动，数值模式下表示乘法）时，就：在空位补零即可；</p>
</blockquote>
<h6 id="把一个8位二进制数字表示成8-N位二进制数字？"><a href="#把一个8位二进制数字表示成8-N位二进制数字？" class="headerlink" title="把一个8位二进制数字表示成8*N位二进制数字？"></a>把一个8位二进制数字表示成8*N位二进制数字？</h6><ul>
<li>手段：符号位扩充；</li>
<li>作用：把二进制数字的位数转化为其他8的倍数；</li>
<li>用法：<ul>
<li>1 如果二进制数字是正数，则：用符号位0填充高权重的位即可；</li>
<li>2 如果二进制数字是负数（用补数表示），则：用符号位1填充高权重的位即可；</li>
</ul>
</li>
</ul>
<h6 id="计算机可以执行的运算"><a href="#计算机可以执行的运算" class="headerlink" title="计算机可以执行的运算"></a>计算机可以执行的运算</h6><ul>
<li>算术运算；<ul>
<li>是：加减乘除四则运算；</li>
<li>作用：按照特定的规则，操作得到预期的结果；</li>
<li>特征：<ul>
<li>与十进制数的加减乘除一样，也涉及到进位问题；</li>
</ul>
</li>
</ul>
</li>
<li>逻辑运算；<ul>
<li>是：一种操作；</li>
<li>作用：按照特定的规则，操作得到预期的结果；</li>
<li>特征：<ul>
<li>1 对二进制数各数字位的0或1会分别进行处理；</li>
<li>2 不存在进位的问题；</li>
<li>3 有4种具体的运算；<ul>
<li>1 逻辑非(NOT运算)；<ul>
<li>规则：0变1，1变0；</li>
</ul>
</li>
<li>2 逻辑与(AND运算)；<ul>
<li>规则：全1为1，否则为0；</li>
</ul>
</li>
<li>3 逻辑或(OR运算)；<ul>
<li>规则：有1为1，否则为0；</li>
</ul>
</li>
<li>4 逻辑异或(XOR运算 exclusive-or 独家的/不同的)；<ul>
<li>规则：不同为1，相同为0；</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>技巧：<ul>
<li>1 逻辑运算中，<strong>二进制数表示的不是数值，而是一组ON/OFF开关</strong>；</li>
<li>2 逻辑运算真值表的规律；</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Computer Basic</category>
      </categories>
      <tags>
        <tag>Computer stuff</tag>
      </tags>
  </entry>
  <entry>
    <title>java基础之快速复习（5）</title>
    <url>/Java-Basic/2020/09/13/interview/20200913-java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BF%AB%E9%80%9F%E5%A4%8D%E4%B9%A0%EF%BC%885%EF%BC%89.html</url>
    <content><![CDATA[<h4 id="Java基础速查"><a href="#Java基础速查" class="headerlink" title="Java基础速查"></a>Java基础速查</h4><h5 id="JDK中哈希操作"><a href="#JDK中哈希操作" class="headerlink" title="JDK中哈希操作"></a>JDK中哈希操作</h5><p>参考：<a href="https://juejin.im/post/6844903583255642120#heading-7">JDK中的哈希应用</a></p>
<a id="more"></a>

<blockquote>
<p>知识卡：哈希；</p>
<ul>
<li><p>是：一种技术；</p>
</li>
<li><p>作用：把任意长度的输入转化为固定长度的输出（哈希值）；</p>
</li>
<li><p>特征：</p>
<ul>
<li>1 相同的输入总是得到相同的输出；</li>
<li>2 不同的输入总是得到不同的输出（真实实现时无法保证 aka 碰撞）；</li>
</ul>
</li>
<li><p>手段：哈希函数；</p>
<ul>
<li>直接定址法：直接以<strong>关键字k或者k加上某个常数（k+c）</strong>作为哈希地址。</li>
<li>数字分析法：提取<strong>关键字中取值比较均匀的数字</strong>作为哈希地址。</li>
<li>除留余数法：用<strong>关键字k除以某个不大于哈希表长度m的数p</strong>，将所得余数作为哈希表地址。</li>
</ul>
<p>衡量哈希函数质量好坏的指标：1 发生碰撞的概率； 2 发生碰撞时的解决方案；</p>
<ul>
<li>哈希函数发生碰撞时，常用的解决手段：<ul>
<li>1 开放定址法；<ul>
<li>如果发生了冲突，就去寻找下一个空的散列地址；</li>
</ul>
</li>
<li>2 链地址法；<ul>
<li>如果发生冲突，就把新的键值对作为链表节点链接在已有的键值对后面；</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h6 id="HashMap存储键值对的过程"><a href="#HashMap存储键值对的过程" class="headerlink" title="HashMap存储键值对的过程"></a>HashMap存储键值对的过程</h6><ul>
<li>1 根据key-value中的key，找到键值对预期插入的哈希桶数组中的位置；</li>
<li>2 根据具体情况，把键值对插入到底层数据结构中；</li>
</ul>
<h6 id="根据key-value中的key来计算预期插入到的桶位置（Java8）"><a href="#根据key-value中的key来计算预期插入到的桶位置（Java8）" class="headerlink" title="根据key-value中的key来计算预期插入到的桶位置（Java8）"></a>根据key-value中的key来计算预期插入到的桶位置（Java8）</h6><p>SOP:</p>
<ul>
<li><p>1 根据key计算出一个哈希值；</p>
</li>
<li><p>2 根据哈希值与哈希桶数组的长度，计算得到预期插入的桶位置；</p>
<ul>
<li>代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>代码说明</p>
<ul>
<li><p>1 先使用key的hashCode()方法，得到一个最初版本的hash值（一个32位的数字）；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">h = key.hashCode() <span class="comment">// hashCode()是Object类型的实例方法</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>2 对1中得到的hash值执行无符号右移16位的操作；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">h &gt;&gt;&gt; <span class="number">16</span> <span class="comment">// &gt;&gt;&gt;是无符号右移的操作符：忽略符号位，空位都用0补齐</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>3 把1中计算得到的hash值与右移16位之后的结果，进行异或操作；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>作用(2+3)：最终减少哈希碰撞;</p>
<p>手段：把最初hash值的高16位与低16位异或，使得每一位的数字都能参与到<strong>桶位置的计算</strong>中；</p>
<p>原理：避免了<strong>虽然哈希值不同，但由于哈希值低位上的数字相同，而计算得到了相同的桶位置</strong>这种碰撞情况；</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="Java中的基本数据类型（8种）"><a href="#Java中的基本数据类型（8种）" class="headerlink" title="Java中的基本数据类型（8种）"></a>Java中的基本数据类型（8种）</h5><h6 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h6><ul>
<li>1 整数类型；<ul>
<li><code>byte</code> - 8 位。<ul>
<li>数值范围：-128~127；</li>
</ul>
</li>
<li><code>short</code> - 16 位。</li>
<li><code>int</code> - 32 位。</li>
<li><code>long</code> - 64 位，赋值时一般在数字后加上 <code>l</code> 或 <code>L</code>。</li>
</ul>
</li>
<li>2 浮点型；<ul>
<li><code>float</code> - 32 位，直接赋值时必须在数字后加上 <code>f</code> 或 <code>F</code>。</li>
<li><code>double</code> - 64 位，赋值时一般在数字后加 <code>d</code> 或 <code>D</code> 。</li>
</ul>
</li>
<li>3 字符型；<ul>
<li><code>char</code> - 16 位，存储 Unicode 码，用单引号赋值。</li>
<li>数值范围：0~65535；</li>
</ul>
</li>
<li>4 布尔型；<ul>
<li><code>boolean</code> - 只有 true 和 false 两个取值。</li>
</ul>
</li>
</ul>
<h6 id="为什么long类型与double类型都是使用8字节内存，但是所能表示的数据范围却差别那么大呢？"><a href="#为什么long类型与double类型都是使用8字节内存，但是所能表示的数据范围却差别那么大呢？" class="headerlink" title="为什么long类型与double类型都是使用8字节内存，但是所能表示的数据范围却差别那么大呢？"></a>为什么long类型与double类型都是使用8字节内存，但是所能表示的数据范围却差别那么大呢？</h6><p>答：因为整数类型与浮点数类型在计算机中的底层表示是不一样的；</p>
<ul>
<li>整数类型long的底层存储方式；<ul>
<li>符号位（一个bit） + 数值位（63个bit）；</li>
</ul>
</li>
<li>浮点类型double的底层表示方式；<ul>
<li>符号位 + 指数位 + 尾数位；</li>
</ul>
</li>
</ul>
<h5 id="Base64编码"><a href="#Base64编码" class="headerlink" title="Base64编码"></a>Base64编码</h5><p>参考：<a href="https://www.cnblogs.com/linguanh/p/11205256.html">Base64编码过程</a></p>
<blockquote>
<p> 知识卡：编码</p>
<p>是：一种技术/一个过程；</p>
<p>作用：把信息转换成另一种形式，方便计算机进行处理；</p>
<p>手段：Basexxx编码；</p>
<p>原理：</p>
<ul>
<li>1 编码算法；</li>
<li>2 编码对照表格；</li>
</ul>
<p>特征：</p>
<ul>
<li>不同编码方式的基本原理都是相同的，主要差异在于：<ul>
<li>1 具体使用<strong>几位二进制数字</strong>来作为<strong>编码对照表的查找索引</strong>;</li>
<li>2 不同编码方式<strong>使用的编码对照表格</strong>各有不同；</li>
</ul>
</li>
</ul>
</blockquote>
<h6 id="流程SOP"><a href="#流程SOP" class="headerlink" title="流程SOP:"></a>流程SOP:</h6><ul>
<li>0 准备预期要被编码的字符串；</li>
<li>1 把字符串中的字符转化成Ascii编码表的数值；</li>
<li>2 把1中得到的数值转化为二进制数字（要求为8位的整数倍）；</li>
<li>3 根据BaseX编码算法中的<strong>获取查找索引的规则</strong>，把2中得到的二进制数字划分成一个个单元；</li>
<li>4 把3中得到的一个个单元转化为10进制数字；</li>
<li>5 使用4中得到的10进制数字作为<strong>编码对照表的查找索引</strong>，得到编码后的字符集合；</li>
</ul>
<h6 id="应用示例："><a href="#应用示例：" class="headerlink" title="应用示例："></a>应用示例：</h6><ul>
<li><p>任务：对原始字符串“ILU”按照Base16算法进行编码；</p>
</li>
<li><p>流程：</p>
<ul>
<li><p>1 把字符串中的字符转化成Ascii编码表的数值；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">I = <span class="number">73</span>, L = <span class="number">76</span>, U = <span class="number">85</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>2 把1中得到的数值转化为二进制数字（要求为8位的整数倍）；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">73</span> = <span class="number">01001001</span></span><br><span class="line"></span><br><span class="line"><span class="number">76</span> = <span class="number">01001100</span></span><br><span class="line"></span><br><span class="line"><span class="number">85</span> = <span class="number">01010101</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>3 根据BaseX编码算法中的<strong>计算查找索引的规则</strong>，把2中得到的二进制数字划分成一个个单元；</p>
<blockquote>
<p>说明：Base16规定-使用4位二进制数字来计算查找索引</p>
</blockquote>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Java Basic</category>
      </categories>
      <tags>
        <tag>Java stuff</tag>
      </tags>
  </entry>
  <entry>
    <title>java基础之快速复习（3）</title>
    <url>/Java-Basic/2020/09/12/interview/20200912-java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BF%AB%E9%80%9F%E5%A4%8D%E4%B9%A0%EF%BC%883%EF%BC%89.html</url>
    <content><![CDATA[<h5 id="自定义注解相关知识"><a href="#自定义注解相关知识" class="headerlink" title="自定义注解相关知识"></a>自定义注解相关知识</h5><a id="more"></a>

<p>参考：<a href="https://mp.weixin.qq.com/s/gdYysBB3aD_HmPyvEThFXw">只会用注解，不会自己写？</a></p>
<blockquote>
<p>注解</p>
<p>是：Java中提供的一项技术；</p>
<p>作用：</p>
<ul>
<li>1 声明被标记的部分有/支持特殊的功能；</li>
<li>2 为被标记的部分添加额外的信息（以便在后面的代码中方便地使用这些信息）</li>
</ul>
<p>特征：</p>
<ul>
<li>1 在代码中可以用注进行解标注的部分：<ul>
<li>类/接口；</li>
<li>字段变量；</li>
<li>方法；</li>
</ul>
</li>
<li>2 特殊的功能：<ul>
<li>代码生成；</li>
<li>数据校验；</li>
<li>资源整合（🚩？？？）</li>
</ul>
</li>
</ul>
<p>用法：</p>
<ul>
<li>1 使用注解来标注需要的代码；</li>
<li>2 使用反射机制，在运行时动态地获取到注解中的标注信息，从而实现注解预期的功能；</li>
</ul>
</blockquote>
<h6 id="手动编写一个注解-Length-amp-验证注解的作用"><a href="#手动编写一个注解-Length-amp-验证注解的作用" class="headerlink" title="手动编写一个注解@Length&amp;验证注解的作用"></a>手动编写一个注解@Length&amp;验证注解的作用</h6><blockquote>
<p>说明：Spring框架其实提供了很多注解来对类的字段进行校验； 比如@NotNull、@NotEmpty、@Min、@Max、@Length</p>
</blockquote>
<ul>
<li><p>1 定义注解；</p>
<ul>
<li><p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.FIELD&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Length &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">()</span></span>;  <span class="comment">// 字符串所允许的最小值</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">()</span></span>; <span class="comment">// 字符串所允许的最大值</span></span><br><span class="line">    <span class="function">String <span class="title">errorMsg</span><span class="params">()</span></span>; <span class="comment">// 自定义的错误提示信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>手段：</p>
<ul>
<li><p>1 关键字：@interface；</p>
</li>
<li><p>2 指定自定义注解的一些特性（注解可以添加到的位置、注解的声明周期）：</p>
<ul>
<li><p>手段：Java提供的元注解（BIA）；</p>
</li>
<li><p>分类：</p>
<ul>
<li><p>@Target(xxx)，用于指定该自定义注解可以用在什么位置【字段 - 方法 - 类（and more）】</p>
<ul>
<li><code>ElementType.FIELD</code>：说明自定义的注解可以用于类的变量</li>
<li><code>ElementType.METHOD</code>：说明自定义的注解可以用于类的方法</li>
<li><code>ElementType.TYPE</code>：说明自定义的注解可以用于类本身、接口或 <code>enum</code>类型</li>
</ul>
</li>
<li><p>@Retention(xxx)，用于指定自定义注解的生命周期【运行时 - 编译时 - 源码时】</p>
<ul>
<li><code>@Retention(RetentionPolicy.RUNTIME)</code>：表示注解可以一直保留到运行时（因此可以通过反射获取注解信息）</li>
<li><code>@Retention(RetentionPolicy.CLASS)</code>：表示注解被编译器编译进 <code>class</code>文件，但运行时会忽略</li>
<li><code>@Retention(RetentionPolicy.SOURCE)</code>：表示注解仅在源文件中有效，编译时就会被忽略</li>
</ul>
<p>一般选择的生命周期为：@Retention(RetentionPolicy.RUNTIME). Retention,延续</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>2 定义一个工具类，在类中添加静态方法——用于动态获取当前实例的字段值，并于程序员指定的字段值边界进行比较；</p>
<ul>
<li><p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">validate</span><span class="params">(Object object)</span> <span class="keyword">throws</span> IllegalAccessException </span>&#123;</span><br><span class="line">        <span class="comment">// Ⅰ 获取类的所有字段</span></span><br><span class="line">        Field[] fields = object.getClass().getDeclaredFields();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Ⅱ 遍历这些个字段对象</span></span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">            <span class="comment">// Ⅲ 如果字段上存在“自定义的注解”...</span></span><br><span class="line">            <span class="keyword">if</span> (field.isAnnotationPresent(Length<span class="class">.<span class="keyword">class</span>)) </span>&#123; </span><br><span class="line">                <span class="comment">// Ⅳ 获取到字段上的注解类实例</span></span><br><span class="line">                MyPattern myPattern = field.getAnnotation(MyPattern<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">                field.setAccessible(<span class="keyword">true</span>); <span class="comment">// 允许通过反射访问到私有变量</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// Ⅴ 通过反射，获取到程序员给对象的该字段绑定的值     诡异地反转：对象的某个字段的值 - 字段.get(对象)</span></span><br><span class="line">                String myRex = (String)field.get(object); <span class="comment">// 获取到字段的值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="comment">// Ⅵ 对字段绑定的值进行判断，如果不在指定的区间内。就返回自定义的异常信息</span></span><br><span class="line">                Pattern p = Pattern.compile(myPattern.regularExpression());</span><br><span class="line">                Matcher m = p.matcher(myRex);</span><br><span class="line">                <span class="keyword">if</span> (!m.matches()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> myPattern.errorMag();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// 否则返回null</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>3 在自定义类型的字段上，使用自定义的注解；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.annotationDemo2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在字段上标记自定义的注解</span></span><br><span class="line">    <span class="meta">@Length</span>(min=<span class="number">11</span>, max=<span class="number">11</span>, errorMsg = <span class="string">"电话号码的长度必须为11位"</span>)</span><br><span class="line">    <span class="keyword">private</span> String mobile;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>4 验证注解是否发挥作用；</p>
<ul>
<li>手段：<ul>
<li>1 写一段代码，尝试给实例的mobile绑定一个6位数字的号码；</li>
<li>2 然后调用工具类中的静态方法对实例进行校验，如果失败，就返回errorMsg；</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="Spring中常用的注解"><a href="#Spring中常用的注解" class="headerlink" title="Spring中常用的注解"></a>Spring中常用的注解</h5><p>参考：<a href="http://cmsblogs.com/?p=4040">Spring中常用的20+注解</a></p>
<blockquote>
<p>知识卡</p>
<p>Spring注解</p>
<ul>
<li>是：Spring框架所提供的一种技术；</li>
<li>作用：<ul>
<li>声明式地描述Spring框架的指定功能；</li>
<li>部分替代Spring的XML配置文件的工作（比如描述<strong>被Spring所管理的Bean</strong>、<strong>装配Bean之间的关系</strong>等）</li>
</ul>
</li>
<li>特征：<ul>
<li>1 对于Spring的不同功能，Spring都提供了实现该功能的注解手段；</li>
<li>2 注解能够声明式地使用，不需要像OOP编程一样指定很多的细节（只需要给出关键信息即可）</li>
</ul>
</li>
<li>用法/分类：<ul>
<li>参考：👇👇👇</li>
</ul>
</li>
</ul>
</blockquote>
<h6 id="1-用于描述组件的注解"><a href="#1-用于描述组件的注解" class="headerlink" title="1.用于描述组件的注解"></a>1.用于描述组件的注解</h6><ul>
<li><p>作用：为Java类添加一个标识，声明此Java类接受Spring容器的管理（这部分替代了Spring配置文件的作用）。</p>
</li>
<li><p>具体注解：</p>
<ul>
<li><strong>@Component</strong>：声明当前类型接受Spring容器的管理（aka 可以视为Spring容器中的一个组件）；</li>
<li>@Repository、@Service、@Controller：作用与@Component完全相同，但是能让程序员直接了解到组件所在的层次；<ul>
<li>@Controller标注的类型：表示此类型为controller层的组件(页面交互层)；</li>
<li>@Service标注的类型：表示此类型为service层的组件（业务逻辑处理层）；</li>
<li>@Repository标注的类型：表示此类型为dao层的组件（数据库操作层）；【<font size=2>引申：开发应用时采用的三层架构</font>】</li>
</ul>
</li>
<li>原理（这些注解的作用相同）：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;) <span class="comment">// 此注解可以使用的位置</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME) <span class="comment">// 此注解有效的范围</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Component</span> <span class="comment">// 🚩所有其他的三个注解都被@Component注解所标注</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Controller &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>特征</p>
<ul>
<li><p>1 Java类型被声明为Spring容器中的Bean（不管是注解手段还是…）后，bean实例的名称默认为：<strong>首字母变成小写</strong>后Bean类型的名称;</p>
</li>
<li><p>2 实际开发时，尽量使用三层架构对应的注解；</p>
</li>
<li><p>3 为Java类型添加注解后，还需要些其他操作才能<strong>由Spring容器来完全管理Java类型的实例</strong>；</p>
<blockquote>
<p>知识卡：</p>
<p>任务：把一个Java类型交给Spring容器管理；</p>
<p>手段：</p>
<ul>
<li><p>1 为Java类型标注Spring提供的注解@Component;</p>
</li>
<li><p>2 在Spring的配置文件中添加<strong>预期执行注解扫描的路径</strong>这个配置信息；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!-- 自动扫描指定包及其子包下的所有Bean类 --&gt;</span><br><span class="line">&lt;context:component-scan base-<span class="keyword">package</span>=<span class="string">"org.springframework.*"</span>/&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
</li>
</ul>
</li>
</ul>
<h6 id="2-用于进行装配Bean的注解"><a href="#2-用于进行装配Bean的注解" class="headerlink" title="2.用于进行装配Bean的注解"></a>2.用于进行装配Bean的注解</h6><ul>
<li>作用：<ul>
<li>1 描述Spring容器中不同Bean之间的依赖关系；</li>
<li>2 在Spring容器中建立这种依赖关系（把B类型的bean实例绑定到/注入到/装配到A类型的属性上）；</li>
</ul>
</li>
<li>具体注解：<ul>
<li><strong>@Autowired</strong>：Spring内置注解；</li>
<li>@Inject：由JSR-330规范提供;</li>
<li>@Resource：由JSR-250规范提供;【非嫡系】</li>
</ul>
</li>
<li>用法：都可以标注在set方法和属性上，<strong>推荐直接标注在属性上</strong>（一目了然，少写代码）</li>
</ul>
<h6 id="3-用于声明“这是一个用于配置的类型”的注解"><a href="#3-用于声明“这是一个用于配置的类型”的注解" class="headerlink" title="3.用于声明“这是一个用于配置的类型”的注解"></a>3.用于声明“这是一个用于配置的类型”的注解</h6><ul>
<li>作用：声明这是一个用于配置Bean之间依赖关系的Java类型；</li>
<li>具体注解：<ul>
<li>@Configuration <ul>
<li>作用：声明当前类为配置类，相当于配置文件中的xxx标签；</li>
<li>用法：标注在类上</li>
</ul>
</li>
<li>@Bean <ul>
<li>作用：产生一个Bean对象，然后这个Bean对象交给Spring管理；</li>
<li>用法：标注在方法上；</li>
</ul>
</li>
<li>@ComponentScan <ul>
<li>作用：用于对Component进行自动扫描（相当于配置文件中的xxx标签）；</li>
<li>用法：标注在类上；</li>
</ul>
</li>
</ul>
</li>
</ul>
<h6 id="4-用于支持AOP的注解"><a href="#4-用于支持AOP的注解" class="headerlink" title="4.用于支持AOP的注解"></a>4.用于支持AOP的注解</h6><ul>
<li><p>作用：支持AOP编程中的技术细节（where、when&amp;how）；</p>
</li>
<li><p>具体注解：</p>
<ul>
<li><p>@Aspect（how）：</p>
<ul>
<li>作用：把一个类声明为切面类（aka 用于对其他类型进行增强的类）；</li>
<li>用法：<ul>
<li>1 标注在Java类上；</li>
<li>2 直接把<strong>拦截规则（where）</strong>作为@Aspect注解的参数；</li>
</ul>
</li>
</ul>
</li>
<li><p>@After（when）：</p>
<ul>
<li>作用：声明<strong>当前用于增强的方法</strong>在<strong>切点方法</strong>执行之后再去执行；</li>
<li>用法：标注在用于增强的方法上；</li>
</ul>
<blockquote>
<p>@Before注解作用与用法和@After都类似；</p>
</blockquote>
</li>
<li><p>@Around（when）</p>
<ul>
<li>作用：声明<strong>当前用于增强的方法</strong>在 <strong>切点方法执行之前</strong> 与 <strong>切点方法执行之后</strong>都会执行；</li>
<li>用法：标注在用于增强的方法上；</li>
</ul>
</li>
<li><p>@PointCut（where）</p>
<ul>
<li>作用：声明预期会被增强的方法/代码；</li>
<li>用法：<ul>
<li>0 开启Spring对AspectJ代理的支持；<ul>
<li>手段：在Java配置类上标注@EnableAspectJAutoProxy注解；</li>
</ul>
</li>
<li>1 把@PointCur注解标注在方法上；</li>
<li>2 编写预期的切点表达式作为@PointCut注解的参数；</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h6 id="5-用于声明bean实例相关属性的注解"><a href="#5-用于声明bean实例相关属性的注解" class="headerlink" title="5.用于声明bean实例相关属性的注解"></a>5.用于声明bean实例相关属性的注解</h6><ul>
<li><p>作用：对bean实例进行更细致的管理（声明bean实例在容器中的作用域）；</p>
</li>
<li><p>具体注解;</p>
<ul>
<li><p>@Scope；</p>
<blockquote>
<p>知识卡—Spring容器中bean实例的作用域分类：</p>
<p>作用域的作用：声明容器中当前Bean的特性；</p>
<ul>
<li>Singleton作用域；<ul>
<li>当前Bean的特性：整个容器中有且只有一个当前Bean的实例；</li>
</ul>
</li>
<li>Prototype作用域；<ul>
<li>当前Bean的特性：代码每次从容器中获取bean实例时，容器都会为这个get操作创建一个新的实例；</li>
</ul>
</li>
<li>Request作用域；<ul>
<li>当前Bean的特性：web项目中，给每个http request（请求与获取bean实例没有必然关系呀？🚩）新建一个bean</li>
<li>特征：创建出的实例只在本次HTTP请求期间有效；</li>
</ul>
</li>
<li>Session作用域；<ul>
<li>当前Bean的特性：同上；</li>
<li>特征：创建出的bean实例只在本次会话期间有效（时间范围比起以此请求更长）；</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li>作用：声明bean实例在Spring容器中的<strong>作用域属性</strong>；</li>
<li>用法：标注在<strong>用于创建bean实例的方法</strong>上；</li>
</ul>
</li>
<li><p>@PostConstruct </p>
<ul>
<li><p>作用：声明方法会在<strong>在构造函数执行完之后（bean的生命周期的一个阶段）</strong>执行；</p>
</li>
<li><p>特征：</p>
<ul>
<li>1 由JSR-250规范提供；</li>
<li>2 等价于xml配置文件中xxx标签的ooo属性；</li>
</ul>
</li>
<li><p>用法：标注在<strong>预期在依赖注入操作执行完成后会被调用</strong>的方法上；</p>
</li>
<li><p>原理：</p>
<ul>
<li><p>bean的生命周期中执行注解的顺序；</p>
<p><img src="https://s1.ax1x.com/2020/09/12/walSC4.png" alt="生命周期中顺序执行的注解"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>@PreDestory </p>
<ul>
<li>作用：声明方法会<strong>在Bean销毁之前（bean生命周期的另一个阶段）</strong>执行;</li>
<li>特征：<ul>
<li>1 由JSR-250规范提供；</li>
<li>2 等价于xml配置文件中xxx标签的ooo属性；</li>
</ul>
</li>
<li>用法：标注在<strong>预期在bean实例被销毁之后会被调用</strong>的方法上；</li>
</ul>
</li>
</ul>
</li>
</ul>
<h6 id="6-用于为属性绑定值的注解"><a href="#6-用于为属性绑定值的注解" class="headerlink" title="6.用于为属性绑定值的注解"></a>6.用于为属性绑定值的注解</h6><ul>
<li><p>作用：为Bean类型的属性绑定/注入值；</p>
</li>
<li><p>用法：从配置文件中加载值，并绑定到成员属性上；</p>
<ul>
<li><p>1 在配置文件<em>test.properties</em>中定义一堆的<strong>属性 - 值</strong>对；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">book.name=《三体》</span><br></pre></td></tr></table></figure>
</li>
<li><p>2 在<strong>当前类</strong>中加载配置文件；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PropertySource(<span class="string">"classpath:com/hgs/hello/test/test.propertie"</span>) <span class="comment">// 在类上标注PropertySource注解</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>3 在配置类中添加一个用于填充占位符的bean实例；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">🚩</span><br></pre></td></tr></table></figure>
</li>
<li><p>4 在<strong>属性上</strong>标注@Value注解；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Value</span>(<span class="string">"$&#123;user.age:11&#125;"</span>) <span class="comment">// 引用配置文件中的键值对，然后把得到的值绑定到age属性上</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h6 id="7-用于切换代码运行环境的注解"><a href="#7-用于切换代码运行环境的注解" class="headerlink" title="7.用于切换代码运行环境的注解"></a>7.用于切换代码运行环境的注解</h6><ul>
<li><p>作用：指定代码运行的当前环境；</p>
<blockquote>
<p>知识卡1——代码的不同阶段</p>
<ul>
<li>1 对于一个项目来说，相同的代码需要先后经历<strong>开发环境 - 测试环境 - 生产环境</strong>的阶段；</li>
<li>2 每一种环境，配置使用的数据库肯定是不同的（还有一些其他的配置信息也会不同）；</li>
</ul>
<p>知识卡2——代码部署</p>
<p>手段1：</p>
<ul>
<li><p>1 当把代码部署到一个新的环境时，修改配置文件中<strong>与代码运行环境相关的信息</strong>；</p>
</li>
<li><p>2 修改正确后，把代码+编辑后的配置文件<strong>放到/部署到新的工作环境中</strong>；</p>
<p>特征：每次部署工作都需要重新修改配置文件，很容易出错；</p>
</li>
</ul>
<p>手段2：</p>
<ul>
<li><p>1 准备好每一种工作环境所对象的配置文件(file_dev、file_test、file_prod);</p>
</li>
<li><p>2 在代码中，通过@Profile注解来指定当前代码所使用的运行环境配置；</p>
<p>特征： 这样每次部署时，就只需要修改一行代码即可（🚩 Not for sure）</p>
</li>
</ul>
</blockquote>
</li>
<li><p>具体注解：</p>
<ul>
<li><p>@Profile；</p>
<ul>
<li><p>作用：指定<strong>代码运行的当前环境</strong>（aka <em>当前context</em>所需要使用的配置环境）；</p>
</li>
<li><p>手段：设定<em>Environment的ActiveProfiles</em>；</p>
</li>
<li><p>用法：</p>
<ul>
<li><p>1 在<strong>预期使用xxx环境配置信息的方法上</strong>标注@Profile(‘xxx’)注解；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Profile</span>(<span class="string">"dev"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">devDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 具体配置信息</span></span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">return</span> basicDataSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>2 激活<strong>预期使用的xxx环境配置</strong>;</p>
<ul>
<li><p>手段：在类上标注<code>@ActiveProfiles</code>注解；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Not going into the details now</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>@Conditional；</p>
<ul>
<li>作用：声明那些个<strong>在特定条件下才会被实例化</strong>的bean；</li>
<li>用法：<ul>
<li>1 自定义类型实现Condition接口，并重写matches()方法；</li>
<li>2 根据matches()方法的返回结果来确定<strong>Bean类型是否会被实例化</strong>；</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h6 id="8-用于支持异步操作的注解"><a href="#8-用于支持异步操作的注解" class="headerlink" title="8.用于支持异步操作的注解"></a>8.用于支持异步操作的注解</h6><ul>
<li>作用：支持异步操作并指定具体的操作细节；</li>
<li>具体注解：<ul>
<li>@EnableAsync；<ul>
<li>作用：开启Spring对异步任务的支持；</li>
<li>用法：标注在配置类上；</li>
</ul>
</li>
<li>@Async；<ul>
<li>作用：声明<strong>bean方法是一个异步任务</strong>（啥意思🚩）；</li>
<li>用法：标注在<strong>预期声明其为异步任务</strong>的方法上；</li>
</ul>
</li>
</ul>
</li>
</ul>
<h6 id="9-用于支持定时任务的注解"><a href="#9-用于支持定时任务的注解" class="headerlink" title="9.用于支持定时任务的注解"></a>9.用于支持定时任务的注解</h6><ul>
<li><p>具体注解：</p>
<ul>
<li><p>@EnableScheduling：</p>
<ul>
<li>作用：开启Spring对定时任务的支持；</li>
<li>用法：标注在配置类上；</li>
</ul>
</li>
<li><p>@Scheduled：</p>
<ul>
<li><p>作用：声明<strong>bean方法是一个待执行的任务(比如爬取新闻)</strong>；</p>
</li>
<li><p>用法：</p>
<ul>
<li><p>1 标注在<strong>预期按照指定规则运行的方法</strong>上；</p>
</li>
<li><p>2 通过注解的参数来指定<strong>任务的运行规则</strong>；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Scheduled</span>(cron = <span class="string">"0 0 0 1 Jan ?"</span>) <span class="comment">//每年的1月的1日的0时0分0秒执行</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>参考:<a href="https://juejin.im/post/6844903470793752584">@Schedule注解的用法</a></p>
</li>
</ul>
<h6 id="10-形如-Enable-的注解说明"><a href="#10-形如-Enable-的注解说明" class="headerlink" title="10.形如@Enable*的注解说明"></a>10.形如@Enable*的注解说明</h6><ul>
<li>作用：用于开启Spring对*所表示的功能的支持；</li>
<li>常用注解：<ul>
<li>@EnableAsync 开启对<strong>异步方法</strong>的支持</li>
<li>@EnableScheduling 开启对<strong>计划任务</strong>的支持</li>
<li>@EnableWebMvc 开启对<strong>Web MVC</strong>的支持</li>
<li>@EnableCaching 开启<strong>注解式的缓存</strong>支持</li>
</ul>
</li>
</ul>
<h6 id="11-用于支持代码测试的注解"><a href="#11-用于支持代码测试的注解" class="headerlink" title="11.用于支持代码测试的注解"></a>11.用于支持代码测试的注解</h6><ul>
<li><p>@RunWith</p>
<ul>
<li><p>作用：指定<strong>当前代码上下文</strong>所使用的<strong>运行器</strong>（aka 运行当前代码的工具）；</p>
</li>
<li><p>用法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RunWith(SpringJUnit4ClassRunner<span class="class">.<span class="keyword">class</span>) // 为参数绑定具体运行器的<span class="title">class</span>对象</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>@ContextConfiguration【上下文配置】</p>
<ul>
<li><p>作用：指定<strong>当前代码上下文</strong>所使用的<strong>Spring容器配置</strong>（aka 具体实例与实例之间的装配关系）；</p>
</li>
<li><p>用法（通过Java配置类来指定Spring容器配置）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ContextConfiguration</span>(classes=&#123;TestConfig<span class="class">.<span class="keyword">class</span>&#125;) // 为<span class="title">classes</span>参数绑定配置类的<span class="title">class</span>对象</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h6 id="12-SpringMVC框架所使用的注解"><a href="#12-SpringMVC框架所使用的注解" class="headerlink" title="12.SpringMVC框架所使用的注解"></a>12.SpringMVC框架所使用的注解</h6><ul>
<li><p>作用：开启SpringMVC框架，并指定MVC框架处理请求的细节；</p>
</li>
<li><p>具体注解；</p>
<ul>
<li><p>@EnableWebMvc；</p>
<ul>
<li>作用：开启Spring<strong>对Web MVC配置的支持</strong>；</li>
<li>用法：标注在配置类上；</li>
</ul>
</li>
<li><p>@Controller;</p>
<ul>
<li>作用：声明当前类为<strong>MVC模型中的控制器</strong>；</li>
<li>用法：标注在当前类型上；</li>
</ul>
</li>
<li><p>@RequestMapping：</p>
<ul>
<li>作用：映射Web请求到特定的Controller方法上；</li>
<li>特征：<ul>
<li>1 映射内容除了路径外，还包括请求参数；</li>
<li>2 请求参数到controller方法参数的绑定会有很多种手段；</li>
</ul>
</li>
</ul>
</li>
<li><p>@ResponseBody；</p>
<ul>
<li>作用：声明方法的返回值会<strong>存入response内</strong>，而不是需要<strong>作为一个视图名</strong>;</li>
<li>用法：标注在controller方法上；</li>
</ul>
</li>
<li><p>@RequestBody；</p>
<ul>
<li>作用：把请求的参数封装到请求体中，而不是跟在请求地址后面；</li>
<li>用法：标注在controller方法参数的前面；</li>
</ul>
</li>
<li><p>@PathVariable；</p>
<ul>
<li>作用：接受Web请求中的路径参数，并把参数值绑定到controller方法参数上；</li>
<li>用法：<ul>
<li>1 编写@RequestMapping注解时，使用<strong>路径参数</strong>来接收Web请求中的参数；</li>
<li>2 把@PathVariable注解标注在controller方法参数的前面即可;（more details）</li>
</ul>
</li>
</ul>
</li>
<li><p>@RestController;</p>
<ul>
<li>作用：@Controller+@ResponseBody；</li>
<li>特征：组合注解；</li>
</ul>
</li>
<li><p>@InitBinder；</p>
<ul>
<li>作用：设置从web请求到controller方法参数的数据绑定；</li>
<li>原理：<ul>
<li>1 使用WebDataBinder来自动绑定前台请求参数到Model中；</li>
<li>2 通过InitBinder注解能够设置WebDataBinder的细节；</li>
</ul>
</li>
</ul>
<blockquote>
<p>OMG, so much details you may want to puke(⚡吼)</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h5 id="多线程中常用的方法说明"><a href="#多线程中常用的方法说明" class="headerlink" title="多线程中常用的方法说明"></a>多线程中常用的方法说明</h5><blockquote>
<p>多线程的应用场景：</p>
<ul>
<li>1 流程中的耗时任务（比如发通知时，需要给每一个参会人员发送短信）；</li>
<li>2 创建需要在后台一直执行的线程（比如定时任务，像备份数据库等）；</li>
<li>3 处理并发请求（Tomcat）/处理多个任务（多任务场景？🚩）；</li>
<li>4 多次独立的循环；</li>
</ul>
</blockquote>
<p>参考：<a href="https://mp.weixin.qq.com/s/FHyqxHcfzOtKvA1_PFtnXw">田小齐-多线程</a></p>
<h6 id="线程的生命周期-6种状态"><a href="#线程的生命周期-6种状态" class="headerlink" title="线程的生命周期(6种状态)"></a>线程的生命周期(6种状态)</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> State &#123;</span><br><span class="line">  NEW,</span><br><span class="line">  RUNNABLE,</span><br><span class="line">  BLOCKED,</span><br><span class="line">  WAITTING,</span><br><span class="line">  TIMED_WAITTING,</span><br><span class="line">  TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>线程6种状态之间的转移图</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/12/wd4gP0.png" alt="状态转移图"></p>
<ul>
<li><p>New;</p>
<ul>
<li><p>状态：A thread that has not yet started is in this state.</p>
<blockquote>
<p>一个还没有启动的线程就处在这种状态；</p>
</blockquote>
</li>
<li><p>手段：创建线程；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MyThread myThread = <span class="keyword">new</span> MyThread();</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Runnable;</p>
<ul>
<li><p>状态：A thread is executing in the Java virtual machine but it may be waiting for other resources from the operating system such as processor.</p>
<blockquote>
<p>线程在Java虚拟机中执行，但它可能在等待从操作系统中得到其他需要的资源（比如CPU资源）</p>
</blockquote>
</li>
<li><p>手段：启动线程；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">myThread.start();</span><br></pre></td></tr></table></figure>
</li>
<li><p>特征：</p>
<ul>
<li>1 线程启动后就会进入Runnable状态；</li>
<li>2 Runnable状态的线程都会被添加到一个等待队列中，等待CPU的调度（皇帝临幸）；</li>
<li>3 线程得到CPU资源后，就会执行。如果没得到，继续等待</li>
</ul>
</li>
</ul>
</li>
<li><p>Blocked;</p>
<ul>
<li><p>状态：Thread state for a thread blocked waiting for a monitor lock.<br>A thread in the blocked state is <strong>waiting for a monitor lock to enter a synchronized block/method</strong> or reenter a synchronized block/method after calling <code>wait()</code> Object.</p>
<blockquote>
<p>描述线程的一种状态：线程阻塞以等待一个监视器的锁；</p>
<p>阻塞状态下的线程会等待监视器的锁来：</p>
<ul>
<li>1 进入一个synchronized修饰的代码块/方法；</li>
<li>2 或者在调用wait()方法后重新进入synchronized修饰的代码块/方法；</li>
</ul>
</blockquote>
</li>
<li><p>特征：</p>
<ul>
<li>1 阻塞状态下的线程是在<strong>等待锁资源</strong>;</li>
<li>2 线程是否能够等待到锁<strong>不是很可控</strong>（起码程序员没有办法指定某个线程获得锁）；</li>
</ul>
</li>
</ul>
</li>
<li><p>Waiting;</p>
<ul>
<li><p>状态：A thread in the waiting state is waiting for another thread to perform a particular action.</p>
<blockquote>
<p>等待状态下的线程，正在等待另一个线程执行特定的动作；</p>
</blockquote>
</li>
<li><p>手段</p>
<p>A thread is in the waiting state due to calling one of the following methods:</p>
<ul>
<li><p>Object.wait with no timeout</p>
</li>
<li><p>Thread.join with no timeout</p>
</li>
<li><p>LockSupport.park</p>
<blockquote>
<p>以下原因会导致线程进入到等待状态：</p>
<ul>
<li>调用了wait()方法；</li>
<li>调用了join()方法；</li>
<li>调用了park()方法；</li>
</ul>
</blockquote>
</li>
</ul>
</li>
<li><p>特征：</p>
<ul>
<li>1 等待状态没有时间限制（无限期等待），所以需要某些方式来唤醒线程；</li>
<li>2 由于使线程进入睡眠状态的手段是可控的，所以唤醒线程的手段也是可控的；<ul>
<li>如果使用wait()方法使线程A进入等待状态，则<ul>
<li>需要使用notify()/notifyall()方法来唤醒；</li>
</ul>
</li>
<li>如果使用join()方法使线程A进入等待状态，则<ul>
<li>需要<strong>等待目标线程运行结束</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>应用：生产者-消费者模型中，当没有产品时，就需要</p>
<ul>
<li>1 让消费者等待；    手段：在消费者线程上调用wait()方法；</li>
<li>2 在生产者生产完毕后，唤醒消费者(去消费)； 手段：在消费者线程上调用notify()方法；</li>
</ul>
</li>
</ul>
</li>
<li><p>Timed_waiting;</p>
<ul>
<li><p>状态：有时长限制的等待状态（太久的话我就不等你了）</p>
</li>
<li><p>手段：</p>
<blockquote>
<ul>
<li>Thread.sleep</li>
<li>Object.wait with timeout</li>
<li>Thread.join with timeout</li>
<li>LockSupport.parkNanos</li>
<li>LockSupport.parkUntil</li>
</ul>
</blockquote>
</li>
<li><p>特征：</p>
<ul>
<li>1 其实就是在等待状态上添加了<strong>等待时长限制</strong>；</li>
<li>2 在时长超限后，线程就不再等待（可以做其他事情）；</li>
</ul>
</li>
</ul>
</li>
<li><p>Terminated;</p>
<ul>
<li><p>状态：A thread that has exited is in this state.</p>
<blockquote>
<p>一个已经退出的线程就处在这种状态；</p>
</blockquote>
</li>
<li><p>手段：</p>
<ul>
<li>1 执行完所有代码，线程正常结束；</li>
<li>2 线程被强制结束；【手段：stop()方法；   注：此手段已弃用】</li>
<li>3 线程执行时，抛出了未处理的异常；</li>
</ul>
</li>
<li><p>特征：</p>
<ul>
<li>1 线程一旦终结/死亡，就无法再复活了（不像超人）；</li>
<li>2 如果在已经终结的线程上调用start()方法，则程序会抛出<strong>非法线程状态异常</strong>；</li>
</ul>
</li>
</ul>
</li>
</ul>
<h6 id="线程实例常用的APIs"><a href="#线程实例常用的APIs" class="headerlink" title="线程实例常用的APIs"></a>线程实例常用的APIs</h6><ul>
<li><p>join()方法；</p>
<ul>
<li><p>作用：</p>
<blockquote>
<p>Waits for this thread to die. 等待当前线程死亡</p>
</blockquote>
</li>
<li><p>手段：<strong>强制让该线程执行</strong>，并且一直会让它执行完；</p>
</li>
<li><p>用法：</p>
<ul>
<li><p>1 实现一个线程类；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123; <span class="comment">// 手段2</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 线程执行时的工作：打印100次特定字符串</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Henry666："</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在类中直接定义主线程</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>2 在主线程中：</p>
<ul>
<li>创建线程实例；</li>
<li>启动线程；</li>
<li>强制线程执行完成；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123; <span class="comment">// 定义main()函数	aka 开启一个主线程</span></span><br><span class="line">    </span><br><span class="line">    	<span class="comment">// 创建一个新线程</span></span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable());</span><br><span class="line">    	<span class="comment">// 开启新线程</span></span><br><span class="line">        t.start();</span><br><span class="line">    	<span class="comment">// 等待，直到新线程执行结束</span></span><br><span class="line">        t.join();</span><br><span class="line"></span><br><span class="line">    	<span class="comment">// 主线程的工作</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"主线程"</span> + i + <span class="string">"：齐姐666"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">// 注：通过控制台的打印结果可以得到：主线程与新创建线程之间的执行顺序</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>应用：使某个线程优先执行，直到线程执行结束（然后才会回到公平竞争的情况）；</p>
</li>
<li><p>原理：join()方法其实是使用wait()方法实现的；</p>
</li>
</ul>
</li>
<li><p>wait()方法 &amp; notify()方法；</p>
<ul>
<li>作用：使得当前线程实例<strong>进入等待状态</strong>；</li>
<li>特征：<ul>
<li>1 wait()方法并不是线程类的方法，而是Object类的方法；</li>
<li>2 可以为wait()方法设置时长参数（这样就不需要别的线程唤醒了）</li>
</ul>
</li>
<li>用法【🚩 不够清晰】：<ul>
<li>1 在当前线程实例上调用wait()方法，使之进入<strong>无限期等待的状态</strong>；</li>
<li>2 直到某个线程调用了notify()/notifyall()方法，唤醒<strong>等待状态下的当前线程</strong>；</li>
</ul>
</li>
<li>代码：xxx</li>
</ul>
</li>
<li><p>yield()方法；</p>
<ul>
<li>作用：强制当前线程让出CPU资源，使得线程从<strong>执行中</strong>切换到<strong>可执行</strong>（都是Runnable状态）；</li>
<li>特征：让出CPU资源后，线程会回到等待队列中，重新等待CPU资源；</li>
</ul>
</li>
<li><p>sleep()方法；</p>
<ul>
<li><p>作用：使当前线程睡一会；</p>
</li>
<li><p>特征：</p>
<ul>
<li><p>1 线程并不会让出CPU资源（它只是占着CPU不做事罢了）；</p>
</li>
<li><p>2 sleep()方法的方法签名中抛出了异常，所以调用时需要使用try/catch捕获可能的异常进行检查；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>用法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">myThread.sleep(<span class="number">1000</span>); <span class="comment">// 睡眠 1 秒钟</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
</li>
<li><p>currentThread()方法；</p>
<ul>
<li><p>作用：Returns a reference to the currently executing thread object.</p>
<blockquote>
<p>返回一个当前正在执行的线程对象的引用；</p>
</blockquote>
</li>
<li><p>特征：</p>
<ul>
<li>1 它是Thread类型的一个static方法；</li>
<li>2 方法的返回值类型是Thread类型；</li>
</ul>
</li>
<li><p>应用：打印当前线程实例；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(Thread.currentThread());</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>getName()方法；</p>
<ul>
<li><p>作用：获取当前线程的名称；</p>
</li>
<li><p>特征：当前线程实例的名称可以由程序员手动设置；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable(), <span class="string">"壹齐学"</span>); <span class="comment">// 手段：Thread类的构造方法</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>getId()方法；</p>
<ul>
<li>作用：获取当前线程的id；</li>
</ul>
</li>
<li><p>getPriority()方法；</p>
<ul>
<li><p>作用：获取当前线程的优先级；</p>
</li>
<li><p>特征：</p>
<ul>
<li><p>1 优先级高的线程更有可能被CPU率先执行；</p>
</li>
<li><p>2 优先级的可选级别为1-10；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The minimum priority that a thread can have.最低优先级</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MIN_PRIORITY = <span class="number">1</span>;</span><br><span class="line">      </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The default priority that is assigned to a thread. 默认优先级</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> NORM_PRIORITY = <span class="number">5</span>;</span><br><span class="line">      </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The maximum priority that a thread can have. 最高优先级</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_PRIORITY = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>3 如果设置的优先级别不在{1, 5, 10}中，则JDK会抛出非法参数异常；</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>setPriority()方法；</p>
<ul>
<li>作用：设置线程的优先级；</li>
</ul>
</li>
<li><p>stop()方法；</p>
<ul>
<li>作用：强制停止线程；</li>
<li>特征：已弃用（因为可能会导致一些线程安全方面的问题<strong>留坑了</strong>）</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Java Basic</category>
      </categories>
      <tags>
        <tag>Java stuff</tag>
      </tags>
  </entry>
  <entry>
    <title>java基础之快速复习（4）</title>
    <url>/Java-Basic/2020/09/12/interview/20200912-java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BF%AB%E9%80%9F%E5%A4%8D%E4%B9%A0%EF%BC%884%EF%BC%89.html</url>
    <content><![CDATA[<h5 id="HashMap类型的resize-过程"><a href="#HashMap类型的resize-过程" class="headerlink" title="HashMap类型的resize()过程"></a>HashMap类型的resize()过程</h5><blockquote>
<p>这个其实在上次分析的时候就学了一遍，但是不够熟悉 所以没有答上来。再复习一波~</p>
</blockquote>
<p>参考：<a href="http://www.tianxiaobo.com/2018/01/18/HashMap-%E6%BA%90%E7%A0%81%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90-JDK1-8/#342-%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6">HashMap详解-田小波</a></p>
<a id="more"></a>

<h6 id="resize-方法SOP："><a href="#resize-方法SOP：" class="headerlink" title="resize()方法SOP："></a>resize()方法SOP：</h6><ul>
<li>1 计算新的<strong>哈希桶数组的容量newCap</strong>和<strong>新阈值newThr</strong>；<a href="#step1">跳转</a></li>
<li>2 根据1中计算出的newCap来<strong>创建新的哈希桶数组</strong>/<strong>对桶数组table进行初始化</strong>；<a href="#step2">跳转</a></li>
<li>3 把键值对重新映射到新的桶数组中（<strong>比较复杂</strong>）；<a href="#step3">跳转</a><ul>
<li>1 如果节点是树节点，则需要对红黑树进行拆分；【红黑树对象的split()方法】</li>
<li>2 如果节点是链表节点，则将节点按照原始顺序进行分组；【循环 + 重新映射】</li>
</ul>
</li>
</ul>
<h6 id="源码-SOP框架-："><a href="#源码-SOP框架-：" class="headerlink" title="源码(SOP框架)："></a>源码(SOP框架)：</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">	<span class="comment">/* Step1: 计算新的桶数组的容量newCap与阈值newThr */</span></span><br><span class="line">	...</span><br><span class="line">	threshold = newThr;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* step2: 根据计算出的newCap来得到新的桶数组newTab,并绑定到table引用上 */</span></span><br><span class="line">	...</span><br><span class="line">	table = newTab;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* step3:把旧的哈希桶数组中的键值对重新映射到新的哈希桶数组中 */</span></span><br><span class="line">	<span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="源码拆解："><a href="#源码拆解：" class="headerlink" title="源码拆解："></a>源码拆解：</h6><ul>
<li><span id="step1">step1</span>：计算新哈希桶数组的容量newCap与新阈值newThr；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 记录旧桶数组的容量与阈值</span></span><br><span class="line">Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">   <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">   <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">   <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">   <span class="comment">// 如果 table 不为空，表明已经初始化过了</span></span><br><span class="line">   <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="comment">// 当 table 容量超过容量最大值，则不再扩容</span></span><br><span class="line">       <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">           threshold = Integer.MAX_VALUE;</span><br><span class="line">           <span class="keyword">return</span> oldTab;</span><br><span class="line">       &#125; </span><br><span class="line">       <span class="comment">// 如果旧容量并没有超过最大容量，则:按旧容量和阈值的2倍计算新容量和阈值的大小</span></span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">           newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// 🚩注：这里计算newThr，可能会导致newThr的值为零（因为数值溢出）</span></span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// 如果旧的阈值大于0，说明“程序员在调用构造方法时指定了初始容量”，则：</span></span><br><span class="line">       <span class="comment">// 把“程序员指定的初始化容量”作为“新桶数组的容量”</span></span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 手段：把 threshold 的值绑定到 newCap（以作为新桶数组的容量）</span></span><br><span class="line"><span class="comment">        * 原理：HashMap()构造方法中，使用了threshold变量来暂时保 initialCapacity参数的值（🚩 参考id="helper" 😳）</span></span><br><span class="line"><span class="comment">        */</span> </span><br><span class="line">       newCap = oldThr;</span><br><span class="line">   <span class="keyword">else</span> &#123;  <span class="comment">// 如果旧的阈值为0，说明“程序员调用了默认的构造方法”，则:</span></span><br><span class="line">       <span class="comment">// 为newCap、newThr变量绑定默认值（默认容量、默认阈值）</span></span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 调用无参构造方法时，桶数组容量为默认容量，</span></span><br><span class="line"><span class="comment">        * 阈值为默认容量与默认负载因子乘积</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">       newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 如果newThr 为 0，说明：1 上面的if&#123;&#125;中没有更新newThr的值； 或者2在计算newThr发生了溢出，导致newThr的值为0。则</span></span><br><span class="line"><span class="comment">// 按“阈值计算公式”进行计算；	公式：阈值 = 容量 * 负载因子</span></span><br><span class="line">   <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">       <span class="comment">// 从两个值中取一个绑定到newThr</span></span><br><span class="line">       newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                 (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把计算得到的newThr绑定到全局变量threshold上</span></span><br><span class="line">   threshold = newThr;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>🚩 程序员调用了有初始容量的构造方法时…</p>
<p><span id="helper">辅助代码</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 参数判空</span></span><br><span class="line">    	...</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// 把程序员指定的初始容量调整后绑定到了threshold变量上（暂存initialCapacity）</span></span><br><span class="line">        <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>计算新容量与新阈值的代码说明：</p>
</blockquote>
<ul>
<li><p>如果旧哈希桶的容量大于0，说明“哈希桶已经初始化过了”。则：</p>
<ul>
<li>尝试使用旧容量&amp;旧阈值的2倍来更新newCap&newThr;<ul>
<li>1 判断容量是否已经到达最大容量MAXIMUM_CAPACITY，如果是，直接返回旧的哈希桶数组；</li>
<li>2 如果旧容量没有到达最大容量MAXIMUM_CAPACITY，则：<ul>
<li>尝试按照扩容两倍的方式来更新newCap与newThr；</li>
<li>注：如果扩容两倍导致容量超限，则语句不会被执行（newCap与newThr仍旧为0）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>如果旧哈希桶的容量等于0，说明“哈希桶还没有被初始化”（aka 程序员通过默认构造器创建的hashMap对象），则：</p>
<ul>
<li>如果旧的阈值大于0，说明“程序员在调用构造方法时指定了初始容量”，则：<ul>
<li>使用”程序员指定的初始容量调整后的值”来更新newCap；</li>
</ul>
</li>
<li>如果旧的阈值等于0，说明”程序员调用了默认的构造方法”，则:<ul>
<li>使用“默认的值”来更新newCap&amp;newThr；</li>
</ul>
</li>
</ul>
<hr>
</li>
<li><p>处理上面流程中可能没有被更新的newThr；</p>
<ul>
<li>如果newThr仍旧等于0，说明：要么newThr的值没有被更新过，要么在更新newThr时发生了溢出。则：<ul>
<li>使用“阈值 = 容量 * 扩容因子”的公式来计算阈值，并使用计算结果来更新newThr；</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>Period</strong></p>
<ul>
<li><p><span id="step2">step2: </span> 根据1中计算出的newCap来<strong>创建新的哈希桶数组</strong>;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建新的桶数组，桶数组的初始化也是在这里完成的</span></span><br><span class="line">Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">table = newTab; <span class="comment">// 把新创建的数组绑定到table全局变量上</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><span id="step3">step3: </span>把键值对重新映射到新的桶数组中;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果旧的桶数组不为空，则遍历桶数组，并将键值对映射到新的桶数组中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="comment">// 重新映射时，需要对红黑树进行拆分</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="comment">// 遍历链表，并将链表节点按原顺序进行分组</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 将分组后的链表映射到新桶中</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>重新映射键值对的代码说明</p>
</blockquote>
<ul>
<li><p>分类1：对桶中的链表进行分组映射；</p>
<blockquote>
<p>知识卡1：向HashMap中插入键值对的流程；</p>
<ul>
<li>1 计算键值对应该插入到的哈希桶的位置；</li>
<li>2 尝试把键值对插入到桶中（作为链表节点/红黑树节点）；</li>
</ul>
<p>说明：JDK1.8中，对第一步做了优化以减少哈希冲突；</p>
</blockquote>
<blockquote>
<p>知识卡2：JDK1.8中，计算键值对预期插入的桶位置的流程；</p>
<ul>
<li>1 根据键值对的key，调用key的hashCode()方法计算得到其哈希值hash_key；</li>
<li>2 根据公式(n - 1) &amp; hash_key来计算出它预期插入的桶位置；</li>
</ul>
</blockquote>
<blockquote>
<p>知识卡3：默认情况下，扩容操作会被桶数组的容量扩大为旧容量的2倍；</p>
</blockquote>
<ul>
<li><p>手段：把链表中的键值对重新映射到<strong>扩容后新的哈希桶数组</strong>中；</p>
</li>
<li><p>特征：</p>
<ul>
<li>1 先前被映射到同一个桶中的键值对，在重新映射时，会被映射到不同的桶中；</li>
<li>2 <strong>不同的桶</strong>分为两个桶：旧位置的桶 + （旧位置 + 扩容长度）位置的桶；</li>
<li>3 这种手段不需要重新计算哈希值，只要查看高一位bit的值是0还是1，就能够得到<strong>键值对应该被映射到的哈希桶位置</strong>；</li>
</ul>
</li>
<li><p>原理：</p>
<ul>
<li>1 重新映射时， (n - 1) &amp; hash_key表达式中hash_key的值是不变的；</li>
<li>2 表达式中的n变成了先前的2倍，具体到二进制表示上——最高位1的前一个bit的值从0变成1；</li>
<li>3 由于按位与&amp;的特征（全1为1，否则为0），所以，根据hash_key的对应bit的值就能得到表达式(n - 1) &amp; hash_key的结果（aka 桶的位置）</li>
</ul>
</li>
<li><p>具体代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">	<span class="comment">// 如果旧的桶数组不为空，则遍历桶数组，并将键值对映射到新的桶数组中</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">		Node&lt;K,V&gt; e;</span><br><span class="line">		<span class="comment">// 获取当前桶位置的节点e，如果节点e不为null...</span></span><br><span class="line">		<span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">// 处理其他的情况</span></span><br><span class="line">			...</span><br><span class="line">			<span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">				<span class="comment">/* 准备需要的指针 	注：根据原理，链表的键值对会被映射到两个桶中 */</span></span><br><span class="line">				Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>; <span class="comment">// “原始桶位置上的链表分组”的头尾指针 </span></span><br><span class="line">				Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>; <span class="comment">// “新的桶位置上的链表分组”的头尾指针</span></span><br><span class="line">				Node&lt;K,V&gt; next; <span class="comment">// 记录当前节点的下一个节点</span></span><br><span class="line">				<span class="comment">// 遍历链表，并将链表节点按原顺序进行分组</span></span><br><span class="line">				<span class="keyword">do</span> &#123;</span><br><span class="line">					next = e.next;</span><br><span class="line">                    <span class="comment">// 判断当前节点应该添加到的“链表分组”</span></span><br><span class="line">                    <span class="comment">// 手段：判断节点的哈希值 &amp; 桶数组的旧容量 的结果是否为0【WHY？】</span></span><br><span class="line">					<span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 构建链表loHead</span></span><br><span class="line">						<span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">							loHead = e;</span><br><span class="line">						<span class="keyword">else</span></span><br><span class="line">							loTail.next = e;</span><br><span class="line">						loTail = e;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 构建链表hiHead</span></span><br><span class="line">						<span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">							hiHead = e;</span><br><span class="line">						<span class="keyword">else</span></span><br><span class="line">							hiTail.next = e;</span><br><span class="line">						hiTail = e;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">				<span class="comment">// 将分组后的链表（loHead、hiHead）添加到新桶中</span></span><br><span class="line">				<span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">					loTail.next = <span class="keyword">null</span>;</span><br><span class="line">					newTab[j] = loHead;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">					hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">					newTab[j + oldCap] = hiHead;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>链表中的键值对重新映射过程的SOP：</p>
<ul>
<li><p>原始桶数组；</p>
<p><img src="https://s1.ax1x.com/2020/09/13/w0dbnK.png" alt="原始桶数组"></p>
</li>
<li><p>桶数组扩容后，对链表中的键值对重新映射；</p>
<ul>
<li><p>1 依次遍历链表，并计算节点 <code>hash &amp; oldCap</code> 的值【为什么是这个公式？🚩】；</p>
<p><img src="https://s1.ax1x.com/2020/09/13/w0wFHS.png" alt="遍历桶中链表的节点"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    next = e.next;</span><br><span class="line">    <span class="comment">// 判断当前节点应该添加到的“链表分组”</span></span><br><span class="line">    <span class="comment">// 手段：判断节点的哈希值 &amp; 桶数组的旧容量 的结果是否为0【WHY？】</span></span><br><span class="line">    <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 构建链表loHead</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 构建链表hiHead</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>- 2 根据计算结果，对节点进行分组并创建分组后的链表（&lt;font size=2&gt;分组依据：键值对应该存放在原始桶位置or新的桶位置&lt;/font&gt;）；

  手段：创建链表的一般步骤（两个指针head + tail）；

  ![分组节点并创建分组链表](https://s1.ax1x.com/2020/09/13/w0ws4H.png)

  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建loHead链表</span></span><br><span class="line"><span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">    loHead = e;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    loTail.next = e;</span><br><span class="line">loTail = e;</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 创建hiHead链表</span></span><br><span class="line"><span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">    hiHead = e;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    hiTail.next = e;</span><br><span class="line">hiTail = e;</span><br></pre></td></tr></table></figure>



- 3 把创建的分组链表添加到新桶数组中预期位置；

  手段：把分组后链表的头节点绑定到桶数组的预期位置上；

  ![把链表绑定到桶数组的预期位置](https://s1.ax1x.com/2020/09/13/w00dRs.png)

  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将分组后的链表（loHead、hiHead）添加到新桶中</span></span><br><span class="line"><span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">    loTail.next = <span class="keyword">null</span>;</span><br><span class="line">    newTab[j] = loHead; <span class="comment">// 旧的桶位置</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">    hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">    newTab[j + oldCap] = hiHead; <span class="comment">// 新的桶位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><hr>
<h6 id="哈希桶扩容后，红黑树中节点的重新映射过程"><a href="#哈希桶扩容后，红黑树中节点的重新映射过程" class="headerlink" title="哈希桶扩容后，红黑树中节点的重新映射过程"></a>哈希桶扩容后，红黑树中节点的重新映射过程</h6><blockquote>
<p>这个过程又会有很多细节，所以这里就简单捋一下</p>
</blockquote>
<p>参考：<a href="http://www.tianxiaobo.com/2018/01/18/HashMap-%E6%BA%90%E7%A0%81%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90-JDK1-8/#342-%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6">红黑树的拆分</a></p>
<ul>
<li><p>手段：按照映射链表节点的方式来重新映射红黑树中的节点；</p>
</li>
<li><p>原理：在<strong>将普通链表转成红黑树treeifyBin()方法</strong>时，HashMap 通过两个额外的引用 next 和 prev <strong>保留了原链表的节点顺序</strong>；</p>
</li>
<li><p>特征：不需要先把红黑树转化成链表，然后再映射到新的桶数组（效率更高）；</p>
</li>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 红黑树转链表阈值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index, <span class="keyword">int</span> bit)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; b = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// Relink into lo and hi lists, preserving order</span></span><br><span class="line">    TreeNode&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">    TreeNode&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * 红黑树节点仍然保留了 next 引用，故仍可以按链表方式遍历红黑树。</span></span><br><span class="line"><span class="comment">     * 下面的循环是对红黑树节点进行分组，与“对链表分组”类似</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; e = b, next; e != <span class="keyword">null</span>; e = next) &#123;</span><br><span class="line">        next = (TreeNode&lt;K,V&gt;)e.next;</span><br><span class="line">        e.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> ((e.hash &amp; bit) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                loHead = e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                loTail.next = e;</span><br><span class="line">            loTail = e;</span><br><span class="line">            ++lc;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                hiHead = e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                hiTail.next = e;</span><br><span class="line">            hiTail = e;</span><br><span class="line">            ++hc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断分组后的树是否需要反树化为链表</span></span><br><span class="line">    <span class="keyword">if</span> (loHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果 loHead 不为空，且链表长度小于等于 6，则将红黑树转成链表</span></span><br><span class="line">        <span class="keyword">if</span> (lc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">            tab[index] = loHead.untreeify(map);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tab[index] = loHead;</span><br><span class="line">            <span class="comment">/* </span></span><br><span class="line"><span class="comment">             * hiHead == null 时，表明扩容后，</span></span><br><span class="line"><span class="comment">             * 所有节点仍在原位置，树结构不变，无需重新树化</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) </span><br><span class="line">                loHead.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 把分组后的红黑树绑定到预期的桶中</span></span><br><span class="line">    <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">            tab[index + bit] = hiHead.untreeify(map);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tab[index + bit] = hiHead;</span><br><span class="line">            <span class="keyword">if</span> (loHead != <span class="keyword">null</span>)</span><br><span class="line">                hiHead.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h6 id="其他参考文章"><a href="#其他参考文章" class="headerlink" title="其他参考文章"></a>其他参考文章</h6><p><a href="https://www.toocruel.net/java8de-hashmapxiang-jie-cun-chu-jie-gou-gong-neng-shi-xian-kuo-rong-you-hua-xian-cheng-an-quan-bian-li-fang-fa/">JDK1.8中HashMap扩容机制简介</a></p>
<p><a href="https://mp.weixin.qq.com/s/qVoebks_Ba17ZtKMlzcbgw">JDK1.7中HashMap扩容机制简介</a></p>
<blockquote>
<p>it’s been a day, until next time 😄</p>
</blockquote>
]]></content>
      <categories>
        <category>Java Basic</category>
      </categories>
      <tags>
        <tag>Java stuff</tag>
      </tags>
  </entry>
  <entry>
    <title>java基础之快速复习（2）</title>
    <url>/Java-Basic/2020/09/11/interview/20200911-java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BF%AB%E9%80%9F%E5%A4%8D%E4%B9%A0%EF%BC%882%EF%BC%89.html</url>
    <content><![CDATA[<h4 id="Java基础-2"><a href="#Java基础-2" class="headerlink" title="Java基础(2)"></a>Java基础(2)</h4><h5 id="Java中的接口相关的内容"><a href="#Java中的接口相关的内容" class="headerlink" title="Java中的接口相关的内容"></a>Java中的接口相关的内容</h5><a id="more"></a>

<p>参考：<a href="https://juejin.im/post/6844903734053437448">接口的最少必要内容</a></p>
<ul>
<li><p>是：一个技术名称；</p>
</li>
<li><p>作用：定义一组抽象的行为规范；</p>
</li>
<li><p>创建接口的手段：interface接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> 接口名称</span>&#123;</span><br><span class="line">    <span class="comment">// 全局常量；</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 多个抽象方法；</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>用法：</p>
<ul>
<li><p>1 定义接口类型（<strong>只能定义这两个部分</strong>）；</p>
<ul>
<li><p>1 定义接口中的静态常量；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String name = <span class="string">"张三"</span>; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">String name = <span class="string">"张三"</span>; <span class="comment">// 2 接口中的成员变量一般都是常量(静态不可变)</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>- 2 定义接口中的静态方法；

  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> List&lt;String&gt; <span class="title">getUserNames</span><span class="params">(Long companyId)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">List&lt;String&gt; <span class="title">getUserNames</span><span class="params">(Long companyId)</span></span>; <span class="comment">// 接口中的抽象方法都是：公开抽象的</span></span><br></pre></td></tr></table></figure></code></pre><ul>
<li>2 定义具体类型来实现接口；</li>
</ul>
<ul>
<li><p>特征：</p>
<ul>
<li><p>1 接口类型<strong>不能直接实例化</strong>（从而得到实例）；</p>
<ul>
<li>手段：接口类型中<strong>不允许定义构造方法</strong>，会直接编译报错；</li>
</ul>
</li>
<li><p>2 定义类型时，可以同时实现多个不同类型的接口；</p>
<ul>
<li>超人既能Fly,还能Fight；</li>
</ul>
</li>
<li><p>3 接口类型不能继承自<strong>普通类型/抽象类型</strong>；</p>
<ul>
<li>原因：普通类型/抽象类型对方法与变量都没有任何限制，而接口对方法与变量有限制。所以不能直接继承它们</li>
</ul>
</li>
<li><p>4 如果：</p>
<ul>
<li><p>Ⅰ 类型A，继承自类型B，并实现了接口C；</p>
<blockquote>
<p>知识卡</p>
<ul>
<li>继承自类型B，则：<ul>
<li>A继承了类型B中的所有用 <strong>public 和 protected 关键字</strong>修饰的方法和属性（啥意思？😕）</li>
</ul>
</li>
<li>实现了接口C，则：<ul>
<li>A必须要实现接口C中规定的所有抽象方法；</li>
</ul>
</li>
</ul>
</blockquote>
</li>
<li><p>Ⅱ 类型B与接口C中有相同的方法f()…</p>
<ul>
<li>方法名相同的情况下，讨论<strong>方法的参数&amp;返回值类型</strong>:<ul>
<li>方法签名与返回值类型都相同，则：如果实现类中没有显式实现抽象方法f()，最终会执行父类中的f()方法；</li>
<li>方法签名相同，但返回值类型不同，则：子类无法成功定义，因为<strong>先继承，后实现</strong>（子类中方法的返回值类型必须与父类中保持一致）；</li>
<li>参数不同，但是返回值类型相同，则：在子类中需要实现接口中的抽象方法（签名不同，aka 一个新的方法）；</li>
<li>参数不同，返回值类型不同，则：子类中需要重新实现接口中的抽象方法；</li>
</ul>
</li>
<li>原理：子类会<strong>先继承自父类，然后再去实现接口</strong>；</li>
</ul>
</li>
</ul>
<hr>
</li>
<li><p>可以在一个普通类型中定义接口；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//源码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 定义接口</span></span><br><span class="line">	<span class="class"><span class="keyword">interface</span> <span class="title">Climb</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以在一个接口类型中定义接口；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//源码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Hunt</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 定义接口</span></span><br><span class="line">	<span class="class"><span class="keyword">interface</span> <span class="title">Kill</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>应用（设计模式-wise）：</p>
<ul>
<li>工厂模式中：<ul>
<li>1 在工厂父类中定义一个接口；（用于创建产品对象）</li>
<li>2 在子类实现中来具体地创建实例；</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="Java中的访问权限修饰符的具体含义"><a href="#Java中的访问权限修饰符的具体含义" class="headerlink" title="Java中的访问权限修饰符的具体含义"></a>Java中的<em>访问权限修饰符</em>的具体含义</h5><p>参考：<a href="https://mp.weixin.qq.com/s/F7Rl64M5aD4UrzxUydPQdw">从HotSpot虚拟机源码认识访问权限修饰符</a></p>
<ul>
<li>private：<ul>
<li>被private修饰的部分，只在<strong>当前类</strong>中可以访问到</li>
</ul>
</li>
<li>package/default:<ul>
<li>被default修饰的部分，<strong>当前包中的其他类</strong>都能够访问到</li>
</ul>
</li>
<li>protected:<ul>
<li>被protected修饰的部分，<strong>其他包中的子类（继承自当前类）</strong>都能访问到</li>
</ul>
</li>
<li>public:<ul>
<li>被public修饰的部分，<strong>其他包中的任意类</strong>访问到</li>
</ul>
</li>
</ul>
<blockquote>
<p>访问控制因素：1 访问者是否在当前包； 2 访问者是否是当前类的子类；</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/09/11/wNiTy9.png" alt="修饰符限定的访问范围"></p>
<h5 id="Java语言特性多态的具体应用场景"><a href="#Java语言特性多态的具体应用场景" class="headerlink" title="Java语言特性多态的具体应用场景"></a>Java语言特性<em>多态</em>的具体应用场景</h5><blockquote>
<p>注：这个问题真的把我问住了，对于多态的作用，一个基本的答案是“能够使一套代码根据运行时具体的实例产生不同的执行结果”。但是面试官并不满意，大脑迅速搜索库存中可能接近的答案，但是没能找到特别贴切的例子…😳</p>
</blockquote>
<p>其实JDBC就是多态应用的一个很好的例子🐣<font size=2>之前的理解只限于Oracle制定用法标准，具体的数据库厂商负责提供具体实现（像是某种设计模式）</font> 但其实在具体使用时，多态发挥了关键作用</p>
<p>参考：<a href="https://mp.weixin.qq.com/s/XShFqTkw2wmOd8-VCVNC-w">认识JDBC</a></p>
<ul>
<li>是：Oracle（Java语言的发明公司）所制定的<strong>Java程序员应该如何操作数据库</strong>的规范；</li>
<li>作用：<ul>
<li>1 规定了Java程序员在编写操作数据库的代码时所使用到的APIs（具体化程序员的工作）；</li>
<li>2 帮助程序员避开了操作数据库时繁琐的底层协议；</li>
</ul>
</li>
</ul>
<blockquote>
<p>说明：</p>
<ul>
<li>市场上有很多种类型的数据库（在Java语言之前就已经存在），比如MySQL、Oracle、 DB2等；</li>
<li>这些个厂商提供给Java程序员操作数据库的接口各不相同（毕竟是竞争关系嘛），这就导致Java程序员在编写代码时，需要根据具体使用的数据库类型来编写对应的代码；</li>
</ul>
</blockquote>
<ul>
<li><p>原理：</p>
<ul>
<li>1 Oracle（Java所属的公司）制定了JDBC规范，统一了Java程序员编写DB操作的编码方式；</li>
<li>2 Oracle要求/请求/强制/协商所有的数据库厂商，请大家根据我制定的规范，实现一个能够操作你家数据库的工具（这个工具叫做<strong>驱动</strong>）；</li>
<li>3 各大厂商就真的去根据JDBC规则实现了<strong>操作自家数据库的工具</strong>，然后免费开放出来，给Java程序员下载来用；</li>
</ul>
</li>
<li><p>用法（Java程序员编码过程）：</p>
<ul>
<li>1 把数据库厂商提供的jar包工具添加进项目中；（这个工具相当于接口的实现类）</li>
<li>2 使用JDBC规定的API编写代码来操作数据库；（JDBC规定的API相当于接口中的抽象方法）</li>
</ul>
<blockquote>
<p>Java程序员编写的代码为什么能够成功操作数据库的？</p>
<p>1 程序员在编写代码时，是在使用接口编程；</p>
<p>2 程序在运行时，会为接口类型绑定具体实例（厂商jar包中的实现类 <strong>代码中的多态</strong>）。所以代码真正执行时，使用的是<strong>厂商提供的子类的实例</strong>去完成对应数据库的操作；</p>
<p>3 既然用他们家的工具操作他们家的产品，当然就能正常地操作啦😄</p>
</blockquote>
</li>
</ul>
<h5 id="如何通过反射机制访问到类中的私有方法？"><a href="#如何通过反射机制访问到类中的私有方法？" class="headerlink" title="如何通过反射机制访问到类中的私有方法？"></a>如何通过反射机制访问到类中的私有方法？</h5><blockquote>
<p>注：这应该只是某个API，但当时记不得这么多细节了</p>
</blockquote>
<p>参考：<a href="https://www.cnblogs.com/mengdd/archive/2013/01/26/2878136.html">利用反射访问私有字段、方法</a></p>
<blockquote>
<p>使用反射机制的流程：</p>
<ul>
<li>1 获取到类的Class对象；</li>
<li>2 根据需要，获取到Method对象或者Field对象；<ul>
<li>任务：获取到Method对象；</li>
<li>API(参考文档):<ul>
<li>getMethod()方法，返回的是public的Method对象</li>
<li>getDeclaredMethod()，返回的Method对象可以是非public的</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h6 id="访问私有方法的手段-反射用法："><a href="#访问私有方法的手段-反射用法：" class="headerlink" title="访问私有方法的手段/反射用法："></a>访问私有方法的手段/反射用法：</h6><ul>
<li>Prepare: 准备一个私有方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrivateClass</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 被private访问修饰符修饰的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">sayHello</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello: "</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><p>0 获取到私有方法的Method对象；</p>
<ul>
<li><p>手段：&lt;class对象&gt;.getDeclaredMethod(xxx, ooo);</p>
</li>
<li><p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Ⅰ 创建实例</span></span><br><span class="line">PrivateClass p = <span class="keyword">new</span> PrivateClass();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ⅱ 使用实例获取到Class对象</span></span><br><span class="line">Class&lt;?&gt; classType = p.getClass();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ⅲ 使用Class对象获取Method对象</span></span><br><span class="line">Method method = classType.getDeclaredMethod(<span class="string">"sayHello"</span>,</span><br><span class="line">                                            <span class="keyword">new</span> Class[] &#123; String<span class="class">.<span class="keyword">class</span> &#125;)</span>;</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
<ul>
<li><p>1 <strong>抑制Java访问权限的检查</strong>；</p>
<ul>
<li><p>手段：通过<strong>AccessibleObject类</strong>（Constructor、 Field和Method类的基类）中的<strong>setAccessible()</strong>方法；</p>
</li>
<li><p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">method.setAccessible(<span class="keyword">true</span>); <span class="comment">// 抑制Java的访问控制检查</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>2 实现对方法的调用；</p>
<ul>
<li><p>手段：Method对象的invoke()方法；</p>
</li>
<li><p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = (String) method.invoke(p, <span class="keyword">new</span> Object[] &#123; <span class="string">"zhangsan"</span> &#125;);</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<p>总结：反射机制破坏了类的封装，private本来是保护方法只有在类的内部才能被访问到。但是现在通过反射机制，在其他类中（类的外部）同样可以访问private修饰的方法；</p>
<h5 id="项目中多线程具体的应用场景"><a href="#项目中多线程具体的应用场景" class="headerlink" title="项目中多线程具体的应用场景"></a>项目中多线程具体的应用场景</h5><blockquote>
<p>注：这个如果没有答好会很吃亏，对于项目中没有真正多线程经验的同学尤其如此。很露怯😳</p>
</blockquote>
<p>参考：<a href="https://mp.weixin.qq.com/s/hrhyihWRBnLX_ZRNachJmA">多线程的应用案例与具体场景</a></p>
<h6 id="多线程的使用场景"><a href="#多线程的使用场景" class="headerlink" title="多线程的使用场景"></a>多线程的使用场景</h6><ul>
<li>1 在一组操作中，有一个<strong>操作比较耗时</strong>（但又没那么重要）。可以开启一个新线程来执行这个操作<ul>
<li>比如用户注册完成后，赠送积分的操作；</li>
</ul>
</li>
<li>2 由于某些需求，可能<strong>需要某个线程一直在后台运行</strong>（比如定期执行某项任务-更新配置文件、采集特定信息…）；</li>
<li>3 某一个<strong>非常耗时的操作</strong>（比如备份数据库，这其实也算是后台任务）<ul>
<li>注：这种情况下，主线程需要轮询开启的线程以便了解备份的进度情况；</li>
</ul>
</li>
<li>4  某个业务逻辑有<strong>很多次的循环，而且每次循环之间没有相互影响</strong>（比如验证1万条url路径是否存在）；<ul>
<li>手段：开启50个线程，每个线程负责200条URL的验证；</li>
<li>特征：耗时比较短（砌墙的工人多了）</li>
</ul>
</li>
<li>5 希望获取到某个任务执行的进度（比如电影下载的进度条）；<ul>
<li>手段：不是很理解（做了Demo后回来补充 🚩）</li>
</ul>
</li>
</ul>
<h6 id="多线程的应用案例"><a href="#多线程的应用案例" class="headerlink" title="多线程的应用案例"></a>多线程的应用案例</h6><ul>
<li><p>1 Tomcat这个Web服务器就是采用多线程的方式来<strong>处理并发请求</strong>的;</p>
<ul>
<li>原理：<ul>
<li>1 每次有新的客户端向Web应用发起请求，Tomcat都会创建一个新的线程来处理它；</li>
<li>2 这个新线程最后会调用到程序员编写的Servlet代码-比如doGet()；</li>
</ul>
</li>
</ul>
</li>
<li><p>2 需要<strong>同时执行多个任务</strong>的场景（aka 异步处理）；</p>
<ul>
<li>手段：<ul>
<li>1 手动为每个任务创建一个线程；</li>
<li>2 通过JVM的线程调度来实现<strong>同时执行多个任务</strong>；</li>
</ul>
</li>
</ul>
<blockquote>
<p>单核CPU的电脑是不可能同时执行多个任务的。所以如果电脑只有一个核心，会使用一种技术，让每个线程都能够获取到CPU时间执行（这样看起来像是“<strong>同时执行</strong>”）</p>
</blockquote>
</li>
</ul>
<p>总结：多线程开发的目的是，<strong>尽量充分利用CPU资源</strong>；</p>
<p>SO， 如果某个业务逻辑执行非常耗时/效率低，就可以考虑使用多线程处理它。  </p>
]]></content>
      <categories>
        <category>Java Basic</category>
      </categories>
      <tags>
        <tag>Java stuff</tag>
      </tags>
  </entry>
  <entry>
    <title>java基础之快速复习</title>
    <url>/Java-Basic/2020/09/09/interview/20200909-java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BF%AB%E9%80%9F%E5%A4%8D%E4%B9%A0.html</url>
    <content><![CDATA[<h4 id="Java常见知识（Common-Sense）"><a href="#Java常见知识（Common-Sense）" class="headerlink" title="Java常见知识（Common Sense）"></a>Java常见知识（Common Sense）</h4><a id="more"></a>

<h5 id="1-重写-amp-重载"><a href="#1-重写-amp-重载" class="headerlink" title="1 重写&amp;重载"></a>1 重写&amp;重载</h5><ul>
<li>重写；<ul>
<li>是：一种编程技术；</li>
<li>作用：对父类中的方法重新进行实现，以满足子类的具体需求；</li>
<li>特征：<ul>
<li>1 发生在子类型/实现类型中；</li>
<li>2 方法签名与父类中的方法签名相同，方法实现应该会不同；</li>
<li>3 不能对父类中的private方法进行重写；</li>
</ul>
</li>
</ul>
</li>
<li>重载；<ul>
<li>是：一种编程技术；</li>
<li>作用：为某一个功能的方法，提供不同的/新的具体实现；</li>
<li>特征：<ul>
<li>1 编写的重载方法与原始方法在同一个类中；</li>
<li>2 重载方法的方法名和原始方法的方法名相同（某一功能），其他的细节不要求相同；</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="String、StringBuffer、StringBuilder的区别"><a href="#String、StringBuffer、StringBuilder的区别" class="headerlink" title="String、StringBuffer、StringBuilder的区别"></a>String、StringBuffer、StringBuilder的区别</h5><ul>
<li><p><strong>String</strong>:</p>
<ul>
<li><p>特征：</p>
<ul>
<li>1 String实例是不可变的；</li>
<li>2 由于实例是不可变的，所以多线程下实例是安全的（只可读）；</li>
<li>3 由于实例是不可变的，所以每次修改实例时，其实都在内存中新建了一个String实例；</li>
</ul>
</li>
<li><p>原理：String的底层数据结构是一个<em>被final修饰的字符数组</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span>[] value;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>StringBuffer &amp; StringBuilder</strong>:</p>
<ul>
<li><p>特征：</p>
<ul>
<li><p>1 实例是可变的；</p>
<ul>
<li>原理：<ul>
<li>1 它们都继承自AbstractStringBuilder 类型；</li>
<li>2 AbstractStringBuilder类型的底层数据结构为<em>一个*</em>没有被final修饰*<em>的字符数组</em>；</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title">Appendable</span>, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] value; <span class="comment">// 底层数据结构：字符数组</span></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
</li>
<li><p>2 StringBuffer是线程安全的，而StringBuilder不是线程安全的；</p>
<ul>
<li>原理：<ul>
<li>StringBuffer对所有操作字符串的方法都加了锁，StringBuilder没有这么做；</li>
</ul>
</li>
</ul>
</li>
<li><p>3 单线程情况下，StringBuilder的效率更高；</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>用法总结：</p>
<ul>
<li>操作少量字符串时，可以使用String类型；</li>
<li>单线程情况下，操作大量字符串数据时，使用StringBuilder类型；</li>
<li>多线程情况下，操作大量字符串数据时，使用StringBuffer类型；</li>
</ul>
</li>
</ul>
<h5 id="Java中的自动装箱与自动拆箱"><a href="#Java中的自动装箱与自动拆箱" class="headerlink" title="Java中的自动装箱与自动拆箱"></a>Java中的自动装箱与自动拆箱</h5><ul>
<li>自动装箱；<ul>
<li>是：JDK提供的一种技术；</li>
<li>作用：<ul>
<li>在需要使用包装类型（Integer等）的场合中，如果程序员使用了基本数据类型（int），自动装箱技术能够把基本类型封装成为其对应的包装类型——从而保证代码编译的正确性；</li>
</ul>
</li>
<li>特征：<ul>
<li>这项技术会自动发挥作用，而不需要任何显式的语法声明；</li>
</ul>
</li>
</ul>
</li>
<li>自动拆箱：<ul>
<li>作用：在xxx的场合，如果xxx，xxx能够把包装类型自动拆封成为其对应的基本类型——从而xxx；</li>
</ul>
</li>
</ul>
<h5 id="Java中的-与equals-方法"><a href="#Java中的-与equals-方法" class="headerlink" title="Java中的==与equals()方法"></a>Java中的==与equals()方法</h5><ul>
<li><p>==</p>
<ul>
<li>是：Java提供的操作符；</li>
<li>作用：<ul>
<li>当==左右两侧是同类型的操作数时，<ul>
<li>如果操作数是<strong>基本数据类型</strong>，则：比较<em>操作数的数值</em>是否相等；</li>
<li>如果操作数是<strong>引用数据类型</strong>，则：比较<em>操作数的内存地址</em>是否相等；</li>
</ul>
</li>
<li>当==左右两侧不是同类型的操作数时，直接编译报错；</li>
</ul>
</li>
<li>特征：<ul>
<li>不同情况下，==的具体作用会有不同；</li>
</ul>
</li>
</ul>
</li>
<li><p>equals()方法</p>
<ul>
<li><p>是：Object类的一个方法；</p>
</li>
<li><p>作用：</p>
<ul>
<li><p>默认实现是：比较当前对象与另外一个对象的<em>内存地址是否相等</em>；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>特征：</p>
<ul>
<li>1 程序员在编码时，可能会根据具体的需要在类型中重写equals()方法——指定新的判等规则；</li>
<li>2 一般重写的判等规则，会根据对象的某个属性值来判断对象是否相等；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// String类型的equals()方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">            <span class="comment">// 实现不重要，关键是equals()方法被重写了</span></span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>应用：</p>
<ul>
<li><p>1 String类型中的equals()方法被重写了，所以判断两个字符串实例是否相等时，判断依据是<strong>对象的值是否相等（而不是内存地址）</strong></p>
<blockquote>
<p>知识卡</p>
<p>当代码中创建String实例时，JVM会从常量池中查找是不是已经存在<strong>值与预期要创建的字符串实例相同</strong>的实例：</p>
<ul>
<li>如果存在，则：不新建String实例，而是直接把实例赋值给新的变量/引用；</li>
<li>如果不存在，则：会在常量池中新创建一个String实例；</li>
</ul>
<p>注：JDK1.8版本中似乎有些变动，具体待考证（Mark🚩）</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h5 id="关于final关键字"><a href="#关于final关键字" class="headerlink" title="关于final关键字"></a>关于final关键字</h5><ul>
<li><p>是：Java提供的一个关键字；</p>
</li>
<li><p>作用：</p>
<ul>
<li>修饰一个成份，标识此成份<strong>不可变</strong>；</li>
</ul>
</li>
<li><p>用法：</p>
<ul>
<li>1 修饰一个变量；<ul>
<li>1 变量为基本数据类型，则：变量的值一旦初始化后，就不能再改变；</li>
<li>2 变量为引用数据类型，则：变量初始化后，不能再重新绑定到新的对象；</li>
</ul>
</li>
<li>2 修饰一个方法；<ul>
<li>标识此方法不能被子类重写；</li>
</ul>
</li>
<li>3 修饰一个类；<ul>
<li>标识此类不能被扩展/继承；</li>
<li>原理：final类中的所有成员方法都隐式地被final修饰；</li>
</ul>
</li>
</ul>
<blockquote>
<p>知识卡：</p>
<p>关键字是什么？它是怎么发挥作用的？</p>
<p>是：字符串；</p>
<p>作用：能够被编译器识别出来，并默认有特定的含义；</p>
<p>原理：</p>
<ul>
<li>在实现编译器时，就对这些关键字的功能进行了内置的定义；</li>
<li><strong>所以关键字的作用是由Java编译器支持的</strong></li>
</ul>
</blockquote>
</li>
</ul>
<h5 id="Object类的常用方法【×7-×5】"><a href="#Object类的常用方法【×7-×5】" class="headerlink" title="Object类的常用方法【×7 + ×5】"></a>Object类的常用方法【×7 + ×5】</h5><p>🐖：在Java中，Object类型是所有其他类型的父类；</p>
<ul>
<li>getClass()方法；<ul>
<li>作用：返回当前运行时对象的Class对象 ；</li>
<li>特征：<ul>
<li>1 使用final关键字修饰（不允许子类重写）；</li>
</ul>
</li>
<li>应用：Java反射机制中获取运行时对象的信息；</li>
</ul>
</li>
<li>hashCode()方法；<ul>
<li>作用：返回对象的hash码；</li>
<li>应用：JDK中HashMap求key的哈希值；</li>
</ul>
</li>
<li>equals()方法；<ul>
<li>作用：比较两个对象的内存地址是否相等（aka 是否为同一个对象）；</li>
<li>用法：在子类型中重写，以重新定义判等规则；</li>
<li>应用：String类型；</li>
</ul>
</li>
<li>clone()方法；<ul>
<li>作用：创建并返回当前对象的一个副本；</li>
<li>用法规则：一般情况下，对于任何对象 x，<ul>
<li>表达式 x.clone() != x 为true；（副本与原始对象是独立的不同对象）</li>
<li>x.clone().getClass() == x.getClass() 为true ；（副本的Class对象与原始对象的Class对象是同一个对象）；</li>
</ul>
</li>
</ul>
</li>
<li>toString()方法；<ul>
<li>作用：返回实例的一个字符串标识；</li>
<li>规则：<em>类的名字</em>@<em>实例的哈希码的16进制表示</em></li>
</ul>
</li>
<li>多线程通知相关的方法【×5】 简单记忆<ul>
<li>1 notify()方法<ul>
<li>作用：唤醒正在等待锁的某个线程；</li>
<li>特征：<ul>
<li>1 如果有多个线程正在等待<strong>当前线程所持有的锁</strong>，此方法只会随机唤醒一个线程；</li>
<li>2 此方法不能被重写（被final修饰）；</li>
<li>3 此方法为native方法（使用C语言实现，无法查看源码）；</li>
</ul>
</li>
<li>用法：<ul>
<li>在当前线程对象上调用notify()方法，以此释放锁，从而唤醒其他等待这个锁的线程；</li>
</ul>
</li>
</ul>
</li>
<li>2 notifyAll()方法<ul>
<li>作用：唤醒正在等待锁的所有线程；</li>
<li>特征：<ul>
<li>等待锁的所有线程都被会被唤醒（😕唤醒也只有一个锁呀，唤醒有啥用？）</li>
</ul>
</li>
</ul>
</li>
<li>3 wait(long timeout)方法<ul>
<li>作用：暂停线程的执行；</li>
<li>特征：<ul>
<li>1 线程会释放自己所持有的锁；</li>
<li>2 timeout参数指定的是线程的释放锁之前的等待时间；</li>
</ul>
</li>
</ul>
</li>
<li>4 wait(long timeout, int nanos)<ul>
<li>作用：更加精确地暂停线程的执行；</li>
<li>特征：<ul>
<li>1 添加了nano参数，用于表示超时的额外时间（单位为毫微秒）；</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>finalize ()方法；<ul>
<li>作用：定义<strong>实例被垃圾回收时</strong>所预期执行的操作；</li>
</ul>
</li>
</ul>
<h5 id="Java中的异常处理机制"><a href="#Java中的异常处理机制" class="headerlink" title="Java中的异常处理机制"></a>Java中的异常处理机制</h5><blockquote>
<p>知识卡</p>
<p>异常；</p>
<ul>
<li>是：一个名词；</li>
<li>作用：描述那些程序执行过程中发生的<strong>预期之外的事情</strong>；</li>
<li>特征：<ul>
<li>1 异常可以是语句执行引发的，也可以由程序员手动抛出（比如xxx数据类型不支持remove()操作，但是为了API的一致性又需要实现删除的API方法，那么就可以通过抛出一个异常来表示不支持此操作）；</li>
<li>2 程序中会使用一个异常对象来封装异常，以便使用代码处理它们；</li>
</ul>
</li>
<li>说明：程序中发生异常时，如果不做任何处理，程序就会完全终止；</li>
<li>处理异常的手段：<ul>
<li>在语言实现中提供一整套的处理机制（Java采用的手段）；</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li><p>作用：</p>
<ul>
<li>1 为程序员提供一种编码方式，能够在编码时就对<em>可能出现的异常**</em>进行针对性的处理**；</li>
<li>2 通过1的处理，使得程序尽可能恢复正常并继续执行；</li>
</ul>
</li>
<li><p>特征：</p>
<ul>
<li>1 Throwable类型是Java异常类的顶级父类；</li>
<li>2 程序的异常分为两类（它们都是Throwable的子类）：<ul>
<li>Excpetion(异常)；</li>
<li>Error(错误)；</li>
</ul>
</li>
</ul>
</li>
<li><p>原理：当出现异常对象时，JRE就会尝试寻找异常处理程序(程序员手动编写)来处理异常；</p>
</li>
<li><p>用法：</p>
<ul>
<li>1 当程序运行出现Error时，表示出现了非常严重的错误（一般是虚拟机发生问题，通过编码无法处理这些错误）；<ul>
<li>Error的具体类型：<ul>
<li>内存溢出错误、虚拟机运行错误、类定义错误等；</li>
</ul>
</li>
<li>处理手段：JVM终止线程的运行（程序员不需要做任何事情）；</li>
</ul>
</li>
<li>2 当程序运行出现Exception时，表示出现了一些问题，但是可以通过代码处理这些问题；<ul>
<li>Exception的具体类型：<ul>
<li>空指针异常、算术运算异常、下标越界异常；</li>
</ul>
</li>
<li>处理手段：程序员在编码时，手动通过try/catch语法来对异常进行处理；</li>
</ul>
</li>
</ul>
</li>
<li><p>用法模板（编程语法）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	<span class="comment">// 可能出现异常的代码片段</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (预期出现的异常类型)&#123;</span><br><span class="line">    <span class="comment">// 对捕捉到的异常进行处理的代码</span></span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 不管是否发生异常都会被执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>finally代码块的特征：<ul>
<li>0 正常情况下，finally块中的语句肯定会被执行（除非发生异常，或者被强制退出）；</li>
<li>1 如果try/catch中有return语句，finally代码块会在return之前被执行；</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="Java中获取键盘输入的手段"><a href="#Java中获取键盘输入的手段" class="headerlink" title="Java中获取键盘输入的手段"></a>Java中获取键盘输入的手段</h5><ul>
<li><p>手段1：Scanner类型；</p>
<ul>
<li><p>用法：</p>
<ul>
<li><p>1 使用标准输入(<strong>System.in</strong>)作为参数，创建一个Scanner对象；</p>
</li>
<li><p>2 调用Scanner实例的API，来在代码中获取到<em>用户通过键盘输入的内容</em>；</p>
</li>
<li><p>3 用完Scanner实例之后，关闭该实例；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">String s = input.nextLine();</span><br><span class="line">input.close();</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>手段2：不常用Mark🚩</p>
</li>
</ul>
<h5 id="Java中接口与抽象类的区别"><a href="#Java中接口与抽象类的区别" class="headerlink" title="Java中接口与抽象类的区别"></a>Java中接口与抽象类的区别</h5><ul>
<li>本质区别；<ul>
<li>接口用于定义一组行为规范，而抽象类用于抽象某一个实体类型（是模板设计）；</li>
</ul>
</li>
<li>语法特征上的区别（抽象类 VS 接口）：<ul>
<li>1 接口中定义的方法一般都是抽象的（Java8之后也允许接口方法有默认实现），而抽象类中可以有具体的方法实现；</li>
<li>2 接口中的实例变量默认会用final修饰，而抽象类不会；</li>
<li>3 接口中的方法默认都是public的；</li>
</ul>
</li>
<li>语法特征上的区别（类 VS 接口）<ul>
<li>1 自定义类型能够实现多个接口，但只能实现/继承一个抽象类；</li>
<li>2 自定义类型实现接口时，必须实现接口中所有的抽象方法。但实现抽象类时，可以选择性地实现其中的抽象方法；</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Java Basic</category>
      </categories>
      <tags>
        <tag>Java stuff</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之代理模式</title>
    <url>/Design-Model/Proxy-mode/2020/09/08/interview/20200908-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.html</url>
    <content><![CDATA[<h4 id="代理模式-amp-Java所提供的具体实现手段-Ⅰ"><a href="#代理模式-amp-Java所提供的具体实现手段-Ⅰ" class="headerlink" title="代理模式 &amp; Java所提供的具体实现手段_Ⅰ"></a>代理模式 &amp; Java所提供的具体实现手段_Ⅰ</h4><h5 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h5><a id="more"></a>

<ul>
<li><p>作用：</p>
<ul>
<li>1 解耦<strong>客户端代码</strong>与<strong>具体实例</strong>之间的依赖关系；</li>
<li>2 控制<strong>客户端代码</strong>对<strong>具体实例</strong>的访问；</li>
<li>3 在代理中，对具体实例的功能进行增强（有点子像装饰器模式，figure out this later）；</li>
</ul>
</li>
<li><p>特征：</p>
<ul>
<li><p>1 这里的“代理”指的是<strong>具体实例</strong>的代理；</p>
<blockquote>
<p>比如我要租房，而我没办法直接找到房东。</p>
<p>但是我知道链家的经纪人一般能够作为房东（具体实例）的代理;</p>
<p>所以我只要联系链家经纪人（房东的代理），就能去租房东的房子了；</p>
</blockquote>
</li>
</ul>
</li>
<li><p>应用场景：</p>
<ul>
<li>1 客户端代码不希望直接访问某个具体实例（这会导致强耦合）；</li>
<li>2 客户端代码无法直接访问到某个具体实例（WHY?🙋）；</li>
</ul>
<p>在以上场景中，客户端代码可以<strong>通过代理对象来访问到具体实例（目标对象）</strong>；</p>
</li>
</ul>
<h6 id="UML图描述各个部分的关系："><a href="#UML图描述各个部分的关系：" class="headerlink" title="UML图描述各个部分的关系："></a>UML图描述各个部分的关系：</h6><p><img src="https://s1.ax1x.com/2020/09/08/wMyxZ6.png" alt="代理模式中各个部分之间的关系"></p>
<p><font size=2>可能是我不太清楚UML图的规则，我不很喜欢UML描述各部分关系的方式</font></p>
<h6 id="用法（根据UML类图）"><a href="#用法（根据UML类图）" class="headerlink" title="用法（根据UML类图）"></a>用法（根据UML类图）</h6><ul>
<li><p>用法（根据UML类图）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1 准备一个接口		特征：目标类 与 代理类都需要实现这个接口（这样才能在代码中无差别地使用接口类型）</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 定义具体类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"This is real doSomeThing"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3 定义代理类型	作用：代理具体的类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxySubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123; <span class="comment">// 特征1：实现具体类型所实现的接口</span></span><br><span class="line">	<span class="comment">// 特征2：持有具体类型的实例变量</span></span><br><span class="line">    <span class="keyword">private</span> Subject mSubject;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 特征3：通过构造方法来初始化具体类型的实例变量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxySubject</span><span class="params">(Subject realSubject)</span> </span>&#123;</span><br><span class="line">        mSubject = realSubject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 委托具体实例完成具体的操作</span></span><br><span class="line">        mSubject.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4 客户端代码的编写</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 4-1 创建具体类型</span></span><br><span class="line">        Subject mRealSubject=<span class="keyword">new</span> RealSubject();</span><br><span class="line">        <span class="comment">// 4-2 创建代理类</span></span><br><span class="line">        ProxySubject mProxy = <span class="keyword">new</span> ProxySubject(mRealSubject);</span><br><span class="line">        <span class="comment">// 4-3 客户端代码调用代理对象来实现需要的操作</span></span><br><span class="line">        mProxy.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码有点子多，拆解一下：</p>
<ul>
<li>根据UML类图实现代理模式的流程：<ul>
<li>1 准备一个接口；<ul>
<li>作用：具体类型 与 代理类型都需要实现这个接口，以便在客户端代码中能够无差别地使用代理对象替代具体实例；</li>
</ul>
</li>
<li>2 编写具体类型；<ul>
<li>作用：实现具体的方法，作为最终会被执行的方法；</li>
</ul>
</li>
<li>3 编写代理类型；<ul>
<li>作用：控制客户端代码中对具体实例的访问（虚）；</li>
</ul>
</li>
<li>4 编写客户端代码；<ul>
<li>作用：使用各个组件编写出的主流程代码（体现代理模式的作用）；</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h6 id="为什么客户端代码中需要使用代理对象呢？😕"><a href="#为什么客户端代码中需要使用代理对象呢？😕" class="headerlink" title="为什么客户端代码中需要使用代理对象呢？😕"></a>为什么客户端代码中需要使用代理对象呢？😕</h6><ul>
<li><p>窘境：在第4步中，为了创建出代理对象，还是需要先创建出具体实例。既然已经有了具体实例，为什么还要使用代理对象呢？</p>
</li>
<li><p>原因：这里是因为<em>代理类中具体类型的实例变量</em>是通过<em>构造方法的参数</em>进行初始化的——这样不能很好地描述代理模式的工作方式（因为客户端代码中既存在代理对象，又存在具体实例对象）；【uncertain】</p>
</li>
<li><p>解决手段：在代理类中，可以在声明实例变量的时候进行初始化操作；</p>
</li>
<li><p>特征/issue：</p>
<ul>
<li>这样每个代理类就只能代理某一种具体的类型；就像一个链家经纪人只能代理一个房东一样，这种处理方式效率很低；</li>
</ul>
<p>追问：</p>
</li>
<li><p>追问：</p>
<ul>
<li>有没有其他方式能够用代理对象代理多个具体类型呢？</li>
</ul>
</li>
</ul>
<h5 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h5><ul>
<li><p>作用：</p>
<ul>
<li>创建出目标对象的代理对象，以控制对目标对象的访问；</li>
</ul>
</li>
<li><p>特征：</p>
<ul>
<li>1 不需要为每个<em>具体类型</em>都手动创建<em>其对应的代理类型</em>；</li>
<li>2 使用JDK提供的工具，传入需要的参数即可得到一个代理对象；</li>
<li>3 代理类并不是在程序编译的时候创建，而是在运行的过程中通过Java的反射机制动态的进行创建；</li>
</ul>
</li>
<li><p>用法：</p>
<ul>
<li>1 准备一个接口；</li>
<li>2 准备一个具体类型；</li>
<li>3 自定义一个处理器类型，实现InvocationHandler接口，并重写invoke()方法；</li>
<li>4 在客户端代码中，通过Proxy.newProxyInstance(&lt;类加载器&gt;, &lt;接口数组&gt;, &lt;处理器&gt;)来获取到一个代理对象；</li>
<li>5 通过4中得到的代理对象来操作具体对象（以获取到一些增强的功能）</li>
</ul>
</li>
<li><p>代码示例</p>
<blockquote>
<p>1 定义接口</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代理类和被代理的接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SaleComputer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sale</span><span class="params">(<span class="keyword">double</span> money)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>2 定义具体类型</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by qjq on 2020/2/23 10:53</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lenovo</span> <span class="keyword">implements</span> <span class="title">SaleComputer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sale</span><span class="params">(<span class="keyword">double</span> money)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"卖出一台电脑，价值："</span>+money);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"联想电脑"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"展示电脑"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>3 客户端代码【注：InvocationHandler接口的实现类使用匿名内部类来实现】</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler; <span class="comment">// 全限定名以java开头，说明是JDK提供的类型/接口</span></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by qjq on 2020/2/23 10:55</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 创建真实对象</span></span><br><span class="line">        Lenovo company = <span class="keyword">new</span> Lenovo();</span><br><span class="line">        <span class="comment">//2. 创建动态代理</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        三个参数：</span></span><br><span class="line"><span class="comment">            1. 类加载器：真实对象.getClass().getClassLoader()</span></span><br><span class="line"><span class="comment">            2. 接口数组：真实对象.getClass().getInterfaces()</span></span><br><span class="line"><span class="comment">            3. 处理器：new InvocationHandler()，处理和被代理对象的方法，即方法增强的地方</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        SaleComputer proxy_lenovo = (SaleComputer) 					           Proxy.newProxyInstance(company.getClass().getClassLoader(), company.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">            <span class="comment">/*代理逻辑编写的方法，代理对象调用的所有方法都会触发该方法的执行</span></span><br><span class="line"><span class="comment">            参数：</span></span><br><span class="line"><span class="comment">                1. proxy：代理对象（一般不用）</span></span><br><span class="line"><span class="comment">                2. method：代理对象调用的方法，被封装为的对象</span></span><br><span class="line"><span class="comment">                3. args：代理对象调用的方法时，传入的实际参数</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                Object obj =<span class="keyword">null</span>;</span><br><span class="line">                System.out.println(<span class="string">"这里是代理。。。。"</span>);</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">"sale"</span>.equals(method.getName()))&#123;</span><br><span class="line">                    <span class="comment">//增强参数</span></span><br><span class="line">                    Double money = (Double) args[<span class="number">0</span>];<span class="comment">//用户买电脑付的钱</span></span><br><span class="line">                    money = money*<span class="number">0.8</span>;<span class="comment">//给电脑厂商的钱</span></span><br><span class="line">                    System.out.println(<span class="string">"你被增强啦"</span>);</span><br><span class="line">                    <span class="comment">//使用compay对象执行此方法，返回值就是真实对象方法的返回值</span></span><br><span class="line">                    obj = method.invoke(company, money);</span><br><span class="line">                    <span class="comment">//增强返回值</span></span><br><span class="line">                    obj = obj+<span class="string">"_鼠标垫"</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    obj = method.invoke(company, args);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> obj;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 客户端代码使用代理对象来编码</span></span><br><span class="line">        String computer = proxy_lenovo.sale(<span class="number">8000</span>);<span class="comment">//用户付钱</span></span><br><span class="line">        System.out.println(computer);<span class="comment">//用户得到的产品</span></span><br><span class="line">        System.out.println(<span class="string">"---------------------"</span>);</span><br><span class="line">        proxy_lenovo.show();<span class="comment">//展示商品</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>疑问：</p>
<p>如果只是通过代理获取到一些增强的功能，那代理模式就和装饰者模式没有差别呀😮</p>
</li>
<li><p>不足：</p>
<p>获取代理对象时，需要传入代理类型预期实现的接口。所以如果具体类型没有实现任何接口，就不能通过这种方式来生成代理对象😳</p>
</li>
<li><p>解决手段：CGLib动态代理</p>
</li>
</ul>
<h5 id="CGLib动态代理"><a href="#CGLib动态代理" class="headerlink" title="CGLib动态代理"></a>CGLib动态代理</h5><ul>
<li><p>特征：</p>
<ul>
<li>1 不要求具体类型实现接口；</li>
<li>2 具体类型的方法不能被final修饰（因为final修饰的方法无法被重写，所以子类方法的字节码无法正常生成）；</li>
<li>3 具体类型不能被final修饰（因为被final修饰的类无法被继承，也就无法生成子类字节码）；</li>
<li>4 依赖于第三方库cglib；</li>
</ul>
</li>
<li><p>原理：</p>
<ul>
<li>1 动态生成具体类型(被代理类)的子类字节码;</li>
<li>2 由于其字节码都是按照jvm编译后的class文件的规范编写的，因而其可以被jvm正常加载并运行;</li>
</ul>
</li>
<li><p>用法：</p>
<ul>
<li>1 引入cglib的jar包；</li>
<li>2 调用jar包所提供的Enhancer类的create()方法，生成代理对象；<ul>
<li>create()方法的参数：<ul>
<li>&lt;Class对象&gt;：具体类型的Class对象/字节码；</li>
<li>&lt;Callback类型实例&gt;: 自定义的代理增强实现；<ul>
<li>手段：编写一个类，实现Callback接口/子接口的实现类<strong>MethodInterceptor</strong>；</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>代码示例：</p>
<blockquote>
<p>具体类型</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 电脑生产商</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lenovo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sale</span><span class="params">(<span class="keyword">double</span> money)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"卖出一台电脑，价值："</span>+money);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"联想电脑"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"展示电脑"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>客户端代码【注：Callback类型参数使用匿名内部类】</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * CGLib动态代理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibProxy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Lenovo factory = <span class="keyword">new</span> Lenovo();</span><br><span class="line">        <span class="comment">// 创建代理对象	手段：Enhancer.create(&lt;Class对象&gt;, &lt;Callback对象&gt;)</span></span><br><span class="line">        <span class="comment">// 1 获取具体类型的Class对象		手段:实例.getClass()；</span></span><br><span class="line">        <span class="comment">// 2 创建Callback类型的对象(匿名内部类)	手段：new MethodInterceptor()&#123; ... &#125; </span></span><br><span class="line">        Lenovo proxy_CGLib = (Lenovo) Enhancer.create(factory.getClass(), <span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 执行被代理对象的任何方法都会经过该方法</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> proxy 代理对象 </span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> method 方法所封装得到的对象</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> args 参数封装得到的对象    注：以上三个参数和基于接口的动态代理中invoke方法的参数是一样的</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> methodProxy ：当前执行方法的代理对象</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@return</span> 调用方法的返回值</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                Object obj = <span class="keyword">null</span>;</span><br><span class="line">                System.out.println(<span class="string">"这里是CGLib动态代理。。。。"</span>);</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">"sale"</span>.equals(method.getName())) &#123;<span class="comment">//当是sale方法时</span></span><br><span class="line">                    <span class="comment">//增强参数</span></span><br><span class="line">                    Double money = (Double) args[<span class="number">0</span>];<span class="comment">//用户买电脑付的钱</span></span><br><span class="line">                    money = money * <span class="number">0.8</span>;<span class="comment">//给电脑厂商的钱</span></span><br><span class="line">                    System.out.println(<span class="string">"你被增强啦"</span>);</span><br><span class="line">                    <span class="comment">//使用factory对象执行此方法，返回值就是真实对象方法的返回值</span></span><br><span class="line">                    obj = method.invoke(factory, money);</span><br><span class="line">                    <span class="comment">//增强返回值</span></span><br><span class="line">                    obj = obj + <span class="string">"_鼠标垫"</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;<span class="comment">//因为这里只有两个方法，所以使用else，也就是指show方法</span></span><br><span class="line">                    obj = method.invoke(factory, args);<span class="comment">//这里执行打印，有无返回值一样</span></span><br><span class="line">                    System.out.println(<span class="string">"小新pro13"</span>);</span><br><span class="line">                    System.out.println(<span class="string">"ThinkPad"</span>);</span><br><span class="line">                    System.out.println(<span class="string">"...."</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> obj;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 客户端代码使用代理对象进行编码</span></span><br><span class="line">        String computer = proxy_CGLib.sale(<span class="number">8000</span>);<span class="comment">//用户付钱</span></span><br><span class="line">        System.out.println(computer);<span class="comment">//用户得到的产品</span></span><br><span class="line">        System.out.println(<span class="string">"---------------------"</span>);</span><br><span class="line">        proxy_CGLib.show();<span class="comment">//展示商品</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ul>
<li>静态代理：<ul>
<li>需要手动创建代理类，而且每一个具体类型都需要单独创建一个代理类；</li>
</ul>
</li>
<li>JDK动态代理：<ul>
<li>1 要求具体类型实现某种接口（可自定义）；</li>
<li>2 使用JDK提供的Proxy类型的newProxyInstance()方法来动态创建代理类；</li>
</ul>
</li>
<li>CGLib动态代理：<ul>
<li>1 要求具体类型不能被final修饰；</li>
<li>2 原理：扩展被代理的类型，隐式得到一个增强后的子类；</li>
</ul>
</li>
</ul>
<h5 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h5><p><a href="https://segmentfault.com/a/1190000021841185">segmentFault-代理模式总结</a></p>
<p><a href="https://juejin.im/post/6844903544965857294">掘金-代理模式</a></p>
<blockquote>
<p>until next time</p>
</blockquote>
]]></content>
      <categories>
        <category>Design Model</category>
        <category>Proxy mode</category>
      </categories>
      <tags>
        <tag>Fancy Stuff</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之单例模式</title>
    <url>/Design-Model/2020/09/07/interview/20200907-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.html</url>
    <content><![CDATA[<h4 id="快速博客（使用双重检查锁来实现多线程下的单例模式）"><a href="#快速博客（使用双重检查锁来实现多线程下的单例模式）" class="headerlink" title="快速博客（使用双重检查锁来实现多线程下的单例模式）"></a>快速博客（使用双重检查锁来实现多线程下的单例模式）</h4><h5 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h5><p>是：一个性质；</p>
<p>作用：描述特定的类只能存在一个实例对象的性质；</p>
<a id="more"></a>

<h5 id="单线程下的单例"><a href="#单线程下的单例" class="headerlink" title="单线程下的单例"></a>单线程下的单例</h5><p>手段：</p>
<ul>
<li>1 类中持有静态私有变量uniqueInstance;</li>
<li>2 把构造方法私有化；</li>
<li>3 提供一个公开的获取单例对象的方法getInstance()；<ul>
<li>在方法中，先判空，再new出来单例对象；</li>
</ul>
</li>
</ul>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(uniqueInstance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="多线程下的单例模式（特征：双重检查锁）"><a href="#多线程下的单例模式（特征：双重检查锁）" class="headerlink" title="多线程下的单例模式（特征：双重检查锁）"></a>多线程下的单例模式（特征：双重检查锁）</h5><p>手段：</p>
<ul>
<li><p>1 为创建单例对象的if()语句块加锁（类对象的锁）；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(Singleton<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(uniqueInstance == <span class="keyword">null</span>)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>2 避免多线程不必要地抢夺锁（如果实例已经创建了，就没有必要再去抢夺锁了）</p>
<p>手段：在抢夺锁之前，判断单例是不是已经存在了；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(uniqueInstance == <span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(Singleton<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(xxx)&#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>3 避免多线程下，创建对象操作所引起的非单例情况；</p>
<p>手段：为实例变量添加volatile修饰符，避免创建对象时发生指令重排；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h6 id="完成代码"><a href="#完成代码" class="headerlink" title="完成代码"></a>完成代码</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == instance) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == instance) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();   </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>ok, until next time 😄</p>
</blockquote>
]]></content>
      <categories>
        <category>Design Model</category>
      </categories>
      <tags>
        <tag>Fancy Stuff</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之简单工厂模式</title>
    <url>/Design-Model/2020/09/07/interview/20200907-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.html</url>
    <content><![CDATA[<p>诚实地讲，我看过设计模式的一本书，但是仍旧觉得它是悬浮在大气层外面的东西。现在对设计模式的基本认识是，它能够：</p>
<ul>
<li>封装变化，从而以最小的代码改动应对需求变化；</li>
</ul>
<a id="more"></a>

<h4 id="常见的设计模式"><a href="#常见的设计模式" class="headerlink" title="常见的设计模式"></a>常见的设计模式</h4><h5 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h5><ul>
<li><p>作用：解耦<strong>客户端代码</strong>与<strong>具体实例</strong>之间的依赖；</p>
</li>
<li><p>直接依赖导致的问题：</p>
<ul>
<li>场景：A对象如果要调用B对象，最简单的做法就是直接new一个B出来【直接依赖】。</li>
<li>需求改动：系统需要把B类修改成C类（假如C类和B类实现了同一个接口/继承自同一个类）；</li>
<li>手段：程序员只能改动A类代码（客户端代码）。</li>
<li>特征：如果程序中有100个地方new了B对象，那么就要修改100处（😫）。</li>
</ul>
</li>
<li><p>简单工厂模式的用法SOP：</p>
<ul>
<li>1 定义一个工厂类IFactory(工厂类能够创建各种类型的实例);</li>
<li>2 编写客户端代码时，使用工厂类来获取到所需要的实例B；</li>
<li>3 当需求变化为：客户端代码使用实例C时,客户端代码不需要做出任何变化…(really?)</li>
</ul>
</li>
<li><p>示例</p>
<blockquote>
<p>水果接口</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Fruit</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 接口中规定的行为集合</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">grow</span><span class="params">()</span></span>;<span class="comment">// 生长</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">harveset</span><span class="params">()</span></span>; <span class="comment">// 收货</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">plant</span><span class="params">()</span></span>;<span class="comment">// 种植</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>两个子类型：苹果和葡萄</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">implements</span> <span class="title">Fruit</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Apple.grow()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">harveset</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Apple.harveset()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">plant</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Apple.plant()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Grape</span> <span class="keyword">implements</span> <span class="title">Fruit</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Grape.grow()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">harveset</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Grape.harveset()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">plant</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Grape.plant()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>园丁（工厂类） 用于生产各种水果</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Gardener</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Fruit <span class="title">getFruit</span><span class="params">(String fruit)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 根据传入的参数，来new出对应类型的实例</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"apple"</span>.equalsIgnoreCase(fruit))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Apple();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"grape"</span>.equalsIgnoreCase(fruit))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Grape();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>客户端代码</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 需要苹果时，传入APPLE参数</span></span><br><span class="line">    Fruit fruit0 = Gardener.getFruit(<span class="string">"APPLE"</span>);</span><br><span class="line">    <span class="comment">// 消费苹果实例	aka 调用apple实例的方法</span></span><br><span class="line">    fruit0.grow();</span><br><span class="line">    <span class="comment">// 需要葡萄时，传入GRAPE参数</span></span><br><span class="line">    Fruit fruit1 = Gardener.getFruit(<span class="string">"GRAPE"</span>);</span><br><span class="line">    fruit1.harveset();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>需求变动时，客户端代码还是需要改动呀？传入工厂类的参数需要变化</p>
</blockquote>
</li>
<li><p>简单工厂模式的作用：</p>
<ul>
<li>1 客户端代码不需要直接new具体实例，而是通过工厂类去获取；</li>
<li>2 把创建实例的部分从客户端代码中分离出去了——<strong>创建代码</strong> 与 <strong>消费代码</strong>分离，职责更清晰</li>
</ul>
</li>
</ul>
<h5 id="简单工厂模式的改进"><a href="#简单工厂模式的改进" class="headerlink" title="简单工厂模式的改进"></a>简单工厂模式的改进</h5><ul>
<li><p>issue：每次增加新类型的水果（比如梨子），就必须要改动工厂类（在类代码中添加if/else语句）；</p>
</li>
<li><p>手段：在工厂类代码中，使用反射的方式来创建类型的实例对象；</p>
</li>
<li><p>特征：</p>
<ul>
<li>1 反射方式创建实例时，需要传入<strong>实例所属的类的全限定名</strong>；</li>
<li>2 反射方式创建实例时，能够<strong>使用同一行代码创建出不同的实例</strong>（根据1中传入参数的不同）；</li>
</ul>
</li>
<li><p>示例</p>
<blockquote>
<p>1 在工厂类中使用反射来创建实例对象；</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Gardener</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Fruit <span class="title">getFruit</span><span class="params">(String fruitPath)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 1 获取到类型的Class对象；		手段：Class.forName("类的全限定名")</span></span><br><span class="line">        Class&lt;?&gt; c = Class.forName(fruitPath);</span><br><span class="line">        <span class="comment">// 2 调用Class对象的newInstance()方法，并进行强制类型转换。得到需要的实例对象</span></span><br><span class="line">        <span class="keyword">return</span> (Fruit)c.newInstance();       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>2 客户端代码在调用时，传入需要类型的全限定名；</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 需要获取苹果的实例	则传入Apple类的全限定名</span></span><br><span class="line">    Fruit fruit0 = Gardener.getFruit(<span class="string">"com.xrq.simplefactory.Apple"</span>);</span><br><span class="line">    fruit0.grow();</span><br><span class="line">    Fruit fruit1 = Gardener.getFruit(<span class="string">"com.xrq.simplefactory.Grape"</span>);</span><br><span class="line">    fruit1.harveset();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>隐藏问题：如果项目进行了重构，则类的全限定名就会发生变化。由于客户端代码使用类的全限定名进行了硬编码，所以客户端代码就无法再找到类的class文件（进而加载到JVM中生成Class对象）</p>
</li>
</ul>
<h5 id="应对项目重构的方式"><a href="#应对项目重构的方式" class="headerlink" title="应对项目重构的方式"></a>应对项目重构的方式</h5><ul>
<li><p>原则：避免客户端代码中的硬编码；</p>
</li>
<li><p>手段：</p>
<ul>
<li><p>1 创建一个属性文件(Fruit.properties),在其中定义水果 -&gt; 类路径的关系；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Apple=com.xrq.simplefactory.Apple</span><br><span class="line">Grape=com.xrq.simplefactory.Grape</span><br></pre></td></tr></table></figure>
</li>
<li><p>2 在客户端代码中，先加载属性文件。然后解析出参数，传入工厂类方法中</p>
<p>…</p>
</li>
</ul>
</li>
<li><p>作用：如果需求发生变动，不需要修改客户端代码，只需要修改配置文件中特定键对应的值即可；</p>
</li>
</ul>
<h5 id="简单工厂模式在JDK中的应用"><a href="#简单工厂模式在JDK中的应用" class="headerlink" title="简单工厂模式在JDK中的应用"></a>简单工厂模式在JDK中的应用</h5><p>答：Java线程池的Executors类；</p>
<p>作用：把<strong>创建线程池</strong>与<strong>使用线程池</strong>的代码进行分离；</p>
<p>用法：</p>
<ul>
<li>1 获取线程池【这种创建线程池的方式似乎是不推荐使用的】；<ul>
<li>Executors.newSingleThreadExecutor()；</li>
</ul>
</li>
<li>2 使用线程池；<ul>
<li>…</li>
</ul>
</li>
</ul>
<p>特征：</p>
<p>​    开发者可以不用关心线程池是如何去实现的，直接使用Executors方法提供给开发者的ThreadPoolExecutor就可以了</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>简单工厂模式的作用：</p>
<ul>
<li>1 把实例的创建过程从客户端代码中分离/解耦出去；</li>
<li>2 （aka）把<strong>创建实例</strong> 与 <strong>消费实例</strong>进行分离；</li>
</ul>
<h5 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h5><p><a href="https://www.cnblogs.com/xrq730/p/4902597.html">五月的仓颉</a></p>
<blockquote>
<p>until next time, Bless！</p>
</blockquote>
]]></content>
      <categories>
        <category>Design Model</category>
      </categories>
      <tags>
        <tag>Fancy Stuff</tag>
      </tags>
  </entry>
  <entry>
    <title>Java垃圾回收机制</title>
    <url>/JVM/2020/09/07/interview/20200907-Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.html</url>
    <content><![CDATA[<h4 id="JVM之垃圾回收"><a href="#JVM之垃圾回收" class="headerlink" title="JVM之垃圾回收"></a>JVM之垃圾回收</h4><h5 id="为什么要进行垃圾回收？"><a href="#为什么要进行垃圾回收？" class="headerlink" title="为什么要进行垃圾回收？"></a>为什么要进行垃圾回收？</h5><ul>
<li>1 提高内存资源的利用率；</li>
<li>2 防止无用的垃圾挤占内存空间，影响程序的正常运行；</li>
</ul>
<a id="more"></a>

<h5 id="如何判断内存中的一个对象是不是垃圾？"><a href="#如何判断内存中的一个对象是不是垃圾？" class="headerlink" title="如何判断内存中的一个对象是不是垃圾？"></a>如何判断内存中的一个对象是不是垃圾？</h5><h6 id="知识卡"><a href="#知识卡" class="headerlink" title="知识卡"></a>知识卡</h6><ul>
<li>垃圾：不再被使用的资源；</li>
<li>程序中的垃圾：不再被使用的对象；</li>
</ul>
<h6 id="如何判断一个对象已经“不再被使用”（aka-成为垃圾）？"><a href="#如何判断一个对象已经“不再被使用”（aka-成为垃圾）？" class="headerlink" title="如何判断一个对象已经“不再被使用”（aka 成为垃圾）？"></a>如何判断一个对象已经“不再被使用”（aka 成为垃圾）？</h6><p>答：垃圾判定算法；</p>
<ul>
<li>手段1：引用计数法；<ul>
<li>具体方法：<ul>
<li>1 在内存中创建对象后，即为对象配置一个引用计数器；</li>
<li>2 如果对象通过某种方式（比如类A持有类B的实例对象）被引用，则引用计数器的值+1；</li>
<li>3 如果引用关系结束，则引用计数器的值-1（什么叫引用关系结束？😕）；</li>
</ul>
</li>
<li>作用：<ul>
<li>这样通过对象的引用计数器的值，就可以清楚对象是不是已经变成垃圾，从而决定是否回收此对象占用的空间；</li>
</ul>
</li>
<li>特征：<ul>
<li>1 执行效率高，对主程序影响小；</li>
<li>2 如果程序中出现了循环引用（a引用b，而b也引用a），则引用计数法无法处理这种类型的垃圾；</li>
</ul>
</li>
</ul>
</li>
<li>手段2：可达性分析算法；<ul>
<li>具体方法：<ul>
<li>1 使用<em>有向图中的一个顶点</em>来表示一个对象；</li>
<li>2 使用<em>有向图中的一条边</em>来表示“<em>一个对象对另一个对象的引用</em>”；</li>
<li>3 从特定的顶点（GC Root）开始进行搜索指定的对象（待审判的对象defendant），<ul>
<li>如果搜索到了defendant,则它不是垃圾；</li>
<li>如果没能搜索到defendant,则它已经变成了垃圾（不可达对象）；</li>
</ul>
</li>
</ul>
</li>
<li>作用：<ul>
<li>通过指定对象defendant在有向图中是否可以到达，就可以清楚对象是不是已经变成垃圾；</li>
</ul>
</li>
<li>特征：<ul>
<li>1 能够处理“循环引用的垃圾对象”；</li>
<li>2 这是JVM垃圾回收所选择的手段；</li>
<li>3 可以被作为GC Root的对象有：虚拟机栈中所引用的对象…</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="找到哪些对象是垃圾后，怎么回收它们占用的内存？"><a href="#找到哪些对象是垃圾后，怎么回收它们占用的内存？" class="headerlink" title="找到哪些对象是垃圾后，怎么回收它们占用的内存？"></a>找到哪些对象是垃圾后，怎么回收它们占用的内存？</h5><p>答：垃圾回收算法；</p>
<h6 id="知识卡-1"><a href="#知识卡-1" class="headerlink" title="知识卡"></a>知识卡</h6><p>Java中提供了4种垃圾回收的手段：</p>
<ul>
<li>标记-清除算法；<ul>
<li>SOP过程：<ul>
<li>1 遍历内存中所有的对象；</li>
<li>2 标记出哪些对象是垃圾（使用垃圾判定算法）；</li>
<li>3 清理掉所有垃圾对象；</li>
</ul>
</li>
<li>特征：<ul>
<li>1 这种清除方式会导致<em>清除出来的内存空间</em>不连续地分布在内存中，aka，一堆的<strong>内存碎片</strong>；</li>
<li>2 过多的内存碎片会导致内存的使用率降低，因为清理出的空间可能<em>不足够创建一个新的对象</em>；</li>
</ul>
</li>
</ul>
</li>
<li>复制算法；<ul>
<li>SOP过程：<ul>
<li>1 把内存空间划分成两个区域：空闲区域A + 用于存储对象的区域B；</li>
<li>2 当区域B空间用完的时候，则：<ul>
<li>1 把区域B中的非垃圾对象复制一份，拷贝/复制到区域A中；</li>
<li>2 清除区域B中的所有对象（垃圾 + 非垃圾）；</li>
</ul>
</li>
</ul>
</li>
<li>特征：<ul>
<li>1 内存中不会出现内存碎片；</li>
<li>2 整体内存使用率低，因为只有一半的内存被用来存储对象；</li>
<li>3 复制对象的过程比较耗时；</li>
</ul>
</li>
<li>应用：<ul>
<li>回收JVM新生代（<font size=2>注：JVM内存区域的划分需要另一篇博客了</font>）中存活率低的对象；</li>
</ul>
</li>
</ul>
</li>
<li>3 标记 - 整理算法；<ul>
<li>SOP过程：<ul>
<li>1 找到内存中所有的垃圾对象；</li>
<li>2 把1中找到的所有垃圾对象移动到一个连续的空间（dumping area）中；</li>
<li>3 把dumping area中的对象全部清除；</li>
</ul>
</li>
<li>特征：<ul>
<li>1 不会产生内存碎片；</li>
<li>2 不会导致内存空间的浪费；</li>
<li>3 移动垃圾对象是一个耗时的过程；</li>
</ul>
</li>
<li>应用：<ul>
<li>对象存活率比较高的场合；</li>
</ul>
</li>
</ul>
</li>
<li>4 分代收集算法（博采众长，为我所用）<ul>
<li>SOP过程：<ul>
<li>1 把JVM内存分成3个区域：新生代、老年代、永久代；</li>
<li>2 对不同区域中的对象，采用不同的垃圾回收算法：<ul>
<li>新生代（用于存放生命周期短的对象）：使用复制算法【标记-复制到空闲区-整体删除】；</li>
<li>老年代（用于存放生命周期长的对象）：使用标记-整理算法【标记-整理-集中删除】；</li>
</ul>
</li>
</ul>
</li>
<li>特征：<ul>
<li>1 对JVM的内存空间进行了逻辑划分；</li>
<li>2 针对不同区域采用了不同的清除算法；</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="清除垃圾的工作具体是谁来完成的？"><a href="#清除垃圾的工作具体是谁来完成的？" class="headerlink" title="清除垃圾的工作具体是谁来完成的？"></a>清除垃圾的工作具体是谁来完成的？</h5><p>答：垃圾收集器；</p>
<p>知识卡：</p>
<p>​    对于JVM中不同的内存区域，具体执行垃圾清除工作的垃圾收集器也是不一样的；</p>
<p>​    原因：因为不同的<strong>垃圾收集器</strong>实现了不同的<strong>垃圾回收算法</strong>；</p>
<p>具体分类：</p>
<ul>
<li>新生代区域（同一个回收算法的不同实现结果）：<ul>
<li>1 Serial收集器；</li>
<li>2 ParNew收集器；</li>
<li>3 Parallel收集器；</li>
</ul>
</li>
</ul>
<blockquote>
<p>虽然不清楚为什么有这么些个收集器，但是它们都是某一个算法的具体实现结果。只是在实现时新增了独特的特性…</p>
</blockquote>
<ul>
<li>老年代区域：<ul>
<li>1 Serial Old收集器；</li>
<li>2 ParNew Old收集器；</li>
<li>3 CMS收集器；</li>
</ul>
</li>
</ul>
<blockquote>
<p>好歹记住一个收集器吧，Serial收集器。<strong>单线程串行(Serial)执行</strong>垃圾回收，<strong>(1)</strong>不需要切换线程，<strong>(2)</strong>但是回收时会终止程序的执行；</p>
</blockquote>
<blockquote>
<p>alright, until next time.😄</p>
</blockquote>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Garbage Collection</tag>
      </tags>
  </entry>
  <entry>
    <title>岛屿问题</title>
    <url>/Algorithm/2020/09/04/interview/20200904-%E5%B2%9B%E5%B1%BF%E9%97%AE%E9%A2%98.html</url>
    <content><![CDATA[<h5 id="题设与条件"><a href="#题设与条件" class="headerlink" title="题设与条件"></a>题设与条件</h5><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p>
<p>岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。</p>
<p>此外，你可以假设该网格的四条边均被水包围。</p>
<blockquote>
<p>注：这是字节跳动第二次面试时给的题目。当时面试官说求出相互不联通的湖泊的数量</p>
<p>现在想想，要是相互连通的话，不就是同一个湖泊了吗？😔</p>
</blockquote>
<a id="more"></a>

<p><img src="https://s1.ax1x.com/2020/09/04/wkC3Dg.png" alt="题设示例"></p>
<h5 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h5><p>一个岛屿可以沿着上下左右方向不断扩展（直到遇到湖泊），扩展得到的是一个大的岛屿；</p>
<p>这本质上是一个搜索问题，只不过这里是在m×n的网格中搜索；</p>
<p>在网格中搜索，这是一个典型的DFS应用场景；</p>
<h6 id="二叉树的DFS"><a href="#二叉树的DFS" class="headerlink" title="二叉树的DFS"></a>二叉树的DFS</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">	<span class="comment">// 递归结束条件</span></span><br><span class="line">	<span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">// 递归遍历两个相邻的节点：左孩子、右孩子</span></span><br><span class="line">	TreeNode(root.left);</span><br><span class="line">	TreeNode(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二叉树DFS的两个要点：</p>
<ul>
<li>1 访问相邻节点：二叉树的相邻节点就只有左子节点 + 右子节点；由于二叉树本身是一个递归结构，所以遍历过程就只需要递归地调用左右子树即可</li>
<li>2 递归终结条件：<ul>
<li>一般地，二叉树 DFS 的结束条件是 root == null；</li>
<li>作用：<ul>
<li>1  root 指向的子树为空，不需要再往下遍历了；</li>
<li>2 在 root == null 的时候及时返回，让后面的 root.left 和 root.right 不会出现空指针异常；</li>
</ul>
</li>
</ul>
</li>
</ul>
<h6 id="类比出网格的DFS遍历："><a href="#类比出网格的DFS遍历：" class="headerlink" title="类比出网格的DFS遍历："></a>类比出网格的DFS遍历：</h6><ul>
<li>1 访问相邻节点：在网格（二维数组/矩阵）中，当前节点（r, c）的相邻节点为- (r-1, c)、(r+1, c)、(r, c-1)、(r, c+1)；</li>
<li>2 递归结束条件：当前网格已经是数组的边界。aka，DFS 的递归结束条件就是网格的四个边界；</li>
</ul>
<p>网格DFS遍历的模板：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">	<span class="comment">// 递归结束条件：如果坐标(r, c)超出网格，直接返回</span></span><br><span class="line">	<span class="keyword">if</span>(!inArea(grid, r, c))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	dfs(grid, r - <span class="number">1</span>, c);<span class="comment">// 上</span></span><br><span class="line">	dfs(grid, r + <span class="number">1</span>, c);<span class="comment">// 下</span></span><br><span class="line">	dfs(grid, r, c - <span class="number">1</span>);<span class="comment">// 左</span></span><br><span class="line">	dfs(grid, r, c + <span class="number">1</span>);<span class="comment">// 右</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">inArea</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 合法的网格范围</span></span><br><span class="line">	<span class="keyword">return</span> r &gt;= <span class="number">0</span> &amp;&amp; r &lt; grid.length &amp;&amp; c &gt;= <span class="number">0</span> &amp;&amp; c &lt; grid[<span class="number">0</span>].length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="避免搜索时，搜索到重复的网格；"><a href="#避免搜索时，搜索到重复的网格；" class="headerlink" title="避免搜索时，搜索到重复的网格；"></a>避免搜索时，搜索到重复的网格；</h6><p>手段：</p>
<ul>
<li>标记搜索过的网格；</li>
<li>然后在搜索前，先判断网格是不是已经搜索过了（如果是，跳过此网格）；</li>
</ul>
<p>具体方法：更新搜索过的网格中的值（不是岛屿的网格不会被搜索到）；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">	<span class="comment">// 递归结束条件：如果坐标(r, c)超出网格，直接返回</span></span><br><span class="line">	<span class="keyword">if</span>(!inArea(grid, r, c))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 如果这个格子不是岛屿，直接返回</span></span><br><span class="line">	<span class="keyword">if</span>(grid[r][c] != <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	grid[r][c] = <span class="number">2</span>;<span class="comment">// 标记已经遍历的格子</span></span><br><span class="line">	</span><br><span class="line">	dfs(grid, r - <span class="number">1</span>, c);<span class="comment">// 上</span></span><br><span class="line">	dfs(grid, r + <span class="number">1</span>, c);<span class="comment">// 下</span></span><br><span class="line">	dfs(grid, r, c - <span class="number">1</span>);<span class="comment">// 左</span></span><br><span class="line">	dfs(grid, r, c + <span class="number">1</span>);<span class="comment">// 右</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">inArea</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> r &gt;= <span class="number">0</span> &amp;&amp; r &lt; grid.length &amp;&amp; c &gt;= <span class="number">0</span> &amp;&amp; c &lt; grid[<span class="number">0</span>].length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法问题一旦有了模板，接下来就只是填写代码的工作了</p>
<h6 id="使用模板解决当前问题"><a href="#使用模板解决当前问题" class="headerlink" title="使用模板解决当前问题"></a>使用模板解决当前问题</h6><ul>
<li>从网格的左上角开始进行 DFS。</li>
<li>走到一个格子，若该格子不是陆地，则跳过该格子继续搜索；</li>
<li>若该格子是陆地，就往它的上下左右四个方向进行搜索；<ul>
<li>直至搜索到边界处或者搜索到已经遍历过的格子，说明一个岛屿成功找出，则把岛屿数量 count + 1。</li>
</ul>
</li>
</ul>
<h5 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                    dfs(grid, i, j);</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 递归结束条件：如果坐标(r, c)超出网格，直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(!inArea(grid, r, c))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 如果这个格子不是岛屿，直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(grid[r][c] != <span class="string">'1'</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        grid[r][c] = <span class="string">'2'</span>;<span class="comment">// 标记已经遍历的格子</span></span><br><span class="line">        </span><br><span class="line">        dfs(grid, r - <span class="number">1</span>, c);<span class="comment">// 上</span></span><br><span class="line">        dfs(grid, r + <span class="number">1</span>, c);<span class="comment">// 下</span></span><br><span class="line">        dfs(grid, r, c - <span class="number">1</span>);<span class="comment">// 左</span></span><br><span class="line">        dfs(grid, r, c + <span class="number">1</span>);<span class="comment">// 右</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">inArea</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">	    <span class="keyword">return</span> r &gt;= <span class="number">0</span> &amp;&amp; r &lt; grid.length &amp;&amp; c &gt;= <span class="number">0</span> &amp;&amp; c &lt; grid[<span class="number">0</span>].length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="代码分解步骤"><a href="#代码分解步骤" class="headerlink" title="代码分解步骤"></a>代码分解步骤</h5><blockquote>
<p>1 从最左上角的网格开始遍历二维数组中的所有网格</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.length; i++)&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">            ...</span><br></pre></td></tr></table></figure>

<blockquote>
<p>2 如果当前网格是一个陆地网格，开始在二维数组中进行DFS搜索</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(grid[i][j] == <span class="string">'1'</span>)&#123;</span><br><span class="line">	dfs(grid, i, j);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>3 搜索结束后，就找到了一个岛屿。对找到的岛屿进行计数</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">...</span><br><span class="line">	count++;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>4 实现二维数组中网格的DFS遍历算法</p>
</blockquote>
<ul>
<li><p>1 递归终结条件</p>
<ul>
<li><p>1 如果坐标(r, c)超出网格，则停止搜索；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(!inArea(grid, r, c))</span><br><span class="line">	<span class="keyword">return</span>; <span class="comment">// 手段：直接返回</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>2 如果遇到非岛屿的网格，则停止搜索；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果这个格子不是岛屿，直接返回</span></span><br><span class="line"><span class="keyword">if</span>(grid[r][c] != <span class="string">'1'</span>)</span><br><span class="line">	<span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>2 本级递归需要做的事情</p>
<ul>
<li><p>1 标记已经被搜索到的格子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">grid[r][c] = <span class="string">'2'</span>;<span class="comment">// 标记已经遍历的格子</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>2 向上下左右四个方向继续执行搜索；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dfs(grid, r - <span class="number">1</span>, c);<span class="comment">// 上</span></span><br><span class="line">dfs(grid, r + <span class="number">1</span>, c);<span class="comment">// 下</span></span><br><span class="line">dfs(grid, r, c - <span class="number">1</span>);<span class="comment">// 左</span></span><br><span class="line">dfs(grid, r, c + <span class="number">1</span>);<span class="comment">// 右</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>3 定义方格所允许的合法边界</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">inArea</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">	    <span class="keyword">return</span> r &gt;= <span class="number">0</span> &amp;&amp; r &lt; grid.length &amp;&amp; c &gt;= <span class="number">0</span> &amp;&amp; c &lt; grid[<span class="number">0</span>].length;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>如果使用非法边界表示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(r &lt; <span class="number">0</span> || r &gt;= grid.length || c &lt; <span class="number">0</span> || c &gt;= grid[<span class="number">0</span>].length || grid[r][c] != <span class="string">'1'</span>)&#123;...&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h5 id="代码重现"><a href="#代码重现" class="headerlink" title="代码重现"></a>代码重现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取到二维数组中所有的岛屿数量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 从最左上角的网格开始遍历，搜索存在的岛屿</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;grid.length; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;grid[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">            <span class="comment">// 如果当前网格是陆地...</span></span><br><span class="line">            <span class="keyword">if</span>(grid[i][j] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                <span class="comment">// 开始进行DFS搜索，以找到完整的当前岛屿</span></span><br><span class="line">                dfs(grid, i, j);</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二维数组中网格的DFS遍历	</span></span><br><span class="line"><span class="comment">// 0 递归方法的作用与返回值	作用：</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1递归终结条件</span></span><br><span class="line">    <span class="comment">// 1-1   当前网格超出合法边界</span></span><br><span class="line">    <span class="keyword">if</span>(r&lt;<span class="number">0</span> || c&lt;<span class="number">0</span> || r &gt;= grid.length || c &gt;=grid[<span class="number">0</span>].length)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1-2 当前网格为湖泊网格</span></span><br><span class="line">    <span class="keyword">if</span>(grid[i][j] != <span class="string">'1'</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2 本级递归需要做的事情</span></span><br><span class="line">    <span class="comment">// 标记已经搜索过的网格</span></span><br><span class="line">    grid[r][c] = <span class="string">'2'</span>; <span class="comment">// 注：这里是字符，而不是数字</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 开始搜索当前网格相邻的网格</span></span><br><span class="line">    dfs(grid, r-<span class="number">1</span>, c);</span><br><span class="line">    dfs(grid, r+<span class="number">1</span>, c);</span><br><span class="line">    dfs(grid, r, c-<span class="number">1</span>);</span><br><span class="line">    dfs(grid, r, c+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="参考：二维数组DFS框架"><a href="#参考：二维数组DFS框架" class="headerlink" title="参考：二维数组DFS框架"></a>参考：<a href="https://blog.csdn.net/weixin_45594025/article/details/106095271?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param">二维数组DFS框架</a></h6><blockquote>
<p> until next time 🐷</p>
</blockquote>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>DFS in 2-dimensional-array</tag>
      </tags>
  </entry>
  <entry>
    <title>java基础之MyBatis</title>
    <url>/MyBatis/2020/09/04/interview/20200904-java%E5%9F%BA%E7%A1%80%E4%B9%8BMyBatis%EF%BC%88%E6%8E%A5%E5%8F%A3%E6%98%A0%E5%B0%84%E5%8E%9F%E7%90%86%EF%BC%89.html</url>
    <content><![CDATA[<h4 id="既然是自己看的，就不用一套一套的。直接攻击要点吧"><a href="#既然是自己看的，就不用一套一套的。直接攻击要点吧" class="headerlink" title="既然是自己看的，就不用一套一套的。直接攻击要点吧"></a>既然是自己看的，就不用一套一套的。直接攻击要点吧</h4><a id="more"></a>

<h6 id="Q1-MyBatis中Dao接口的工作原理（从Dao中的接口方法映射到XML中的SQL语句）"><a href="#Q1-MyBatis中Dao接口的工作原理（从Dao中的接口方法映射到XML中的SQL语句）" class="headerlink" title="#Q1 MyBatis中Dao接口的工作原理（从Dao中的接口方法映射到XML中的SQL语句）"></a>#Q1 MyBatis中Dao接口的工作原理（从<em>Dao中的接口方法</em>映射到<em>XML中的SQL语句</em>）</h6><blockquote>
<p>前置知识卡：</p>
<p>1 Dao层接口是一个Mapper类型的接口(程序员不会为此接口编写实现类)；</p>
<p>2 接口方法与XML映射文件的对应规则；</p>
<ul>
<li>接口的全限定名，就是XML映射文件的namespace属性绑定的值；</li>
<li>接口的方法名，就是XML映射文件中Statement的id属性所绑定的值；</li>
<li>接口方法的参数，就是SQL语句中传入的变量；</li>
</ul>
<p>3 在MyBatis中，XML映射文件的每一个语句（<insert>、<select>等）都会被解析成为一个Statement对象；</p>
</blockquote>
<p>答：当程序员在代码中调用接口中的方法时，</p>
<ul>
<li>1 使用<strong>接口全限定名 + 方法名</strong>的字符串作为key来定位到XML映射文件中唯一的MapperStatement对象；</li>
<li>2 执行MapperStatement对象所封装的SQL语句；</li>
<li>3 返回SQL语句的执行结果。</li>
</ul>
<p>举例：</p>
<p>​    使用<code>cn.mybatis.mappers.StudentDao.findStudentById</code>作为key，可以唯一地找到：</p>
<ul>
<li><code>namespace</code>为 <code>com.mybatis.mappers.StudentDao</code>下面</li>
<li><code>id</code>为 <code>findStudentById</code>的 MapperStatement。</li>
</ul>
<h6 id="Q2-Dao中方法的参数不同时，可以进行方法重载吗？"><a href="#Q2-Dao中方法的参数不同时，可以进行方法重载吗？" class="headerlink" title="#Q2:Dao中方法的参数不同时，可以进行方法重载吗？"></a>#Q2:Dao中方法的参数不同时，可以进行方法重载吗？</h6><p>答：Mapper接口里的方法，是不能重载的，因为是使用 <strong>全限名+方法名</strong> 的保存和寻找策略</p>
<p>Mapper接口的工作原理：JDK动态代理；</p>
<p>工作流程：</p>
<ul>
<li>1 Mybatis运行时会使用<strong>JDK动态代理</strong>为Mapper接口生成<strong>代理对象proxy</strong>；</li>
<li>2 代理对象会拦截<strong>接口方法</strong>，转而执行<strong>MapperStatement所代表的sql</strong>；</li>
<li>3 最后将<strong>sql执行结果</strong>返回；</li>
</ul>
]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>Java stuff</tag>
      </tags>
  </entry>
  <entry>
    <title>java基础之Redis</title>
    <url>/Redis/2020/09/03/interview/20200903-java%E5%9F%BA%E7%A1%80%E4%B9%8BRedis.html</url>
    <content><![CDATA[<h4 id="Java应用之Redis（快速记忆）"><a href="#Java应用之Redis（快速记忆）" class="headerlink" title="Java应用之Redis（快速记忆）"></a>Java应用之Redis（快速记忆）</h4><h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><ul>
<li>是：数据库；</li>
<li>作用：存储数据；</li>
</ul>
<a id="more"></a>

<ul>
<li>特征：<ul>
<li>1 数据存储在内存中（所以读写速度很快）；</li>
<li>2 支持事务；</li>
<li>3 支持持久化；</li>
<li>4 支持LUA脚本（能够方便地定制与扩展功能）；</li>
<li>5 支持多种集群方案（所以可以在分布式环境下使用）；</li>
</ul>
</li>
<li>应用：<ul>
<li>1 缓存；</li>
<li>2 分布式锁；</li>
</ul>
</li>
</ul>
<h5 id="为什么要用缓存？"><a href="#为什么要用缓存？" class="headerlink" title="为什么要用缓存？"></a>为什么要用缓存？</h5><ul>
<li>1 能够更快地对查询进行响应；</li>
<li>2 由于缓存是存在内存中地，因此可以支持更高的并发量；</li>
</ul>
<h5 id="Redis比起Map-guava有什么不一样？"><a href="#Redis比起Map-guava有什么不一样？" class="headerlink" title="Redis比起Map/guava有什么不一样？"></a>Redis比起Map/guava有什么不一样？</h5><ul>
<li>map/guava：<ul>
<li>是：本地缓存；</li>
<li>作用：在本地机器上为数据在内存中创建缓存；</li>
<li>特征：<ul>
<li>1 轻量快速；</li>
<li>2 生命周期随着JVM的销毁而结束（aka 无法持久化）；</li>
<li>3 多态机器之间的缓存数据没有办法保持一致（aka 多实例时，缓存不一致）；</li>
</ul>
</li>
</ul>
</li>
<li>Redis/memcached：<ul>
<li>是：分布式缓存；</li>
<li>作用：为多台机器提供统一的缓存数据；</li>
<li>特征：<ul>
<li>1 当有多台机器/服务器/电脑时，多台机器能够共用一份缓存数据（aka 多实例时，缓存具有一致性）；</li>
<li>2 为了缓存能够稳定地服务于多台机器，需要做很多其他的准备；</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="Redis-VS-Memcached"><a href="#Redis-VS-Memcached" class="headerlink" title="Redis VS Memcached"></a>Redis VS Memcached</h5><ul>
<li>支持的数据类型：<ul>
<li>Redis支持更多的数据类型（String, list, hash, set等），Memcached只支持简单的数据类型；</li>
</ul>
</li>
<li>数据持久化：<ul>
<li>Redis支持数据持久化（aka 把缓存数据保存到磁盘中，以备后用），Memcached不支持持久化；</li>
</ul>
</li>
<li>对集群的支持：<ul>
<li>Redis天生支持集群(aka 实现服务器集群非常简单)，但Memcached并不是原生支持集群的；</li>
</ul>
</li>
<li>运行原理：<ul>
<li>Redis是单线程 + 多路IO复用； Memcached是多线程 + 非阻塞IO复用【😵】</li>
</ul>
</li>
</ul>
<p>综上，现在Redis的使用率斩杀Memcached（太难读了）</p>
<h5 id="Redis常见的数据结构-amp-数据结构关联的使用场景"><a href="#Redis常见的数据结构-amp-数据结构关联的使用场景" class="headerlink" title="Redis常见的数据结构 &amp; 数据结构关联的使用场景"></a>Redis常见的数据结构 &amp; 数据结构关联的使用场景</h5><ul>
<li><p>String类型</p>
<ul>
<li>常用命令：set,get,decr（值减一）,incr（值加一）,mget（获取多个指定key的值）等  </li>
<li>应用场景：<ul>
<li>key-value中，key就是String类型的；</li>
<li>常规计数：微博数、粉丝数；</li>
</ul>
</li>
</ul>
</li>
<li><p>Hash类型（存储key-value集合）</p>
<ul>
<li><p>作用：用于存储对象；</p>
</li>
<li><p>常用命令：hget（获取对象指定属性的值）,hset（设置对象指定属性的值）,hgetall （查看对象中所有的属性与其绑定的值）等</p>
</li>
<li><p>应用：</p>
<ul>
<li>存储用户信息</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">key=JavaUser293847</span><br><span class="line">value=&#123;</span><br><span class="line">“id”: 1,</span><br><span class="line">“name”: “SnailClimb”,</span><br><span class="line">“age”: 22,</span><br><span class="line">“location”: “Wuhan, Hubei”</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>list类型</p>
<ul>
<li>是：双向链表；</li>
<li>作用：存储一堆的String数据类型；</li>
<li>常用命令：lpush（在链表左端添加元素）,rpush,lpop（移除链表左边的第一个元素）,rpop,lrange （获取链表中指定范围的key-value集合）</li>
<li>特征：<ul>
<li>支持反向查找与遍历；</li>
</ul>
</li>
<li>应用：<ul>
<li>实现分页查询（lrange），aka，从某个元素开始读取指定个数的元素；</li>
</ul>
</li>
</ul>
</li>
<li><p>Set类型</p>
<ul>
<li><p>是：一个集合类型；</p>
</li>
<li><p>作用：存储一堆的String类型数据；</p>
</li>
<li><p>特征：</p>
<ul>
<li>1 可以自动去重；</li>
<li>2 能够方便地实现集合操作（交集、差集、并集）</li>
</ul>
</li>
<li><p>用法：sadd,spop,smembers（返回指定key对应的集合中的所有元素）,sunion,sismember(判断指定key中指定value是否存在集合中，返回 0 或 1) 等  </p>
</li>
<li><p>应用：</p>
<ul>
<li>1 微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合；</li>
<li>2 实现共同关注、共同粉丝、共同喜好等功能 （求交集）；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sinterstore key1 key2 key3 将交集存在key1内</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>SortedSort类型</p>
<ul>
<li>作用：同Sort类型；</li>
<li>特征：集合中的元素能够按score进行有序排列  ；</li>
<li>原理：sorted set增加了一个权重参数score；</li>
<li>用法：zadd,zrange,zrem（从排序的集合中删除一个或多个成员）,zcard（获取一个排序的集合中的成员数量）等  </li>
<li>应用：<ul>
<li>直播系统中的时时排行榜（用户列表、礼物排行榜、弹幕消息等）</li>
</ul>
</li>
</ul>
<blockquote>
<p>this is nuts!</p>
</blockquote>
</li>
</ul>
<h5 id="Redis中设置数据的过期时间"><a href="#Redis中设置数据的过期时间" class="headerlink" title="Redis中设置数据的过期时间"></a>Redis中设置数据的过期时间</h5><ul>
<li>作用：保证缓存数据是最新的；</li>
<li>应用：项目中的 token 或者一些登录信息、短信验证码等</li>
<li>用法：set key 的时候，指定一个 expire time ；</li>
<li>原理（过期之后，Redis如何删除过期数据）<ul>
<li>1 <strong>定期删除</strong><ul>
<li>redis默认是每隔 100ms 就<strong>随机抽取</strong>一些设置了过期时间的key，检查其是否过期，如果过期就删<br>除 ；（注意这里是随机抽取的，因为数据量很大）</li>
</ul>
</li>
<li>2 *<em>惰性删除 *</em><ul>
<li>过期key在定期删除时没有被删除掉（还停留在内存里），只有重新查询该过期的key，它才会被redis给删除 ；</li>
</ul>
</li>
<li>遗留问题：过期的key可能会堆积在内存中，影响缓存的正常工作；</li>
<li>解决方案：Redis内存淘汰机制；</li>
</ul>
</li>
</ul>
<h5 id="Redis内存淘汰机制"><a href="#Redis内存淘汰机制" class="headerlink" title="Redis内存淘汰机制"></a>Redis内存淘汰机制</h5><ul>
<li>作用：保证Redis中存储的数据都是热门数据（经常被查询到的数据）；</li>
<li>数据淘汰策略：<ul>
<li>从设置了过期时间的数据集中删除：<ul>
<li>最近最少使用的数据（LRU）；</li>
<li>即将要过期的数据（TTL）；</li>
<li>随机的数据（random）；</li>
</ul>
</li>
<li>当内存空间不够用时，在键空间中，移除最近最少使用的key；【最常用】</li>
<li>从数据集中任意选择数据进行删除；</li>
<li>不删除旧的缓存数据，如果空间不够用，而又有新的数据要写入缓存，就拒绝新的数据；</li>
</ul>
</li>
</ul>
<h5 id="Redis的持久化原理"><a href="#Redis的持久化原理" class="headerlink" title="Redis的持久化原理"></a>Redis的持久化原理</h5><ul>
<li>持久化：把内存中的数据写入硬盘（相当于永久存储）；</li>
<li>作用：备份数据；</li>
<li>手段：<ul>
<li>1 快照（snapshotting/rdb文件）<ul>
<li>是：一个文件；</li>
<li>作用：存储内存中某一时刻的数据；</li>
<li>特征：<ul>
<li>1 rdb文件可以在多台机器上复制与同步，从而保持备份数据的一致性；</li>
<li>2 这是Redis默认使用的持久化方式；</li>
<li>3 快照的细节可以在redis.conf中进行配置；</li>
</ul>
</li>
<li>原理：在某些时刻自动触发创建快照的操作；</li>
</ul>
</li>
<li>2 AOF持久化<ul>
<li>是：一个文件；</li>
<li>作用：记录数据的变化过程（被执行的写命令）；</li>
<li>特征：<ul>
<li>0 备份数据的实时性更好（所以是主要使用的持久化方案）；</li>
<li>1 默认情况下，AOF持久化没有开启；</li>
<li>2 开启AOF后，每次执行写入操作时，写入命令就会被追加到AOF文件中；</li>
<li>3 AOF存储的细节可以在redis.conf文件中进行配置；</li>
</ul>
</li>
<li>原理：写操作发生后，以一定的规律向AOF文件中追加写操作命令；</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h5><blockquote>
<p>事务；</p>
<p>是：一个规范；</p>
<p>作用：提供了一种将多个命令请求打包，然后一次性、按顺序地执行多个命令的机制  ；</p>
<p>特征：</p>
<p>​        1 执行事务期间，服务器不会中断事务而去执行其他客户端的请求；</p>
<p>​        2 如果事务执行到一半时发生意外情况，服务器会把之前执行的事务部分撤销操作；</p>
</blockquote>
<ul>
<li>是：Redis对事务的具体实现；</li>
<li>手段：使用MULTI、EXEC、WATCH 等命令来实现事务(transaction)功能 ；</li>
<li>特征：<ul>
<li>1 Redis事务总能保证事务的ACI(Atomicity  、Consistency  、Isolation)；</li>
<li>2 在设置了持久化模式之后，Redis事务也能保证事务的D（Durability ）；</li>
</ul>
</li>
</ul>
<p>ACID：原子性、连续性、隔离性、持久性；</p>
<h5 id="缓存雪崩-amp-缓存穿透（及解决方案）"><a href="#缓存雪崩-amp-缓存穿透（及解决方案）" class="headerlink" title="缓存雪崩&amp;缓存穿透（及解决方案）"></a>缓存雪崩&amp;缓存穿透（及解决方案）</h5><p>缓存雪崩</p>
<ul>
<li>是：一个现象；</li>
<li>作用：描述缓存在短时间内大量失效（缓存的数据不再是热点数据了）</li>
<li>特征：请求都会落在数据库服务器上，数据库压力很大</li>
<li>解决手段：<ul>
<li>事前：建立Redis集群，保证缓存机器集群的可用性；</li>
<li>事中：利用各种手段防止MySQL崩掉（ehcache缓存 + hystrix限流/降级等）；</li>
<li>事后：使用Redis持久化备份的数据尽快恢复缓存；</li>
</ul>
</li>
</ul>
<p>缓存穿透</p>
<ul>
<li>是：一个现象；</li>
<li>作用：描述客户端故意请求缓存中不存在的数据，使得请求总是落在数据库服务器上；</li>
<li>解决手段：<ul>
<li>1 使用布隆过滤器；<ul>
<li>原理：如果请求的数据在数据库中一定不存在，布隆过滤器就会拦截掉这个请求；</li>
</ul>
</li>
<li>2 把查询为空的结构也添加到缓存中；<ul>
<li>原理：这样即便客户端请求不存在的数据，缓存也能发挥作用；</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="Redis并发竞争Key的问题"><a href="#Redis并发竞争Key的问题" class="headerlink" title="Redis并发竞争Key的问题"></a>Redis并发竞争Key的问题</h5><ul>
<li>是：一种现象；</li>
<li>作用：描述多个系统同时操作一个key，而执行的顺序不是预期执行的顺序。最终导致了非预期的结果</li>
<li>解决手段：分布式锁（首选Zookeeper）；<ul>
<li>是：一种技术；</li>
<li>作用：解决分布式（多台机器上都有相同的实例）场景下，多台机器同时操作相同资源的并发问题；</li>
<li>特征：有点子像多线程并发操作资源的情况；</li>
<li>手段：使用zookeeper的临时有序节点；</li>
<li>原理：<ul>
<li>1 当客户端对某个方法加锁时，在zookeeper上的<strong>与该方法对应的指定节点的目录</strong>下，生成一个唯一的瞬时有序节点  ;</li>
<li>2 当机器要获取资源的锁时，只需要判断有序节点中序号最小的一个  ；【😵】</li>
<li>3 当机器要释放锁时，只需将这个瞬时节点删除即可 ；</li>
</ul>
</li>
<li>用法：<ul>
<li>完成业务流程后，删除对应的子节点来释放锁 ；</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="数据写入数据库-amp-缓存时，保证双写一致"><a href="#数据写入数据库-amp-缓存时，保证双写一致" class="headerlink" title="数据写入数据库&amp;缓存时，保证双写一致"></a>数据写入数据库&amp;缓存时，保证双写一致</h5><p>双写一致：</p>
<ul>
<li>是：一个要求；</li>
<li>作用：要求缓存中的数据与数据库中的数据保持一致；</li>
<li>特征：多数情况下，系统并不必须要保持双写一致（串行化会导致系统处理请求的能力大大降低）；</li>
<li>手段：把读请求&amp;写请求串行化放到一个队列中；</li>
<li>原理：请求串行化后，Redis就会同步数据库中新写入的数据。从而保证从缓存中读取的数据总是正确的；</li>
</ul>
<p>​    </p>
<h5 id="参考：JavaGuide《面试突击》"><a href="#参考：JavaGuide《面试突击》" class="headerlink" title="参考：JavaGuide《面试突击》"></a>参考：JavaGuide《面试突击》</h5><blockquote>
<p>until next time 😳</p>
</blockquote>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Java stuff</tag>
      </tags>
  </entry>
  <entry>
    <title>java基础之HashMap</title>
    <url>/JDK-source-type/2020/09/01/interview/20200901-java%E5%9F%BA%E7%A1%80%E4%B9%8BHashMap.html</url>
    <content><![CDATA[<h4 id="java集合类型之HashMap"><a href="#java集合类型之HashMap" class="headerlink" title="java集合类型之HashMap"></a>java集合类型之HashMap</h4><p>对于JDK源码来说，它有点像吉他谱中的F和弦。第一道坎，跨过去就会是另一番风景</p>
<a id="more"></a>

<blockquote>
<p>bear in mind</p>
<p>1 HashMap是用来存储键值对的容器；</p>
<p>2 HashMap能够实现O(1)时间复杂度的查找（根据key来查找对应的键值对）；</p>
<p>3 HashMap底层的数据结构为：数组 + 链表 + 红黑树；</p>
</blockquote>
<h5 id="前置说明：为了表述的统一-amp-简化表达"><a href="#前置说明：为了表述的统一-amp-简化表达" class="headerlink" title="前置说明：为了表述的统一&amp;简化表达"></a>前置说明：为了表述的统一&amp;简化表达</h5><ul>
<li>把底层结构中的数组叫做散列数组/桶数组；</li>
</ul>
<blockquote>
<p>鉴于只有文字说明时，写得没劲，看得也没劲。所以这次会配合源码+图解</p>
</blockquote>
<h5 id="HashMap的特性"><a href="#HashMap的特性" class="headerlink" title="HashMap的特性"></a>HashMap的特性</h5><p><em>注：刚开始学这些容器类型时，发现它们有着各种不同的特性，多到无从记忆。其实所有这些特性都是容器类型实现的具体结果，所以要记住这些个特性，看一看源码就好了</em></p>
<ul>
<li>1 默认的初始容量为16；</li>
<li>2 默认的装载因子为0.75;</li>
<li>3 只有在链表中的节点数量 &gt; =8 并且 HashMap中的键值对数量 &gt; 64时，才会对链表进行树化；</li>
<li>4 当树化与扩容冲突时，应该优先扩容。这样能够从更高层面解决问题；</li>
</ul>
<h5 id="原理（存储键值对的过程）"><a href="#原理（存储键值对的过程）" class="headerlink" title="原理（存储键值对的过程）"></a>原理（存储键值对的过程）</h5><ul>
<li>1 计算key-value中key的散列值；</li>
<li>2 使用散列值来计算得到key-value应该插入到散列数组的哪个桶中；</li>
<li>3 判断桶是不是空的，如果是，直接插入key-value；</li>
<li>4 如果桶不是空的，说明不同的键值对被映射到了散列数组相同的桶中（aka 发生了散列冲突）。</li>
<li>5 发生散列冲突后，先判断桶中的key-value与预期插入的key-value的key是否相等，如果相等，直接更新桶中的key-value的value值；</li>
<li>6 如果不相等，把新的key-value以链表节点的形式连接到桶中已有的节点上；【Mark：一般面试时，回答到这里就已经足够了】</li>
<li>7 当链表中的节点数量大于8时，把链表转化成红黑树（以提升查询效率）；【具体手段比较复杂】</li>
<li>8 当哈希数组中的key-value数量大于阈值（阈值 = 容量 * 加载因子）时，需要对散列数组进行扩容，并对桶中的链表/红黑树上的key-value进行重新布局；【具体手段比较复杂】</li>
</ul>
<p>HashMap的key-value存储结果图：<a href="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15161231547335.jpg">田小波</a></p>
<p><img src="https://s1.ax1x.com/2020/09/02/wSwlKe.png" alt="HashMap存储节点的效果"></p>
<h5 id="HashMap源码分析"><a href="#HashMap源码分析" class="headerlink" title="HashMap源码分析"></a>HashMap源码分析</h5><h6 id="1-HashMap的特性"><a href="#1-HashMap的特性" class="headerlink" title="1 HashMap的特性"></a>1 HashMap的特性</h6><p><img src="https://s1.ax1x.com/2020/09/02/wSPg9e.png" alt="HashMap特性说明"></p>
<p>这些大段大段的介绍的确很吓人，这时候就需要点子耐心了。其实这只是你想象出来的无法跨越的人行道罢了 </p>
<p>上面的图片引用自<a href="https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&mid=2247484139&idx=1&sn=bb73ac07081edabeaa199d973c3cc2b0&chksm=ebd743eadca0cafc532f298b6ab98b08205e87e37af6a6a2d33f5f2acaae245057fa01bd93f4&scene=21#wechat_redirect">Java3y</a></p>
<p><font size="3">使用有道词典翻译了源码上的注释 &amp; 翻译了JDK提供的HashMap的接口文档。两者内容基本一致，建议参考接口文档（毕竟它就是用源码生成的）</font></p>
<blockquote>
<p>特性总结</p>
</blockquote>
<ul>
<li>允许空键与空值；</li>
<li>存储时，不保证key-value的顺序就是插入时的顺序；</li>
<li>装载因子对迭代key-value对的性能有很大影响；</li>
<li>当key-value对的数量 &gt; 散列数组的容量 * 装载因子时，会创建新的散列数组（大小是旧数组的两倍），并对key-value进行重哈希；</li>
<li>默认装载因子0.75是在时间与空间上妥协的结果，装载因子越大，越节省空间，但是访问key-value的时间就会随之增长。反之亦然</li>
<li>HashMap没有实现多线程同步的逻辑，所以多线程操作是不安全的；</li>
<li>遍历HashMap的迭代器时，如果有其他线程在修改哈希表，就会马上抛出并发修改的异常；</li>
</ul>
<blockquote>
<p>HashMap的类继承结构</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/09/02/wSw93T.png" alt="HashMap类继承结构"></p>
<p><font size=3>为什么要看它的类继承结构呢？</font></p>
<p>这样能够直观地知道HashMap预期会有哪些功能，然后可以在看源码的时候有的放矢地查看源码是如何实现这些功能的。</p>
<h6 id="2-HashMap的实例变量（包含底层数据结构）"><a href="#2-HashMap的实例变量（包含底层数据结构）" class="headerlink" title="2 HashMap的实例变量（包含底层数据结构）"></a>2 HashMap的实例变量（包含底层数据结构）</h6><p><font size=2>这里不想再借别人的图，但是却没有好用的截长图与截图标注工具。饶了些狗尾巴圈子😳</font></p>
<p>注：接口文档中没有关于成员属性的说明，因为接口文档是教会用户如何使用的，并不想把底层实现呈现出来；</p>
<ul>
<li><p>成员常量；</p>
<p>​    <img src="https://s1.ax1x.com/2020/09/02/wSDOzV.png" alt="成员常量"></p>
<ul>
<li>作用：各种场景下对应的默认值（通过常量的名称基本能了解其使用场合）</li>
</ul>
</li>
<li><p>成员变量；</p>
<p>​    <img src="https://s1.ax1x.com/2020/09/02/wSryOU.png" alt="成员变量"></p>
<ul>
<li>作用：作为底层的数据结构，以支持各种API的操作；<ul>
<li>table    作用：作为散列数组；</li>
<li>loadFacotr   作用：哈希表的加载因子（用于计算扩容时的门槛）；</li>
<li></li>
</ul>
</li>
</ul>
</li>
<li><p>成员内部类；</p>
<p><img src="https://s1.ax1x.com/2020/09/02/wSsanO.png" alt="HashMap成员内部类"></p>
<ul>
<li><p>作用：作为底层数据结构，支持各种API操作；</p>
<blockquote>
<p> 核心内部类说明；</p>
</blockquote>
<ul>
<li>Node    作用：封装key-value映射关系，表示哈希表中的一个节点；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key; <span class="comment">// 键值对中的key</span></span><br><span class="line">        V value; <span class="comment">// 键值对中的value</span></span><br><span class="line">        Node&lt;K,V&gt; next; <span class="comment">// 链表结构中下一个节点的指针</span></span><br><span class="line">    	...</span><br></pre></td></tr></table></figure>

<ul>
<li>TreeNode 作用：表示红黑树中的一个节点；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links	指向父节点的指针</span></span><br><span class="line">        TreeNode&lt;K,V&gt; left; <span class="comment">// 指向左子节点的指针</span></span><br><span class="line">        TreeNode&lt;K,V&gt; right; <span class="comment">// 指向右子节点的指针</span></span><br><span class="line">        TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion（删除后需要取消链接） </span></span><br><span class="line">        <span class="keyword">boolean</span> red; <span class="comment">// 是否为红色节点</span></span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h6 id="3-HashMap的构造方法"><a href="#3-HashMap的构造方法" class="headerlink" title="3 HashMap的构造方法"></a>3 HashMap的构造方法</h6><p>作用：</p>
<ul>
<li>规定程序员使用HashMap的语法；</li>
<li>创建出HashMap的实例对象；</li>
<li>强制程序员为某些成员属性绑定值；</li>
</ul>
<p>分析底层原理时，构造方法似乎并不重要。不管用户决定用哪种构造方法，核心API的逻辑不会受到任何影响。所以这里只分析最常用的构造方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里只是为loadFactor属性进行了初始化（绑定了值）；而哈希表都还没有创建与初始化——因为这个操作是在第一次插入key-value的时候实现的。</p>
<h6 id="4-常用常量分析"><a href="#4-常用常量分析" class="headerlink" title="4 常用常量分析"></a>4 常用常量分析</h6><ul>
<li>初始容量initialCapacity;<ul>
<li>作用：指定散列数组的初始容量大小；</li>
</ul>
</li>
<li>负载因子loadFactor；<ul>
<li>作用：计算散列（桶）数组的扩容门槛；</li>
</ul>
</li>
<li>扩容门槛threshold；<ul>
<li>作用：声明当前HashMap所能存储key-value对的最大数量；如果继续插入key-value，会引发散列数组的扩容操作；</li>
</ul>
</li>
</ul>
<p>三者之间的关系：threshold = initialCapacity * loadFactor;</p>
<h5 id="核心APIs"><a href="#核心APIs" class="headerlink" title="核心APIs"></a>核心APIs</h5><h6 id="从键值对集合中查询；（get-方法）"><a href="#从键值对集合中查询；（get-方法）" class="headerlink" title="从键值对集合中查询；（get()方法）"></a>从键值对集合中查询；（get()方法）</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">    	<span class="comment">// 计算key的hash值，并作为参数传入getNode()方法中</span></span><br><span class="line">        <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 准备需要的局部变量：tab-散列数组； first、e-节点、n-散列数组的长度、k-键的类型；</span></span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    	<span class="comment">// 如果散列数组不为空 &amp;&amp; key映射到的桶不为空...</span></span><br><span class="line">    	<span class="comment">// 任务：求出key所映射到的桶；	手段1：hash % n	手段2：(n-1) &amp; hash</span></span><br><span class="line">    	<span class="comment">// 说明：只有在n等于2的乘方时，才会有： hash % n &lt;=&gt; (n-1) &amp; hash</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 判断桶中的第一个节点是不是待查找的键值对</span></span><br><span class="line">            <span class="comment">// 手段：1 判断节点的hash值与key的hash值是否相等； 2 判断节点的key与key是否相等</span></span><br><span class="line">            <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">                ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="keyword">return</span> first;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 否则，从桶中继续查找</span></span><br><span class="line">            <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 判断桶中的节点是不是树节点...</span></span><br><span class="line">                <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">                <span class="comment">// 否则，桶中一定是一个链表</span></span><br><span class="line">                <span class="comment">// 遍历链表进行查找</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">return</span> e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">// 都没能找到，则返回null</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>流程</p>
</blockquote>
<ul>
<li>1 找到key所映射到的散列数组中桶的位置（桶就是散列数组中的一个位置）；</li>
<li>2 从桶中的链表/红黑树来查找是否存在键为key的节点；</li>
</ul>
<blockquote>
<p>关键操作</p>
</blockquote>
<ul>
<li>1 计算key会映射到的桶的位置；<ul>
<li>手段：(n - 1) &amp; hash；    </li>
<li>特征：1 高效的位运算； 2 n的值必须是2的乘方；3 等价于(hash % n);</li>
</ul>
</li>
<li>2 计算key的哈希值；<ul>
<li>手段: 内置的hash(Object key)方法；</li>
<li>SOP：1 调用key的hashCode()方法，初次获取到hash值；2 把h无符号右移16位得到一个新的二进制数字； 3 把1与2的值进行^（异或运算）；</li>
<li>原因（HashMap为什么这样计算哈希值）：<ul>
<li>移位操作-1：通过这种方式，让高位数据与低位数据进行异或，以此加大低位信息的随机性，变相的让高位数据参与到计算中；</li>
<li>移位操作-2：在 Java 中，hashCode 方法产生的 hash 是 int 类型，32 位宽。前16位为高位，后16位为低位，所以要右移16位;</li>
<li>异或操作：通过移位和异或运算，可以让 hash 变得更复杂，进而影响 hash 的分布性；</li>
</ul>
</li>
</ul>
</li>
</ul>
<h6 id="遍历HashMap中所有的key-value-（keySet-方法）"><a href="#遍历HashMap中所有的key-value-（keySet-方法）" class="headerlink" title="遍历HashMap中所有的key-value （keySet()方法）"></a>遍历HashMap中所有的key-value （keySet()方法）</h6><p><font size=3>注:遍历的操作分为两步——1 获取到键集合 / 键值对Entry集合； 2 使用迭代器模式来遍历键值对；</font></p>
<blockquote>
<p>用法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用法1-获取到所有的键组成的集合	然后使用迭代器模式进行遍历</span></span><br><span class="line"><span class="keyword">for</span>(Object key : map.keySet()) &#123;</span><br><span class="line">    <span class="comment">// 通过map.get(key)方法获取到关联的value</span></span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用法2-获取到所有的键值对组成的集合	然后使用迭代器模式进行遍历</span></span><br><span class="line"><span class="keyword">for</span>(HashMap.Entry entry : map.entrySet()) &#123;</span><br><span class="line">    <span class="comment">// Entry对象就是封装好的key-value</span></span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>迭代器模式是一种遍历集合的统一方式，aka，程序员可以使用确定的API来编写迭代的代码；</p>
<blockquote>
<p>流程（遍历键集合）</p>
</blockquote>
<ul>
<li>1 首先要获取键集合<code>KeySet</code>对象；</li>
<li>2 再通过 KeySet 的迭代器<code>KeyIterator</code>（继承自HashIterator）进行遍历；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 键集合的类型</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 迭代器模式	要求：返回一个迭代器对象；    </span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;K&gt; <span class="title">iterator</span><span class="params">()</span>     </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> KeyIterator(); &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 键-迭代器类型</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextNode().key; &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父类迭代器类型</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HashIterator</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; next;        <span class="comment">// next entry to return</span></span><br><span class="line">        Node&lt;K,V&gt; current;     <span class="comment">// current entry</span></span><br><span class="line">        <span class="keyword">int</span> expectedModCount;  <span class="comment">// for fast-fail</span></span><br><span class="line">        <span class="keyword">int</span> index;             <span class="comment">// current slot</span></span><br><span class="line"></span><br><span class="line">        HashIterator() &#123;</span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">            Node&lt;K,V&gt;[] t = table;</span><br><span class="line">            current = next = <span class="keyword">null</span>;</span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123; <span class="comment">// advance to first entry</span></span><br><span class="line">                <span class="comment">// 寻找第一个包含链表节点引用的桶</span></span><br><span class="line">                <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    	...</span><br><span class="line">        <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">nextNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">if</span> ((next = (current = e).next) == <span class="keyword">null</span> &amp;&amp; (t = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 寻找下一个包含链表节点引用的桶</span></span><br><span class="line">                <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p> 关键操作(在HashIterator中完成)</p>
</blockquote>
<ul>
<li>1 从桶数组中找到包含链表节点引用的桶；</li>
<li>2 对这个桶指向的链表进行遍历；</li>
<li>3 遍历完成后，再继续寻找下一个包含链表节点引用的桶.so on and so forth, till  can not find such a bucket;</li>
</ul>
<blockquote>
<p>操作过程图示</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/09/02/wp8nzj.png" alt="遍历键集合的过程"></p>
<blockquote>
<p>验证</p>
</blockquote>
<p>原理：如果在创建HashMap时指定容器的大小为16，并在插入key-value时根据16来选择合适的key。就能把key-value插入到预期的桶中，并最终预测遍历操作的打印顺序</p>
<p>举例：key=43 43%16=11.所以该key-value会存储在编号为11的桶中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span> <span class="comment">// 因为IDEA的集成工作做得太棒了，有时候你真弄不清楚到底是谁完成了哪些工作...😳</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTraversal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap(<span class="number">16</span>);</span><br><span class="line">        <span class="comment">// 可以预见这些key-value会被映射到什么地方吗？</span></span><br><span class="line">        map.put(<span class="number">7</span>, <span class="string">""</span>);</span><br><span class="line">        map.put(<span class="number">11</span>, <span class="string">""</span>);</span><br><span class="line">        map.put(<span class="number">43</span>, <span class="string">""</span>);</span><br><span class="line">        map.put(<span class="number">59</span>, <span class="string">""</span>);</span><br><span class="line">        map.put(<span class="number">19</span>, <span class="string">""</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="string">""</span>);</span><br><span class="line">        map.put(<span class="number">35</span>, <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"遍历结果："</span>);</span><br><span class="line">        <span class="keyword">for</span> (Integer key : map.keySet()) &#123;</span><br><span class="line">            System.out.print(key + <span class="string">" -&gt; "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// 预期输出结果：19 -&gt; 3 -&gt; 35 -&gt; 7 -&gt; 11 -&gt; 43 -&gt; 59 -&gt; </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="向容器中插入新的key-value（input-方法）"><a href="#向容器中插入新的key-value（input-方法）" class="headerlink" title="向容器中插入新的key-value（input()方法）"></a>向容器中插入新的key-value（input()方法）</h6><blockquote>
<p>流程</p>
</blockquote>
<ul>
<li>找到键值对预期插入的桶编号；</li>
<li>判断桶是否为空，为空则直接插入key-value;</li>
<li>如果不为空，判断桶中的节点是哪一种类型的节点；<ul>
<li>如果是链表节点，则执行“向链表中插入新节点”的操作；</li>
<li>如果是树节点，则执行“向红黑树中插入新节点”的操作；</li>
</ul>
</li>
<li>插入操作结束后，需要考虑两个问题——扩容、树化；</li>
</ul>
<blockquote>
<p>核心操作（源码)</p>
</blockquote>
<p><font size=3>源码中有很多保证健壮性的代码，但它们不是核心代码，可以跳过</font></p>
<p><img src="https://s1.ax1x.com/2020/09/02/wpwKl8.jpg" alt="put添加key-value的过程"></p>
<p>这里比较困惑的是找到key相同的节点后，源码把找到的节点存储到了变量e中；</p>
<p>其实只需要明确一点，如果找到了key相同的节点，接下来肯定需要执行覆盖操作，具体的手段就要看源码的具体实现了（这里是使用变量e记录了已经存在的key-value，然后用新的value进行更新）。</p>
<p><strong>注：覆盖旧值后，put()方法会把旧的value值返回给调用者</strong>👇</p>
<p><img src="https://s1.ax1x.com/2020/09/03/wC3rxH.png" alt="覆盖旧值后，会把旧的value返回"></p>
<h6 id="对散列表进行扩容操作（resize-）"><a href="#对散列表进行扩容操作（resize-）" class="headerlink" title="对散列表进行扩容操作（resize()）"></a>对散列表进行扩容操作（resize()）</h6><blockquote>
<p>预备知识</p>
</blockquote>
<ul>
<li>在 HashMap 中，桶数组的长度均是2的幂，阈值大小为桶数组长度与负载因子的乘积。</li>
<li>当 HashMap 中的键值对数量超过阈值时，就会进行扩容操作。</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/02/wpBtMT.jpg" alt="扩容方法"></p>
<blockquote>
<p>原理</p>
</blockquote>
<ul>
<li>按当前桶数组长度的2倍进行扩容，阈值也变为原来的2倍；</li>
<li>扩容之后，要重新计算键值对的位置，并把它们移动到合适的位置上去；</li>
</ul>
<blockquote>
<p>源码中的核心操作</p>
</blockquote>
<ul>
<li>1 计算新桶数组的容量 newCap 和新阈值 newThr</li>
<li>2 根据计算出的 newCap 创建新的桶数组，桶数组 table 也是在这里进行初始化的</li>
<li>3 将键值对节点重新映射到新的桶数组里。<ul>
<li>如果节点是 TreeNode 类型，则需要拆分红黑树。</li>
<li>如果是普通节点，则节点按原顺序进行分组。</li>
</ul>
</li>
</ul>
<blockquote>
<p>核心操作对应的代码- newCap 和 newThr 计算过程(分类讨论)</p>
</blockquote>
<p>​    this is way too much, Can not bear this right now.</p>
<blockquote>
<p>需要记忆的结论</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一个条件分支</span></span><br><span class="line"><span class="keyword">if</span> ( oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 嵌套条件分支</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;...&#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY) &#123;...&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) &#123;...&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二个条件分支</span></span><br><span class="line"><span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;...&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><p>#Q:initialCapacity 参数没有被保存下来，那么它怎么参与桶数组的初始化过程的呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">            newCap = oldThr; <span class="comment">// 把旧的阈值绑定到newCap上</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li>#A: 上述语句等价于<code>newCap = threshold = tableSizeFor(initialCapacity)</code>。aka 我们在初始化时传入的 initialCapacity 参数经过 threshold 中转最终赋值给了 newCap</li>
</ul>
<ul>
<li><p>#Q：嵌套分支的作用是什么？</p>
<ul>
<li>#A：<ul>
<li>1 处理容器容量达到极限的情况； </li>
<li>2 处理容器正常扩容的情况（但用户指定的loadFactor可能会导致移位/扩大两倍时发生溢出归零）</li>
</ul>
</li>
</ul>
</li>
<li><p>#Q：为什么需要第二个分支？</p>
<ul>
<li>#A：<ul>
<li>第一个条件分支未计算 newThr的情况（当旧容量=0，而旧的阈值大于0时，分支中只是用旧阈值更新了newCap） ;</li>
<li>嵌套分支在计算过程中导致 newThr 溢出归零的情况（这时候需要使用loadFactor * newCap的公式重新计算阈值）；</li>
</ul>
</li>
</ul>
</li>
<li><p>链表桶经过重新映射后，两条链表中的节点顺序并未发生变化，还是保持了扩容前的顺序。</p>
</li>
</ul>
<h6 id="桶中节点的重新映射（在resize-方法中实现）"><a href="#桶中节点的重新映射（在resize-方法中实现）" class="headerlink" title="桶中节点的重新映射（在resize()方法中实现）"></a>桶中节点的重新映射（在resize()方法中实现）</h6><div id="anchor1"></div>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">	...</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">            Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">            Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">            Node&lt;K,V&gt; next;</span><br><span class="line">            ...</span><br></pre></td></tr></table></figure>



<p>说明：对于不同的节点类型，重新映射的手段并不一样；</p>
<ul>
<li>对于树形节点，需先拆分红黑树再映射。</li>
<li>对于链表类型节点，则需先对链表进行分组，然后再映射（分组后，组内节点相对位置保持不变）。</li>
</ul>
<blockquote>
<p>对链表中的节点进行分组映射</p>
</blockquote>
<p>JDK1.7的手段：</p>
<ul>
<li>把链表中的节点重新插入到新的桶数组中；</li>
</ul>
<p>JDK1.8的手段:</p>
<ul>
<li>说明：扩容前被映射到同一个桶中的键值对，经过扩容后，可能会被映射到新的桶中；</li>
<li>原理：<ul>
<li>1 映射的过程是使用(n - 1) &amp; hash的方式来计算桶的位置;</li>
<li>2 扩容前，由于n=16，所以二进制表示的前四位是0000。真正参与&amp;运算的实际上只有hash的后四位——这会导致不同的哈希值被映射到同一个桶的位置；</li>
<li>3 扩容2倍后，n &gt; 16，所以参与&amp;运算的二进制数字位更多（多出的高位表示16）。不同的hash值会被映射到不同的桶位置；</li>
</ul>
</li>
<li>算法：<ul>
<li>1 依次遍历链表，并计算节点 <code>hash &amp; oldCap</code> 的值；</li>
<li>2 如果值为0，将 loHead 和 loTail 指向这个节点；<ul>
<li>如果后面还有节点 hash &amp; oldCap 为0的话，则将节点链入 loHead 指向的链表中，并将 loTail 指向该节点；</li>
</ul>
</li>
<li>3 如果值为非0的话，则让 hiHead 和 hiTail 指向该节点；</li>
<li>4 把分组后的两个链表存储到新的桶数组对应的桶中；</li>
</ul>
</li>
</ul>
<p>重新映射前的桶数组</p>
<p><img src="https://s1.ax1x.com/2020/09/03/wCNRds.png" alt="映射前"></p>
<p>重新映射算法得到的分组链表</p>
<p><img src="https://s1.ax1x.com/2020/09/03/wCUKOg.png" alt="分组后的链表"></p>
<p>重新映射后的桶数组</p>
<p><img src="https://s1.ax1x.com/2020/09/03/wCUwm4.png" alt="映射后的桶数组"></p>
<p>评论：相比于JDK1.7的做法，1.8的做法避免了插入操作的hash计算，效率有提高；</p>
<h6 id="链表树化-treeifyBin-方法"><a href="#链表树化-treeifyBin-方法" class="headerlink" title="链表树化(treeifyBin()方法)"></a>链表树化(treeifyBin()方法)</h6><p>the details is overwhelming, so we’ll just jump into the conclusion.</p>
<blockquote>
<p>流程</p>
</blockquote>
<ul>
<li>1 把链表中的普通节点，转化为树形节点(得到一个树形节点组成的链表)；</li>
<li>2 把树形节点组成的链表转换为红黑树（treeify()方法）；</li>
</ul>
<blockquote>
<p> 在扩容过程中，树化要满足两个条件：</p>
</blockquote>
<ul>
<li>链表长度大于等于 TREEIFY_THRESHOLD</li>
<li>桶数组容量大于等于 MIN_TREEIFY_CAPACITY<ul>
<li>原因：<ul>
<li>1 当桶数组容量比较小时，键值对节点 hash 的碰撞率可能会比较高，进而导致链表长度较长；</li>
<li>2 这个时候应该优先扩容，而不是立马树化——高碰撞率是因为桶数组容量较小引起的，这个是主因；</li>
<li>3 容量小时，优先扩容可以避免一些列的不必要的树化过程；</li>
<li>4 同时，桶容量较小时，扩容会比较频繁，而扩容时需要拆分红黑树并重新映射——所以在桶容量比较小的情况下，将长链表转成红黑树是一件吃力不讨好的事；</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>treeifyBin 方法-把链表转化为TreeNode类型节点组成的链表</p>
</blockquote>
<ul>
<li>TreeNode类型间接继承自Node类型，所以包含next指针/引用。aka 通过TreeNode就能保存原始链表中的节点顺序；</li>
</ul>
<blockquote>
<p>树化带来的问题与解决方案</p>
</blockquote>
<ul>
<li>问题：树化过程中需要比较键对象的大小，但是HashMap并没有强制要求键对象一定要实现Comparable接口。SO,如果键并没有实现Comparable接口，树化要怎么进行呢？</li>
<li>手段：<ul>
<li>1 比较键与键之间 hash 的大小，如果 hash 相同，继续往下比较</li>
<li>2 检测键类是否实现了 Comparable 接口，如果实现调用 compareTo 方法进行比较</li>
<li>3 如果仍未比较出大小，就需要进行仲裁了，仲裁方法为 tieBreakOrder（没看过具体实现）</li>
</ul>
</li>
</ul>
<p><font size=2>tieBreak(赛点)</font></p>
<blockquote>
<p>树化前后对比</p>
</blockquote>
<ul>
<li><p>树化前</p>
<p><img src="https://s1.ax1x.com/2020/09/02/wpLK3t.png" alt="桶中的链表结构"></p>
</li>
<li><p>树化后</p>
<p><img src="https://s1.ax1x.com/2020/09/02/wpOua4.png" alt="桶中的红黑树结构"></p>
<p>橙色的箭头表示 TreeNode 的 next 引用</p>
</li>
<li><p>特征：</p>
<ul>
<li>原链表的顺序仍旧保持（红黑树的根节点会被移动到链表的第一位），SO,可以按遍历链表的方式去遍历上面的红黑树;</li>
<li>这种结构非常有利于红黑树的切分 &amp; 红黑树转换为链表的操作</li>
</ul>
</li>
</ul>
<h6 id="红黑树拆分（split-方法）"><a href="#红黑树拆分（split-方法）" class="headerlink" title="红黑树拆分（split()方法）"></a>红黑树拆分（split()方法）</h6><blockquote>
<p>说明：散列数组扩容后，需要为先前存储的键值对重新找到存储位置（重新映射）。链表和红黑树上的节点要怎么重新映射呢？</p>
</blockquote>
<ul>
<li><p>链表：<a href="#anchor1">参考</a></p>
</li>
<li><p>红黑树：</p>
<ul>
<li><p>手段1（效率有点低）：</p>
<ul>
<li>1 先把红黑树转换成链表；</li>
<li>2 然后按照链表的方式对所有的键值对重新映射；</li>
</ul>
</li>
<li><p>手段2：</p>
<ul>
<li><p>原理：在将普通链表转成红黑树时，HashMap 通过两个额外的引用 next 和 prev 保留了原链表的节点顺序；</p>
</li>
<li><p>所以，在重新映射红黑树时，就能够按照映射链表的方式进行映射；</p>
</li>
<li><p>特征：</p>
<ul>
<li><p>1 重新映射红黑树的逻辑和重新映射链表的逻辑基本一致（代码结构基本相同）；</p>
</li>
<li><p>2 但是重新映射后，会将红黑树拆分成两条<em>由 TreeNode 组成的链表</em>（<em>中间状态</em>）；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TreeNode&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">  TreeNode&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>3 如果链表长度小于 UNTREEIFY_THRESHOLD，则</p>
<ul>
<li>将链表转换成普通链表（Node）；</li>
<li>否则根据条件重新将 TreeNode 链表树化（treeify）；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (loHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (lc &lt;= UNTREEIFY_THRESHOLD) <span class="comment">// 重新映射后的链表长度小于等于UNTREEIFY_THRESHOLD</span></span><br><span class="line">        tab[index] = loHead.untreeify(map); <span class="comment">// 转化为普通链表</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        tab[index] = loHead;</span><br><span class="line">        <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) <span class="comment">// (else is already treeified)</span></span><br><span class="line">            loHead.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>红黑树重新映射第一步后的结果👇</p>
<p><img src="https://s1.ax1x.com/2020/09/02/wpX3kQ.png" alt="RBT重新映射后"></p>
</li>
</ul>
<h6 id="红黑树链化（untreeify-方法）"><a href="#红黑树链化（untreeify-方法）" class="headerlink" title="红黑树链化（untreeify()方法）"></a>红黑树链化（untreeify()方法）</h6><ul>
<li><p>场景：当链表中的节点数比较少时，就把红黑树转化为普通链表以节省空间；</p>
</li>
<li><p>原理：红黑树中仍然保留了原链表节点顺序；</p>
</li>
<li><p>手段(Thus)：</p>
<ul>
<li>将 TreeNode 链表转成 Node 类型的链表（即可）；</li>
</ul>
</li>
</ul>
<p>I do not really understand how does this work, yet time is consuming…</p>
<h6 id="从容器中删除键值对（remove-方法）"><a href="#从容器中删除键值对（remove-方法）" class="headerlink" title="从容器中删除键值对（remove()方法）"></a>从容器中删除键值对（remove()方法）</h6><blockquote>
<p>流程</p>
</blockquote>
<ul>
<li>第一步是定位桶位置；</li>
<li>第二步遍历链表并找到键值相等的节点；</li>
<li>第三步删除节点。</li>
</ul>
<blockquote>
<p>源码</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/09/02/wpjDDf.jpg" alt="先找到后删除"></p>
<p><img src="https://s1.ax1x.com/2020/09/02/wpvCIe.jpg" alt="删除流程"></p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ul>
<li>在JDK8中HashMap的底层数据结构为：<strong>数组+链表(散列表)+红黑树</strong>；</li>
<li>当初始容量 * 装载因子 &lt; HashMap中的键值对数量时，对散列数组/桶数组进行扩容；</li>
<li>装在因子loadFactor默认为0.75;【太大会容易产生散列冲突 VS 太小容易引起扩容】</li>
<li>初始容量默认为16；【空间 VS 时间】</li>
<li>计算key的hash值：将key的哈希值的高16位进行异或操作，以此来增加随机性；</li>
<li>并不是桶子上有8位元素的时候它就能变成红黑树，它得同时满足我们的散列表容量大于64才行；</li>
<li>使用构造方法指定initialCapacity时，这个参数不会直接初始化capacity，而是先绑定到threshold上，在初始化桶数组时，才会再绑定到newCap上；</li>
</ul>
<blockquote>
<p>what have I done?!</p>
</blockquote>
<h5 id="启示"><a href="#启示" class="headerlink" title="启示"></a>启示</h5><p>1 写文章时，需要一些其他工具。比如截长图与截图文字标注工具，否则文字会缺少一些表现力</p>
<p>2 需要想办法能够对JDK源码进行编辑，这种可望不可及的感觉不好。而且很容易遗忘</p>
<h5 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h5><p><a href="http://www.tianxiaobo.com/2018/01/18/HashMap-%E6%BA%90%E7%A0%81%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90-JDK1-8/#342-%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6">http://www.tianxiaobo.com/2018/01/18/HashMap-%E6%BA%90%E7%A0%81%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90-JDK1-8/#342-%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&amp;mid=2247484139&amp;idx=1&amp;sn=bb73ac07081edabeaa199d973c3cc2b0&amp;chksm=ebd743eadca0cafc532f298b6ab98b08205e87e37af6a6a2d33f5f2acaae245057fa01bd93f4&amp;scene=21#wechat_redirect">https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&amp;mid=2247484139&amp;idx=1&amp;sn=bb73ac07081edabeaa199d973c3cc2b0&amp;chksm=ebd743eadca0cafc532f298b6ab98b08205e87e37af6a6a2d33f5f2acaae245057fa01bd93f4&amp;scene=21#wechat_redirect</a></p>
]]></content>
      <categories>
        <category>JDK source type</category>
      </categories>
      <tags>
        <tag>Java stuff</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次面试（字节跳动）_java基础之线程池</title>
    <url>/interview/2020/08/28/interview/20200826-%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%9D%A2%E8%AF%95%EF%BC%88%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%EF%BC%89_java%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0.html</url>
    <content><![CDATA[<h4 id="关于线程池的初印象"><a href="#关于线程池的初印象" class="headerlink" title="关于线程池的初印象"></a>关于线程池的初印象</h4><p>由于接触到的项目都简单到只是CRUD，我并没有直接编码使用过线程池。所以感觉上非常生疏，甚至在被打击了一次之后，现在仍然觉得它就是个绣花枕头…</p>
<a id="more"></a>

<h5 id="预备知识：池化技术"><a href="#预备知识：池化技术" class="headerlink" title="预备知识：池化技术"></a>预备知识：池化技术</h5><ul>
<li>参考：<a href="https://mp.weixin.qq.com/s/_wP3w2sm0qzBaGC5O6heAg">能看得懂的文章</a></li>
<li>是：一种通用的技术思想；</li>
<li>作用：提前准备一些资源，以应对紧急的需求（紧急响应组）；</li>
<li>特征：<ul>
<li>提前准备资源（节省临时创建线程的开销）；</li>
<li>这些资源可以重复使用；</li>
</ul>
</li>
</ul>
<blockquote>
<p>知识卡：Java对象创建的过程；</p>
<ul>
<li>1 根据代码中<em>new关键字后面的参数</em>来在JVM常量池中找到<em>类的符号引用</em>；</li>
<li>2 如果没有找到，就把类的class文件加载到JVM中；</li>
<li>3 类加载完成后，JVM会执行一系列的操作：<ul>
<li>在堆空间中分配内存空间；</li>
<li>把分配的空间初始化为0[预初始化,尽量避免NPE]；</li>
<li>建立对象头的描述结构[<strong>耗时操作，因为在更新堆内存的状态</strong>]；</li>
</ul>
</li>
<li>4 调用对象的初始化方法，完成实例真正的初始化[<strong>耗时操作,因为有一系列的校验过程</strong>]；</li>
</ul>
<p>anyway, 创建一个类的实例对象是一个很耗时的过程；BUT,这和池化技术有什么关系呢？</p>
</blockquote>
<ul>
<li><p>应用：</p>
<ul>
<li><p>线程池；</p>
<p>原理：把线程池当作紧急响应组；</p>
<ul>
<li>池子中有多个沉睡的线程；</li>
<li>如果客户端来了一个请求，则唤醒池子中的一个线程；</li>
<li>线程对请求进行处理；</li>
<li>处理完成后，线程回到池子里继续睡觉；</li>
</ul>
<p>作用：在高并发的场景中，避免所有的CPU资源都耗费在创建线程的工作上（线程才能真正地处理请求）。</p>
</li>
<li><p>内存池；</p>
</li>
<li><p>数据库连接池等</p>
</li>
</ul>
</li>
<li><p>验证：使用线程池比起临时创建线程更高效；</p>
<ul>
<li><p>手段：创建两个方法，方法1使用线程池执行任务A，方法2临时创建线程执行任务A。比较方法1与方法2的执行耗时；</p>
</li>
<li><p>线程的用法；</p>
<ul>
<li><p>创建线程对象，创建时传入任务对象（任务类本身也是一个线程）；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread td = <span class="keyword">new</span> Thread(<span class="keyword">new</span> PerformanceRunnable()); <span class="comment">// 把要执行的任务添加到线程中</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>启动线程;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">td.start(); <span class="comment">// 启动线程</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>等待线程执行完成；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">td.join(); <span class="comment">// 确保线程执行完成</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>线程池的用法；</p>
<ul>
<li><p>创建线程池对象（构造方法有5个参数😄）；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadPoolExecutor tp = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">10</span>, <span class="number">10</span>, <span class="number">0</span>,</span><br><span class="line">                  TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingDeque&lt;&gt;());</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用线程池对象来执行任务；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">tp.execute(<span class="keyword">new</span> PerformanceRunnable());</span><br></pre></td></tr></table></figure>
</li>
<li><p>关停线程池对象；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">tp.shutdown(); <span class="comment">// 为什么任务还没有执行完，就要调用shutdown()?</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>等待线程池执行完成；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">tp.awaitTermination(<span class="number">1</span>, TimeUnit.SECONDS);  <span class="comment">// 等待线程池执行完成</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>运行耗时结果；</p>
<blockquote>
<p>线程执行时长：418 毫秒.<br>线程池执行时长：38 毫秒.</p>
</blockquote>
</li>
</ul>
<ul>
<li>结论：使用线程池能够大幅地提高程序性能；</li>
</ul>
<hr>
<h5 id="Java中的多线程与线程池"><a href="#Java中的多线程与线程池" class="headerlink" title="Java中的多线程与线程池"></a>Java中的多线程与线程池</h5><ul>
<li>应用场景：为了提高性能往往会在主线程里面开启一个新线程去执行；</li>
<li>事实：开启线程需要消耗很多资源；</li>
<li>issue：如果用户量上涨，如果每次任务都创建一个新的线程。服务器表示压力很大…</li>
<li>手段：使用线程池来预先创建线程，作为备用军团；</li>
</ul>
<h6 id="创建线程类的三种手段"><a href="#创建线程类的三种手段" class="headerlink" title="创建线程类的三种手段"></a>创建线程类的三种手段</h6><ul>
<li>1 继承Thread类；</li>
<li>2 实现Runnable接口；</li>
<li>3 实现Callable接口；</li>
</ul>
<h6 id="线程类的用法（启动）"><a href="#线程类的用法（启动）" class="headerlink" title="线程类的用法（启动）"></a>线程类的用法（启动）</h6><ul>
<li><p>如果是通过继承Thread类来创建的线程…</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  通过继承 thread 类</span></span><br><span class="line">Mytheard1 thread1 =  <span class="keyword">new</span> Mytheard1();</span><br><span class="line">thread1.start();</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果是通过实现Runnable接口来创建的线程…</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  通过实现 runnable 接口</span></span><br><span class="line">Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Mytheard2()); <span class="comment">// 把实例作为Thread构造器的参数</span></span><br><span class="line">thread2.start();</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果是通过实现Callable接口来创建的线程…</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  通过实现 callable 接口</span></span><br><span class="line">Mytheard3 th = <span class="keyword">new</span> Mytheard3();</span><br><span class="line">FutureTask&lt;Integer&gt; result = <span class="keyword">new</span> FutureTask&lt;&gt;(th); <span class="comment">// 把实例作为FutureTask构造器的参数</span></span><br><span class="line"><span class="keyword">new</span> Thread(result).start(); <span class="comment">// 把task对象再作为Thread构造器的参数</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h6 id="线程类的特征"><a href="#线程类的特征" class="headerlink" title="线程类的特征"></a>线程类的特征</h6><ul>
<li>1 不会直接调用自定义线程类中的run()方法；</li>
<li>2 而是调用Thread类型对象的start()方法；<ul>
<li>原理：Thread实例对象的start()方法，会调用本地系统方法，并最终导致自定义线程类的run()方法被调用；</li>
</ul>
</li>
</ul>
<h6 id="线程的分类"><a href="#线程的分类" class="headerlink" title="线程的分类"></a>线程的分类</h6><ul>
<li><p>1 守护线程；</p>
<ul>
<li><p>任务：设置一个线程为守护线程；</p>
</li>
<li><p>手段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">thread.setDaemon(<span class="keyword">true</span>)；</span><br></pre></td></tr></table></figure>
</li>
<li><p>特征：</p>
<ul>
<li>1 必须在start()方法被调用之前完成set操作（否则会抛出异常）；</li>
<li>2 在守护线程中开启的新线程也是守护线程；</li>
</ul>
</li>
<li><p>作用：为所有的非守护进程提供守护服务；</p>
</li>
<li><p>应用：JVM中的垃圾回收(GC)线程；</p>
</li>
</ul>
</li>
<li><p>2 用户线程/非守护线程；</p>
<ul>
<li><p>特征：</p>
<ul>
<li>Java线程默认是非守护线程；</li>
<li>主线程运行结束后，如果主线程中还有非守护线程，则JVM就不会退出；</li>
<li>只有在所有的非守护线程执行完成后，JVM才会退出。</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>JVM退出时，只会考虑非守护线程的状态；</p>
</blockquote>
<h6 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h6><ul>
<li>场景：如果有多个并发同时访问主线程,而主线程中又创建了多个子线程。则创建线程的开销巨大;</li>
<li>解决手段：使用线程池来提前预备线程，避免短时间大量创建线程的情形；</li>
<li>作用：<ul>
<li>1 减少在创建和销毁线程上所花的时间以及系统资源的开销;</li>
<li>2 如不使用线程池，有可能造成系统创建大量线程而导致消耗完系统内存;</li>
</ul>
</li>
</ul>
<h6 id="自定义线程池"><a href="#自定义线程池" class="headerlink" title="自定义线程池"></a>自定义线程池</h6><ul>
<li><p>手段：</p>
<ul>
<li><p>1 自定义类型中持有具体的线程池类型；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> MyPool myPool = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//单例线程池中有两种具体的线程池</span></span><br><span class="line">    <span class="keyword">private</span> ThreadPoolExecutor threadPool = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> ScheduledThreadPoolExecutor scheduledPool = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>2 以实例变量的方式来设置线程池的各项参数的大小；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置线程池的各个参数的大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> corePoolSize = <span class="number">10</span>;<span class="comment">// 池中所保存的线程数，包括空闲线程。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maximumPoolSize = <span class="number">20</span>;<span class="comment">// 池中允许的最大线程数。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> keepAliveTime = <span class="number">3</span>;<span class="comment">// 当线程数大于核心时，此为终止前多余的空闲线程等待新任务的最长时间。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> scheduledPoolSize = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>3 在私有的构造方法中：</p>
<ul>
<li>实例化线程池；</li>
<li>实例化“计划任务线程池”；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">MyPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//实例化线程池，这里使用的 LinkedBlockingQueue 作为 workQueue ，使用 DiscardOldestPolicy 作为 handler</span></span><br><span class="line">	<span class="keyword">this</span>.threadPool = <span class="keyword">new</span> ThreadPoolExecutor(corePoolSize, maximumPoolSize,</span><br><span class="line">			keepAliveTime, TimeUnit.SECONDS,</span><br><span class="line">			<span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(),</span><br><span class="line">			<span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());<span class="comment">//不在新线程中执行任务，而是由调用者所在的线程来执行</span></span><br><span class="line">	<span class="comment">//实例化计划任务线程池</span></span><br><span class="line">	<span class="keyword">this</span>.scheduledPool = <span class="keyword">new</span> ScheduledThreadPoolExecutor(scheduledPoolSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>4 定义静态方法，返回线程池对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MyPool <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (myPool == <span class="keyword">null</span>)</span><br><span class="line">    create();</span><br><span class="line">    <span class="keyword">return</span> myPool;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
<ul>
<li><p>创建线程池时传入的参数说明：</p>
<ul>
<li>1 <code>corePoolSize（int）</code>：线程池中保持的线程数量，包括空闲线程在内。</li>
<li>2 <code>maximumPoolSize（int）</code>: 线程池中能够容纳最大线程数量；</li>
<li>3 <code>keepAliveTime(long)</code>：当线程池中线程数量大于 corePoolSize 的时候,空闲线程保持在线程池中的时间;</li>
<li>4 <code>unit(TimeUnit枚举类)</code>: 上面参数时间的单位，可以是分钟，秒，毫秒等等;</li>
<li>5 <code>workQueue（BlockingQueue）</code>: 任务队列；<ul>
<li>作用：当线程任务提交到线程池以后…<ul>
<li>1 首先放入队列中;</li>
<li>2 然后线程池按照该任务队列依次执行相应的任务;</li>
</ul>
</li>
</ul>
</li>
<li>6 <code>threadFactory(ThreadFactory类)</code>: 新线程产生工厂类;</li>
<li>7 <code>handler（RejectedExecutionHandler类）</code>: 当提交线程拒绝执行、异常的时候，处理异常的类;<ul>
<li>取值范围：<ul>
<li>AbortPolicy：丢弃任务并抛出异常；</li>
<li>DiscardPolicy：丢弃任务但是不抛出异常；</li>
<li>DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务；</li>
<li>CallerRunsPolicy：由调用线程处理该任务（？？？）；</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>用法：获取线程池，并向其中添加任务；</p>
<ul>
<li><p>1 获取到线程池对象；</p>
<ul>
<li><p>手段1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadPoolExecutor pool1 = (ThreadPoolExecutor) Executors.newCachedThreadPool(); <span class="comment">// 调用Executors类的newCachedThreadPool()方法</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>手段2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadPoolExecutor pool2 = MyPool.getInstance().getThreadPool(); <span class="comment">// 自定义类的静态方法</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>2 调用线程池对象的execute()方法执行指定的任务;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">pool1.execute(() -&gt; System.out.println(<span class="string">"快捷线程池中的线程！"</span>));</span><br><span class="line"></span><br><span class="line">pool2.execute(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"pool2 普通线程池中的线程！"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">30</span>*<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;); <span class="comment">// 使用lambda表达式来表示待执行的任务</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>3 打印线程池的状态信息；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">"pool2 poolSize:"</span>+pool2.getPoolSize()); <span class="comment">// </span></span><br><span class="line">System.out.println(<span class="string">"pool2 corePoolSize:"</span>+pool2.getCorePoolSize()); <span class="comment">// 核心线程数</span></span><br><span class="line">System.out.println(<span class="string">"pool2 largestPoolSize:"</span>+pool2.getLargestPoolSize()); <span class="comment">// </span></span><br><span class="line">System.out.println(<span class="string">"pool2 maximumPoolSize:"</span>+pool2.getMaximumPoolSize()); <span class="comment">// ？？？</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>JDK中提供的几种常用线程池</p>
<ul>
<li><code>newFixedThreadPool</code> 创建固定大小数量线程池；</li>
<li><code>newSingleThreadExecutor</code> 创建容量为1的线程池——所有的线程依次执行；</li>
<li><code>newCachedThreadPool</code> 创建可缓存的线程池；<ul>
<li>特征：<ul>
<li>1 没有最大线程限制；</li>
<li>2 如果空闲线程等待时间超过1分钟，就关闭此线程；</li>
</ul>
</li>
</ul>
</li>
<li><code>newScheduledThreadPool</code> 创建计划 (延迟) 任务线程池；<ul>
<li>特征：可以设置线程池中线程的执行状态；<ul>
<li>1 使线程在特定的延迟时间后执行；</li>
<li>2 使线程周期性地执行；（作用等同于Timer）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h6 id="在SpringBoot中使用线程池"><a href="#在SpringBoot中使用线程池" class="headerlink" title="在SpringBoot中使用线程池"></a>在SpringBoot中使用线程池</h6><p>​    this is for further practice.</p>
<blockquote>
<p>全是文字，写着写着就没劲了。因为没有推理的过程，就只是照本宣科地陈列规则。<br>Plus,为什么一个构造方法需要有7个参数 OMG 🙃</p>
</blockquote>
]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>Java stuff</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次面试（字节跳动）_后续</title>
    <url>/interview/2020/08/28/interview/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%9D%A2%E8%AF%95%EF%BC%88%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%EF%BC%89_%E5%90%8E%E7%BB%AD.html</url>
    <content><![CDATA[<h4 id="ConcurrentHashMap的put-操作过程"><a href="#ConcurrentHashMap的put-操作过程" class="headerlink" title="ConcurrentHashMap的put()操作过程"></a>ConcurrentHashMap的put()操作过程</h4><p>这个问题在上次被问到后，我其实做了一番搜索。还搜索了一些文章，但都本着太长不看的原则跑进收藏夹里吃灰了</p>
<p>不过这次既然被同一个问题绊倒两次，还是坐下来跟它好好对付对付</p>
<a id="more"></a>

<h5 id="基本认识（5点认知）"><a href="#基本认识（5点认知）" class="headerlink" title="基本认识（5点认知）"></a>基本认识（5点认知）</h5><p>是：一个元素容器；</p>
<p>作用：对元素进行存储；</p>
<p>特征：</p>
<ul>
<li>与多线程相关；</li>
</ul>
<p>应用：xxx</p>
<p>用法：xxx</p>
<p>底层原理：散列表 + 红黑树；</p>
<h5 id="进一步认识"><a href="#进一步认识" class="headerlink" title="进一步认识"></a>进一步认识</h5><h6 id="底层数据结构（JDK1-8）"><a href="#底层数据结构（JDK1-8）" class="headerlink" title="底层数据结构（JDK1.8）"></a>底层数据结构（JDK1.8）</h6><p><img src="https://s1.ax1x.com/2020/08/28/dImSRf.md.png" alt="底层数据结构"></p>
<p>类的具体作用：参考源码中类上面的注释（不夸张的有两百行）；</p>
<p>简单概括（5点）：</p>
<ul>
<li>JDK1.8中的实现是散列表 + 红黑树；</li>
<li>ConcurrentHashMap支持高并发的访问与更新操作，因为它是线程安全的；</li>
<li>访问/检索操作不需要加锁；</li>
<li>get()方法是非阻塞的（啥意思？）；</li>
<li>key与value都不能为null；</li>
</ul>
<h6 id="WHY"><a href="#WHY" class="headerlink" title="WHY?"></a>WHY?</h6><ul>
<li>Hashtable实现线程安全的手段很直接（每个方法都添加了synchronized关键字），但是效率很低；</li>
<li>ConcurrentHashMap使用了更优的手段实现线程安全（部分加锁 + CAS算法）；</li>
</ul>
<h6 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h6><ul>
<li>CAS算法（compare and swap）<ul>
<li>作用：解决多个线程对变量的并发操作问题；</li>
<li>手段：规定对于任意一个线程，每次对变量进行修改操作时，都检查变量当前在主内存中的值 == 自己获取到的变量值；<ul>
<li>aka 判断主内存中的变量值是否被其他线程修改过了。</li>
<li>如果相等，说明没有其他线程修改主内存中的变量。则把修改过的值同步到主内存中；</li>
<li>如果不相等，说明已经有别的线程捷足先登，把主内存中的变量值修改了。则当前线程放弃自己计算的值，然后从主内存中重新获取变量的初始值，重新计算，然后再次尝试把计算结果同步到主内存中；</li>
</ul>
</li>
<li>知识卡：JMM(java内存模型 = CPU + 各个线程的工作内存 + 主内存；)</li>
</ul>
</li>
<li>volatile关键字<ul>
<li>作用：保证变量对所有线程的可见性（但是不保证原子性）；</li>
<li>原理-多线程环境下，变量对多个线程的可见性：一旦变量的值（主内存中）被某个线程修改，其他的线程都会看到修改后的变量；（从而重新获取、重新计算）</li>
<li>原理-无法保证变量操作的原子性：变量赋值的操作其实分成了多个步骤执行，而volatile没有对这一事实产生任何影响；</li>
</ul>
</li>
</ul>
<hr>
<h5 id="从源码认识类的实现原理"><a href="#从源码认识类的实现原理" class="headerlink" title="从源码认识类的实现原理"></a>从源码认识类的实现原理</h5><blockquote>
<p>bear this in mind：实现源码时，需要充分考虑底层数据结构被多个线程操作的可能性。以保证操作的线程安全</p>
</blockquote>
<h6 id="多线程下有哪些操作需要保证多线程安全呢？"><a href="#多线程下有哪些操作需要保证多线程安全呢？" class="headerlink" title="多线程下有哪些操作需要保证多线程安全呢？"></a>多线程下有哪些操作需要保证多线程安全呢？</h6><ul>
<li>增删改</li>
</ul>
<hr>
<h6 id="类的域对象（×10-不夸张的）"><a href="#类的域对象（×10-不夸张的）" class="headerlink" title="类的域对象（×10 不夸张的）"></a>类的域对象（×10 不夸张的）</h6><ul>
<li>Node&lt;K,V&gt;[] table; // 用于存储元素的散列表</li>
<li>其他域对象; // 为了其他API服务的</li>
<li>int sizeCtl; // 用于控制散列表的初始化与扩容； 规则：…</li>
</ul>
<h5 id="类的构造方法（×5-也不夸张）"><a href="#类的构造方法（×5-也不夸张）" class="headerlink" title="类的构造方法（×5 也不夸张）"></a>类的构造方法（×5 也不夸张）</h5><ul>
<li><p>构造方法的作用</p>
<ul>
<li>调用它，来创建实例对象；</li>
<li>强制调用者传入某些参数来初始化某些实例变量；</li>
</ul>
</li>
<li><p>选择一个构造方法进行代码分析</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* 参数判空代码... */</span></span><br><span class="line">    </span><br><span class="line">    	<span class="comment">// 为局部变量cap绑定一个值	手段：判断xxx条件是否成立：如果是，绑定ooo。否则绑定tableSizeFor()方法的调用结果		&gt;&gt;&gt;表示无符号右移操作</span></span><br><span class="line">        <span class="keyword">int</span> cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ?</span><br><span class="line">                   MAXIMUM_CAPACITY :</span><br><span class="line">                   tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>));</span><br><span class="line">    	<span class="comment">// 把cap的值绑定到sizeCtl属性上</span></span><br><span class="line">        <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>tableSizeFor()方法的作用？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = c - <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        ...</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">return</span> ...;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这个实现手段不是重点，重点是它的作用是：获取到大于且最接近指定容量的2的指数数值；</p>
</li>
<li><p>this.sizeCtl = cap; // 指定下次扩容时，散列表容量的大小</p>
</li>
</ul>
</li>
</ul>
<h5 id="类的API-put-方法"><a href="#类的API-put-方法" class="headerlink" title="类的API-put()方法"></a>类的API-put()方法</h5><blockquote>
<p>OS:这是面试官真正问到的方法，我没有细致地看过 只能硬着头皮说，和HashMap地put()方法实现过程类似，只是添加了synchronized关键字吧吧🐷</p>
<p>参考:<a href="https://mp.weixin.qq.com/s/r1ErR7EroJt4b83Pm7Xk6g">Java3y</a></p>
</blockquote>
<ul>
<li><p>看之前推测一下子，put()作为一个添加键值对的api，可能的实现过程是怎样的；</p>
<ul>
<li>找到键值对应该存放的位置；</li>
<li>把键值对绑定到这个位置上；Over~</li>
</ul>
</li>
<li><p>真实情况是，put()方法需要做更多的工作（一方面是为了”容器的底层数据结构”,另一方面是为了“多线程操作的正确性”）</p>
<ul>
<li>代码拆解（源码基本没有给注释 引用图片：Java3y）</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/08/28/do6lpn.png" alt="put()方法的工作"></p>
<p>这里面的步骤虽然多，但是层次还是能理清楚的。</p>
<ul>
<li><p>第一次插入键值对时，判断哈希表是否为空。如果是，就要先对哈希表进行初始化工作；</p>
</li>
<li><p>手段：调用initTable()方法，把方法的返回结果绑定到tab（在for循环中创建的局部变量）</p>
<p><img src="https://s1.ax1x.com/2020/08/28/dog6Fe.png" alt="初始化节点数组tab的代码"></p>
<ul>
<li>sizeCtl的规则：小于0时，表示有线程正在执行初始化操作。则，需要控制其他进程不能再次执行初始化的代码;</li>
<li>任务：对于多个线程，保证初始化的代码同一时刻就只能有唯一的线程在执行；</li>
<li>手段：<ul>
<li>1 在线程进入初始化的代码之前，先对sizeCtl属性进行判断；以决定线程能不能继续执行代码</li>
<li>2 如果线程能够执行初始化代码，在执行代码前，把sizeCtl设置为-1——支持1中的判断操作</li>
</ul>
</li>
<li>作用：多线程情况下，只会有一个线程取完成散列表的初始化操作；</li>
</ul>
</li>
</ul>
<blockquote>
<p>这种总结似乎缺了点意思 所以再从另一个角度补充下</p>
</blockquote>
</li>
</ul>
<h6 id="补充细节"><a href="#补充细节" class="headerlink" title="补充细节"></a>补充细节</h6><p>CAS操作的Java API：</p>
<ul>
<li><strong>tabAt</strong>    作用：获取 table 数组中索引为 i 的 Node 元素；</li>
<li><strong>casTabAt</strong>  作用：设置 table 数组中索引为 i 的元素</li>
<li><strong>setTabAt</strong>   作用：设置 table 数组中索引为 i 的元素</li>
</ul>
<h6 id="put-流程分析"><a href="#put-流程分析" class="headerlink" title="put()流程分析"></a>put()流程分析</h6><ul>
<li>1 计算出key应该在哈希表中插入的位置；<ul>
<li>手段：对key进行重哈希，以减少哈希冲突；</li>
</ul>
</li>
<li>2 判断当前数组是否为空，如果为空，就进行初始化操作intiTable();<ul>
<li>作用：只会有一个线程执行初始化的代码；</li>
</ul>
</li>
<li>3 判断key-value能不能直接添加到哈希表上；<ul>
<li>手段：<ul>
<li>1 计算key映射到的哈希表的索引； </li>
<li>2 调用CAS的tabAt()方法获取到该位置上的值； </li>
<li>3 如果当前值为null,直接调用casTabAt()完成插入操作；</li>
</ul>
</li>
</ul>
</li>
<li>4 如果预期插入哈希表的位置上的元素不为null,判断哈希表是不是正在扩容（多线程需要考虑的问题）<ul>
<li>手段：判断当前节点是不是特殊节点forwardingNode（这是ConcurrentHashMap中定义的一个内部类型，用于表示扩容操作状态下的节点）</li>
<li>具体方法：判断节点的hash值是不是等于-1（使用MOVED标识）；</li>
</ul>
</li>
<li>5 如果哈希表也没有在扩容中，说明可以执行插入节点的操作了（synchronzied加锁以实现线程安全性）</li>
<li>6 如果节点为链表的头节点：<ul>
<li>如果在链表中找到key相同的节点，则更新/覆盖节点的值</li>
<li>如果没有找到这样的节点，就直接在链表尾部添加一个新的节点</li>
</ul>
</li>
<li>7 如果节点为红黑树的根节点：<ul>
<li>说明：如果链表连接的节点长度太长的话，ConcurrentHashMap就会自动把链表转化成一个红黑树；</li>
<li>1 判断当前节点是不是红黑树的根节点；</li>
<li>2 判断红黑树中是否已经存在了键为key的节点；<ul>
<li>存在，则使用新的value来更新它；</li>
<li>不存在，则向红黑树中添加一个新的节点；</li>
</ul>
</li>
</ul>
</li>
<li>8 [<em>插入导致的结果</em>]根据当前链表的长度，来决定要不要把链表转化成一棵红黑树；</li>
<li>9 [<em>插入导致的结果</em>]插入新的键值对后，查看当前容量。如果超过临界值就进行扩容；</li>
</ul>
<h6 id="get-方法"><a href="#get-方法" class="headerlink" title="get()方法"></a>get()方法</h6><blockquote>
<p>get()的作用是取出数据</p>
</blockquote>
<ul>
<li>1 重hash；</li>
<li>2 找到节点在哈希表中的预期位置i；</li>
<li>3 如果哈希表的桶节点table[i]的key与待查找的key相等，则直接返回；</li>
<li>4 如果不相等，而根节点是红黑树节点。则<ul>
<li>在红黑树中查找</li>
</ul>
</li>
<li>5 如果不相等，而根节点是链表节点。则<ul>
<li>在链表中查找</li>
</ul>
</li>
</ul>
<blockquote>
<p>Java基础知识也挺繁杂的 until next time 😄</p>
</blockquote>
]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>Java stuff</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次面试（字节跳动）</title>
    <url>/interview/2020/08/26/interview/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%9D%A2%E8%AF%95%EF%BC%88%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%EF%BC%89.html</url>
    <content><![CDATA[<h3 id="字节跳动（视频面试一面）"><a href="#字节跳动（视频面试一面）" class="headerlink" title="字节跳动（视频面试一面）"></a>字节跳动（视频面试一面）</h3><hr>
<h4 id="关于面试官："><a href="#关于面试官：" class="headerlink" title="关于面试官："></a>关于面试官：</h4><p>​    面试官给我的感觉很好，年龄和我相仿，穿着也很随意。就不会让人产生紧张的情绪，而且问的问题也很有递进性。过程是挺轻松的，结果嘛…</p>
<a id="more"></a>

<h4 id="关于项目："><a href="#关于项目：" class="headerlink" title="关于项目："></a>关于项目：</h4><p>   这个主要问了做过项目中的一些难点问题。但实话讲，做过的项目有些头疼的问题，但都算不上技术难点。于是我先说了公司项目的特征：面向政府机构居多，所以不会存在什么高并发访问的情况。（这是真实情况，也算是降低面试官的期望，别一上来就问大流量情况下如何削峰、限流什么的）</p>
<p>   我说了两点：1 excel表格中大数据导入MySQL数据库的问题；2 后台上传多种格式的资料时的处理；富文本编辑器上传时的格式处理等等</p>
<p>   因为项目总是和业务强相关，面试官可能也不想纠结于细节问题。于是很快就跳到了Java基础的阶段</p>
<h4 id="关于Java基础："><a href="#关于Java基础：" class="headerlink" title="关于Java基础："></a>关于Java基础：</h4><p>这个据我推测，面试官面前可能有一个巨大的Xmind脑图，根据你简历上所写的内容。随机抽取一个点来问你，基本是要考察你对知识点了解的深度；具体问的问题如下：</p>
<h5 id="数据库联合索引与最左匹配原则"><a href="#数据库联合索引与最左匹配原则" class="headerlink" title="数据库联合索引与最左匹配原则"></a>数据库联合索引与最左匹配原则</h5><p>索引：为数据表中的指定字段添加的额外的数据结构；</p>
<p>作用：在查询时，能够通过某个字段的索引来快速定位到满足条件的记录行；</p>
<p>原理：</p>
<ul>
<li>索引一般使用树一类的结构进行存储，因此查询速度很快。</li>
<li>通过索引中的字段值，就能快速定位到数据表中对应的数据行；</li>
</ul>
<p>用法：在SQL查询语句中，使用添加了索引的字段作为查询条件（where xxx=???）。这样就能命中索引，从而实现快速查询；</p>
<p><strong>联合索引</strong>：使用数据表中的多个字段所创建的索引；</p>
<p>作用：在编写SQL语句时，就能够通过多个字段来命中索引——这会使得SQL语句的编写更加灵活；</p>
<p>规则：<strong>最左匹配原则</strong>；（这个我并没有答对）</p>
<p>示例：</p>
<ul>
<li>在创建联合索引时，选择了字段a、b、c；</li>
<li>在编写查询SQL时，<ul>
<li>如果查询的字段以a开头（a、a-b、a-b-c），则能够命中联合索引，从而加速查询；</li>
<li>如果查询的字段不是以a开头（准确的说，是不包含a字段），则无法命中联合索引，查询操作仍旧是遍历的方式；</li>
</ul>
</li>
</ul>
<p>（讲真，我只用Navicat这个可视化工具创建过索引。所以上面的这些东西都是事后找补的   印象分什么的基本就没了）</p>
<h5 id="volatile关键字："><a href="#volatile关键字：" class="headerlink" title="volatile关键字："></a>volatile关键字：</h5><p>（这个我两周之前很细致的看过，但是忘得永远比记住得要快）</p>
<p>是：Java提供的一个关键字；</p>
<p>作用：修饰一个变量，以保证多线程情况下，变量的可见性与有序性；</p>
<p>特征：</p>
<ul>
<li>volatile就只能修饰变量，不能修饰方法啥的；</li>
<li>volatile不能保证多线程操作下的原子性（可能线程A执行了一半后，线程B接管CPU时间片）——需要其他手段来保证；</li>
<li>真正在编码时，这个关键字用得并不多；</li>
</ul>
<p>原理：</p>
<ul>
<li><p>变量对多个线程的可见性：</p>
<ul>
<li><p>JMM（Java 内存模型）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> 每个线程都有自己的工作内存；</span><br><span class="line"><span class="number">2</span> 所有线程共享的变量都在主内存中；</span><br><span class="line"><span class="number">3</span> 线程操作变量时，先从主内存把变量的值拷贝到自己的工作内存中，操作结束后，再把变量的值更新到主内存</span><br><span class="line">中；</span><br></pre></td></tr></table></figure>
</li>
<li><p>结合JMM的3条规则，volatile关键字能够保证所有对变量的更新都即时地同步到主内存中；</p>
</li>
</ul>
</li>
<li><p>变量的有序性：</p>
<ul>
<li><p>JVM指令重排</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">为了提高代码执行的效率，CPU或者编译器可能会对程序员编写的代码进行重新排序；</span><br></pre></td></tr></table></figure>

<ul>
<li>规则：不管如何重新排序，JVM保证在单线程执行时，得到的结果总是相同的；</li>
<li>问题来了，多线程时，指令重排就可能导致程序出现非预期的执行结果；</li>
</ul>
</li>
<li><p>结合以上，volatile关键字能够保证变量的赋值过程（非原子操作）不会出现指令重排，aka，指令的有序性。</p>
</li>
</ul>
</li>
</ul>
<p>应用：实现双重检查锁的单例模式；</p>
<h5 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h5><p>是：Java提供的一个关键字；</p>
<p>作用：为一段代码加锁，从而限制此段代码同一时刻只能被一个线程访问；</p>
<p>特征：早期它的性能很低，但是JDK8中做了很多优化；</p>
<p>用法：</p>
<ul>
<li>修饰实例方法；<ul>
<li>作用：线程在执行实例方法之前，必须要获得当前实例的对象锁；</li>
</ul>
</li>
<li>修饰静态方法；（<em>这里面试官着重问了，但是我没能很好的区分实例锁与类锁</em>）<ul>
<li>作用：线程在执行静态方法之前，必须要获得当前类的对象锁；</li>
</ul>
</li>
<li>修饰代码块；<ul>
<li>作用：线程在执行代码块之前，必须要获得指定对象的锁；</li>
<li>特征：这里的对象可以由程序员手动指定；</li>
</ul>
</li>
</ul>
<p>应用：双重检查校验的单例模式（和volatile配合使用）；</p>
<p>原理：JVM层面的一些东西，在字节码上添加了一些独特的标识；</p>
<h5 id="synchronized关键字-与-ReentrantLock类型（这个面试官没问，可能是因为上面答得不好）"><a href="#synchronized关键字-与-ReentrantLock类型（这个面试官没问，可能是因为上面答得不好）" class="headerlink" title="synchronized关键字 与 ReentrantLock类型（这个面试官没问，可能是因为上面答得不好）"></a>synchronized关键字 与 ReentrantLock类型（这个面试官没问，可能是因为上面答得不好）</h5><p>作用：都能够为代码段加锁，从而限制多个线程对代码块的访问；</p>
<p>相同点：</p>
<ul>
<li>两者都是可重入锁（re-entree）;<ul>
<li>线程可以重复获取到对象的锁——当再次获取对象锁时，计数值+1；</li>
</ul>
</li>
</ul>
<p>不同点：</p>
<ul>
<li>实现层面<ul>
<li>synchronized关键字的实现是在JVM中，而ReentrantLock的实现在JDK的concurrent包中；</li>
</ul>
</li>
<li>用法层面<ul>
<li>synchronized是关键字，用法比较单一（无非修饰不同的成份），而ReentrantLock是一个类，用法就非常灵活了；</li>
</ul>
</li>
<li>功能层面<ul>
<li>ReentrantLock提供了更多的功能：<ul>
<li>1 使等待中的线程放弃等待（去做别的事情）；</li>
<li>2 指定锁的类型（是公平锁，还是非公平锁）；公平锁：等待最久的线程会在锁被释放时，优先获取到锁；</li>
<li>3 实现等待 - 通知机制；</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h5><p>参考：<a href="https://www.jianshu.com/p/f584799f1c77">公平🔒</a></p>
<p>必须：兔子喝水，黑狗看门；</p>
<p>结论：</p>
<ul>
<li>1、若在释放锁的时候总是没有新的兔子来打扰，则非公平锁等于公平锁；</li>
<li>2、若释放锁的时候，正好一个兔子来喝水，而此时位于队列头的兔子还没有被唤醒（因为线程上下文切换是需要不少开销的），此时后来的兔子则优先获得锁，成功打破公平，成为非公平锁；</li>
</ul>
<h5 id="类加载过程中的双亲委派模型"><a href="#类加载过程中的双亲委派模型" class="headerlink" title="类加载过程中的双亲委派模型"></a>类加载过程中的双亲委派模型</h5><p><strong>类加载过程</strong>：</p>
<p>是：一个过程；</p>
<p>作用：把编译器编译生成的class文件，以特定的格式加载到JVM内存中的特定区域；</p>
<p>特征：分为两类；</p>
<ul>
<li>预加载；<ul>
<li>在虚拟机启动时就会被加载到内存中的class文件；比如lang.*与util.*等；</li>
</ul>
</li>
<li>运行时加载；<ul>
<li>在运行程序时，虚拟机根据类的全限定名来去查找并加载对应的class文件；</li>
</ul>
</li>
</ul>
<p>SOP:</p>
<ul>
<li>通过类的全限定名获取到<em>类的二进制字节流</em>；</li>
<li>把<em>字节流所代表的静态存储结构</em>转化为<em>方法区的运行时数据结构</em>；</li>
<li>在JVM内存中生成<em>表示这个类的Class对象</em>——它包含类的一切信息，是反射机制的基础；</li>
</ul>
<p><strong>双亲委派模型</strong>：</p>
<p>是：一个使用类加载器时，推荐遵守的规则；</p>
<p>作用：保证核心类型都能够被安全地加载到内存中；防止不法分子写的String类型被JVM错误加载…</p>
<p>特征：</p>
<p>​    1 这不是一个强制遵守的规则；</p>
<p>​    2 每一层加载器都有自己能够加载的类型范围；</p>
<p>规则描述：</p>
<ul>
<li>当类加载器需要把一个类加载到内存中的时候，先尝试把加载的工作交给更高层的类加载器完成；</li>
<li>然后再转交给更高级的类加载器，so on and so forth,直到到达最高层的类加载器（Bootstrap）；</li>
<li>只有顶层类加载器无法加载的类型（每一层加载器都有自己所能加载的类型范围），才会交给底层的类加载器去加载；</li>
</ul>
<h5 id="Spring-IoC容器"><a href="#Spring-IoC容器" class="headerlink" title="Spring IoC容器"></a>Spring IoC容器</h5><p>是：一个管理对象 以及 对象之间依赖关系的第三方；</p>
<p><em>如何解决循环依赖的问题呢？</em></p>
<p><strong>循环依赖</strong>：</p>
<p>IoC容器中注入了实例a与实例b，实例a依赖于实例b，同时实例b也依赖于实例a；</p>
<p>issue：IoC容器在创建实例a时，需要先创建实例b。但是创建实例b时，又需要先创建实例a，狗咬尾巴</p>
<p>参考：<a href="https://segmentfault.com/a/1190000015221968">Spring对循环依赖的解决</a></p>
<p>解决方案：</p>
<p>1 尝试创建实例a，发现实例a依赖于实例b；</p>
<p>2 尝试创建实例b，发现实例b依赖于实例a；</p>
<p>3 获取到实例a的一个<strong>早期引用</strong>（属性未进行初始化的引用）；</p>
<p>4 把这个早期引用注入到实例b中，使得实例b完成初始化；</p>
<p>5 然后实例a再去获取到实例b的引用，得到实例a的<strong>完全引用</strong>；</p>
<h5 id="AOP（面向切面编程）"><a href="#AOP（面向切面编程）" class="headerlink" title="AOP（面向切面编程）"></a>AOP（面向切面编程）</h5><p>是：一种编程的方式；对标OOP</p>
<p>作用：能够把应用中一些公共的功能（事务、安全等）抽取出来单独实现，然后以声明的方式编织到需要它们的代码中；</p>
<p>特征：AOP是一种思想，不同框架对这种思想的实现会各有差异。比如Spring AOP与AspectJ；</p>
<p>用法：这个步骤比较多，不宜作为面试部分；</p>
<p>原理：Spring AOP的底层原理是动态代理+反射；</p>
<ul>
<li>代理类会封装目标类，并把<em>用于增强的切面类</em>添加到目标类的外围；</li>
<li>动态代理这种方式绝定了Spring AOP<em>只能对方法做一些增强（因为动态代理使用反射实现目标）</em>，而对字段等无能为力；</li>
<li>Java中的动态代理：JDK动态代理（要求被代理的类实现接口） 与 CGLib动态代理（不要求…）；</li>
</ul>
<h5 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h5><p>注：这是一个多线程安全的类型，我在简历中有写看过它的源码，但其实只看了分析的文章。时隔两周，就只记得“分段锁”这三个字了 😭</p>
<p>是：一个容器/集合；</p>
<p>作用：存储键值对；</p>
<p>特征：多线程安全；</p>
<p><strong>多线程安全原理</strong>：</p>
<p>​    JDK1.7的手段：</p>
<ul>
<li><p>把容器表示成多个数据段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcurrentHashMap</span></span>&#123;</span><br><span class="line">    <span class="comment">// Segment数组	Segment类型本身继承了ReentrantLock，可以当作锁</span></span><br><span class="line">    Segment[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>数据段中存储多个键值对：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Segment</span></span>&#123;</span><br><span class="line">    HashEntry[]; <span class="comment">// HashEntry就是一个封装了键值对的类型；</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<ul>
<li>为每个数据段Segment添加一把锁，这样如果多个线程访问的是不同的数据段，就不会出现并发访问；而如果访问的是同一个数据段，仍旧是获取到锁的执行，没有获取到锁的等待</li>
</ul>
<p>​    JDK1.8使用的手段：</p>
<ul>
<li>synchronized关键字 + CAS乐观锁【细节需要看源码】</li>
<li>synchronized关键字只会锁住链表或红黑二叉树的头节点，如果多线程操作没有发生哈希冲突，就不会出现并发访问；如果操作到了同一个哈希位置，仍旧是…;</li>
</ul>
<p><strong>底层结构</strong>：</p>
<p>​    JDK1.7 Segment[] + HashEntry[]；</p>
<p>​    JDK1.8 Node[] + 链表 + 红黑树；</p>
<p>用法：</p>
<p>​    put()方法，前后有8步。</p>
<p>​    get()方法，就是按图索骥的过程，与多线程关系不大（毕竟它只是一个访问操作）；</p>
<blockquote>
<p>in case I don’t see u again, good morning, good afternoon, and good evening!😄</p>
</blockquote>
<p>​    </p>
]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>Java stuff</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>奇偶链表_10</title>
    <url>/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8%EF%BC%88%E6%8A%8A%E5%A5%87%E6%95%B0%E4%BD%8D%E7%BD%AE%E4%B8%8E%E5%81%B6%E6%95%B0%E4%BD%8D%E7%BD%AE%E4%B8%8A%E7%9A%84%E8%8A%82%E7%82%B9%E8%BF%9E%E5%9C%A8%E4%B8%80%E8%B5%B7%EF%BC%89_10.html</url>
    <content><![CDATA[<h4 id="把链表中的奇数位置节点与偶数位置节点放在一起"><a href="#把链表中的奇数位置节点与偶数位置节点放在一起" class="headerlink" title="把链表中的奇数位置节点与偶数位置节点放在一起"></a>把链表中的奇数位置节点与偶数位置节点放在一起</h4><h4 id="题设-与-要求"><a href="#题设-与-要求" class="headerlink" title="题设 与 要求"></a>题设 与 要求</h4><p><img src="https://s1.ax1x.com/2020/08/15/dklpjK.md.png" alt="题设与要求"></p>
<a id="more"></a>

<h4 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h4><p><img src="https://s1.ax1x.com/2020/08/15/dkldDU.md.png" alt="测试用例"></p>
<h4 id="附加说明"><a href="#附加说明" class="headerlink" title="附加说明"></a>附加说明</h4><p><img src="https://s1.ax1x.com/2020/08/15/dklLKf.md.png" alt="提示信息"></p>
<h4 id="分析（问题的难点）"><a href="#分析（问题的难点）" class="headerlink" title="分析（问题的难点）"></a>分析（问题的难点）</h4><ul>
<li>如何把奇数/偶数位置的节点都连接起来？</li>
<li>如何把奇数位置节点的集合 与 偶数位置节点的集合连接起来？</li>
</ul>
<h4 id="思路（难点的解决方案）"><a href="#思路（难点的解决方案）" class="headerlink" title="思路（难点的解决方案）"></a>思路（难点的解决方案）</h4><ul>
<li>如何把奇数位置/偶数位置的节点都连接起来？<ul>
<li>答：使用两个指针odd、even，初始化指向第一个节点与第二个节点。然后去创建奇数位置节点链表与偶数位置节点链表；</li>
</ul>
</li>
<li>如何把奇数位置节点集合与偶数位置节点集合连接起来？<ul>
<li>答：只要把odd链表的尾节点连接到even链表的头节点就可以了</li>
</ul>
</li>
</ul>
<h4 id="根据思路进行编码（细节处理）"><a href="#根据思路进行编码（细节处理）" class="headerlink" title="根据思路进行编码（细节处理）"></a>根据思路进行编码（细节处理）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">oddEvenList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 鲁棒性代码</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1 定义需要的实例变量</span></span><br><span class="line">        ListNode odd = head; <span class="comment">// 奇数位置节点的指针	作用：连接奇数位置的节点</span></span><br><span class="line">        ListNode even = head.next; <span class="comment">// 偶数位置节点的指针	作用：连接偶数位置的节点</span></span><br><span class="line">        ListNode evenHead = even; <span class="comment">// 作用：记录偶数节点链表的头节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 遍历当前链表	在循环中：1 创建奇数位置节点链表； 2 创建偶数位置节点链表</span></span><br><span class="line">        <span class="keyword">while</span>(even != <span class="keyword">null</span> &amp;&amp; even.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 创建链表SOP： 1 建立连接； 2 更新指针；</span></span><br><span class="line">            odd.next = even.next;</span><br><span class="line">            odd = odd.next;</span><br><span class="line"></span><br><span class="line">            even.next = odd.next;</span><br><span class="line">            even = even.next; <span class="comment">// even会率先达到链表的尾部</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 把偶数链表连接到奇数链表的尾节点上</span></span><br><span class="line">        odd.next = evenHead;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 返回新链表的头节点（作图可知）</span></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="代码分解SOP"><a href="#代码分解SOP" class="headerlink" title="代码分解SOP"></a>代码分解SOP</h4><ul>
<li>定义需要的实例变量</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ListNode odd = head; <span class="comment">// 用于指向奇数位置的节点</span></span><br><span class="line">ListNode even = head.next; <span class="comment">// 用于指向偶数位置的节点</span></span><br></pre></td></tr></table></figure>

<ul>
<li>遍历当前链表中的所有节点    在循环中：1 创建奇数节点的链表； 2 创建偶数节点的链表</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(ture)&#123; <span class="comment">// 参考：画图</span></span><br><span class="line">    <span class="comment">// 创建连接</span></span><br><span class="line">    odd.next = even.next;</span><br><span class="line">    <span class="comment">// 更新指针</span></span><br><span class="line">    odd = odd.next;</span><br><span class="line">    </span><br><span class="line">    even.next = odd.next;</span><br><span class="line">    even = even.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s1.ax1x.com/2020/08/15/dkteIO.md.jpg" alt="遇事不决画个图"></p>
<ul>
<li>确定循环执行表达式</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据链表中的节点数的不同，循环终结会有两种情况</span></span><br><span class="line"><span class="comment">// 1 链表中的节点数目为偶数个	even.next == null</span></span><br><span class="line"><span class="comment">// 2 链表中的节点数目为奇数个	even == null</span></span><br><span class="line"><span class="comment">// 当这两种情况之一发生时，就要终止循环 所以</span></span><br><span class="line"><span class="keyword">while</span>(even == <span class="keyword">null</span> &amp;&amp; even.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>把偶数链表连接到奇数链表上</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">odd.next = evenHead; <span class="comment">// 连接到记录的最初的偶数链表的头节点</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Bingo! good morning,good afternoon,and good night 🌙</p>
</blockquote>
]]></content>
      <categories>
        <category>ListNode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>分隔链表得到子链表_09</title>
    <url>/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E6%8A%8A%E9%93%BE%E8%A1%A8%E5%88%86%E9%9A%94%E6%88%90k%E4%B8%AA%E5%AD%90%E9%93%BE%E8%A1%A8_09.html</url>
    <content><![CDATA[<h4 id="把链表分隔成k个子链表"><a href="#把链表分隔成k个子链表" class="headerlink" title="把链表分隔成k个子链表"></a>把链表分隔成k个子链表</h4><hr>
<h4 id="题设与要求"><a href="#题设与要求" class="headerlink" title="题设与要求"></a>题设与要求</h4><p><img src="https://s1.ax1x.com/2020/08/15/dFWppn.md.png" alt="题设与要求"></p>
<a id="more"></a>

<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p><img src="https://s1.ax1x.com/2020/08/15/dFICeP.md.png" alt="测试用例"></p>
<h4 id="提示信息"><a href="#提示信息" class="headerlink" title="提示信息"></a>提示信息</h4><p><img src="https://s1.ax1x.com/2020/08/15/dFoZtO.png" alt="提示信息"></p>
<h4 id="分析（题目中的难点）"><a href="#分析（题目中的难点）" class="headerlink" title="分析（题目中的难点）"></a>分析（题目中的难点）</h4><ul>
<li>根据题设，就是要把链表中的节点均分为k份；<ul>
<li>要如何处理(length % k)余下的这些个节点？</li>
</ul>
</li>
<li>k个连续的部分，每个部分相差不超过1；<ul>
<li>说明每个子链表中的节点数会有不一样。可以顺序的让靠前的子链表中多出一个节点，来消耗余下的节点</li>
<li>如何确定到哪一个子链表时，余下的节点已经被消耗完了呢？</li>
</ul>
</li>
<li>如果k &gt; length，缺少的部分补充null作为元素；</li>
</ul>
<h4 id="思路（对难点的解决方案）"><a href="#思路（对难点的解决方案）" class="headerlink" title="思路（对难点的解决方案）"></a>思路（对难点的解决方案）</h4><ul>
<li>定义一个大小为k数组，数组中的第i个元素表示：第i个子链表中应该包含的节点数目；</li>
<li>定义一个循环，每次循环都为数组中的一个元素绑定值<ul>
<li>先求出余数；</li>
<li>每次绑定值时，判断余数是否还大于0.如果是，就把要绑定的值+1； 同时余数-1</li>
<li>每个子节点要绑定的基础数值为：(length / k)</li>
</ul>
</li>
<li>定义一个子链表列表，用于存储分割后的子链表；</li>
<li>定义一个循环，每次循环<ul>
<li>从数组中取出当前子链表应该包含的节点数；</li>
<li>根据上面的节点数目来创建一个子链表，并把子链表绑定到子链表列表的一个元素上；</li>
<li>循环往复，直到链表中的所有节点都被安排了</li>
</ul>
</li>
</ul>
<h4 id="把思路翻译成代码（🙏）"><a href="#把思路翻译成代码（🙏）" class="headerlink" title="把思路翻译成代码（🙏）"></a>把思路翻译成代码（🙏）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode[] splitListToParts(ListNode root, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="comment">// 定义一个指针 作用：作为游标，计算链表的节点长度</span></span><br><span class="line">        ListNode cursor = root;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义一个链表列表 作用：存储分割后的多个子链表；</span></span><br><span class="line">        ListNode[] res = <span class="keyword">new</span> ListNode[k]; <span class="comment">// 默认每个元素绑定的都是一个null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 鲁棒性代码</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算链表长度</span></span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cursor != <span class="keyword">null</span>)&#123;</span><br><span class="line">            length++;</span><br><span class="line">            cursor = cursor.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 比较链表长度length 与 预期分割得到的子链表数目k</span></span><br><span class="line">        <span class="keyword">if</span>(k &gt;= length)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;length; i++)&#123; <span class="comment">// 使用root链表中的节点对res数组的元素进行重新初始化</span></span><br><span class="line">                res[i] = <span class="keyword">new</span> ListNode(root.val);</span><br><span class="line">                root = root.next;</span><br><span class="line">            &#125; <span class="comment">// 只初始化了length个元素。剩下的元素仍旧是null</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 计算出第N个子链表应该包含多少个节点</span></span><br><span class="line">            <span class="keyword">int</span> remainder = length % k;</span><br><span class="line">            <span class="keyword">int</span> part = length / k;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">                counts[i] = remainder &gt; <span class="number">0</span> ? part + <span class="number">1</span> : part;</span><br><span class="line">                remainder--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从原始链表中截取出k个子链表，并添加到链表数组中</span></span><br><span class="line">            ListNode p = root;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;k; i++)&#123;</span><br><span class="line"></span><br><span class="line">                res[i] = p;</span><br><span class="line">                <span class="comment">// 当前子链接中应该包含多少个节点</span></span><br><span class="line">                <span class="keyword">int</span> count = counts[i];</span><br><span class="line">                <span class="keyword">while</span>(--count &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    p = p.next;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 记录下一个节点</span></span><br><span class="line">                ListNode temp = p.next;</span><br><span class="line">                <span class="comment">// 为当前节点绑定null</span></span><br><span class="line">                p.next = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 更新当前节点</span></span><br><span class="line">                p = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回得到的子链表列表</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="代码分解步骤"><a href="#代码分解步骤" class="headerlink" title="代码分解步骤"></a>代码分解步骤</h4><ul>
<li>定义需要的实例变量</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ListNode cursor = head; <span class="comment">// 用于在链表的节点上遍历</span></span><br><span class="line">ListNode[] res = <span class="keyword">new</span> ListNode[k]; <span class="comment">// 一个大小为k的ListNode类型的数组	用于存储分割后的子链表</span></span><br></pre></td></tr></table></figure>



<ul>
<li>求出链表的长度</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(cursor != <span class="keyword">null</span>)&#123;</span><br><span class="line">	length++;</span><br><span class="line">    cursor = cursor.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>比较链表长度length与预期分隔得到的子链表数目k</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(k &gt; length)&#123;</span><br><span class="line">	<span class="comment">// 子链表数目比链表本身的节点还要多		手段：不足的部分补上null</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 子链表数目小于等于链表本身的节点数目	手段：平均分配，盈余的话可能要多分一个</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当子链表数目k比起链表本身的节点length还要多时</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化res数组中前面length个元素</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;length; i++)&#123;</span><br><span class="line">    <span class="comment">// 创建一个新的链表，并绑定到子链表中	为什么要新建链表？</span></span><br><span class="line">    res[i] = <span class="keyword">new</span> ListNode(root.val);</span><br><span class="line">    root = root.next;</span><br><span class="line">&#125; <span class="comment">// 没有绑定子链表的节点，值默认是null 符合题目要求</span></span><br></pre></td></tr></table></figure>

<ul>
<li>当子链表数目小于等于链表本身的节点length时<ul>
<li>Ⅰ 计算出每个子链表应该包含的节点数量，并存储到一个数组中；</li>
<li>Ⅱ 遍历原始链表：<ul>
<li>从中取出正确数量的节点添加到子链表中；</li>
<li>当前子链接添加完成后，截断子链表。并把指针移动到下一个子链表的起始处</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Ⅰ计算出每个子链表应该包含的节点数量，并存储到一个数组中；</span></span><br><span class="line"><span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> perPart = length / k; <span class="comment">// 每个子链表的基础节点数目</span></span><br><span class="line"><span class="keyword">int</span> remainder = (length % k); <span class="comment">// 均分k份之后，余下的节点数量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;k; i++)&#123;</span><br><span class="line">    <span class="comment">// 使用三目运算符来替代一个if/else逻辑</span></span><br><span class="line">    counts[i] = (remainder &gt; <span class="number">0</span>) : perPart + <span class="number">1</span> : perPart;</span><br><span class="line">    remainder--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Ⅱ 遍历原始链表,把原始列表分割成k个子链表</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; k; i++)&#123;</span><br><span class="line">	<span class="comment">/* ① 从原始链表中取出正确数量的节点添加到子链表中 */</span></span><br><span class="line">    <span class="comment">// 创建一个新的指针		指向头节点</span></span><br><span class="line">    ListNode p = root; </span><br><span class="line">    <span class="comment">// 把当前子链表的头节点绑定到res[]的元素上</span></span><br><span class="line">    res[i] = p;</span><br><span class="line">    <span class="comment">// 获取到当前子链接中应该包含的节点数</span></span><br><span class="line">    <span class="keyword">int</span> count = counts[i];</span><br><span class="line">    <span class="comment">// 获取到指定数量的节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;count; j++)&#123; <span class="comment">// 应该向后遍历(count - 1)次</span></span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 当前子链接添加完成后，截断子链表。并把指针移动到下一个子链表的起始处 */</span></span><br><span class="line">    <span class="comment">// 记录下一个节点</span></span><br><span class="line">    ListNode temp = p.next; </span><br><span class="line">    <span class="comment">// 截断当前链表</span></span><br><span class="line">    p.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 更新当前节点</span></span><br><span class="line">    p = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>返回添加了子链表元素的res数组</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure>



<h4 id="启示"><a href="#启示" class="headerlink" title="启示"></a>启示</h4><p>对于循环次数已知的情况，推荐使用for循环。因为它的表达式非常容易写</p>
<p>while循环语法适用于那些循环次数不确定的场合</p>
<blockquote>
<p>until next time 😄</p>
</blockquote>
]]></content>
      <categories>
        <category>ListNode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>回文链表(迭代)_08_2</title>
    <url>/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E9%93%BE%E8%A1%A8%E6%98%AF%E4%B8%8D%E6%98%AF%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8%EF%BC%88%E8%BF%AD%E4%BB%A3%E6%96%B9%E5%BC%8F%EF%BC%89_08_2.html</url>
    <content><![CDATA[<h3 id="判断一个链表是不是回文链表（迭代方式）"><a href="#判断一个链表是不是回文链表（迭代方式）" class="headerlink" title="判断一个链表是不是回文链表（迭代方式）"></a>判断一个链表是不是回文链表（迭代方式）</h3><h4 id="题设与要求"><a href="#题设与要求" class="headerlink" title="题设与要求"></a>题设与要求</h4><p><img src="https://s1.ax1x.com/2020/08/15/diX5I1.png" alt="题设与要求"></p>
<a id="more"></a>

<h4 id="分析（问题的难点）"><a href="#分析（问题的难点）" class="headerlink" title="分析（问题的难点）"></a>分析（问题的难点）</h4><ul>
<li><p>这里不再考虑使用递归的方式，因为上一篇中已经实现了递归的代码；</p>
</li>
<li><p>为了判断链表是不是回文链表，肯定要对其左半边与右半边的节点进行比较；</p>
<p><strong>难点1</strong>：如何确定链表的左半边与右半边？aka 链表的中间节点位置</p>
</li>
<li><p>假设现在已经找到了中间节点的位置，接下来要怎么逐个比较各个节点呢？</p>
<p>方式1 从两边到中间，逐个比较节点的值；</p>
<p>方式2 从中间到两边，逐个比较节点的值；</p>
<p>说明：不管哪一种方式，都会面临一个问题——指针无法逆着链表节点移动；</p>
<p><strong>难点2</strong>：如何能让指针逆着链表的方向移动？</p>
</li>
<li><p>如果上面两个难点都得到解决，接下来就只需要逐个比较节点的值，分分钟无障碍</p>
</li>
</ul>
<h4 id="思路（难点的解决手段）"><a href="#思路（难点的解决手段）" class="headerlink" title="思路（难点的解决手段）"></a>思路（难点的解决手段）</h4><ul>
<li><p>难点1 如何确定链表的中间节点位置？</p>
<p>手段：快慢指针。</p>
<p>具体方法：从head节点开始（具体需要画图确认最佳方案），快指针一次走两个节点，慢指针一次走一个节点。</p>
<p>原理：当快指针指向链表尾节点时，慢指针应该刚好指向链表的中间节点。（或者前面一个节点）</p>
</li>
<li><p>难点2 如何能让指针逆着链表方向移动？</p>
<p>说明：实现这个目标其实有多个手段，比如借助额外空间整一个新链表。但是题目要求O(1)的空间复杂度，so pass this</p>
<p>手段：对链表的左半部分/右半部分进行翻转；</p>
<p>具体方法：翻转链表所需要的3个指针——prev、curr、temp；</p>
<p>原理：如果翻转左半部分，从中间节点到两边的节点进行比较；如果翻转右半部分，则是从两边的节点向中间节点进行比较；</p>
<p>这里我们选择翻转左半部分</p>
</li>
</ul>
<h4 id="把思路翻译成代码"><a href="#把思路翻译成代码" class="headerlink" title="把思路翻译成代码"></a>把思路翻译成代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1 作用：判断一个链表是不是回文链表，并返回布尔值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 迭代方式</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 防止NPE的指针</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用于翻转链表的指针</span></span><br><span class="line">        ListNode prev = dummy;</span><br><span class="line">        ListNode curr = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用于定位到中点的指针</span></span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一边定位，一边创建新的链表   翻转三部曲：1 记录当前节点的下一个节点； 2 改变当前节点的连接   3 更新指针prev与curr</span></span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123; <span class="comment">// slow与curr的位置关系还需要考察</span></span><br><span class="line">            <span class="comment">// 注： 当前节点的下一个节点总是slow,所以第1步省略</span></span><br><span class="line">            curr = slow; <span class="comment">// 3-2 更新指针curr</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新快慢指针</span></span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 翻转链表</span></span><br><span class="line">            curr.next = prev; <span class="comment">// 2 改变连接</span></span><br><span class="line">            prev = curr; <span class="comment">// 3-1 更新指针prev</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据fast的特征判断slow的位置</span></span><br><span class="line">        <span class="keyword">if</span>(fast != <span class="keyword">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过逐个比较两个链表的节点来判断是否为回文链表</span></span><br><span class="line">        <span class="keyword">while</span>(slow != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(curr.val != slow.val)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            curr = curr.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="代码步骤分解"><a href="#代码步骤分解" class="headerlink" title="代码步骤分解"></a>代码步骤分解</h4><ul>
<li>定义需要的实例变量（包括指针变量）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方便定位链表头节点的指针</span></span><br><span class="line">      ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">      dummy.next = head;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 用于翻转链表的指针</span></span><br><span class="line">      ListNode prev = dummy;</span><br><span class="line">      ListNode curr = head;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 用于定位到中点的指针</span></span><br><span class="line">      ListNode slow = head;</span><br><span class="line">      ListNode fast = head;</span><br></pre></td></tr></table></figure>

<ul>
<li>循环中需要做的事情：Ⅰ 定位链表的中间节点；    </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123; <span class="comment">// 2 直到快指针指向链表的尾节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 手段SOP：1 不断更新快慢指针</span></span><br><span class="line">    slow = slow.next;</span><br><span class="line">    fast = fast.next.next;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Ⅱ 对左半部分链表进行翻转；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">    翻转三步曲	</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    // 1 记录当前节点的下一个节点；</span></span><br><span class="line"><span class="comment">    ListNode temp = curr.next;</span></span><br><span class="line"><span class="comment">    // 2 改变当前节点的连接</span></span><br><span class="line"><span class="comment">    curr.next = prev;</span></span><br><span class="line"><span class="comment">    // 3 更新指针prev与curr	把prev更新到curr，把curr更新到temp</span></span><br><span class="line"><span class="comment">    prev = curr;</span></span><br><span class="line"><span class="comment">    curr = temp;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 问题来了：1 当前节点的下一个节点是什么呢？</span></span><br><span class="line">    <span class="comment">// 问题2：左半边的链表应该结束于哪一个节点呢？</span></span><br><span class="line">    <span class="comment">// 解决手段：为了准确定位左半部分链表的边界，把“当前节点的下一个节点”设置为slow指向的节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 知道了“当前节点的下一个节点为slow”后，套用上面的翻转三步曲 */</span></span><br><span class="line">    <span class="comment">// 1 记录当前节点的下一个节点 	手段：直接获取slow就可以了</span></span><br><span class="line">    <span class="comment">// 2 更新当前节点的连接为前一个节点</span></span><br><span class="line">    curr.next = prev; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3 更新指针</span></span><br><span class="line">    prev = curr; </span><br><span class="line">    curr = slow; <span class="comment">// 更新当前指针</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s1.ax1x.com/2020/08/15/dFei4K.md.jpg" alt="翻转图示"></p>
<ul>
<li>确保curr总是落后于slow一个节点</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 手段：把更新curr的语句放在更新快慢指针的语句之前</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    curr = slow; <span class="comment">// 更新当前节点为temp</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更新快慢指针</span></span><br><span class="line">    slow = slow.next;</span><br><span class="line">    fast = fast.next.next;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 翻转链表中的节点</span></span><br><span class="line">    curr.next = prev;</span><br><span class="line">    prev = curr;</span><br><span class="line">    <span class="comment">// 更新curr指针的代码在第一行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>确定循环执行表达式</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参考图示可知，fast应该停留在尾节点 或者 null节点上</span></span><br><span class="line"><span class="comment">// 原则：刚好形成可以一一对比其节点的左半部分链表（已翻转）</span></span><br><span class="line"><span class="keyword">while</span>(fast != <span class="keyword">null</span> || fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>根据情况来移动slow指针——因为这时候左右链表的节点数可能不一样</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参考图示可知：当链表节点数为奇数个时，slow指在最中间节点的位置。这时候右半部分链表的节点多了一个</span></span><br><span class="line"><span class="keyword">if</span>(fast != <span class="keyword">null</span>)&#123; <span class="comment">// fast!=null是这种情况下的特征</span></span><br><span class="line">    slow = slow.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>逐个比较左右两个链表的节点，来判断总链表是不是回文链表</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(curr.val != slow.val)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    curr = curr.next;</span><br><span class="line">    slow = slow.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>确定循环执行表达式</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 由于左右两个链表的节点长度是一样的，所以只要任一一个链表到头，循环就结束</span></span><br><span class="line"><span class="keyword">while</span>(slow != <span class="keyword">null</span>)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>鲁棒性代码</li>
<li>测试用例</li>
</ul>
<h4 id="代码重现（拆解之后的组合）"><a href="#代码重现（拆解之后的组合）" class="headerlink" title="代码重现（拆解之后的组合）"></a>代码重现（拆解之后的组合）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 定义需要的指针</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 翻转所需要用到的指针</span></span><br><span class="line">        ListNode prev = dummy;</span><br><span class="line">        ListNode curr = head;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 寻找中间节点所需要用到的指针</span></span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123; <span class="comment">// 只要有一个为false，循环就会结束</span></span><br><span class="line">            <span class="comment">// 翻转节点 - 2 </span></span><br><span class="line">            curr = slow;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 更新快慢指针</span></span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 翻转节点 - 1</span></span><br><span class="line">            curr.next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果需要，更新slow指针的位置</span></span><br><span class="line">        <span class="keyword">if</span>(fast != <span class="keyword">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历左右链表的每个节点，逐一比较</span></span><br><span class="line">        <span class="keyword">while</span>(slow != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(curr.val != slow.val)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            curr = curr.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>this is loads of code. until next time 😓</p>
</blockquote>
]]></content>
      <categories>
        <category>ListNode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>回文链表_08</title>
    <url>/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E4%B8%BA%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8(%E9%80%92%E5%BD%92%E6%96%B9%E5%BC%8F)_08.html</url>
    <content><![CDATA[<h3 id="判断一个链表是否为回文链表"><a href="#判断一个链表是否为回文链表" class="headerlink" title="判断一个链表是否为回文链表"></a>判断一个链表是否为回文链表</h3><h4 id="题设与要求"><a href="#题设与要求" class="headerlink" title="题设与要求"></a>题设与要求</h4><p><img src="https://s1.ax1x.com/2020/08/15/diX5I1.png" alt="题设与要求"></p>
<a id="more"></a>

<h4 id="分析（问题的难点）"><a href="#分析（问题的难点）" class="headerlink" title="分析（问题的难点）"></a>分析（问题的难点）</h4><p>1 回文链表的定义:左半边与右半边完全对称——这样从左边读起与从右边读起来，读到的内容是相同的。</p>
<p>2 如果使用迭代的方式，比较直观的想法是：头尾节点各一个指针，然后指针向里走。指针每走一次，就要比较一次节点的值。</p>
<ul>
<li>难点：但是由于是单向链表，尾节点的指针没有办法直接向前走。所以在此之前需要把右半边的链表翻转，然后再进行迭代与比较操作。可以预见，需要确定诸多的细节：右半边链表的终点、循环终止条件等</li>
</ul>
<p>3 能不能使用递归的方式呢？</p>
<ul>
<li>把问题转换为更小规模的问题：head头节点 + 中间节点组成的链表 + tail尾节点；<ul>
<li>中间节点组成的链表是不是回文链表，这就是一个更小规模的问题；</li>
</ul>
</li>
<li>更小规模问题的处理结果，能用来解决问题本身吗？<ul>
<li>如果中间节点组成的链表middle是一个回文链表，就只需要判断head.val == tail.val。如果相等，则整个链表就是一个回文链表</li>
</ul>
</li>
</ul>
<h4 id="思路（优先使用递归）"><a href="#思路（优先使用递归）" class="headerlink" title="思路（优先使用递归）"></a>思路（优先使用递归）</h4><p>1 把方法定义为一个递归方法，确定方法的作用与返回值；</p>
<ul>
<li>方法作用：判断一个链表是否为回文链表；    返回值：true/false；</li>
</ul>
<p>2 确定递归的终止条件；</p>
<ul>
<li>链表为null/链表中只有一个节点；    这时候可以认为链表是一个回文链表</li>
</ul>
<p>3 确定本级递归要完成的事情；</p>
<ul>
<li>编码时再具体说明</li>
</ul>
<h4 id="把思路翻译成代码"><a href="#把思路翻译成代码" class="headerlink" title="把思路翻译成代码"></a>把思路翻译成代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ListNode类型的定义省略</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1 方法作用：判断一个链表是否为回文链表；	返回值：true/false；</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 2 递归终结条件</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3 本级递归要做的事情</span></span><br><span class="line">        <span class="comment">// ① 把链表视为：链表头节点head + 中间节点组成的链表middle + 尾节点tail</span></span><br><span class="line">        <span class="comment">// ② 获取到head与tail，判断头节点与尾节点的值是否相等。如果不相等，返回false</span></span><br><span class="line">        <span class="comment">// ③ 如果相等，并且middle也是一个回文链表。则返回true，否则返回false</span></span><br><span class="line">        ListNode cursor = head;</span><br><span class="line">        <span class="keyword">while</span>(cursor.next != <span class="keyword">null</span>)&#123; <span class="comment">// 循环终止时，希望cursor指向尾节点，而不是null</span></span><br><span class="line">            cursor = cursor.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断头节点与尾节点的值是否相等</span></span><br><span class="line">        <span class="keyword">if</span>(head.val != cursor.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 获取到中间节点组成的链表middle</span></span><br><span class="line">            cursor = head.next;</span><br><span class="line">            ListNode middle = cursor;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 删除尾节点：这样其实破坏了原始的链表结构，需要和面试官确认</span></span><br><span class="line">            <span class="keyword">while</span>(cursor != <span class="keyword">null</span> &amp;&amp; cursor.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(cursor.next.next = <span class="keyword">null</span>)&#123;</span><br><span class="line">                    cursor.next = <span class="keyword">null</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cursor = cursor.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 判断middle是不是一个回文链表</span></span><br><span class="line">            <span class="keyword">return</span> isPalindrome(middle);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：这里获取到middle的过程还是差了点意思。</p>
<h4 id="添加鲁棒性的代码"><a href="#添加鲁棒性的代码" class="headerlink" title="添加鲁棒性的代码"></a>添加鲁棒性的代码</h4><h4 id="使用不同的测试用例测试"><a href="#使用不同的测试用例测试" class="headerlink" title="使用不同的测试用例测试"></a>使用不同的测试用例测试</h4><ul>
<li>功能性测试（各种极端情况下的有效输入）</li>
<li>非法输入测试（对各种非法输入是否进行了合适的处理）</li>
</ul>
<blockquote>
<p>until next time😄</p>
</blockquote>
]]></content>
      <categories>
        <category>ListNode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>链表数相加_07</title>
    <url>/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E9%93%BE%E8%A1%A8%E8%A1%A8%E7%A4%BA%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%9B%B8%E5%8A%A0(%E8%BF%AD%E4%BB%A3%E6%96%B9%E5%BC%8F)_07.html</url>
    <content><![CDATA[<h3 id="链表表示的两个数相加"><a href="#链表表示的两个数相加" class="headerlink" title="链表表示的两个数相加"></a>链表表示的两个数相加</h3><h4 id="题设与要求"><a href="#题设与要求" class="headerlink" title="题设与要求"></a>题设与要求</h4><p><img src="https://s1.ax1x.com/2020/08/14/diKVtx.md.png" alt="题目条件与要求"></p>
<a id="more"></a>

<h4 id="分析（面临的核心问题）"><a href="#分析（面临的核心问题）" class="headerlink" title="分析（面临的核心问题）"></a>分析（面临的核心问题）</h4><p>两个数的加法算法，主要的特征：</p>
<ul>
<li>从低位到高位计算（个十百千…）;</li>
<li>计算除了个位以外的位数上的数字时，都需要加上来自后一位的进位（如果没有进位数，默认为0）</li>
<li>位数上的数字 = （第一个数 + 第二个数 + 进位数）% 10；</li>
<li>当前位向高位数提供的进位数 = (第一个数 + 第二个数 + 进位数) / 10；</li>
<li>如果最高位计算时，有进位数。则直接把这个进位数作为加和结果的最高位；</li>
</ul>
<p>问题1：我们需要从低位向高位计算，对于链表来说，就是从链表尾节点到头节点计算。BUT，访问链表中的节点只能从头节点到尾节点。</p>
<p>怎么办？</p>
<p>解决手段：使用栈来存储链表各个节点中的值；</p>
<p>原理：链表这种数据容器的存储特征是“先进后出”——这样在从栈中取出数值时，获取到的其实就是链表尾部节点中的数值；</p>
<p>问题2：两个链表的长度可能不一样，如果在同一个循环中通过pop()来取值的话，肯定会有一个栈调用pop()时会抛出”栈为空”的异常；</p>
<p>解决手段：在调用isEmpty()结果为true时（表示栈已经空了），手动为操作数绑定0；</p>
<p>问题3：如果使用循环，在短链表中的节点用完后，如何保证循环继续进行（继续计算加和）？</p>
<p>手段：循环条件 = （链表A节点 != null || 链表B节点 != null);</p>
<p>问题4：即便使用长链表的节点数来控制循环次数（循环中执行操作数的计算），但是最高位在得到进位后，可能会再产生一个进位。这个进位要怎么处理？</p>
<p>手段：把进位carry !=0 添加到循环执行表达式中。这样上述情况下，循环会再执行一次(0 + 0 + 进位1) 的计算。计算后carry==0，循环退出，进位数也被作为最高位添加到链表中</p>
<h4 id="思路SOP"><a href="#思路SOP" class="headerlink" title="思路SOP"></a>思路SOP</h4><p>1 使用两个栈分别存储两个链表中的所有节点；</p>
<p>2 定义一个循环：</p>
<ul>
<li>从栈中弹出值进行计算。得到数位上的数与进位数；</li>
<li>把位数上的数封装到一个节点，并添加到链表中(使用头插法，即最新的节点总是头节点)； head - xxx - null</li>
</ul>
<p>3 循环结束后，循环中创建的链表就是加和结果；</p>
<h4 id="根据思路SOP来进行编码"><a href="#根据思路SOP来进行编码" class="headerlink" title="根据思路SOP来进行编码"></a>根据思路SOP来进行编码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ListNode类型的定义省略</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 鲁棒性代码</span></span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(l2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 定义两个栈</span></span><br><span class="line">        Stack&lt;Integer&gt; stack_l1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Stack&lt;Integer&gt; stack_l2 = <span class="keyword">new</span> Stack&lt;&gt;(); <span class="comment">// 作用：用于分别存储各个链表中的节点</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用栈来存储对应链表中的节点</span></span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack_l1.push(l1.val);</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack_l2.push(l2.val);</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 定义一个循环 循环中：1 得到位数上的数字； 2 使用1中的数字创建节点，并添加到新链表中</span></span><br><span class="line">        ListNode first = <span class="keyword">null</span>; </span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!stack_l1.isEmpty() || !stack_l2.isEmpty() || carry != <span class="number">0</span>)&#123; <span class="comment">// 循环执行条件:</span></span><br><span class="line">            <span class="comment">// 1 获取到操作数</span></span><br><span class="line">            <span class="keyword">int</span> num1 = stack_l1.isEmpty() ? <span class="number">0</span> : stack_l1.pop();</span><br><span class="line">            <span class="keyword">int</span> num2 = stack_l2.isEmpty() ? <span class="number">0</span> : stack_l2.pop();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 2 进行计算，得到数位上的数值remainder 与 进位数字carry</span></span><br><span class="line">            <span class="keyword">int</span> remainder = (num1 + num2 + carry) % <span class="number">10</span>;</span><br><span class="line">            carry = (num1 + num2 + carry) / <span class="number">10</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 3 使用数位上的数值来创建一个新的节点，并添加到first链表中</span></span><br><span class="line">            ListNode curr = <span class="keyword">new</span> ListNode(remainder);</span><br><span class="line">            curr.next = first;</span><br><span class="line">            first = curr;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回创建的新链表的头节点first</span></span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="编码步骤分解"><a href="#编码步骤分解" class="headerlink" title="编码步骤分解"></a>编码步骤分解</h4><ul>
<li>定义两个栈，并把链表中节点的值添加到对应的栈中</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stack&lt;Integer&gt; stack_l1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">Stack&lt;Integer&gt; stack_l2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把链表节点中的值添加到栈中</span></span><br><span class="line"><span class="keyword">while</span>(l1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">    stack_l1.push(l1.val);</span><br><span class="line">    l1 = l1.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">    stack_l2.push(l2.val);</span><br><span class="line">    l2 = l2.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>定义一个循环 循环中：1 得到位数上的数字；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> carry = <span class="number">0</span>; <span class="comment">// 初始化进位数为0	作用：用于个位数的计算</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    <span class="comment">// 1 从栈中获取到当前的操作数</span></span><br><span class="line">    <span class="keyword">int</span> num1 = stack_l1.isEmpty() ? <span class="number">0</span> : stack_l1.pop();</span><br><span class="line">    <span class="keyword">int</span> num2 = stack_l2.isEmpty() ? <span class="number">0</span> : stack_l2.pop();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2 计算操作数，得到位数上的数字</span></span><br><span class="line">    <span class="keyword">int</span> remainder = (num1 + num2 + carry) % <span class="number">10</span>;</span><br><span class="line">    carry = (num1 + num2 + carry) / <span class="number">10</span>; <span class="comment">// 这里需要计算出新的进位数，这样下次遍历时计算结果才能正确</span></span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>2 使用1中的数字创建节点，并添加到新链表中</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">ListNode first = <span class="keyword">null</span>; <span class="comment">// 一个头节点	作用：作为计算结果的链表容器；	特征：头插法</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 头插法</span></span><br><span class="line">    <span class="comment">// 1 创建新节点</span></span><br><span class="line">    ListNode curr = <span class="keyword">new</span> ListNode(remainder);</span><br><span class="line">    <span class="comment">// 2 连接到first指针所指向的节点</span></span><br><span class="line">    curr.next = first;</span><br><span class="line">    <span class="comment">// 3 更新first指针</span></span><br><span class="line">    first = curr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>确定循环执行的表达式</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 由于栈中的每个数字都需要参与计算，所以最终两个栈要都为空</span></span><br><span class="line"><span class="comment">// 对应于表达式: !satck_l1.isEmpty() || !stack_l2.isEmpty()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最高位计算后，可能会有一个进位————这就要求循环体再执行一次，以便把新的进位添加到链表中。</span></span><br><span class="line"><span class="comment">// 进位添加到链表中后，需要对进位进行更新，以便终止循环</span></span><br><span class="line"><span class="comment">// 更新手段：现有代码 carry = (num1 + num2 + carry) / 10; // 这里需要计算出新的进位数，这样下次遍历时计算结果才能正确</span></span><br><span class="line"><span class="comment">// 此时，由于栈都已经空了。所以num1 = 0、num2 = 0、carry = 1（最高位的进位只会为1）</span></span><br><span class="line"><span class="comment">// 更新后carry的值 = 1 / 10; carry = 0</span></span><br><span class="line"><span class="comment">// 从而应该添加新的条件：carry != 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 综上有：循环执行表达式(!stack_l1.isEmpty() || !stack_l2.isEmpty() || carry != 0)</span></span><br><span class="line"><span class="keyword">while</span>(!stack_l1.isEmpty() || !stack_l2.isEmpty() || carry != <span class="number">0</span>)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>返回循环中创建的链表的头节点</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> first;</span><br></pre></td></tr></table></figure>

<ul>
<li>添加鲁棒性代码（或者叫防御性编程代码）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 鲁棒性代码</span></span><br><span class="line"><span class="keyword">if</span>(l1 == <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> l2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(l2 == <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> l1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用设计的测试用例进行功能测试 &amp; 非法输出测试</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 作用：</span></span><br><span class="line"><span class="comment">// 1 保证代码涵对所有可能的合法输入都有效；</span></span><br><span class="line"><span class="comment">// 2 保证对那些个非法输入，代码都做了合适的处理————不会导致程序崩溃；</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p> this is whole loads of thing. until next time 😄</p>
</blockquote>
]]></content>
      <categories>
        <category>ListNode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>交换链表节点_06_2</title>
    <url>/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9%EF%BC%88%E9%80%92%E5%BD%92%E6%96%B9%E5%BC%8F%EF%BC%89_06_2.html</url>
    <content><![CDATA[<h4 id="两两交换链表中的节点（递归方式）"><a href="#两两交换链表中的节点（递归方式）" class="headerlink" title="两两交换链表中的节点（递归方式）"></a>两两交换链表中的节点（递归方式）</h4><hr>
<h4 id="题设与要求"><a href="#题设与要求" class="headerlink" title="题设与要求"></a>题设与要求</h4><p><img src="https://s1.ax1x.com/2020/08/14/dPzGHH.md.png" alt="题设与要求"></p>
<a id="more"></a>

<h4 id="分析（递归的可行性）"><a href="#分析（递归的可行性）" class="headerlink" title="分析（递归的可行性）"></a>分析（递归的可行性）</h4><ul>
<li>问题能够拆解成更小的同类问题吗？<ul>
<li>答：对链表来说，总是可以把链表拆分成: 头节点head + 剩余节点组成的rest链表（这个链表还可以根据情况再去拆分）</li>
</ul>
</li>
<li>更小同类问题的返回值能够用来帮助解决大问题本身吗？<ul>
<li>答：对rest执行swapParis操作后，返回的是一个节点已经两两交换后的新链表。它可以和剩余的节点连接起来，从而得到一个所有节点都已经两两交换的新链表——大问题；</li>
</ul>
</li>
</ul>
<p>结论：这个问题可以使用递归进行解决；</p>
<h4 id="使用递归实现的SOP"><a href="#使用递归实现的SOP" class="headerlink" title="使用递归实现的SOP"></a>使用递归实现的SOP</h4><ul>
<li>1 明确方法的作用与返回值；</li>
<li>2 明确递归的终结条件（根据方法的作用推理）；</li>
<li>3 描述本次递归需要完成的工作</li>
</ul>
<h4 id="按照SOP进行编码"><a href="#按照SOP进行编码" class="headerlink" title="按照SOP进行编码"></a>按照SOP进行编码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1 方法作用：把链表中的节点两两进行交换，并返回节点交换后的新链表	参考：示例</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">swapParis</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 2 递归的终结条件 链表为null、链表中就只有一个节点</span></span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3 本级递归需要完成的事情</span></span><br><span class="line">    <span class="comment">// ① 把链表拆分为：头节点head + 第二个节点second + 剩余节点组成的链表rest</span></span><br><span class="line">    <span class="comment">// 原因：交换节点需要至少两个节点参与，而且我们不能改变swapPair(rest)的返回值</span></span><br><span class="line">    <span class="comment">// ② 对rest执行swapParis()的操作，并获取到返回值swapedRest</span></span><br><span class="line">    <span class="comment">// ③ 对head、second以及swapedRest进行必要的操作，以得到所有节点都已经两两交换的链表</span></span><br><span class="line">    ListNode second = head.next;</span><br><span class="line">    ListNode swapedRest = swapPairs(second.next);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 交换head与second节点</span></span><br><span class="line">    head.next = swapedRest;</span><br><span class="line">    second.next = head;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>启示</p>
</blockquote>
<p>递归大法好，不像递归那样。循环终止条件就能让人💫</p>
<blockquote>
<p>until next time😄</p>
</blockquote>
]]></content>
      <categories>
        <category>ListNode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>交换链表节点(迭代)_06</title>
    <url>/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9(%E8%BF%AD%E4%BB%A3%E6%96%B9%E5%BC%8F)_06.html</url>
    <content><![CDATA[<h3 id="两两交换链表中的节点"><a href="#两两交换链表中的节点" class="headerlink" title="两两交换链表中的节点"></a>两两交换链表中的节点</h3><hr>
<h4 id="题设与要求"><a href="#题设与要求" class="headerlink" title="题设与要求"></a>题设与要求</h4><p><img src="https://s1.ax1x.com/2020/08/14/dP37xf.png" alt="题设与要求"></p>
<a id="more"></a>

<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>要求进行节点之间的两两交换。</p>
<p>如果使用迭代的方式，可以每次处理两个相邻节点之间的连接关系；</p>
<p>然后在下次迭代时，再去处理下一批的两个节点之间的连接关系；</p>
<p>还要处理每个区间（2个节点）之间的连接关系，来保证连接的正确性；</p>
<p>说明：</p>
<p>1 当通过这种分析无法得到有效的突破点时，就只好画图来找找规律了，对自己的想象力不要太自信；</p>
<p>2 翻转操作需要3个指针：两个指针用于指向需要交换的节点，一个指针用于迭代链表；</p>
<blockquote>
<p>画图大法(画图找规律)</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/08/14/dPU7kD.md.jpg" alt="节点的交换过程"></p>
<ul>
<li>通过画图可以看出,可以通过连续翻转节点来实现题设中的“两两节点交换”；</li>
<li>节点翻转需要3个指针：curr指向当前节点、temp指向当前节点的下一个节点；prev指向当前节点的前驱节点（用于更新这三个连续的指针）</li>
<li>可以根据预期的指针情况（图3）与当前的指针情况（图2）来推理出指针更新的手段；prev = curr;</li>
</ul>
<h4 id="代码实现的SOP："><a href="#代码实现的SOP：" class="headerlink" title="代码实现的SOP："></a>代码实现的SOP：</h4><p>1 定义所需要的指针，并初始化指针的原始位置；</p>
<p>2 定义一个循环，在循环中完成以下工作：</p>
<ul>
<li>对指针指向的当前节点区间进行翻转；</li>
<li>更新指针，以便进行下一次的翻转操作；</li>
</ul>
<h4 id="代码实现（虽然SOP不复杂，但是代码实现还是挺讲究的）"><a href="#代码实现（虽然SOP不复杂，但是代码实现还是挺讲究的）" class="headerlink" title="代码实现（虽然SOP不复杂，但是代码实现还是挺讲究的）"></a>代码实现（虽然SOP不复杂，但是代码实现还是挺讲究的）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1 定义需要的指针</span></span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>); <span class="comment">// 作用：指向链表的头节点</span></span><br><span class="line">    dummy.next = head;</span><br><span class="line">    </span><br><span class="line">    ListNode prev = dummy; <span class="comment">// </span></span><br><span class="line">    ListNode curr = head;</span><br><span class="line">    <span class="comment">// ListNode temp = curr.next; // 有点不对劲，因为temp都是在遍历过程中临时更新的		参考：翻转链表的操作</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2 定义一个循环，在循环中： 1 完成当前区间内节点的翻转； 2 更新到下一个翻转区间</span></span><br><span class="line">    <span class="keyword">while</span>(curr != <span class="keyword">null</span> &amp;&amp; curr.next != <span class="keyword">null</span>)&#123; <span class="comment">// 循环终止条件：curr == null(对应于奇数个节点) OR curr.next == null (对应于偶数个节点)</span></span><br><span class="line">        <span class="comment">// 1 获取到当前节点的下一个节点 [curr-temp]</span></span><br><span class="line">        ListNode temp = curr.next;</span><br><span class="line">        </span><br><span class="line">         <span class="comment">// 2 完成当前区间内节点的翻转(需要借助temp节点才能实现)</span></span><br><span class="line">        prev.next = temp;</span><br><span class="line">        curr.next = temp.next;</span><br><span class="line">        temp.next = curr;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3 更新到下一个翻转区间[prev-curr]</span></span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = prev.next;</span><br><span class="line">        <span class="comment">// temp = curr.next;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3 返回链表的头节点</span></span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="代码实现过程SOP分解"><a href="#代码实现过程SOP分解" class="headerlink" title="代码实现过程SOP分解"></a>代码实现过程SOP分解</h4><ul>
<li>定义所需要的指针</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">dummy.next = head;	<span class="comment">// 作用：指向链表的头节点</span></span><br><span class="line"></span><br><span class="line">ListNode prev = dummy; <span class="comment">// 作用：翻转区间内的第一个节点</span></span><br><span class="line">ListNode curr = prev.next; <span class="comment">// 作用：翻转区间内的第二个节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 所需要的辅助节点temp（当前节点的下一个节点），在循环中再临时获取</span></span><br></pre></td></tr></table></figure>

<ul>
<li>定义一个循环，在循环中完成<ul>
<li>当前节点区间的节点翻转；</li>
<li>更新当前节点区间；</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    <span class="comment">// 对当前节点区间中的节点进行翻转</span></span><br><span class="line">    <span class="comment">// ① 获取到当前节点的下一个节点	作用：防止链表断裂</span></span><br><span class="line">    ListNode temp = curr.next;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ② 按照下图流程来实现节点的翻转		参考：👇图</span></span><br><span class="line">    prev.next = temp; </span><br><span class="line">    curr.next = temp.next;</span><br><span class="line">    temp.next = curr;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更新当前的区间节点</span></span><br><span class="line">    prev = curr; <span class="comment">// 更新后的翻转区间第一个节点 参考：“分析”部分</span></span><br><span class="line">    curr = prev.next; <span class="comment">// 更新后的翻转区间第二个节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s1.ax1x.com/2020/08/14/dPLV7q.md.jpg" alt="节点翻转流程"></p>
<ul>
<li><p>确定循环执行的条件</p>
<ul>
<li>循环终止条件（直接根据代码不能NPE来反推）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ListNode temp = curr.next;	<span class="comment">// 因此curr != null</span></span><br><span class="line">...</span><br><span class="line">curr.next = temp.next; <span class="comment">// 因此temp != null aka curr.next != null</span></span><br></pre></td></tr></table></figure>

<p>r u kidding me?</p>
<ul>
<li>循环终止条件（极端情况）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 极端情况：prev为倒数第二个节点、curr为尾节点 此时需要翻转prev与curr之间的指向</span></span><br><span class="line"><span class="comment">// 特征:curr.next == null aka 循环执行条件 curr.next != null</span></span><br><span class="line"><span class="comment">// 为了避免循环中的更新操作导致curr为null SO</span></span><br><span class="line"><span class="keyword">while</span>(curr != <span class="keyword">null</span> &amp;&amp; curr.next != <span class="keyword">null</span>)</span><br></pre></td></tr></table></figure>

<p>不很满意这种说法😳</p>
</li>
<li><p>返回新链表的头节点</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 由于每个节点都只有一个next指针，所以dummy其实连接到了新的链表头部</span></span><br><span class="line"><span class="keyword">return</span> dummy.next;</span><br></pre></td></tr></table></figure>

<ul>
<li>添加鲁棒性代码</li>
<li>编写各种测试用例，测试代码：1 功能是否可用； 2 对于各种非法输出是否有合理的输出/提示信息；</li>
</ul>
<h4 id="代码默写-重现"><a href="#代码默写-重现" class="headerlink" title="代码默写/重现"></a>代码默写/重现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1 定义需要用到的指针</span></span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    dummy.next = head; <span class="comment">// 指向链表的头节点</span></span><br><span class="line">    </span><br><span class="line">    ListNode prev = dummy; <span class="comment">// 翻转区间的第一个节点</span></span><br><span class="line">    ListNode curr = prev.next; <span class="comment">// 翻转区间的第二个节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(curr != <span class="keyword">null</span> &amp;&amp; curr.next != <span class="keyword">null</span>)&#123; <span class="comment">// 烦人的循环执行条件</span></span><br><span class="line">        <span class="comment">// 翻转区间中节点的指向</span></span><br><span class="line">        ListNode temp = curr.next;</span><br><span class="line">        </span><br><span class="line">        prev.next = temp;</span><br><span class="line">        curr.next = temp.next;</span><br><span class="line">        temp.next = curr;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 更新翻转区间</span></span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = curr.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>until next time 😄</p>
</blockquote>
]]></content>
      <categories>
        <category>ListNode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>倒数第k个节点_05_2</title>
    <url>/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E8%8A%82%E7%82%B9%EF%BC%88%E4%B8%80%E6%AC%A1%E9%81%8D%E5%8E%86%EF%BC%89_05_2.html</url>
    <content><![CDATA[<h3 id="删除链表中的倒数第n个节点（一次遍历）"><a href="#删除链表中的倒数第n个节点（一次遍历）" class="headerlink" title="删除链表中的倒数第n个节点（一次遍历）"></a>删除链表中的倒数第n个节点（一次遍历）</h3><h4 id="题设-amp-要求"><a href="#题设-amp-要求" class="headerlink" title="题设 &amp; 要求"></a>题设 &amp; 要求</h4><p><img src="https://s1.ax1x.com/2020/08/14/dCLxyj.png" alt="题设 &amp; 要求"></p>
<a id="more"></a>

<h4 id="分析（难点）"><a href="#分析（难点）" class="headerlink" title="分析（难点）"></a>分析（难点）</h4><p>如何能找到倒数第N个节点（预期节点：此节点的上一个节点）？</p>
<h4 id="思路2（难点的解决方案）"><a href="#思路2（难点的解决方案）" class="headerlink" title="思路2（难点的解决方案）"></a>思路2（难点的解决方案）</h4><ul>
<li>定义两个指针front与back，设置两个指针之间的初始间距。</li>
<li>然后把两个指针同时向后移动，直到front指针到达了链表的尾节点。</li>
<li>这时候back指针就会指在某一个可以计算的位置——通过设置指针间的初始间距，就能确定back指针停下的具体位置。</li>
</ul>
<h4 id="实现SOP"><a href="#实现SOP" class="headerlink" title="实现SOP"></a>实现SOP</h4><ul>
<li>1 定义所需要的指针front与back与dummy（并初始化）；    注：画图分析指针初始化的位置；    原则：方便编码；&amp; 避免NPE；</li>
<li>2 画图分析，front指针与back指针之间的初始间距span与n的关系（span = n）；</li>
<li>3 把front与back指针初始化指向dummy节点(这里引入dummy节点只是为了方便计算指针应该移动的距离)；</li>
<li>4 把front指针向前移动n个节点；</li>
<li>5 把front与back指针同时向后移动，直到front指针指向链表的尾节点；</li>
<li>6 back指向预期节点后，对待删除节点进行删除；</li>
</ul>
<h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 实践证明：在删除的时候使用栈不是一个好主意</span></span><br><span class="line">        <span class="comment">// 鲁棒性代码</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 需要的实例变量</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line"></span><br><span class="line">        ListNode front = dummy;</span><br><span class="line">        ListNode back = dummy;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 先让front向前走n个节点   如果只有一个节点，然后要删除倒数第一个节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123; <span class="comment">// 注：front的初始化值会决定循环执行的次数</span></span><br><span class="line">            front = front.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 再让front与back一起先前移动，直到front到达尾节点</span></span><br><span class="line">        <span class="keyword">while</span>(front != <span class="keyword">null</span> &amp;&amp; front.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            front = front.next;</span><br><span class="line">            back = back.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 这里得到的back就是预期删除的节点的前一个节点</span></span><br><span class="line">        <span class="comment">// 执行删除</span></span><br><span class="line">        back.next = back.next.next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="启示"><a href="#启示" class="headerlink" title="启示"></a>启示</h4><p>1 代码的鲁棒性编码在实现了基本功能后，再进行添加；</p>
<p>2 对于循环执行次数已知的情况，使用for语法来实现循环——这样能避免令人纠结的循环执行/终止条件；</p>
<p>3 编写while循环执行表达式的参考：节点的最终状态； &amp;  避免代码中的NPE；</p>
]]></content>
      <categories>
        <category>ListNode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>倒数第k个节点_05</title>
    <url>/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9(%E4%B8%A4%E6%AC%A1%E9%81%8D%E5%8E%86)_05.html</url>
    <content><![CDATA[<h3 id="删除链表中的倒数第N个节点"><a href="#删除链表中的倒数第N个节点" class="headerlink" title="删除链表中的倒数第N个节点"></a>删除链表中的倒数第N个节点</h3><h4 id="分析（找到问题的难点）："><a href="#分析（找到问题的难点）：" class="headerlink" title="分析（找到问题的难点）："></a>分析（找到问题的难点）：</h4><ul>
<li>对于单向链表，只能从前往后地查找节点；</li>
<li>删除链表节点的常用手段: curr.next = curr.next.next; // 这样就能把curr后面的一个节点从链表中删除掉</li>
</ul>
<a id="more"></a>

<h4 id="思路（解决问题难点）："><a href="#思路（解决问题难点）：" class="headerlink" title="思路（解决问题难点）："></a>思路（解决问题难点）：</h4><p>如果链表的长度已知，就能通过公式（length - N）来求出待删除节点的正向位置。这样就可以执行删除操作了</p>
<p>可能犯错的地方：找错了节点；</p>
<p>根据分析的第二点，我们应该找到的是待删除节点的上一个节点（预期节点）；</p>
<h4 id="实现SOP"><a href="#实现SOP" class="headerlink" title="实现SOP:"></a>实现SOP:</h4><ul>
<li>1 先计算出链表中的节点的总长度；</li>
<li>2 根据公式(length - N)计算出待删除节点的正向位置索引；</li>
<li>3 找到预期节点，然后删除“待删除的节点”；</li>
</ul>
<h4 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ListNode类型的定义省略</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 0 鲁棒性代码</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1 定义需要的指针</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>); <span class="comment">// 备用</span></span><br><span class="line">        dummy.next = head;</span><br><span class="line">        </span><br><span class="line">        ListNode cursor = head;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2 计算链表中节点的总长度</span></span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cursor != <span class="keyword">null</span>)&#123;</span><br><span class="line">            length++;</span><br><span class="line">            cursor = cursor.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3 计算预期节点的位置</span></span><br><span class="line">        <span class="keyword">int</span> expect_postion = length - n;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4 通过迭代的方式找到预期节点</span></span><br><span class="line">        cursor = head; <span class="comment">// 把游标拨回链表头节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i &lt; expect_position; i++)&#123;</span><br><span class="line">            cursor = cursor.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 5 找到预取节点后，对待删除节点执行删除操作</span></span><br><span class="line">        cursor.next = cursor.next.next; <span class="comment">// 由于题设已经保证n是有效的，所以这里不会出现NPE</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 6 返回删除节点后的链表</span></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="添加鲁棒性代码"><a href="#添加鲁棒性代码" class="headerlink" title="添加鲁棒性代码"></a>添加鲁棒性代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">参考 <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>



<h4 id="算法特征"><a href="#算法特征" class="headerlink" title="算法特征"></a>算法特征</h4><p>1 需要两次遍历：第一次遍历用来计算链表中的节点总长度；第二次遍历用来找到“预期的节点”，以便执行删除</p>
<h4 id="优化（只需要进行一次遍历）"><a href="#优化（只需要进行一次遍历）" class="headerlink" title="优化（只需要进行一次遍历）"></a>优化（只需要进行一次遍历）</h4><p>原理：通过前后指针来找到预期位置，而不是用（length - N）的方式。</p>
<blockquote>
<p>until NEXT time 😄</p>
</blockquote>
]]></content>
      <categories>
        <category>ListNode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>链表去重_04_2</title>
    <url>/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%EF%BC%88%E9%80%92%E5%BD%92%E6%96%B9%E5%BC%8F%EF%BC%89_04_2.html</url>
    <content><![CDATA[<h3 id="删除有序链表中的重复元素（递归方式）"><a href="#删除有序链表中的重复元素（递归方式）" class="headerlink" title="删除有序链表中的重复元素（递归方式）"></a>删除有序链表中的重复元素（递归方式）</h3><h4 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h4><p><img src="https://s1.ax1x.com/2020/08/14/dCTVln.png" alt="题设与要求"></p>
<a id="more"></a>

<h4 id="分析（确定思路）"><a href="#分析（确定思路）" class="headerlink" title="分析（确定思路）"></a>分析（确定思路）</h4><ul>
<li><p>使用递归的可行性；</p>
<ul>
<li>问题能够被分解为规模更小的问题吗？</li>
</ul>
<p>答：可以。手段：把链表视为：头节点head + 剩余节点组成的链表rest;</p>
<ul>
<li>可以在更小的问题上应用当前操作，并用它的返回值来帮助解决大问题吗？</li>
</ul>
<p>答：可以。对递归调用的返回值做一些额外的处理，就能得到整个链表删除重复元素之后的结果。</p>
</li>
</ul>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> val)&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1 递归方法的作用：删除链表中的重复元素并返回更新后的链表/头节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 2 递归终结条件 链表为空 OR 链表中就只有一个节点</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3 本级递归需要做的事情</span></span><br><span class="line">        <span class="comment">// ① 把链表视为：头节点head + 剩余节点构成的链表rest；</span></span><br><span class="line">        <span class="comment">// ② 对rest链表执行删除重复节点的操作（假设已经有一个功能可用的API）；</span></span><br><span class="line">        <span class="comment">// ③ 对返回值进行必要的处理</span></span><br><span class="line">        ListNode rest = deleteDuplicates(head.next); <span class="comment">// ② </span></span><br><span class="line">        <span class="keyword">if</span>(head.val == rest.val)&#123; <span class="comment">// 头节点的值与rest头节点的值相等... 重复了</span></span><br><span class="line">             <span class="comment">// 更新head指针</span></span><br><span class="line">             head = rest;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 把rest连接到head上</span></span><br><span class="line">            head.next = rest;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回新链表的头节点</span></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="代码实现步骤SOP分解"><a href="#代码实现步骤SOP分解" class="headerlink" title="代码实现步骤SOP分解"></a>代码实现步骤SOP分解</h4><ul>
<li>确定递归的可行性</li>
<li>确定递归方法的作用与返回值</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1 递归方法的作用：删除链表中的重复元素并返回更新后的链表/头节点</span></span><br></pre></td></tr></table></figure>



<ul>
<li>确定递归方法的终结条件</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2 递归终结条件 链表为空 OR 链表中就只有一个节点</span></span><br><span class="line"><span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br></pre></td></tr></table></figure>

<ul>
<li>确定本级递归需要完成的事情</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 3 本级递归需要做的事情</span></span><br><span class="line"><span class="comment">// ① 把链表视为：头节点head + 剩余节点构成的链表rest；</span></span><br><span class="line"><span class="comment">// ② 对rest链表执行删除重复节点的操作（假设已经有一个功能可用的API）；</span></span><br><span class="line"><span class="comment">// ③ 对返回值进行必要的处理</span></span><br><span class="line">ListNode rest = deleteDuplicates(head.next); <span class="comment">// ② </span></span><br><span class="line"><span class="keyword">if</span>(head.val == rest.val)&#123; <span class="comment">// 头节点的值与rest头节点的值相等... 重复了</span></span><br><span class="line">    <span class="comment">// 更新head指针</span></span><br><span class="line">    head = rest;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 把rest连接到head上</span></span><br><span class="line">    head.next = rest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>返回正确链表的头指针（最好画图确认）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回新链表的头节点</span></span><br><span class="line"><span class="keyword">return</span> head;</span><br></pre></td></tr></table></figure>



<h4 id="启示"><a href="#启示" class="headerlink" title="启示"></a>启示</h4><p>在分析递归可行的情况下，对递归调用的返回值还需要进一步处理。</p>
<p>基本的原则是：使用递归调用的返回值来解决本级递归所需要解决的问题；</p>
<blockquote>
<p>until next time 😄</p>
</blockquote>
]]></content>
      <categories>
        <category>ListNode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>链表去重_04</title>
    <url>/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0(%E8%BF%AD%E4%BB%A3%E6%96%B9%E5%BC%8F)_04.html</url>
    <content><![CDATA[<h3 id="删除排序链表中的重复元素"><a href="#删除排序链表中的重复元素" class="headerlink" title="删除排序链表中的重复元素"></a>删除排序链表中的重复元素</h3><hr>
<h4 id="题目要求："><a href="#题目要求：" class="headerlink" title="题目要求："></a>题目要求：</h4><p><img src="https://s1.ax1x.com/2020/08/14/dCy9C8.png" alt="题目要求"></p>
<p><img src="https://s1.ax1x.com/2020/08/14/dCguPP.png" alt="测试用例示例"></p>
<a id="more"></a>

<h4 id="题设分析："><a href="#题设分析：" class="headerlink" title="题设分析："></a>题设分析：</h4><ul>
<li>1 链表已经是有序的了，aka，重复的元素会相邻在一起；</li>
<li>2 删除元素时，只需要删除重复多次的部分，使元素只会出现一次；</li>
</ul>
<h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>最直观的方式：</p>
<ul>
<li>遍历整个链表，逐个比较当前节点curr与当前节点的下一个节点next的值。</li>
<li>如果curr.val == next.val,就想办法删除掉当前节点；</li>
<li>如果不相等，就更新curr指针，以便迭代下一个节点；</li>
</ul>
<h4 id="代码实现的SOP"><a href="#代码实现的SOP" class="headerlink" title="代码实现的SOP"></a>代码实现的SOP</h4><ul>
<li>创建一个指针curr，初始化为链表的头节点head；    作用：用于迭代链表；</li>
<li>创建一个指针dummy,初始化为null； 作用：用于指向链表的头节点，方便返回更新后的链表；</li>
<li>循环链表中的每一个节点，判断节点是否是重复节点；<ul>
<li>如果是，删除此节点；</li>
<li>如果不是，继续执行循环，直到所有节点都已经被遍历了</li>
</ul>
</li>
</ul>
<h4 id="完整的代码实现"><a href="#完整的代码实现" class="headerlink" title="完整的代码实现"></a>完整的代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    </span><br><span class="line">    ListNode(<span class="keyword">int</span> val)&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 1 定义需要的指针</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        </span><br><span class="line">        ListNode curr = head;</span><br><span class="line">        <span class="comment">// 2 遍历链表中的每一个节点，判断是否为重复节点，并执行相应的操作</span></span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="keyword">null</span> &amp;&amp; curr.next != <span class="keyword">null</span>)&#123; <span class="comment">// 循环执行条件：当前节点与当前节点的下一个节点都不为null	根据画图的边界条件推导 并使用代码中可能的NPE来验证</span></span><br><span class="line">            <span class="keyword">if</span>(curr.val == curr.next.val)&#123;</span><br><span class="line">                curr.next = curr.next.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                curr = curr.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3 遍历完成后，返回新链表的头节点</span></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="实现过程SOP"><a href="#实现过程SOP" class="headerlink" title="实现过程SOP"></a>实现过程SOP</h4><ul>
<li><p>定义需要的指针</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1 定义需要的指针</span></span><br><span class="line">ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);	</span><br><span class="line">dummy.next = head; <span class="comment">// dummy指针	作用：指向链表的头节点，方便无脑地返回链表的头节点</span></span><br><span class="line"></span><br><span class="line">ListNode curr = head; <span class="comment">// 作用：在链表中遍历所有节点（结合循环）</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>定义一个循环，在循环中执行判重与删除操作 &amp; 迭代链表的操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">	<span class="keyword">if</span>(curr.val == curr.next.val)&#123; <span class="comment">// 判重</span></span><br><span class="line">        <span class="comment">// 删除</span></span><br><span class="line">        curr.next = curr.next.next; <span class="comment">// 把当前节点连接到下下个节点上</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        curr = curr.next; <span class="comment">// 更新指针	作用：实现遍历链表</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>确定循环()表达式的内容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 临界情况：比较倒数第一与倒数第二个节点，判断倒数第一个节点是否需要删除</span></span><br><span class="line"><span class="comment">// curr为倒数第二个节点，curr.next为倒数第一个节点</span></span><br><span class="line"><span class="comment">// 为了循环能够正常执行，要求两个节点均不为null</span></span><br><span class="line"><span class="keyword">while</span>(curr != <span class="keyword">null</span> &amp;&amp; curr.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>确定方法的返回值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 由于定义了指向原始链表头节点的指针dummy,而且没有改变链表中的连接方向，SO</span></span><br><span class="line"><span class="keyword">return</span> dummy.next; <span class="comment">// 直接返回dummy的下一个节点 aka 链表的头节点</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="代码重现"><a href="#代码重现" class="headerlink" title="代码重现"></a>代码重现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicats</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1 定义所需要的指针</span></span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    dummy.next = head;</span><br><span class="line">    </span><br><span class="line">    ListNode curr = dummy;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2 迭代链表中的节点，并完成必要的操作</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(curr.val == curr.next.val)&#123;</span><br><span class="line">            curr.next = curr.next.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 这里必须要有else字句，因为链表中可能出现连续重复的节点</span></span><br><span class="line">            <span class="comment">// 更新指针指向下一个节点</span></span><br><span class="line">            curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3 返回更新后的节点</span></span><br><span class="line">    <span class="keyword">return</span> dummy.next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>until next time 😄</p>
</blockquote>
]]></content>
      <categories>
        <category>ListNode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>合并链表_03_2</title>
    <url>/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%EF%BC%88%E9%80%92%E5%BD%92%E6%96%B9%E5%BC%8F%EF%BC%89_03_2.html</url>
    <content><![CDATA[<h3 id="合并两个有序链表（递归方式）"><a href="#合并两个有序链表（递归方式）" class="headerlink" title="合并两个有序链表（递归方式）"></a>合并两个有序链表（递归方式）</h3><hr>
<p><img src="https://s1.ax1x.com/2020/08/11/aOHNlD.png" alt="题目要求"></p>
<a id="more"></a>

<h4 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h4><ul>
<li><p>使用递归的可行性；</p>
<p>把第一个链表叫做l1，第二个链表叫做l2。可以把 l1 分解为（head + rest）,然后拿rest与l2进行合并操作，合并得到的结果再连接到head；</p>
<p>结论：可行</p>
</li>
<li><p>递归三部曲回顾：</p>
<p>1 方法的作用与返回值；</p>
<p>2 递归的终结条件（根据方法的作用推演）；</p>
<p>3 本级递归需要完成的工作（假设已经有了一个功能完整实现的API）；</p>
</li>
</ul>
<hr>
<h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>一旦确定是可以递归的，这种方式需要关注的细节其实很少</p>
<hr>
<h4 id="完整实现"><a href="#完整实现" class="headerlink" title="完整实现"></a>完整实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ListNode定义的代码省略（参考其他文章）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1 作用：合并两个有序的列表，并返回合并后的列表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 2 递归终结条件</span></span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(l2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3 本级递归需要做的事情</span></span><br><span class="line">        <span class="comment">// ① 比较两个原始链表的头节点谁更小，对更小的那个链表进行拆分；</span></span><br><span class="line">        <span class="comment">// ② 把拆分后的rest链表与原始链表中的另一个进行合并操作，得到新的链表tempMerge</span></span><br><span class="line">        <span class="comment">// ③ 再对head头节点与tempMerge进行合并</span></span><br><span class="line">        <span class="keyword">if</span>(l1.val &lt; l2.val)&#123;</span><br><span class="line">            l1.next = mergeTwoLists(l1.next, l2); <span class="comment">// 把得到的新链表直接连接到头节点上</span></span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l2.next = mergeTwoLists(l2.next, l1);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h4><p>参考代码中的1、2、3</p>
<hr>
<h4 id="启示"><a href="#启示" class="headerlink" title="启示"></a>启示</h4><p>递归的代码真的非常简洁（不需要考虑很多的边界细节），而且只要确定可行性，代码一般不会太复杂</p>
<blockquote>
<p>until next time😄</p>
</blockquote>
]]></content>
      <categories>
        <category>ListNode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>翻转链表_02_2</title>
    <url>/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E9%93%BE%E8%A1%A8%E7%BF%BB%E8%BD%AC%E4%B9%8B%E9%80%92%E5%BD%92%E8%A7%A3%E6%B3%95_02_2.html</url>
    <content><![CDATA[<h3 id="链表翻转之递归解法"><a href="#链表翻转之递归解法" class="headerlink" title="链表翻转之递归解法"></a>链表翻转之递归解法</h3><a id="more"></a>

<hr>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>并不是所有的情况都能使用递归解决，能用递归解决的问题需要有两个特征：</p>
<ul>
<li>1 能够通过某种方式把问题的规模变小；</li>
<li>2 对于1中更小规模的问题，可以使用同样的操作去处理它；</li>
</ul>
<p>现在先看看“翻转链表”这样的操作是不是符合上面的两个特征：</p>
<h5 id="能够通过某种方式把问题的规模变小"><a href="#能够通过某种方式把问题的规模变小" class="headerlink" title="能够通过某种方式把问题的规模变小"></a>能够通过某种方式把问题的规模变小</h5><p>由于链表本身就是递归的结构，所以总是可以把链表分为：头节点head + 剩余节点所组成的链表rest；</p>
<h5 id="对于更小规模的问题，可以使用同样的操作去处理它"><a href="#对于更小规模的问题，可以使用同样的操作去处理它" class="headerlink" title="对于更小规模的问题，可以使用同样的操作去处理它"></a>对于更小规模的问题，可以使用同样的操作去处理它</h5><p>在对rest做翻转操作后，我们就能得到一个已经翻转了的链表。接下来就只要想办法把头节点head连接进来即可</p>
<hr>
<h4 id="使用递归的三部曲"><a href="#使用递归的三部曲" class="headerlink" title="使用递归的三部曲"></a>使用递归的三部曲</h4><ul>
<li><p>1 明确方法的作用与返回值；</p>
</li>
<li><p>2 找到递归的终结条件——这个条件会停止递归，并开始弹出调用栈；</p>
</li>
<li><p>3 确定本级递归需要完成的工作；（这时候要假设已经有了功能可用的API给自己调用）</p>
</li>
</ul>
<p>注：一般而言，递归方法可以按照这3步来编写。但不尽然，有些递归方法的实现可能会surprise us</p>
<hr>
<h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 0 作用：翻转指定的链表，并返回链表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1 递归的终结条件</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 本级递归需要做的事情</span></span><br><span class="line">        <span class="comment">// ① 把链表视为：头节点 + 剩下节点组成的链表rest</span></span><br><span class="line">        <span class="comment">// ② 对rest中的节点执行翻转操作————翻转后，rest指向新链表的头节点</span></span><br><span class="line">        ListNode rest = reverseList(head.next);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ③ 把原始的头节点连接到新链表的尾节点</span></span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rest;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="代码重现"><a href="#代码重现" class="headerlink" title="代码重现"></a>代码重现</h4><blockquote>
<p>step0 画个图，理清思路；需要什么东西，应该做怎样的操作；</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/08/11/aOaGT0.md.jpg" alt="递归下的链表"></p>
<blockquote>
<p>step1 确定方法的作用与返回值；</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法作用：翻转链表，并返回翻转后的链表；</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>step2 编写递归终结条件；</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实现翻转链表的最简情况是什么？ 答：空链表或者只有一个节点的链表</span></span><br><span class="line"><span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head; <span class="comment">// 这两种情况可以分开写，一起写只是为了让代码简洁一些</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>step3 本级递归需要做的事情；</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	① 把链表拆分为：头节点head + 剩下的节点所组成的链表rest;</span></span><br><span class="line"><span class="comment">	② 对rest链表执行“翻转”操作————翻转后的链表头节点为旧链表的尾节点；</span></span><br><span class="line"><span class="comment">	③ 处理head节点与rest链表，使得整个链表中的所有节点都被翻转；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 对rest链表执行“翻转”操作</span></span><br><span class="line">ListNode rest = reverseList(head.next);</span><br><span class="line"><span class="comment">// 把head节点添加到rest链表的末尾</span></span><br><span class="line">head.next.next = head;</span><br><span class="line"><span class="comment">// 为head连接一个null——表示链表结束</span></span><br><span class="line">head.next = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<h4 id="测试用例（检查代码功能与代码的健壮性）"><a href="#测试用例（检查代码功能与代码的健壮性）" class="headerlink" title="测试用例（检查代码功能与代码的健壮性）"></a>测试用例（检查代码功能与代码的健壮性）</h4><ul>
<li>极端情况下，功能是否正常工作； 传入的链表为空/只有一个节点</li>
</ul>
<h4 id="启示"><a href="#启示" class="headerlink" title="启示"></a>启示</h4><p>链表节点之间的关系，最好画张图比较容易弄清楚。</p>
<p>比如“把head连接到rest链表的末尾”这一步，刚开始我是想沿着链表找到rest的尾节点，然后再连接到head</p>
<p>但如果画图就能看出来，获取rest链表尾节点可以用head.next；</p>
<p>拆解一下head.next.next = head;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取到rest的尾节点</span></span><br><span class="line">ListNode lastOfRest = head.next;</span><br><span class="line"><span class="comment">// 把获取到的尾节点连接到head上</span></span><br><span class="line">lastOfRest.next = head;</span><br><span class="line"><span class="comment">// 把head连接到一个null	这一步必须有，否则head与lastOfRest节点之间就会有环出现 这会导致报错</span></span><br><span class="line">head.next = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>until next time 😄</p>
</blockquote>
]]></content>
      <categories>
        <category>ListNode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>合并链表_03</title>
    <url>/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8-%E5%BE%97%E5%88%B0%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%EF%BC%88%E8%BF%AD%E4%BB%A3%E6%96%B9%E5%BC%8F%EF%BC%89_03.html</url>
    <content><![CDATA[<h3 id="合并两个有序链表，得到一个新的有序链表（迭代方式）"><a href="#合并两个有序链表，得到一个新的有序链表（迭代方式）" class="headerlink" title="合并两个有序链表，得到一个新的有序链表（迭代方式）"></a>合并两个有序链表，得到一个新的有序链表（迭代方式）</h3><a id="more"></a>



<h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>1 创建一个链表就只需要想某个节点上不断连接其他节点就行了；</p>
<p>2 对两个链表对应位置节点的值进行比较，把较小的节点先连接到链表中；</p>
<p>3 如果出现某一个链表中的节点比较多（另一个链表中的节点已经用完了），直接把链表剩余的节点连接到正在创建的链表上就行了（因为剩余的这些节点都已经是有序的了，并且值也更大）</p>
<hr>
<h4 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h4><p>1 创建链表就只需要一个指针就可以；    </p>
<p>创建链表的SOP:</p>
<ul>
<li>1 连接到下一个节点；</li>
<li>2 更新当前指针到下一个节点；以便重复步骤1</li>
</ul>
<p>2 为了方便比较两个链表对应位置上的节点，这里需要添加一个假节点dummy；它总是指向链表的头节点</p>
<hr>
<h4 id="根据上面的分析尝试写代码"><a href="#根据上面的分析尝试写代码" class="headerlink" title="根据上面的分析尝试写代码"></a>根据上面的分析尝试写代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> val)&#123; <span class="keyword">this</span>.val = val;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 准备指针，用于生成链表</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>); <span class="comment">// 指向链表的头节点</span></span><br><span class="line">        ListNode cursor = dummy; <span class="comment">// 用于不管更新链表的指针</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 迭代并比较两个链表中节点的大小，并根据比较结果把节点连接到链表中</span></span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>)&#123; <span class="comment">// 循环执行条件：haed to describe</span></span><br><span class="line">            <span class="keyword">if</span>(l1.val &lt; l2.val)&#123;</span><br><span class="line">                <span class="comment">// 创建链表step1：连接到下一个节点</span></span><br><span class="line">                cursor.next = l1;</span><br><span class="line">                <span class="comment">// 更新l1链表的指针到下一个位置	作用：实现迭代</span></span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 作用同上</span></span><br><span class="line">                cursor.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 创建链表step2：更新链表的指针	作用：方便连接到下一个节点</span></span><br><span class="line">            cursor = cursor.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// always safe to use this to refer the ListNode, cus it always point to the first node of the ListNode</span></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h4><p>step1 定义需要的指针</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>); <span class="comment">// 方便新链表的创建</span></span><br><span class="line">ListNode cursor = dummy; <span class="comment">// cursor的意思是游标，我感觉比起指针更形象一些	用于创建新链表</span></span><br></pre></td></tr></table></figure>



<p>step2 通过迭代的方式，遍历两个子链表中的指针，并连接到新链表中；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">	<span class="keyword">if</span>(l1.val &lt; l2.val)&#123;</span><br><span class="line">		<span class="comment">// 为新链表连接到下一个节点	扩展新链表</span></span><br><span class="line">		cursor.next = l1;</span><br><span class="line">		<span class="comment">// 找到原始链表中的下一个节点 用于比较两个原始链表之间的节点</span></span><br><span class="line">		l1 = l1.next;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		cursor.next = l2;</span><br><span class="line">		l2 = l2.next;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 更新cursor指针	用于扩展链表</span></span><br><span class="line">	cursor = cursor.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>step3 确定循环执行条件的表达式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1 当表达式的值为true时，循环执行；</span></span><br><span class="line"><span class="comment">// 2 循环的作用：为新链表连接一个新节点，并且做一些方便连接下一个节点的操作</span></span><br><span class="line"><span class="comment">// 3 当某个链表的节点用尽时，应该终止循环：因为这时候不再需要进行节点间的比较</span></span><br><span class="line"><span class="comment">// 4 链表节点用尽的情况：l1 == null、l2 == null</span></span><br><span class="line"><span class="comment">// 这两种情况之间的逻辑关系是什么？只要有一个成立，循环就应该终止。对应地，为了让循环执行，应该两者都不为null aka l1 != null &amp;&amp; l2 != null</span></span><br><span class="line"><span class="keyword">while</span>(l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>)&#123; ... &#125;  <span class="comment">// this is truly a piece of work</span></span><br></pre></td></tr></table></figure>



<p>step4 处理某个原始链表中没有添加进新链表的节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 为什么出现节点没有被添加的情况？ 因为另外一个链表中的节点已经用完了，它里面的节点值都比较小</span></span><br><span class="line"><span class="comment">// 如何确定是哪一个链表的节点没有被用完？ 没有被用完的链表指针不为null</span></span><br><span class="line"><span class="comment">// 如何处理没有被添加的节点？ 直接连接到新链表中即可 找对节点</span></span><br><span class="line"><span class="comment">// 这时候最好边看着操作图，边编写代码 	因为某些边界条件很容易弄错</span></span><br><span class="line"><span class="keyword">if</span>(l1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">    cursor.next = l2;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span>(l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">    cursor.next = l1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>step5 返回创建的新链表的头节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> dummy.next;</span><br></pre></td></tr></table></figure>



<p>step6 编写基础测试用例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">main()&#123;</span><br><span class="line">	<span class="comment">// 测试用例代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>step7 添加鲁棒性代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 鲁棒性代码一般添加在开始的地方，来对参数进行校验</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>until next time😄</p>
</blockquote>
]]></content>
      <categories>
        <category>ListNode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>交换链表节点_02_1</title>
    <url>/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E5%AF%B9%E9%93%BE%E8%A1%A8%E8%BF%9B%E8%A1%8C%E7%BF%BB%E8%BD%AC(%E8%BF%AD%E4%BB%A3%E6%96%B9%E5%BC%8F)_02_1.html</url>
    <content><![CDATA[<h3 id="对链表进行翻转（使用迭代的方式）"><a href="#对链表进行翻转（使用迭代的方式）" class="headerlink" title="对链表进行翻转（使用迭代的方式）"></a>对链表进行翻转（使用迭代的方式）</h3><hr>
<p><img src="https://s1.ax1x.com/2020/08/11/aLKOne.png" alt="翻转链表"></p>
<a id="more"></a>

<hr>
<h3 id="分析-👇👇👇"><a href="#分析-👇👇👇" class="headerlink" title="分析:👇👇👇"></a>分析:👇👇👇</h3><h4 id="节点翻转示意图"><a href="#节点翻转示意图" class="headerlink" title="节点翻转示意图"></a>节点翻转示意图</h4><p><img src="https://s1.ax1x.com/2020/08/11/aL1MgP.md.jpg" alt="节点翻转示意图"></p>
<p>1 既然是要翻转链表，那每个节点的连接方向都会发生变化；</p>
<p>2 每个节点都只能有一个连接。当它指向自己的前一个节点时，它就不能再指向自己的下一个节点；</p>
<p>3 需要处理链表中的每一个节点，但是根据2可知，节点连接方向改变后，无法再沿着链表获取到下一个节点；</p>
<p>解决手段：在改变节点的连接方向之前，使用一个临时变量保存当前节点的下一个节点；</p>
<blockquote>
<p>实现SOP</p>
</blockquote>
<p>1 为了能够遍历链表，我们需要一个指针；</p>
<p>2 为了能够改变节点的连接方向，我们需要另一个指针来指向当前节点的前一个节点；</p>
<blockquote>
<p>完整代码(不包含测试用例，可以自己编写main()函数作为测试用例)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 链表/节点的类定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val; <span class="comment">// 节点中存储的值</span></span><br><span class="line">    ListNode next; <span class="comment">// 节点连接到的下一个节点</span></span><br><span class="line">    ListNode(<span class="keyword">int</span> x) &#123;val = x;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 0 作用：翻转指定的链表，并返回链表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 迭代的方式</span></span><br><span class="line">        ListNode prev = <span class="keyword">null</span>; </span><br><span class="line">        ListNode curr = head; <span class="comment">// 翻转链表需要前后两个指针：一个用于更新头节点，一个用于创建链表的连接</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 记录原始的下一个节点 防止链表断掉</span></span><br><span class="line">            ListNode temp = curr.next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 建立链表的连接</span></span><br><span class="line">            curr.next = prev;</span><br><span class="line">            <span class="comment">// 更新两个指针</span></span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="实现过程☕☕☕"><a href="#实现过程☕☕☕" class="headerlink" title="实现过程☕☕☕"></a>实现过程☕☕☕</h3><h4 id="step1-定义两个指针，用来遍历和翻转链表；"><a href="#step1-定义两个指针，用来遍历和翻转链表；" class="headerlink" title="step1 定义两个指针，用来遍历和翻转链表；"></a>step1 定义两个指针，用来遍历和翻转链表；</h4><p>问题：如何初始化这两个指针？/这两个指针最开始应该指向什么位置？</p>
<p>答：参考上面的 [链表翻转示意图](#### 节点翻转示意图)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ListNode prev = <span class="keyword">null</span>; <span class="comment">// 初始化指向一个null节点</span></span><br><span class="line">ListNode curr = head; <span class="comment">// 初始化指向链表的头节点（head与curr一样，都是头节点的一个指针）</span></span><br></pre></td></tr></table></figure>



<h4 id="step2-遍历链表中的节点，并进行节点间的翻转；（每次翻转两个节点的连接）"><a href="#step2-遍历链表中的节点，并进行节点间的翻转；（每次翻转两个节点的连接）" class="headerlink" title="step2 遍历链表中的节点，并进行节点间的翻转；（每次翻转两个节点的连接）"></a>step2 遍历链表中的节点，并进行节点间的翻转；（每次翻转两个节点的连接）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123; <span class="comment">// 循环终止条件一般是比较容易出错的地方，所以放在最后再完成</span></span><br><span class="line">	<span class="comment">// 1 保存当前节点的下一个节点		作用：这样在遍历时才能直到下一个节点是哪一个</span></span><br><span class="line">    Node temp = curr.next;</span><br><span class="line">    <span class="comment">// 2 把当前节点连接到当前节点的前一个节点		说明：这个相邻节点的关系需要手动维护</span></span><br><span class="line">    curr.next = prev;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3 维护相邻节点的关系	作用：支持2</span></span><br><span class="line">    prev = curr;</span><br><span class="line">    <span class="comment">// 4 更新当前节点为当前节点的下一个节点		作用：实现遍历链表操作</span></span><br><span class="line">    curr = curr.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="step3-确定循环终止条件"><a href="#step3-确定循环终止条件" class="headerlink" title="step3 确定循环终止条件"></a>step3 确定循环终止条件</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">分析极端情况：</span></span><br><span class="line"><span class="comment">	1 当前节点指针指向链表的尾节点（非null）时，还需要一次循环来翻转last与其上一个节点之间的连接方向；</span></span><br><span class="line"><span class="comment">	2 当前节点指针指向null时，所有翻转都已经完成，循环结束；</span></span><br><span class="line"><span class="comment">	所以循环终止条件为：curr == null;		相应地，(表达式)就应该为curr != null</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">while</span>(curr != <span class="keyword">null</span>)&#123;...&#125;</span><br></pre></td></tr></table></figure>



<h4 id="step4-确定返回值"><a href="#step4-确定返回值" class="headerlink" title="step4 确定返回值"></a>step4 确定返回值</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原则：总是应该返回预期链表的头节点</span></span><br><span class="line"><span class="comment">// 手段：查看循环终止时，各个指针的指向情况		翻转后链表的头节点应该是prev</span></span><br><span class="line"><span class="keyword">return</span> prev;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="代码重现-🦇🦇🦇"><a href="#代码重现-🦇🦇🦇" class="headerlink" title="代码重现 🦇🦇🦇"></a>代码重现 🦇🦇🦇</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    </span><br><span class="line">    ListNode(<span class="keyword">int</span> x)&#123; <span class="keyword">this</span>.val = x&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> <span class="title">Solution</span>(<span class="title">ListNode</span> <span class="title">head</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 定义两个指针并初始化	作用：用于连接与遍历</span></span><br><span class="line">    ListNode prev = <span class="keyword">null</span>;</span><br><span class="line">    ListNode curr = head;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 开始遍历，并在遍历的过程中进行节点连接的翻转</span></span><br><span class="line">    <span class="keyword">while</span>(curr != <span class="keyword">null</span>)&#123; <span class="comment">// 循环执行条件</span></span><br><span class="line">        <span class="comment">// 记录当前节点（开始时是头节点）的下一个节点	作用：实现遍历</span></span><br><span class="line">        ListNode temp = curr.next;</span><br><span class="line">        <span class="comment">// 更新当前节点的连接</span></span><br><span class="line">        curr.next = prev; <span class="comment">// 连接到前一个节点	说明：需要维护这种节点的相邻关系</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 维护节点的相邻关系 &amp; 实现遍历</span></span><br><span class="line">        prev = curr; <span class="comment">// 1 把prev指向curr所指向的节点</span></span><br><span class="line">        curr = temp; <span class="comment">// 2 更新curr到链表的下一个节点	由于节点的连接方向已经变化，所以不能使用curr.next 使用预先存储的节点temp</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回链表的头节点</span></span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="启示"><a href="#启示" class="headerlink" title="启示"></a>启示</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">知道为什么这么写后，才能把思路翻译成代码。不然就是在背代码了</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>ListNode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>两个链表的交点_01</title>
    <url>/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E6%B1%82%E4%B8%A4%E4%B8%AA%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E4%BA%A4%E7%82%B9_01.html</url>
    <content><![CDATA[<h3 id="求两个相交链表的交点"><a href="#求两个相交链表的交点" class="headerlink" title="求两个相交链表的交点"></a>求两个相交链表的交点</h3><hr>
<p><img src="https://s1.ax1x.com/2020/08/11/aLZ7UP.png" alt="图片无法显示"></p>
<a id="more"></a>

<p><strong>要求</strong></p>
<ul>
<li>如果两个链表没有交点，返回null</li>
<li>返回结果后，两个链表必须仍保持原有的结构；</li>
<li>默认链表中不存在环；</li>
<li>尽量满足O(n)的时间复杂度与O(1)的空间复杂度。</li>
</ul>
<hr>
<p>思路：</p>
<p>既然两个链表有长度差异，计算出差出来的长度，想办法消除这个多余长度的影响。就可以一一比较节点了</p>
<p>手段SOP：</p>
<p>1 为两个链表的头节点分别添加一个指针；</p>
<p>2 计算出链表之间的长度差异，然后让较长的那个链表的游标向后移动等长的节点；</p>
<p>3.再让两个游标同步移动，并比较所指向节点是否相等。直到找到相等/相交的节点或者到达链表的末端</p>
<hr>
<p>把上述SOP翻译成代码：</p>
<ol>
<li>先定义表示链表的类型；</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以直接作为一个内部类与Solution类定义在同一个文件中</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x)&#123;</span><br><span class="line">        val = x;</span><br><span class="line">        next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="2">
<li>实现上述SOP（完整实现 + 分解动作）</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123; <span class="comment">// 两个链表结构</span></span><br><span class="line">        <span class="comment">// 最优解法（目前）：1 先计算出两个链表直接的长度差距； 2 再使用两个前后指针解决问题</span></span><br><span class="line">        <span class="comment">// 原理：1 起点相同的两个人，沿同一个方向以相同的速度移动。每时每刻，两个人都在同一个位置上；</span></span><br><span class="line">        <span class="comment">// 2 当两个链表相遇时，节点就重合了</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 鲁棒性代码</span></span><br><span class="line">        <span class="keyword">if</span>(headA == <span class="keyword">null</span> || headB == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode cursorA = headA;</span><br><span class="line">        ListNode cursorB = headB;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算headA与headB的长度</span></span><br><span class="line">        <span class="keyword">int</span> lengthA = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cursorA!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            lengthA++;</span><br><span class="line">            cursorA = cursorA.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> lengthB = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cursorB!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            lengthB++;</span><br><span class="line">            cursorB = cursorB.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算出两个链表之间的距离差————这个就是哨兵指针需要前进的节点数</span></span><br><span class="line">        <span class="keyword">int</span> diff = lengthA - lengthB; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里问题来了，我们需要确定一个信息：哪个链表更长？（这样才能正确地设置指针）</span></span><br><span class="line">        <span class="comment">// 手段：先假设A更长，然后根据真实情况进行更新</span></span><br><span class="line">        ListNode fronter = headA;</span><br><span class="line">        ListNode follower = headB;</span><br><span class="line">        <span class="keyword">if</span>(diff &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            fronter = headB;</span><br><span class="line">            follower = headA;</span><br><span class="line"></span><br><span class="line">            diff = lengthB - lengthA;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 让fronter指针先向前走diff个节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; diff; i++)&#123;</span><br><span class="line">            fronter = fronter.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 让fronter和follwer同时沿着节点先前移动，并比较节点是否为同一个节点</span></span><br><span class="line">        ListNode firstCommon = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(follower != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fronter == follower)&#123;</span><br><span class="line">                firstCommon = fronter;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fronter = fronter.next;</span><br><span class="line">            follower = follower.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> firstCommon;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<ol start="3">
<li>分解实现过程</li>
</ol>
<p>step1 定义两个指针，分别指向两个链表的头节点；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ListNode cursorA = headA;</span><br><span class="line">ListNode cursorB = headB;</span><br></pre></td></tr></table></figure>



<p>step2 计算headA链表与headB链表的长度；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> lengthA = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(cursorA != <span class="keyword">null</span>)&#123;</span><br><span class="line">	lengthA++;</span><br><span class="line">	cursorA = cursorA.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> lengthB = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(cursorB != <span class="keyword">null</span>)&#123;</span><br><span class="line">	lengthB++;</span><br><span class="line">	cursorB = cursorB.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>step3 计算两个链表之间的节点数量差;这个值就是长链表的指针需要前进的距离</p>
<blockquote>
<p>问题来了，怎么知道哪个链表更长呢？为了向前移动指针，一定需要一个正数；</p>
<p>手段：先绑定值，再通过判断来更新值；（其实就是if/else）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> diff = lengthA - lengthB;</span><br><span class="line"></span><br><span class="line">ListNode fronter = headA;</span><br><span class="line">ListNode follower = headB;</span><br><span class="line"><span class="keyword">if</span>(diff &lt; <span class="number">0</span>)&#123;</span><br><span class="line">	fronter = headB;</span><br><span class="line">	follower = headA;</span><br><span class="line">	</span><br><span class="line">	diff = lengthB - lengthA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>step4 把长链表的指针沿着链表向前移动diff个节点；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 让fronter指针先向前走diff个节点</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; diff; i++)&#123;</span><br><span class="line">   	fronter = fronter.next;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<p>step5 同时移动长链表的指针fronter与短链表的指针follower，并比较指针指向的节点是否是同一个节点；</p>
<p>直到（这个循环终止的条件）：1 找到了两个链表的第一个交点； 2 迭代到了链表的尾部，没有任何交点；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ListNode firstCommon = <span class="keyword">null</span>; <span class="comment">// 用于存储找到的第一个节点</span></span><br><span class="line"><span class="keyword">while</span>(fronter != <span class="keyword">null</span>)&#123;</span><br><span class="line">	<span class="keyword">if</span>(fronter == follower)&#123;</span><br><span class="line">		firstCommon = fronter;</span><br><span class="line">		<span class="keyword">break</span>; <span class="comment">// 找到了第一个交点</span></span><br><span class="line">	&#125;</span><br><span class="line">	fronter = fronter.next;</span><br><span class="line">	follower = follower.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>step6 把找到的交点节点返回；（如果没有交点，firstCommon的值不会被更新，也就是为null）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> firstCommon;</span><br></pre></td></tr></table></figure>



<p>step7 检查所有的变量名拼写；（在编辑器没有智能提示的情况下，拼写很容易出错）</p>
<p>step8 添加鲁棒性代码，增强代码的健壮性；最常见的就是参数判空</p>
<blockquote>
<p>启示：虽然把所有的成员变量写在一起看上去很规整，但是看代码的时候却不能重现写代码时的思路；</p>
<p>所以最好在需要变量的时候才添加这些变量，并且写在需要的地方。这会增加可读性</p>
</blockquote>
]]></content>
      <categories>
        <category>ListNode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Web应用第一谈（请求处理的中枢DispatcherServlet）</title>
    <url>/uncategorized/2020/05/17/Spring%20Web%E5%BA%94%E7%94%A8%E7%AC%AC%E4%B8%80%E8%B0%88%EF%BC%88%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E7%9A%84%E4%B8%AD%E6%9E%A2DispatcherServlet%EF%BC%89.html</url>
    <content><![CDATA[<p>Spring Web应用第一谈（请求处理的中枢DispatcherServlet）</p>
<hr>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Web应用？</span><br><span class="line">是：一个能够提供CURD功能的程序；</span><br><span class="line">作用：为用户提供服务；</span><br><span class="line">特征：</span><br><span class="line">	<span class="number">1</span> 用户通过浏览器来访问应用中的功能；</span><br><span class="line">	<span class="number">2</span> 程序需要运行在一个Web容器中（这样它才能被用户访问到）；</span><br><span class="line">	<span class="number">3</span> 用户不需要安装任何东西，他只需要一个能够访问网络的浏览器；</span><br></pre></td></tr></table></figure>



<h4 id="1-SpringMVC框架对一个URL请求的处理流程"><a href="#1-SpringMVC框架对一个URL请求的处理流程" class="headerlink" title="1.SpringMVC框架对一个URL请求的处理流程"></a>1.SpringMVC框架对一个URL请求的处理流程</h4><hr>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">SpringMVC处理URL请求的流程：</span><br><span class="line">1 请求发送给DispatcherServlet；</span><br><span class="line">	作用：DS作为一个前端控制器，把请求委托给应用程序的其他组件</span><br><span class="line">2 DispatcherServlet查询处理器映射（<span class="keyword">Handler</span> <span class="keyword">Mapping</span>）来确定把请求发送给哪一个映射器(Hanlder)进行处理；</span><br><span class="line">	</span><br><span class="line"><span class="number">3</span> 根据查询的结果，DS把请求发送给指定的映射器(<span class="keyword">Handler</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">4</span> 控制器把处理后的<span class="keyword">model</span>数据与视图名称(<span class="keyword">View</span>)发送给DS；</span><br><span class="line"></span><br><span class="line"><span class="number">5</span> DispatcherServlet使用视图解析器（ViewResolver）来通过视图名称找到对应的视图文件；</span><br><span class="line"></span><br><span class="line"><span class="number">6</span> DS把<span class="keyword">model</span>渲染到视图文件中，并最终返回到用户浏览器上;</span><br></pre></td></tr></table></figure>

<h5 id="Q1-不就是处理个请求吗？不应该最多两步吗？SpringMVC怎么一下搞了这么多有的没的，设计者是咋想的？-○´･д･-ﾉ"><a href="#Q1-不就是处理个请求吗？不应该最多两步吗？SpringMVC怎么一下搞了这么多有的没的，设计者是咋想的？-○´･д･-ﾉ" class="headerlink" title="#Q1 不就是处理个请求吗？不应该最多两步吗？SpringMVC怎么一下搞了这么多有的没的，设计者是咋想的？(○´･д･)ﾉ"></a>#Q1 不就是处理个请求吗？不应该最多两步吗？SpringMVC怎么一下搞了这么多有的没的，设计者是咋想的？(○´･д･)ﾉ</h5><h5 id="A1-DS其实在这个过程中，相当于是一个前端控制器。作用就是委托请求，有点子想Nginx"><a href="#A1-DS其实在这个过程中，相当于是一个前端控制器。作用就是委托请求，有点子想Nginx" class="headerlink" title="#A1 DS其实在这个过程中，相当于是一个前端控制器。作用就是委托请求，有点子想Nginx"></a>#A1 DS其实在这个过程中，相当于是一个前端控制器。作用就是委托请求，有点子想Nginx</h5><p>配张图，描述整个过程：</p>
<p>​    Web 请求 —&gt; DispatcherServlet - (!@#$%^)</p>
<hr>
<h4 id="2-创建SpringMVC的请求处理系统"><a href="#2-创建SpringMVC的请求处理系统" class="headerlink" title="2.创建SpringMVC的请求处理系统"></a>2.创建SpringMVC的请求处理系统</h4><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">--</span><br><span class="line"><span class="number">1</span> 配置DispatcherServlet；</span><br><span class="line">作用：把URL请求路由到具体的Spring组件中；</span><br><span class="line">手段<span class="number">1</span>：在web.xml中对DS进行配置</span><br><span class="line">手段<span class="number">2</span>：使用java类对DS进行配置（aka 在Servlet容器中声明前端控制器）</span><br><span class="line">参考：HelloWorldInitializer.java</span><br><span class="line"></span><br><span class="line">--</span><br><span class="line"><span class="number">2</span> 启用SpringMVC,并添加视图解析器的配置</span><br><span class="line">手段：添加注解@EnableWebMvc</span><br><span class="line">参考：WebConfig.java</span><br><span class="line"></span><br><span class="line"><span class="number">3</span> 创建管理其他非Web组件的上下文contextLoaderListener</span><br><span class="line">参考：RootConfig.java</span><br><span class="line"></span><br><span class="line">注：RootConfig先于WebConfig执行，所以：</span><br><span class="line">	<span class="number">1</span> 预期交给WebConfig管理的组件需要在RootConfig中过滤掉；</span><br><span class="line">	<span class="number">2</span> WebConfig中的Bean所依赖的组件可以在RootConfig中先行声明；</span><br></pre></td></tr></table></figure>

<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">说明：直接导入书上的源码到IDEA中运行会各种报错（百度无果的报错）；</span><br><span class="line">最终按照外网上的一个教程，搭建Web项目运行成功。</span><br><span class="line">参考链接：<span class="keyword">http</span>://websystique.com/springmvc/spring<span class="number">-4</span>-mvc-helloworld-tutorial-annotation-javaconfig-full-example/</span><br><span class="line"></span><br><span class="line">然后按照Spring实战书上的代码对项目进行更新，发现书上的代码是可以工作的。</span><br><span class="line">踩坑报错：xxx</span><br><span class="line">原因：一般测试某种手段是否可行时，我都会把原有文件拷贝一份，命名为xxx_backup.java。这样才测试方案不可行时能够快速恢复到初始状态。</span><br><span class="line">但是对Controller类来说，这种做法会导致<span class="built_in">URL</span>的歧义性</span><br><span class="line">参考:Servlet规范<span class="title">_05</span>(本地文件 如何引用？)</span><br><span class="line">引用：既然应用的上下文路径决定了Web应用中内容的<span class="built_in">URL</span>命名空间，Web容器必须要拒绝web应用定义一个在此<span class="built_in">URL</span>命名空间中可能导致冲突的上下文路径</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-1-按照控制器的方式来对控制器进行测试"><a href="#2-1-按照控制器的方式来对控制器进行测试" class="headerlink" title="2.1 按照控制器的方式来对控制器进行测试"></a>2.1 按照控制器的方式来对控制器进行测试</h5><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">需求：按照控制器的方式来测试控制器：</span><br><span class="line">SOP：</span><br><span class="line">    <span class="number">1</span> 创建控制器对象；</span><br><span class="line">    手段：<span class="built_in">new</span></span><br><span class="line">    <span class="number">2</span> 创建SpringMvc mock对象；</span><br><span class="line">    手段：standaloneSetup(xxx).build()		这是Spring框架test模块中的一个静态方法</span><br><span class="line">    <span class="number">3</span> 使用mock对象发起请求并验证响应结果；</span><br><span class="line">    手段：<span class="keyword">perform</span>()方法[执行] + andExcept()方法[断言预期结果]		同样是test框架提供的方法</span><br><span class="line">特征：不需要启动Tomcat就能能够对控制器进行测试；</span><br><span class="line">参考：HomeControllerTest.java</span><br><span class="line">结果：报错“java.lang.NoSuchMethodError: org.springframework.util.StreamUtils.emptyInput()Ljava/io/InputStream;”</span><br><span class="line">解决参考：https://blog.csdn.net/weixin_30487317/article/details/<span class="number">95601425</span></span><br><span class="line">原因：test的版本与spring-mvc版本不一致</span><br><span class="line">解决手段：test的版本参考spring-mvc的版本</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-2-把模型数据传递到视图中"><a href="#2-2-把模型数据传递到视图中" class="headerlink" title="2.2 把模型数据传递到视图中"></a>2.2 把模型数据传递到视图中</h5><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">需求：把模型数据传递到视图中</span></span><br><span class="line"><span class="attr">SOP</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">1</span> <span class="string">定义用来与数据库交互的接口SpittleRepository；</span></span><br><span class="line">    <span class="attr">2</span> <span class="string">定义域数据表对应的实体类Spittle；</span></span><br><span class="line">    <span class="attr">3</span> <span class="string">编写针对于新的Controller控制器的测试类；</span></span><br><span class="line">    <span class="attr">参考：SpittleControllerTest.java</span></span><br><span class="line">    <span class="attr">4</span> <span class="string">编写新的控制器Controller</span></span><br><span class="line"><span class="attr">为什么先编写测试类，后编写控制器？？？😳</span></span><br></pre></td></tr></table></figure>

<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">编写完成后，重启Tomcat时，项目启动失败；</span><br><span class="line">报错：找不到指定的bean；</span><br><span class="line">原因：</span><br><span class="line">    原理：</span><br><span class="line">    Spring对不同类型的组件，创建的时机会不一样；</span><br><span class="line">        <span class="number">1</span> 对于Web相关的组件（aka 控制器对象），由DispatcherServlet所创建的上下文(WebConfig)管理；</span><br><span class="line">        <span class="number">2</span> 其他类型的组件（比如dao层的对象），由ContextLoaderListener所创建的上下文（RootConfig）进行管理；</span><br><span class="line">        <span class="number">3</span> RootConfig先于WebConfig执行，它服务于整个项目；</span><br><span class="line">    具体原因：</span><br><span class="line">        在RootConfig扫描的时候就扫描到controller中的类：</span><br><span class="line">            <span class="number">1</span> bean初始化就要找自动装填的 实现SpitterRepository接口的对象(A)，</span><br><span class="line">            <span class="number">2</span> 但我把A放在WebConfig里了，环境中找不到这个Bean，于是报错。</span><br><span class="line">        所以我在RootConfig中的ComponentScan里添加了过滤，不扫描spittr.web，这样controller中的bean就不会在NoSuchBean的情况下提前初始化了，启动成功。</span><br><span class="line">    同样的原因，SpittleRepository的声明应该放在RootConfig中，否则控制器初始化时也会找不到依赖Bean而报错</span><br><span class="line">参考：https:<span class="comment">//blog.csdn.net/q5738415/article/details/78197508</span></span><br></pre></td></tr></table></figure>

<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line">这里虽然有dao层的执行方法，但是却并没有配置数据库。它是怎么实现的呢？</span><br><span class="line"><span class="params">...</span> <span class="keyword">to</span> be continue <span class="params">...</span></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-3-向控制器方法发送请求时携带参数"><a href="#2-3-向控制器方法发送请求时携带参数" class="headerlink" title="2.3 向控制器方法发送请求时携带参数"></a>2.3 向控制器方法发送请求时携带参数</h5><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">需求：向控制器发送请求时携带参数；</span><br><span class="line">参数类型（按功能分类）：</span><br><span class="line">    <span class="number">1</span> 查询参数；</span><br><span class="line">    <span class="number">2</span> 表单参数；</span><br><span class="line">    <span class="number">3</span> 路径变量；</span><br></pre></td></tr></table></figure>



<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--</span></span><br><span class="line">1 控制器接收查询参数： /spittles/<span class="keyword">show</span>?spittle_id=<span class="number">12345</span></span><br><span class="line">需求：分页列表展示xxx</span><br><span class="line">手段：调用控制器方法时，传入两个参数————页面中第一个xxx的<span class="keyword">ID</span> + 页面中xxx的总条数；</span><br><span class="line">    <span class="keyword">before</span>参数：当前页面xxx列表的左边界；</span><br><span class="line">    <span class="keyword">count</span>参数：当前页面中要包含的xxx数量</span><br><span class="line">实现方法： com.websystique.springmvc.controller.SpittleController.spittles()方法</span><br><span class="line">测试:shouldShowPagedSpittles()</span><br></pre></td></tr></table></figure>



<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">--</span><br><span class="line"><span class="number">2</span> 控制器接收路径参数：/spittles/<span class="number">12345</span></span><br><span class="line">特征：</span><br><span class="line">    <span class="number">1</span> 这种描述方式更加面向资源：<span class="number">12345</span>就是要查询的资源</span><br><span class="line">    <span class="number">2</span> 查询参数的描述方式表示：这是一个带有参数的操作；（通过HTTP发起的RPC）</span><br><span class="line">-</span><br><span class="line">先编写测试方法：</span><br><span class="line">参考：testSpittle()</span><br><span class="line">测试方法fail？？？</span><br><span class="line"></span><br><span class="line">项目访问URL：失败<span class="number">400</span></span><br><span class="line">这都是因为热部署延迟 😳</span><br><span class="line"></span><br><span class="line">-</span><br><span class="line">进入方法后，跳转视图页面时。报错<span class="number">404.</span>..</span><br><span class="line">/spring_mvc/spittles/WEB-INF/views/spittle.jsp</span><br><span class="line">在其他的控制器方法中都可以正常跳转，为什么这个方法就不行？</span><br><span class="line">原因：在配置视图解析器时，没有添加前缀/</span><br><span class="line">参考：https:<span class="comment">//blog.csdn.net/xujin_chen/article/details/53557463</span></span><br><span class="line">原理：不晓得😵[又是半夜无眠]</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-4-向控制器方法发送请求时携带表单参数"><a href="#2-4-向控制器方法发送请求时携带表单参数" class="headerlink" title="2.4 向控制器方法发送请求时携带表单参数"></a>2.4 向控制器方法发送请求时携带表单参数</h5><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">需求：向控制器发送请求时携带表单数据；</span><br><span class="line">实现手段：</span><br><span class="line">    <span class="number">1</span> 处理用户通过表单提交的数据；</span><br><span class="line">    参考：show<span class="constructor">RegistrationForm()</span>方法</span><br><span class="line">    完整流程SOP:</span><br><span class="line">        <span class="number">1</span> 编写控制器方法的测试方法：<span class="module-access"><span class="module"><span class="identifier">SpitterController</span>.</span></span>show<span class="constructor">RegistrationForm()</span></span><br><span class="line">        <span class="number">2</span> 编写视图文件；registerForm.jsp</span><br><span class="line">        <span class="number">3</span> 编写表单提交到的控制器方法 aka 保存表单的控制器方法；<span class="module-access"><span class="module"><span class="identifier">SpitterController</span>.</span></span>processRegistration</span><br><span class="line">        <span class="number">4</span> 编写保存表单的方法的测试方法：should<span class="constructor">ProcessRegistration()</span></span><br><span class="line">        <span class="number">5</span> 编写保存表单后所跳转到的控制器方法；  show<span class="constructor">SpitterProfile()</span></span><br><span class="line">        <span class="number">6</span> 编写控制器方法跳转到的对应页面：profile.jsp</span><br><span class="line">访问链接：http:<span class="comment">//localhost:8088/spring_mvc/spitter/jbauer</span></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-5-对表单中的字段值进行校验"><a href="#2-5-对表单中的字段值进行校验" class="headerlink" title="2.5 对表单中的字段值进行校验"></a>2.5 对表单中的字段值进行校验</h5><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">需求：对表单中的字段值进行校验；</span><br><span class="line">校验类型：</span><br><span class="line">    <span class="number">1</span> 字段值不能为空；</span><br><span class="line">    <span class="number">2</span> 字段值的长度不能超过指定边界；</span><br><span class="line">手段<span class="number">1</span>：在控制方法中对用户提交的表单字段进行逐一验证；</span><br><span class="line">手段<span class="number">2</span>：java校验API接口（SpringMVC框架支持此接口）；</span><br><span class="line">具体方法SOP：</span><br><span class="line">    <span class="number">1</span> 在类路径下包含Java校验API接口的具体实现（比如Hibernate Validator）：</span><br><span class="line">        手段：引用jar包</span><br><span class="line">    <span class="number">2</span> 在java类的属性上添加所需要的注解；</span><br><span class="line">        手段：@NotNull、@Size</span><br><span class="line">    <span class="number">3</span> 在控制器方法中启用校验功能；</span><br><span class="line">        手段：为方法的POJO类型参数添加 @Valid 注解————通知Spring对此参数进行校验；</span><br><span class="line">    <span class="number">4</span> 在控制器方法中处理校验未通过的错误</span><br><span class="line">        手段：使用Errors对象来获取到校验失败的具体信息；</span><br><span class="line">特征：</span><br><span class="line">    <span class="number">1</span> 即便校验没有通过，用户仍旧能够提交表单。aka 控制器方法仍旧会被调用</span><br><span class="line">    <span class="number">2</span> 为了使Errors对象能够获取到校验失败的信息，需要让Errors参数紧跟在@Valid注解的参数后面</span><br><span class="line">    <span class="number">3</span> 在控制器方法中，第一步就应该查看是否出现校验错误————如果校验有错，后面的逻辑就不用再执行了</span><br><span class="line">参考：SpitterController.processRegistration()</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-6-java校验API"><a href="#2-6-java校验API" class="headerlink" title="2.6 java校验API"></a>2.6 java校验API</h5><figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">Java校验API：</span><br><span class="line">作用：对Java类的属性进行校验；</span><br><span class="line">手段：提供多个用于特定校验规则的注解；</span><br><span class="line">用法：把特定的注解放到属性上，就能够限制属性的值。</span><br><span class="line">特征：所有的这些个注解都在javax.validation.constraints包中提供；</span><br><span class="line">常用的校验注解：</span><br><span class="line">    <span class="symbol">@NotNull</span>：限制被注解的属性的值不能为<span class="literal">null</span></span><br><span class="line">    <span class="symbol">@Size</span>：限制被注解的属性的值必须是<span class="built_in">String</span>、数组或者集合，并且长度要符合给定的范围；</span><br><span class="line">参考：Spitter类 （这是Spittr应用的用户）</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-额外收获"><a href="#3-额外收获" class="headerlink" title="3.额外收获"></a>3.额外收获</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">有趣的点：</span></span><br><span class="line">    <span class="number">1</span> <span class="string">SpitterRepository接口的实现类是在WebConfig中配置Bean的时候实现的：</span></span><br><span class="line">        <span class="string">如果没提供这个实现类。创建Controller时注入依赖就会失败</span></span><br><span class="line">    <span class="number">2</span> <span class="string">这里的save()方法并没有把值存储到数据库中，而是添加到一个map对象中。</span></span><br><span class="line">        <span class="string">尽管对象会在每次重启JVM时消失，但是作为一个容器，它是可以当成临时数据库来使用的</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">小结：</span><br><span class="line">大需求：编写应用程序的Web部分；</span><br><span class="line">手段：使用SpringMVC框架（这是Spring框架的一个模块）；</span><br><span class="line">特征：</span><br><span class="line">    <span class="number">1</span> 这种开发方式几乎就是在写POJO类；</span><br><span class="line">    <span class="number">2</span> 编写控制器方法与编写普通java方法无异，唯一的区别在于————你要想办法让方法能够接收到页面发来的参数</span><br><span class="line">    <span class="number">3</span> SpringMVC编写的控制器非常容易测试；</span><br><span class="line">    手段：Mockito框架 + Spring test模块</span><br><span class="line">NexT？</span><br><span class="line">Spring视图相关的一堆东西</span><br></pre></td></tr></table></figure>













]]></content>
  </entry>
  <entry>
    <title>Spring AOP第二谈（与AspectJ AOP的对比）</title>
    <url>/uncategorized/2020/05/11/Spring%20AOP%E7%AC%AC%E4%BA%8C%E8%B0%88%EF%BC%88%E4%B8%8EAspectJ%20AOP%E7%9A%84%E5%AF%B9%E6%AF%94%EF%BC%89.html</url>
    <content><![CDATA[<p>Spring AOP第二谈（与AspectJ AOP的对比）</p>
<hr>
<h4 id="1-AOP的实现方案"><a href="#1-AOP的实现方案" class="headerlink" title="1.AOP的实现方案"></a>1.AOP的实现方案</h4><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">方案<span class="number">1</span>：Spring AOP；</span><br><span class="line">方案<span class="number">2</span>：AspectJ；</span><br><span class="line">特征：AspectJ提供了很多其他的切点类型（Spring AOP只能提供方法调用的切点类型）</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="2-在创建对象时应用指定的通知"><a href="#2-在创建对象时应用指定的通知" class="headerlink" title="2. 在创建对象时应用指定的通知"></a>2. 在创建对象时应用指定的通知</h4><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">需求：在创建对象时应用指定的通知；</span><br><span class="line">说明：创建对象需要调用<span class="keyword">Bean的构造器，但是Spring </span>AOP无法指定这样的连接点/切点类型</span><br><span class="line">为什么Spring AOP实现不了呢？</span><br><span class="line">答：因为它基于代理实现，只能做一些方法层面的操作；</span><br><span class="line">手段：使用AspectJ提供的AOP功能；</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="3-管理由AspectJ创建的切面bean所依赖的Spring组件"><a href="#3-管理由AspectJ创建的切面bean所依赖的Spring组件" class="headerlink" title="3. 管理由AspectJ创建的切面bean所依赖的Spring组件"></a>3. 管理由AspectJ创建的切面bean所依赖的Spring组件</h4><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">说明：一个通知方法可能需要依赖其他的类来实现功能。</span><br><span class="line">需求：管理通知方法所依赖的其他类</span><br><span class="line">手段：把通知方法所依赖的<span class="keyword">Bean注入到切面类中</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">--</span></span><br><span class="line"><span class="keyword">需求：为演出创建一个评论员的角色；</span></span><br><span class="line"><span class="keyword">功能：观看演出，并在观看完成后提出一些批评意见</span></span><br><span class="line"><span class="keyword">参考：CriticAspect </span>+ CriticismEngine + CriticismEngineImpl + <span class="keyword">bean_declare_xmlconfig</span></span><br><span class="line"><span class="keyword">特征：</span></span><br><span class="line"><span class="keyword"> </span>   <span class="number">1</span> AspectJ切面不需要Spring就可以织入到我们的应用中<span class="comment">;</span></span><br><span class="line">    <span class="number">2</span> 但是如果想要使用Spring来管理AspectJ的一些个依赖，就需要把AspectJ切面来声明成一个Spring <span class="keyword">bean</span></span><br><span class="line"><span class="keyword"> </span>   参考：<span class="keyword">bean_declare_xmlconfig.xml</span></span><br><span class="line"><span class="keyword"> </span>   <span class="number">3</span> AspectJ切面<span class="keyword">bean不是Spring容器创建的，而是AspectJ在运行时创建的；</span></span><br><span class="line"><span class="keyword"> </span>   <span class="number">4</span> 为了能够在Spring中获取到AspectJ切面的实例，需要调用切面类的aspectOf()方法————此方法返回切面类的一个单例</span><br></pre></td></tr></table></figure>



<h4 id="4-AOP小结"><a href="#4-AOP小结" class="headerlink" title="4.AOP小结"></a>4.AOP小结</h4><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line"><span class="comment">------</span></span><br><span class="line">AOP：</span><br><span class="line">是：一种编程方式；</span><br><span class="line">作用：把分散在应用各处的行为集中在一个模块中（方便管理），并作为重用模块（方便引用）</span><br><span class="line">特征：</span><br><span class="line">    <span class="number">1</span> 使程序员编写的类更加简洁、准确；</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">需求：支持AOP形式的编程风格；</span><br><span class="line">Spring提供的手段：Spring AOP；</span><br><span class="line">原理：</span><br><span class="line">    在程序员进行必要的操作后，Spring AOP会创建一个代理类，在代理类中把切面插入到目标方法执行的周围；</span><br><span class="line">必要的操作：</span><br><span class="line">    <span class="number">1</span> 程序员通过自定义切面来声明预期插入到目标类/方法中的功能；</span><br><span class="line">    <span class="number">2</span> 程序员通过编写切点表达式来声明应用切面中的通知；</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">应用：</span><br><span class="line">    <span class="number">1</span> 把通知织入/应用前置、后置和环绕方法的调用中；</span><br><span class="line">    <span class="number">2</span> 为异常处理添加自定义的行为————抛出异常时的通知方法；</span><br><span class="line">    <span class="number">3</span> 与DI一起，支持程序员创建松散耦合的应用</span><br><span class="line">用法SOP:</span><br><span class="line">    <span class="number">1</span> 声明切面类；</span><br><span class="line">    <span class="number">2</span> 配置切面类中的通知方法（when + where + what）</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>SpringAOP第一谈（术语 &amp; SOP）</title>
    <url>/uncategorized/2020/05/11/SpringAOP%E7%AC%AC%E4%B8%80%E8%B0%88%EF%BC%88%E6%9C%AF%E8%AF%AD%20&amp;%20SOP%EF%BC%89.html</url>
    <content><![CDATA[<p>面向切面编程AOP第一谈：术语 &amp; Java配置方式 &amp; XML配置方式</p>
<hr>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">面向切面编程；</span><br><span class="line"></span><br><span class="line">是：一种编程方式；</span><br><span class="line"></span><br><span class="line">作用：</span><br><span class="line"></span><br><span class="line">​	<span class="number">1</span> 分离应用程序中的业务逻辑点与横切关注点；</span><br><span class="line"></span><br><span class="line">​	<span class="number">2</span> 使业务逻辑点的代码更加简洁清晰；</span><br><span class="line"></span><br><span class="line">​	<span class="number">3</span> 使所有的横切关注点能够集中起来，方便管理；</span><br><span class="line"></span><br><span class="line">特征：</span><br><span class="line"></span><br><span class="line">​	<span class="number">1</span> 通过声明的方式来引用切面中的通知方法到指定的目标方法；</span><br><span class="line"></span><br><span class="line">​	<span class="number">2</span> 切面类是一个POJO类；</span><br></pre></td></tr></table></figure>





<hr>
<h4 id="1-切点"><a href="#1-切点" class="headerlink" title="1.切点"></a>1.切点</h4><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">切点：</span><br><span class="line">作用：定义切面实际作用到的代码位置；</span><br><span class="line">原理：选择切点表达式所匹配到的连接点；</span><br><span class="line">手段：使用AspectJ的切点表达式定义切点；</span><br><span class="line">特征：</span><br><span class="line">    <span class="number">1</span> Spring仅仅支持AspectJ切点指示器的一个子集；</span><br><span class="line">    <span class="number">2</span> Spring所支持的指示器中：</span><br><span class="line">        只有execution指示器是用来执行匹配的；</span><br><span class="line">        其他的指示器都只是限制匹配的；</span><br><span class="line">    <span class="number">3</span> execution指示器是编写切点时，最常使用到的指示器；</span><br></pre></td></tr></table></figure>



<p>1.1 定义切点</p>
<p>手段：编写切点表达式；</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="comment">---</span></span><br><span class="line">任务：编写切点表达式；</span><br><span class="line">前提：需要一个主题————应用切面的目标；</span><br><span class="line">参考：Performance.java</span><br><span class="line"></span><br><span class="line"><span class="comment">--</span></span><br><span class="line">连接点：Performance接口中的<span class="keyword">perform</span>()方法</span><br><span class="line">需求：当<span class="keyword">perform</span>()被调用时，触发自定义的通知；</span><br><span class="line">手段：编写一个切点表达式；</span><br><span class="line">execution(* concert.Performance.<span class="keyword">perform</span>(..))</span><br><span class="line">语义：在方法执行时触发 不关心方法的返回值类型 方法的全限定名(任意参数)</span><br><span class="line">作用：通过此切点表达式，选择了连接点为Performance的<span class="keyword">perform</span>()方法</span><br><span class="line"></span><br><span class="line"><span class="comment">--</span></span><br><span class="line">需求：通过切点表达式的多个规则来选择多个连接点</span><br><span class="line">手段：切点表达式A &amp;&amp; 切点表达式B</span><br><span class="line">具体表达式：execution(* concert.Performance.<span class="keyword">perform</span>(..)) &amp;&amp; <span class="keyword">within</span>(concert.*)</span><br><span class="line"><span class="keyword">within</span>()指示器用来限制连接点匹配指定的类型</span><br><span class="line">&amp;&amp;/<span class="keyword">and</span> 表示连接点必须匹配所有的指示器</span><br><span class="line"></span><br><span class="line"><span class="comment">--</span></span><br><span class="line">任务：在切点中选择指定的Bean</span><br><span class="line">原理：使用bean ID或bean名称来选择指定的bean</span><br><span class="line">需求：执行Performance的<span class="keyword">perform</span>()方法时来应用通知，但是仅限于bean ID为woodstock的bean实例上的方法调用</span><br><span class="line">手段：bean()指示器</span><br><span class="line">切点表达式：</span><br><span class="line">    execution(* concert.Performance.<span class="keyword">perform</span>(..)) <span class="keyword">and</span> bean(<span class="string">'woodstock'</span>)</span><br><span class="line"></span><br><span class="line">需求：限制bean ID不为woodstock的bean实例上，执行xxx方法时，应用通知；</span><br><span class="line">切点表达式：</span><br><span class="line">    execution(* concert.Performance.<span class="keyword">perform</span>(..)) <span class="keyword">and</span> !bean(<span class="string">'woodstock'</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-定义切面（通知-切点）"><a href="#2-定义切面（通知-切点）" class="headerlink" title="2.定义切面（通知 + 切点）"></a>2.定义切面（通知 + 切点）</h4><p>手段：编写切面类；</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">任务：编写切面类；</span><br><span class="line">手段：编写POJO类，然后使用AspectJ5提供的注解声明它是一个切面类；</span><br><span class="line">默念：插入切面、应用/织入通知、选择连接点、匹配切点</span><br><span class="line">应用：对于一场演出来说，观众就可以视为一个切面（可以单独分离出来的功能）；</span><br><span class="line">SOP:</span><br><span class="line">    Ⅰ 声明切面类及通知细节</span><br><span class="line">    <span class="number">1</span> 通过@Aspect注解来声明一个作为切面的类；</span><br><span class="line">    <span class="number">2</span> 在类中定义通知方法：功能实现 + 应用时机；</span><br><span class="line">    <span class="number">3</span> 如果出现了同一个切点表达式被多次书写的情况，把切点表达式单独使用@Pointcut注解定义为一个方法————导出调用</span><br><span class="line">    参考：Audience.java</span><br><span class="line">    ---</span><br><span class="line">    Ⅱ 告诉Spring为定义为切面的类创建代理：</span><br><span class="line">    手段：启用自动代理功能；</span><br><span class="line">    具体方法<span class="number">1</span>：如果使用java类来配置的话，注解@EnableAspectJAutoProxy</span><br><span class="line">        参考：ConcertConfig.java</span><br><span class="line">    具体方法<span class="number">2</span>：使用xml文件配置，aop:aspectj-<span class="built_in">auto</span>proxy标签</span><br><span class="line">        参考：aspect-audience-config.xml</span><br><span class="line">    作用：</span><br><span class="line">        <span class="number">1</span> AspectJ自动代理会给bean创建一个代理————这个代理会包围切点所匹配的bean，以提供切面的功能</span><br><span class="line">        <span class="number">2</span> Audience切面类中的通知方法会在切点所指定的连接点perform()方法调用的前后执行[<span class="keyword">this</span> <span class="keyword">is</span> the <span class="keyword">final</span> propose]</span><br></pre></td></tr></table></figure>



<hr>
<p>Spring对AOP的实现：Spring AOP</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">特征：</span><br><span class="line">    <span class="number">1</span> 使用@AspectJ来声明切面类；</span><br><span class="line">    <span class="number">2</span> 只能够对方法调用这样的操作进行通知；因为代理类就只能对方法的调用进行代理</span><br><span class="line">原理：为被通知的类创建一个代理类，在代理类中实现目标对象的增强（通知方法）</span><br></pre></td></tr></table></figure>



<h5 id="1-为目标方法创建一个环绕通知"><a href="#1-为目标方法创建一个环绕通知" class="headerlink" title="1.为目标方法创建一个环绕通知"></a>1.为目标方法创建一个环绕通知</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">创建环绕通知（round</span> <span class="string">advice）</span></span><br><span class="line"><span class="string">作用：使用自定义的逻辑包围被通知的目标方法；</span> <span class="string">aka</span> <span class="string">前置通知</span> <span class="string">+</span> <span class="string">后置通知</span></span><br><span class="line"><span class="string">应用参考：aop.Audience.watchPerformance()环绕通知方法</span></span><br></pre></td></tr></table></figure>



<h5 id="2-在通知方法中使用目标方法中的参数"><a href="#2-在通知方法中使用目标方法中的参数" class="headerlink" title="2.在通知方法中使用目标方法中的参数"></a>2.在通知方法中使用目标方法中的参数</h5><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">issue：当被通知的目标方法有参数时，通知方法要怎样才能使用这些参数呢？</span><br><span class="line">需求：记录光盘中某个磁道被播放的次数</span><br><span class="line">手段<span class="number">1</span>：在play<span class="constructor">Track()</span>方法中添加一个计数器————每次play<span class="constructor">Track()</span>方法被调用后，都更新计数器的值；</span><br><span class="line">手段<span class="number">2</span>：既然这个需求与播放磁道是不同的任务，把这个需求放在切面中来完成；</span><br><span class="line">参考：<span class="module-access"><span class="module"><span class="identifier">TrackCounter</span>.</span></span>java</span><br><span class="line">验证：</span><br><span class="line">	<span class="number">1</span> 通过代码显式地播放某个磁道多次（play<span class="constructor">Track()</span>）;</span><br><span class="line">	<span class="number">2</span> 然后调用计数器counter的get<span class="constructor">PlayCount()</span>来判断记录的次数是否正确</span><br><span class="line">特征：get<span class="constructor">PlayCount()</span>并没有在CD的方法中，但是同样获取到了方法的调用次数</span><br></pre></td></tr></table></figure>



<h5 id="3-为目标类添加新的方法"><a href="#3-为目标类添加新的方法" class="headerlink" title="3.为目标类添加新的方法"></a>3.为目标类添加新的方法</h5><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">任务：为目标对象添加新的方法：</span><br><span class="line">实现手段：代理对象在实现目标类接口的同时，再实现新添加的接口； aka 为目标对象引入（<span class="built_in">int</span>roduce）新的接口方法</span><br><span class="line">原理：代理会把对目标对象的所有方法调用都委托到底层的具体实现；</span><br><span class="line">特征：</span><br><span class="line">    <span class="number">1</span> 对客户端程序员来说，他只是在一个对象上调用方法（他用的其实是一个代理对象）；</span><br><span class="line">    <span class="number">2</span> 在底层，其实把这一个bean实例的实现分散到了多个类中；</span><br><span class="line">应用：</span><br><span class="line">    在不改动类的原始代码的情况下，灵活地为现有类添加新方法</span><br><span class="line">SOP:</span><br><span class="line">    <span class="number">1</span> 创建一个新的切面类；</span><br><span class="line">    参考：EncoreableIntroducer</span><br><span class="line">    <span class="number">2</span> 在IoC容器中，把切面类声明为一个Spring Bean；</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="3-使用XML来实现上面的所有任务-需求"><a href="#3-使用XML来实现上面的所有任务-需求" class="headerlink" title="3.使用XML来实现上面的所有任务/需求"></a>3.使用XML来实现上面的所有任务/需求</h4><h5 id="3-1-声明一个类为切面；"><a href="#3-1-声明一个类为切面；" class="headerlink" title="3.1 声明一个类为切面；"></a>3.1 声明一个类为切面；</h5><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">特征：</span><br><span class="line">    <span class="number">1</span> 能够在没有组件源码的情况下（比如说使用的第三方组件），能够对组件进行插入切面的操作；</span><br><span class="line">    <span class="number">2</span> 相比于“java配置类”的手段，使用XML配置没有侵入性。也就是说，这种方式不要求你对原始代码做出任何的改动 </span><br><span class="line">实现手段：Spring的aop命名空间下的多个元素；</span><br><span class="line">    例：</span><br><span class="line">        aop:aspectj-autoproxy</span><br><span class="line">        作用：自动创建代理对象————代理由<span class="meta">@AspectJ</span>所注解的通知类</span><br><span class="line">SOP:</span><br><span class="line">    <span class="number">1</span> 去掉添加在切面类上的所有AspectJ提供的注解：<span class="meta">@AspectJ</span>、<span class="meta">@Before</span>、<span class="meta">@After</span>、<span class="meta">@Around</span></span><br><span class="line">    现在有的只是一个单纯的POJO类</span><br><span class="line"></span><br><span class="line">    <span class="number">2</span> 在XML中声明这个类为一个通知类（通知 + 切点 = 切面）</span><br><span class="line">    通知是一个类、切点是一个表达式、切面是一个概念（<span class="keyword">when</span>、<span class="keyword">where</span>、what）</span><br><span class="line">    参考：announce-audience-via-xmlconfig.xml</span><br><span class="line">    使用切点方法对切点表达式的usage进行简化</span><br></pre></td></tr></table></figure>

<h5 id="3-2-在XML声明环绕通知"><a href="#3-2-在XML声明环绕通知" class="headerlink" title="3.2 在XML声明环绕通知"></a>3.2 在XML声明环绕通知</h5><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">环绕通知：</span><br><span class="line">原理：通知方法会包装目标方法，然后在目标方法调用前后添加一些功能；</span><br><span class="line">特征：</span><br><span class="line">    <span class="number">1</span> 等同于前置通知方法 + 后置通知方法；</span><br><span class="line">    <span class="number">2</span> 能够省去前置通知方法 与 后置通知方法中的通信问题（多线程时，方法之间使用成员变量进行通信会有线程安全的问题）</span><br><span class="line">环绕通知方法：watchPerformance()</span><br><span class="line">手段：aop命名空间中的aop:around元素</span><br><span class="line">参考：announce-audience-via-xmlconfig.xml</span><br></pre></td></tr></table></figure>



<h5 id="3-3-在通知方法中使用目标方法中的参数"><a href="#3-3-在通知方法中使用目标方法中的参数" class="headerlink" title="3.3 在通知方法中使用目标方法中的参数"></a>3.3 在通知方法中使用目标方法中的参数</h5><figure class="highlight less"><table><tr><td class="code"><pre><span class="line">手段：为“通知方法”传递参数;</span><br><span class="line">特征：为通知方法所传递的参数应该是目标方法中的参数</span><br><span class="line"><span class="attribute">SOP</span>:</span><br><span class="line">    <span class="number">1</span> 去掉切面类上添加的<span class="variable">@AspectJ</span>注解</span><br><span class="line">    参考：TrackCounterWithoutAnnotation</span><br><span class="line">    <span class="number">2</span> 通过XML配置的方式把TrackCounter声明为一个切面类</span><br><span class="line">    参考：announce-trackcounter-as-aspect-via-xmlconfig.xml</span><br></pre></td></tr></table></figure>



<h5 id="3-4-为目标类添加-引入新的方法"><a href="#3-4-为目标类添加-引入新的方法" class="headerlink" title="3.4 为目标类添加/引入新的方法"></a>3.4 为目标类添加/引入新的方法</h5><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">手段：Spring</span> <span class="string">aop命名空间中的&lt;aop:declare-parents&gt;元素；</span></span><br><span class="line"><span class="attr">参考：add_new_methods_into_target_via_xmlconfig.xml</span></span><br><span class="line"><span class="attr">SOP</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">1</span> <span class="string">在aop:config中声明一个切面类的配置</span></span><br><span class="line">    <span class="attr">2</span> <span class="string">指定预期会被通知的Bean</span></span><br><span class="line">    <span class="attr">3</span> <span class="string">指定预期会为Bean的父类结构所添加的新接口</span></span><br><span class="line">    <span class="attr">4</span> <span class="string">指定为添加的新接口所编写的具体实现</span></span><br><span class="line"><span class="meta">that'a</span> <span class="string">all.</span></span><br></pre></td></tr></table></figure>





]]></content>
  </entry>
  <entry>
    <title>更高级的bean装配第五谈</title>
    <url>/uncategorized/2020/05/05/%E6%9B%B4%E9%AB%98%E7%BA%A7%E7%9A%84bean%E8%A3%85%E9%85%8D%E7%AC%AC%E4%BA%94%E8%B0%88.html</url>
    <content><![CDATA[<p>更高级的bean装配第五谈</p>
<hr>
<h4 id="在运行时向方法中装配-注入值"><a href="#在运行时向方法中装配-注入值" class="headerlink" title="在运行时向方法中装配/注入值"></a>在运行时向方法中装配/注入值</h4><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">需求：避免在声明bean时使用硬编码；</span><br><span class="line">手段：使原来硬编码的值推迟到运行时再确定；</span><br><span class="line">具体方法：Spring提供的再运行时求值的方式</span><br><span class="line">    <span class="number">1</span> 属性占位符（<span class="keyword">Property</span><span class="title"> </span>placeholder）</span><br><span class="line">    <span class="number">2</span> Spring表达式语言（SpEL）</span><br></pre></td></tr></table></figure>

<h5 id="使用属性表达式来动态注入值"><a href="#使用属性表达式来动态注入值" class="headerlink" title="使用属性表达式来动态注入值"></a>使用属性表达式来动态注入值</h5><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">手段SOP：</span><br><span class="line">    <span class="number">1</span> 把属性单独定义到一个properties文件中（外部文件）</span><br><span class="line">    <span class="number">2</span> 在java配置类中加载属性文件到Spring的Environment中</span><br><span class="line">    <span class="number">3</span> 在java代码中从Environment中获取到属性值————用于替换占位符所占的位置</span><br><span class="line">参考：EnvironmentConfig</span><br></pre></td></tr></table></figure>

<hr>
<p>Spring中的Environment实例：getProperty()方法的各种重载</p>
<hr>
<h6 id="在xml配置文件中使用属性占位符"><a href="#在xml配置文件中使用属性占位符" class="headerlink" title="在xml配置文件中使用属性占位符"></a>在xml配置文件中使用属性占位符</h6><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">SOP:</span><br><span class="line">	<span class="number">1</span> 在java配置类中声明PropertySourcesPlaceholderConfigurer这个bean；</span><br><span class="line">    或者在xml配置文件中，使用context命名空间中的<span class="keyword">property</span>-placeholder元素</span><br><span class="line">	<span class="number">2</span> 在需要属性值的地方使用属性占位符</span><br><span class="line">作用：用于解析占位符；</span><br><span class="line">特征：</span><br><span class="line">    <span class="number">1</span> 把值得注入操作推迟到运行时；</span><br><span class="line">    <span class="number">2</span> 属性表达式需要放在$&#123;xxx&#125;中</span><br><span class="line">原理：根据名称来解析来自于Spring Environment和属性源中的属性值</span><br></pre></td></tr></table></figure>

<hr>
<h6 id="使用SpEL表达式来动态注入值"><a href="#使用SpEL表达式来动态注入值" class="headerlink" title="使用SpEL表达式来动态注入值"></a>使用SpEL表达式来动态注入值</h6><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">作用：把一个变量装配到bean的方法中</span><br><span class="line">特征：变量的值在运行时才会计算出来</span><br><span class="line">用法：</span><br><span class="line">    <span class="number">1</span> SpEL表达式要放在#&#123;xxx&#125;中</span><br><span class="line">    <span class="number">2</span> 引用字面量的值</span><br><span class="line">    <span class="number">3</span> 引用bean、属性以及方法</span><br><span class="line">    <span class="number">4</span> 访问类作用域的方法与常量：T()运算符   语法：T(java类型)</span><br><span class="line">    <span class="number">5</span> 使用运算符来创建复杂的表达式</span><br><span class="line">        使用三目运算符来检查<span class="literal">null</span>值</span><br><span class="line">    <span class="number">6</span> 匹配正则表达式的模式</span><br><span class="line">    <span class="number">7</span> 计算集合</span><br><span class="line">太强不记 有点子像正则表达式哈</span><br></pre></td></tr></table></figure>

<p>it’s running late,call it a day~</p>
]]></content>
  </entry>
  <entry>
    <title>更高级的bean装配第四谈</title>
    <url>/uncategorized/2020/05/05/%E6%9B%B4%E9%AB%98%E7%BA%A7%E7%9A%84bean%E8%A3%85%E9%85%8D%E7%AC%AC%E5%9B%9B%E8%B0%88.html</url>
    <content><![CDATA[<p>更高级的bean装配第四谈</p>
<hr>
<h4 id="Spring中bean实例的作用域"><a href="#Spring中bean实例的作用域" class="headerlink" title="Spring中bean实例的作用域"></a>Spring中bean实例的作用域</h4><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">说明：Spring应用上下文中的<span class="keyword">bean默认都是单例的；</span></span><br><span class="line"><span class="keyword">单例：一个类就只会创建一个bean实例；</span></span><br><span class="line"><span class="keyword">特征：</span></span><br><span class="line"><span class="keyword"> </span>   <span class="number">1</span> <span class="keyword">bean实例没有状态，对所有的其他bean都是一样的；</span></span><br><span class="line"><span class="keyword"> </span>   <span class="number">2</span> 能够在应用中反复使用；</span><br></pre></td></tr></table></figure>

<p>pickle：如果对象需要保持自己的状态，这时候再反复重用就行不通了（单例作用域也就不适用了）</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">解决手段：</span><br><span class="line">Spring为bean实例提供了多种作用域；</span><br><span class="line">    <span class="number">1</span> 单例：整个应用中，就只有一个bean实例；[这是默认的作用域]</span><br><span class="line">    <span class="number">2</span> 原型：</span><br><span class="line">        <span class="number">01</span> 每次注入/装配时，</span><br><span class="line">        <span class="number">02</span> 每次通过Spring容器获取时，都会创建一个新的bean实例</span><br><span class="line">    <span class="number">3</span> 会话：</span><br><span class="line">        为web应用中的每一个会话创建一个bean实例；</span><br><span class="line">        特征：适用于购物车需求</span><br><span class="line">    <span class="number">4</span> 请求：</span><br><span class="line">        在Web应用中，为每个请求创建一个bean实例；</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">需求：在配置Bean时，手动指定bean实例的作用域；</span><br><span class="line">手段：使用<span class="meta">@Scope</span>注解声明bean实例的作用域</span><br><span class="line">参见：Notepad.java</span><br><span class="line">    <span class="comment">// 获取可配置的bean工厂的静态常量xxx作为注解的参数</span></span><br><span class="line">    <span class="meta">@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span> <span class="comment">// 手动指定bean实例的作用域</span></span><br></pre></td></tr></table></figure>



<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">需求：Web应用中的购物车；</span><br><span class="line">参考：<span class="module-access"><span class="module"><span class="identifier">ShoppingCart</span>.</span></span>java</span><br><span class="line">作用：每个会话中，只会有一个购物车实例；</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">需求：把会话&#x2F;请求作用域的bean注入到单例bean中；</span><br></pre></td></tr></table></figure>

<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="string">//</span> 单例Bean</span><br><span class="line">	<span class="string">...</span> <span class="string">//</span> 装配/注入一个会话域的bean作为参数</span><br><span class="line"></span><br><span class="line"><span class="string">//</span> 会话作用域的Bean</span><br><span class="line">@Scope<span class="params">(<span class="attr">value</span>=WebApplicationContext.SCOPE_SESSION, <span class="attr">proxyMode</span>=ScopedProxyMode.INTERFACES)</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure>

<h5 id="pickle-one"><a href="#pickle-one" class="headerlink" title="pickle one:"></a>pickle one:</h5><p>1 storeService是一个单例的bean实例——它会在Spring应用上下文被加载的时候创建；<br>2 在创建1中的bean实例时，Spring会尝试把ShoppingCart bean实例注入到方法中。但是此时shoppingCart bean实例还不存在<br>说明：会话作用域的bean实例在用户登录系统创建了会话之后才会创建；</p>
<hr>
<h5 id="pickle-two"><a href="#pickle-two" class="headerlink" title="pickle two:"></a>pickle two:</h5><p>3 应用中会包含多个shoppingCart的Bean实例，注入setter方法的时候。使用任何一个具体的bean都不好</p>
<h4 id="Spring给出的解决方案：proxyMode属性"><a href="#Spring给出的解决方案：proxyMode属性" class="headerlink" title="Spring给出的解决方案：proxyMode属性"></a>Spring给出的解决方案：proxyMode属性</h4><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">原理：不装配/注入某个具体的bean实例，而是注入一个bean的代理；</span><br><span class="line">特征：</span><br><span class="line">        <span class="number">1</span> 客户端可以无差别地像使用目标对象一样使用代理</span><br><span class="line">        <span class="number">2</span> 当调用shoppingCart的方法时，代理会对此调用进行懒加载</span><br><span class="line">        <span class="number">3</span> 代理会把调用委托给会话作用域中真正的bean</span><br></pre></td></tr></table></figure>



<hr>
<p>proxyMode语义说明：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="attribute">proxyMode</span>=ScopedProxyMode.INTERFACES</span><br><span class="line">语义：声明代理需要实现xxx接口； 基于xxx接口的代理</span><br><span class="line">这里的xxx就是方法的返回值</span><br></pre></td></tr></table></figure>

<p>如果方法的返回值不是接口类型，而是具体类型呢？</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">手段：以生成目标类扩展的方式创建代理；</span><br><span class="line">具体方法：<span class="selector-tag">ScopedProxyMode</span><span class="selector-class">.TARGET_CLASS</span></span><br></pre></td></tr></table></figure>

<hr>
<p>ProxyMode是如何解决上面的pickle one + two的？</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">pickle1</span>：进行注入时，购物车的<span class="keyword">bean实例还不存在；</span></span><br><span class="line"><span class="keyword">解决手段：对方法调用进行懒解析，从而延迟注入的操作</span></span><br></pre></td></tr></table></figure>



<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">pickle2</span>：注入<span class="keyword">bean时，不应该注入具体的bean。而应该注入当前会话中的bean实例</span></span><br><span class="line"><span class="keyword">解决手段：不是注入具体的bean实例，而是注入一个代理对象</span></span><br></pre></td></tr></table></figure>



<h4 id="XML的替换方案"><a href="#XML的替换方案" class="headerlink" title="XML的替换方案"></a>XML的替换方案</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">使用xml来配置会话作用域/请求作用域的bean：</span></span><br><span class="line"><span class="number">1</span> <span class="string">配置bean为会话作用域；</span></span><br><span class="line"><span class="string">手段：bean元素的scope属性；</span></span><br><span class="line"><span class="number">2</span> <span class="string">如何设置代理模式呢？</span></span><br><span class="line"><span class="string">手段：Spring</span> <span class="string">aop命名空间的&lt;aop:scoped-proxy&gt;元素</span></span><br><span class="line"><span class="string">作用：告诉Spring为bean创建一个作用域代理；</span></span><br><span class="line"><span class="string">特征：</span></span><br><span class="line">    <span class="number">1</span> <span class="string">默认情况下会使用CGLib来创建目标类的代理；</span></span><br><span class="line">    <span class="number">2</span> <span class="string">通过添加proxy-target-class=false，可以指定Spring生成基于接口的代理；</span></span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>更高级的bean装配第三谈</title>
    <url>/uncategorized/2020/05/05/%E6%9B%B4%E9%AB%98%E7%BA%A7%E7%9A%84bean%E8%A3%85%E9%85%8D%E7%AC%AC%E4%B8%89%E8%B0%88.html</url>
    <content><![CDATA[<p>更高级的bean装配第三谈</p>
<hr>
<p>自动装配面临的问题：进行装配时，如果有多个bean实例满足需求，装配进来哪一个呢？</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line">场景：</span><br><span class="line">自动装配一个setter()方法，装配进一个接口类型的参数；</span><br><span class="line">该接口类型有多个实现类；</span><br><span class="line">所有的实现类都添加了<span class="meta">@Component</span>注解；</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">说明：注入Bean时出现歧义的情况是非常罕见的；</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="当出现多个满足需求的bean实例时，可以有下面这些个解决方案："><a href="#当出现多个满足需求的bean实例时，可以有下面这些个解决方案：" class="headerlink" title="当出现多个满足需求的bean实例时，可以有下面这些个解决方案："></a>当出现多个满足需求的bean实例时，可以有下面这些个解决方案：</h5><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">手段<span class="number">1</span> 标志出首选的bean</span><br><span class="line">具体方法：使用@Primary注解标识一个指定的bean</span><br></pre></td></tr></table></figure>



<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">手段<span class="number">2</span>：使用Spring提供的限定符@Qualifier(<span class="string">"bean id"</span>)</span><br><span class="line">特征：</span><br><span class="line">    <span class="number">1</span> 能够把满足条件的bean限定到只有一个</span><br><span class="line">    <span class="number">2</span> 依赖于String类型的参数，所以无法应对Bean的类名被重构的情况</span><br></pre></td></tr></table></figure>



<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">手段<span class="number">3</span>：创建并使用自定义的限定符注解</span><br><span class="line">特征：</span><br><span class="line">    <span class="number">1</span> 在注入依赖的位置，可以使用多个自定义的限定符————把目标Bean的可选范围缩小到<span class="number">1</span>个</span><br><span class="line">    <span class="number">2</span> 不再显式指定依赖关系，而是使用自定义的特性限定符来指定；</span><br><span class="line">    <span class="number">3</span> setter()方法与具体的Dessert实现进行解耦；</span><br></pre></td></tr></table></figure>



]]></content>
  </entry>
  <entry>
    <title>更高级的Bean装配第二谈</title>
    <url>/uncategorized/2020/05/05/%E6%9B%B4%E9%AB%98%E7%BA%A7%E7%9A%84Bean%E8%A3%85%E9%85%8D%E7%AC%AC%E4%BA%8C%E8%B0%88.html</url>
    <content><![CDATA[<p>更高级的Bean装配第二谈</p>
<hr>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">对<span class="keyword">Bean进行条件化地管理</span></span><br><span class="line"><span class="keyword">根据指定条件是否成立来决定是否创建某个bean实例；</span></span><br></pre></td></tr></table></figure>



<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">什么叫条件化地管理？</span><br><span class="line">    只有在满足特定条件后，才会创建对应的bean</span><br><span class="line">常见的条件：</span><br><span class="line">    <span class="number">1</span> 应用类路径下包含特定的库；</span><br><span class="line">    <span class="number">2</span> 另一个相关bean被声明为Spring组件；</span><br><span class="line">    <span class="number">3</span> 某个特定的环境变量绑定了值；</span><br><span class="line">    ...</span><br><span class="line">实现手段：@<span class="constructor">Conditional(<span class="params">xxx</span>)</span></span><br><span class="line"></span><br><span class="line">应用案例：对于MagicBean类，只有当magic环境属性绑定值后，才创建它的bean实例；否则不创建bean实例</span><br><span class="line">参考：<span class="module-access"><span class="module"><span class="identifier">MagicConfig</span>.</span></span>java</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">@Conditional(xxx)的参数说明:</span><br><span class="line">    <span class="number">1</span> xxx是实现了Condition接口的一个具体实现类的Class对象；</span><br><span class="line">    <span class="number">2</span> Condition接口中，只有一个抽象方法<span class="built_in">bool</span>ean matches(ConditionContext context, AnnotatedTypeMetadata metadata);</span><br><span class="line">    <span class="number">3</span> 从context参数中就能得到所有期望的条件参数...</span><br><span class="line">    太多不看</span><br><span class="line">注：使用IDEA能够快捷地追踪源码,但源码一般比较抽象。能看出大概是在做什么就可以了</span><br></pre></td></tr></table></figure>

<p><img src="C:%5CUsers%5CHenryInSH%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200505175236602.png" alt="image-20200505175236602"></p>
<p><img src="C:%5CUsers%5CHenryInSH%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200505175305356.png" alt="image-20200505175305356"></p>
<p><img src="C:%5CUsers%5CHenryInSH%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200505175341452.png" alt="image-20200505175341452"></p>
<p><img src="C:%5CUsers%5CHenryInSH%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200505175452986.png" alt="image-20200505175452986"></p>
<hr>
<p>extra bonus</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">Spring4中,@Profile()注解是使用@Conditional()注解来实现的</span></span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>更高级的bean配置第一谈</title>
    <url>/uncategorized/2020/05/05/%E6%9B%B4%E9%AB%98%E7%BA%A7%E7%9A%84bean%E9%85%8D%E7%BD%AE%E7%AC%AC%E4%B8%80%E8%B0%88.html</url>
    <content><![CDATA[<p>更高级的bean配置第一谈</p>
<hr>
<p>应用：根据那个激活的profile来决定是否要创建某个bean；</p>
<p>说明：同一个项目，在不同的阶段，某个bean实例的获取方式可能是不一样的；</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">开发时的常见操作（表示没用过）：</span><br><span class="line">    使用嵌入式数据库；</span><br><span class="line">    作用：快速获取到一个dataSource，并预先加载测试数据；</span><br><span class="line">    参考：EmbeddedDatabaseBuilder</span><br><span class="line"></span><br><span class="line">生产环境中的常见操作：</span><br><span class="line">    使用<span class="keyword">JNDI从容器中获取一个DataSource；</span></span><br><span class="line"><span class="keyword"> </span>   作用：由容器决定如何创建这个DataSource；</span><br><span class="line">    特征：</span><br><span class="line">        有一定的复杂性</span><br><span class="line"></span><br><span class="line">QA环境中的常见操作：</span><br><span class="line">    其他获取dataSource的方式</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="Problem-amp-Solution"><a href="#Problem-amp-Solution" class="headerlink" title="Problem &amp; Solution"></a>Problem &amp; Solution</h4><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">现象说明：不同环境中的某一个<span class="keyword">bean实例可能会有所不同。</span></span><br><span class="line"><span class="keyword">解决思路：通过某种技术，使得dataSource能够在不同的环境下选择对应的配置；</span></span><br><span class="line"><span class="keyword">实现手段1：单独配置每一种bean实例，然后在构建时决定把哪一个bean实例的配置编译到可部署的应用中</span></span><br><span class="line"><span class="keyword">特征：</span></span><br><span class="line"><span class="keyword"> </span>   需要重复地构建应用</span><br><span class="line"></span><br><span class="line">实现手段<span class="number">2</span>：Spring提供的profile <span class="keyword">bean；</span></span><br><span class="line"><span class="keyword">作用：根据环境来决定该创建哪一个bean；</span></span><br><span class="line"><span class="keyword">特征：</span></span><br><span class="line"><span class="keyword"> </span>   <span class="number">1</span> 在运行时才确定使用哪一个<span class="keyword">bean的配置；</span></span><br><span class="line"><span class="keyword"> </span>   <span class="number">2</span> 这使得同一个部署包适用于所有的环境，部署时不需要重新进行构建；</span><br></pre></td></tr></table></figure>



<hr>
<p>Spring提供的profile bean用法SOP：</p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">用法SOP:</span><br><span class="line">    <span class="number">1</span> 把所有的bean定义添加到/绑定到一个<span class="keyword">profile</span>中；</span><br><span class="line">    手段：在配置类/方法上添加@Profile(<span class="string">"dev"</span>)注解；</span><br><span class="line">    作用：告诉Spring，当前配置类中的bean/方法所绑定的bean[使用@Bean声明]只有在dev <span class="keyword">profile</span>激活时才会创建</span><br><span class="line">    参考：DataSourceConfig.java</span><br><span class="line">    特征：</span><br><span class="line">        <span class="number">1</span> 对于添加了@Profile的bean：当指定的<span class="keyword">profile</span>被激活时，它修饰的bean才会被创建</span><br><span class="line">        <span class="number">2</span> 没有添加@Profile的bean：总是会被创建</span><br><span class="line">        <span class="number">3</span> 通过XML配置文件能完成同样的功能（略）</span><br><span class="line"></span><br><span class="line">    <span class="number">2</span> 在把应用部署到指定环境时，确保该环境对应的<span class="keyword">profile</span>处于激活状态</span><br><span class="line">    手段：设置 spring.profiles.active / spring.<span class="keyword">profile</span>.<span class="keyword">default</span> 这个属性的值；</span><br><span class="line">    如何设置这两个属性的值呢？</span><br><span class="line">    推荐方式：使用DispatcherServlet的参数来把spring.<span class="keyword">profile</span>.<span class="keyword">default</span>设置为开发环境的<span class="keyword">profile</span></span><br><span class="line">    具体方法<span class="number">1</span>：在servlet上下文（web.xml）中进行设置</span><br><span class="line">        参考：web.xml</span><br><span class="line">            <span class="variable">&lt;servlet&gt;</span></span><br><span class="line">                <span class="variable">&lt;init-param&gt;</span></span><br><span class="line">                    <span class="variable">&lt;param-name&gt;</span>xxx&lt;/param-name&gt;</span><br><span class="line">                ...</span><br><span class="line">            ...</span><br><span class="line">        特征：</span><br><span class="line">            <span class="number">1</span> 项目中的所有成员拉取代码后，都能使用开发环境的设置来运行代码。不需要任何额外的配置</span><br><span class="line">            <span class="number">2</span> 在部署项目到其他环境时，部署人员可以再对应设置spring.profiles.active属性的值</span><br></pre></td></tr></table></figure>

<hr>
<p>启示：xml文件可以在项目上直接进行改动。不需要对项目进行重新构建</p>
<hr>
<p>功能测试： </p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">测试说明：</span><br><span class="line">在我指定激活了某个<span class="keyword">profile</span>后：</span><br><span class="line">	<span class="number">1</span> 绑定到此<span class="keyword">profile</span>上的bean是否被正常创建；</span><br><span class="line">	<span class="number">2</span> 绑定到其他<span class="keyword">profile</span>上的bean是否符合预期——没有被创建；</span><br><span class="line">	<span class="number">3</span> 没有绑定任何<span class="keyword">profile</span>的bean是否仍旧正常创建；</span><br></pre></td></tr></table></figure>



<p>需求：在运行测试代码时，指定要激活的某个profile；</p>
<p>手段：Spring提供的<strong>@ActiveProfiles(“dev”)</strong>注解</p>
<hr>
<p>see this in a higher view</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">任务：根据<span class="string">"那个激活的profile"</span>来决定是否要创建某个<span class="keyword">bean；</span></span><br><span class="line"><span class="keyword">手段：1 </span>把<span class="keyword">bean添加到某个profile中； </span><span class="number">2</span> 在web.xml中声明被激活的profile；</span><br><span class="line"></span><br><span class="line">任务扩展：根据<span class="string">"指定的条件"</span>来决定是否要创建某个<span class="keyword">bean；</span></span><br><span class="line"><span class="keyword">手段：条件化的bean</span></span><br></pre></td></tr></table></figure>



<p>emoji: 😄</p>
]]></content>
  </entry>
  <entry>
    <title>Spring中bean的创建&amp;装配（第三谈）</title>
    <url>/uncategorized/2020/05/05/Spring%E4%B8%ADbean%E7%9A%84%E5%88%9B%E5%BB%BA&amp;%E8%A3%85%E9%85%8D%EF%BC%88%E7%AC%AC%E4%B8%89%E8%B0%88%EF%BC%89.html</url>
    <content><![CDATA[<p>Spring中bean的创建&amp;装配（第三谈）</p>
<hr>
<h4 id="方式3：使用xml文件进行配置"><a href="#方式3：使用xml文件进行配置" class="headerlink" title="方式3：使用xml文件进行配置"></a>方式3：使用xml文件进行配置</h4><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">SOP</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">1</span> <span class="string">创建一个xml文件；</span></span><br><span class="line">    <span class="attr">2</span> <span class="string">在文件顶部声明多个XML模式文件（XSD）————这些文件指定了在xml文件中的可用标签</span></span><br><span class="line">    <span class="attr">3</span> <span class="string">在spring-bean模式下添加beans元素————作为所有bean配置的根元素；</span></span><br><span class="line">    <span class="attr">4</span> <span class="string">在beans中声明所有需要Spring bean实例的配置</span></span><br></pre></td></tr></table></figure>



<h5 id="实现手段1：构造器方式注入-装配-DI"><a href="#实现手段1：构造器方式注入-装配-DI" class="headerlink" title="实现手段1：构造器方式注入/装配/DI"></a>实现手段1：构造器方式注入/装配/DI</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">声明构造器方式的DI（注入引用）</span></span><br><span class="line">    <span class="string">ref属性</span></span><br><span class="line">    <span class="string">ConstructorArgReferenceTest-context.xml</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">使用c命名空间声明构造器DI(注入引用)</span></span><br><span class="line">    <span class="string">c:xx-ref="bean</span> <span class="string">id"</span></span><br><span class="line">    <span class="string">CNamespaceReferenceTest-context.xml</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">声明构造器方式的DI(注入字面量值)：</span></span><br><span class="line">    <span class="string">value="xxx"</span></span><br><span class="line"><span class="string">说明：c命名空间会有另一套规则</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">构造器方式的DI(装配字面量集合):</span></span><br><span class="line">    <span class="string">&lt;constructor-arg&gt;</span></span><br><span class="line">        <span class="string">&lt;list&gt;</span></span><br><span class="line">            <span class="string">&lt;value&gt;...&lt;/value&gt;</span></span><br><span class="line">            <span class="string">...</span></span><br><span class="line">        <span class="string">&lt;/list&gt;</span></span><br><span class="line">    <span class="string">&lt;...&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">构造器方式的DI(装配引用集合)</span></span><br><span class="line">    <span class="string">...</span></span><br><span class="line">        <span class="string">...</span></span><br><span class="line">            <span class="string">&lt;ref&gt;...&lt;/ref&gt;</span></span><br><span class="line"><span class="string">说明：在装配集合时，constructor-arg原生元素比c命名空间更好用</span></span><br></pre></td></tr></table></figure>



<hr>
<h5 id="实现手段2：属性设置方式的注入-装配-DI"><a href="#实现手段2：属性设置方式的注入-装配-DI" class="headerlink" title="实现手段2：属性设置方式的注入/装配/DI"></a>实现手段2：属性设置方式的注入/装配/DI</h5><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">通过setter方法注入依赖</span><br><span class="line">原则：对强依赖使用构造器注入，对可选性的依赖使用setter注入；</span><br><span class="line">用法：</span><br><span class="line">    &lt;<span class="keyword">property</span> <span class="built_in">name</span>=<span class="string">"属性名"</span> <span class="keyword">ref</span>=<span class="string">"bean id"</span>/&gt;</span><br><span class="line"></span><br><span class="line">setter注入的替换方案：p-命名空间</span><br><span class="line">又是一套烦人的语法</span><br></pre></td></tr></table></figure>



<hr>
<p>多种配置方式的共用</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line"><span class="comment">-----------</span></span><br><span class="line">多种装配方式的混用mix</span><br><span class="line">说明：显式的xml配置总是必不可少，因为自动扫描+装配的方式需要先启动注解扫描<span class="keyword">context</span>:<span class="keyword">component</span>-sacn；</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>Spring中Bean的创建&amp;装配（第二谈）</title>
    <url>/uncategorized/2020/05/05/Spring%E4%B8%ADBean%E7%9A%84%E5%88%9B%E5%BB%BA&amp;%E8%A3%85%E9%85%8D%EF%BC%88%E7%AC%AC%E4%BA%8C%E8%B0%88%EF%BC%89.html</url>
    <content><![CDATA[<p>Spring中Bean的创建与装配（第二谈）</p>
<hr>
<p>方式2：使用java配置类</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="attribute">SOP</span>:</span><br><span class="line">    <span class="number">1</span> 声明一个配置类</span><br><span class="line">    手段：<span class="variable">@Configuration</span></span><br><span class="line">    <span class="number">2</span> 在配置类中声明bean</span><br><span class="line">    手段：编写一个方法，方法会返回需要类型的bean实例；</span><br><span class="line">    <span class="number">3</span> 声明方法的返回对象要作为Spring组件；</span><br><span class="line">    手段：<span class="variable">@Bean</span></span><br><span class="line">特征：方法体中可以使用任意的java语法</span><br></pre></td></tr></table></figure>

<p>bean的引用id</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">默认情况下，bean实例的ID与<span class="meta">@Bean</span>所注解的方法名相同；</span><br><span class="line">需求：手动指定bean实例的ID</span><br><span class="line">手段：<span class="meta">@Bean(name=<span class="meta-string">"《预期为bean实例指定的ID》"</span>)</span></span><br></pre></td></tr></table></figure>

<p>对bean实例进行装配</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">对声明的<span class="keyword">bean进行装配：</span></span><br><span class="line"><span class="keyword">手段01：通过“引用创建bean的方法”来装配；</span></span><br><span class="line"><span class="keyword">特征：</span></span><br><span class="line"><span class="keyword"> </span>   <span class="number">1</span> 每次方法调用得到的都是同一个<span class="keyword">bean实例；</span></span><br><span class="line"><span class="keyword"> </span>   <span class="number">2</span> 不推荐使用</span><br><span class="line">原理：</span><br><span class="line">    Spring会拦截对方法的调用：</span><br><span class="line">        如果Spring容器中已经存在了对应的<span class="keyword">bean实例，就直接返回。</span></span><br><span class="line"><span class="keyword"> </span>       如果不存在<span class="keyword">bean实例，才对方法进行调用。从而创建bean实例</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">手段02：在声明Bean时，通过方法参数指定要装配的bean；</span></span><br><span class="line"><span class="keyword">说明：这是DI的一种方式</span></span><br><span class="line"><span class="keyword">特征：</span></span><br><span class="line"><span class="keyword"> </span>   <span class="number">1</span> 由于使用方法参数，所以要装配的<span class="keyword">bean可以从外部注入；</span></span><br><span class="line"><span class="keyword"> </span>   <span class="number">2</span> 由于从外部注入，待装配的<span class="keyword">bean可以使用其他方式配置（自动扫描 </span><span class="keyword">OR </span>XML配置）</span><br><span class="line">    <span class="number">3</span> 这是推荐的方式</span><br></pre></td></tr></table></figure>

<p>DI的几种方式</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">DI（注入依赖）的几种实现方式：</span><br><span class="line"><span class="number">1</span> 构造器注入</span><br><span class="line"><span class="number">2</span> setter()方法注入</span><br><span class="line"><span class="number">3</span> 其他注入方式</span><br><span class="line"></span><br><span class="line">注入的本质上都是给bean属性绑定值</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>Spring中的Bean创建&amp;装配</title>
    <url>/uncategorized/2020/05/05/Spring%E4%B8%AD%E7%9A%84Bean%E5%88%9B%E5%BB%BA&amp;%E8%A3%85%E9%85%8D.html</url>
    <content><![CDATA[<h3 id="Spring中的Bean创建-amp-装配"><a href="#Spring中的Bean创建-amp-装配" class="headerlink" title="Spring中的Bean创建&amp;装配"></a>Spring中的Bean创建&amp;装配</h3><hr>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">装配（wiring）：建立应用中不同bean之间的依赖关系/关联关系；</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">任务：完成装配的工作；</span></span><br><span class="line"><span class="string">实现手段：DI</span></span><br><span class="line"><span class="string">具体方法：</span></span><br><span class="line">    <span class="number">1</span> <span class="string">在XML显示配置装配关系</span></span><br><span class="line">    <span class="number">2</span> <span class="string">在java中显示配置装配关系</span></span><br><span class="line">    <span class="number">3</span> <span class="string">使用Spring的bean发现</span> <span class="string">&amp;</span> <span class="string">自动装配技术</span></span><br></pre></td></tr></table></figure>



<p>方式1 自动发现 + 自动装配</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> Spring的自动化装配<span class="keyword">bean技术</span></span><br><span class="line"><span class="keyword">原理：① </span>发现<span class="keyword">bean </span>+ ② 建立<span class="keyword">bean之间的依赖关系</span></span><br><span class="line"><span class="keyword">手段：</span></span><br><span class="line"><span class="keyword"> </span>   ① 组件扫描（component <span class="keyword">scanning）：Spring框架通过扫描操作来发现由Spring容器/应用上下文所创建的bean</span></span><br><span class="line"><span class="keyword"> </span>   ② 自动装配（autowiring）：Spring框架根据发现的<span class="keyword">bean来建立bean之间的依赖关系</span></span><br><span class="line"><span class="keyword">疑问：</span></span><br><span class="line"><span class="keyword"> </span>   <span class="number">1</span> 有哪些工作是Spring完成的？</span><br><span class="line">    <span class="number">2</span> 我作为一个程序员，需要做哪些操作？</span><br><span class="line">    <span class="number">3</span> 我做的这些个操作具体是什么作用？</span><br><span class="line"></span><br><span class="line">用法：</span><br><span class="line">    参考：对音响系统中的组件进行装配；</span><br><span class="line">    CompactDisc.<span class="keyword">java </span>压缩碟片 CD</span><br></pre></td></tr></table></figure>



<h4 id="验证Spring上下文是否为Spring组件创建了bean"><a href="#验证Spring上下文是否为Spring组件创建了bean" class="headerlink" title="验证Spring上下文是否为Spring组件创建了bean"></a>验证Spring上下文是否为Spring组件创建了bean</h4><hr>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">音响系统的组件列表：</span></span><br><span class="line">    <span class="number">1</span> <span class="string">CD：音乐容器</span></span><br><span class="line">    <span class="string">参考：CompactDisc</span></span><br><span class="line">    <span class="number">2</span> <span class="string">CD</span> <span class="string">Player：播放CD的工具</span></span><br><span class="line"></span><br><span class="line"><span class="string">Spring要完成的工作：</span></span><br><span class="line">    <span class="number">1</span> <span class="string">发现项目中有@Component注解的类；</span></span><br><span class="line">    <span class="number">2</span> <span class="string">为这些个类创建其Spring</span> <span class="string">bean；</span></span><br><span class="line">    <span class="number">3</span> <span class="string">装配这些bean的依赖关系？</span></span><br><span class="line"></span><br><span class="line"><span class="string">程序员要做的工作：</span></span><br><span class="line">    <span class="number">1</span> <span class="string">为预期会交给Spring管理的类添加@Component注解</span></span><br><span class="line">        <span class="string">参考：SgtPeppers.java</span></span><br><span class="line">    <span class="number">2</span> <span class="string">在Spring配置文件中，手动开启组件扫描</span></span><br><span class="line">        <span class="string">手段1：CDPlayerConfig.java</span> <span class="string">[这是通过java配置类来开启组件扫描]</span></span><br><span class="line">        <span class="string">手段2：soundsystem.xml</span> <span class="string">[这是通过xml的方式来开启组件扫描]</span></span><br><span class="line">    <span class="number">3</span> <span class="string">需要装配的时候，使用@Autowired来声明依赖关系/注入依赖</span></span><br></pre></td></tr></table></figure>



<p>测试过程</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">测试：</span><br><span class="line">    在把CompactDisc声明为Spring组件后，Spring容器/上下文有没有创建出这个组件的实例呢？</span><br><span class="line">手段：Junit单元测试</span><br><span class="line">参考：<span class="module-access"><span class="module"><span class="identifier">CDPlayerTest</span>.</span></span>java</span><br><span class="line">SOP:</span><br><span class="line">    <span class="number">1</span> 使用JUnit框架完成两件事：</span><br><span class="line">        Ⅰ 自动创建Spring上下文的实例</span><br><span class="line">        Ⅱ 指定在什么地方加载配置信息</span><br><span class="line">    <span class="number">2</span> 在Test中注入需要被测试的Spring组件：</span><br><span class="line">        @Autowired</span><br><span class="line">        xxx</span><br><span class="line">    <span class="number">3</span> 在测试方法中，查看这个Spring组件的bean实例有没有被创建出来</span><br><span class="line">        <span class="keyword">assert</span><span class="constructor">NotNull(<span class="params">cd</span>)</span>; <span class="comment">// Junit所提供的方法</span></span><br></pre></td></tr></table></figure>



<hr>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">拾遗：</span><br><span class="line">    声明Spring组件：<span class="meta">@Component</span></span><br><span class="line">    java配置类：<span class="meta">@Configuration</span></span><br><span class="line">    开启组件扫描：<span class="meta">@Component</span> + <span class="string">context:</span>component-scan</span><br><span class="line">    实现自动装配：<span class="meta">@Autowired</span></span><br><span class="line">目的：使Spring上下文能够：</span><br><span class="line">    ① 自动发现Spring组件；</span><br><span class="line">    ② 创建它们的bean实例；</span><br><span class="line">    ③ 管理这些bean实例之间的依赖关系（aka 装配工作）</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="更多注解相关的细节"><a href="#更多注解相关的细节" class="headerlink" title="更多注解相关的细节"></a>更多注解相关的细节</h4><h5 id="指定bean实例的引用"><a href="#指定bean实例的引用" class="headerlink" title="指定bean实例的引用"></a>指定bean实例的引用</h5><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">引用<span class="keyword">bean实例：</span></span><br><span class="line"><span class="keyword">对于Spring通过组件扫描所创建的bean实例————bean实例的默认id：类名的首字母小写；</span></span><br><span class="line"><span class="keyword">需求：手动指定bean实例的id：</span></span><br><span class="line"><span class="keyword">手段：@Component("《预期的id》")</span></span><br></pre></td></tr></table></figure>



<h5 id="自动装配的规则"><a href="#自动装配的规则" class="headerlink" title="自动装配的规则"></a>自动装配的规则</h5><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">建立组件之间的依赖关系：自动装配</span><br><span class="line">原理：Spring会根据指定规则,在Spring容器中查找bean01所需要的其他bean</span><br><span class="line">手段：@Autowired注解</span><br><span class="line">具体方法：</span><br><span class="line">    <span class="number">1</span> 在类A的有参构造方法上使用@Autowired注解</span><br><span class="line">    作用：Spring上下文在创建类A的实例bean时，会自动创建类B的实例bean。并注入到构造器中</span><br><span class="line"></span><br><span class="line">    <span class="number">2</span> 在setter方法上使用@Autowired注解</span><br><span class="line">    作用：Spring上下文在初始化时，会尽可能满足bean的依赖；</span><br><span class="line"></span><br><span class="line">    <span class="number">3</span> 用在其他方法上...</span><br><span class="line">说明：Spring会尝试满足方法参数所声明的依赖；</span><br><span class="line">注入成功的条件：Spring应用上下文中有且只有一个bean满足依赖需求；</span><br><span class="line">装配不成功：</span><br><span class="line">    <span class="number">1</span> Spring上下文中没有找到符合条件的依赖bean：</span><br><span class="line">        结果：抛出一个异常；</span><br><span class="line">        说明：使用required=<span class="literal">false</span>能够避免这种情况下抛出异常</span><br><span class="line">    <span class="number">2</span> Spring上下文中有多个bean满足依赖需求：</span><br><span class="line">        结果：Spring无法决定使用哪个实例bean进行注入，抛出异常</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>Spring初体验</title>
    <url>/uncategorized/2020/05/05/Spring%E5%88%9D%E4%BD%93%E9%AA%8C.html</url>
    <content><![CDATA[<h3 id="Spring初体验"><a href="#Spring初体验" class="headerlink" title="Spring初体验"></a>Spring初体验</h3><hr>
<p>降低bean之间的耦合程度：DI</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> 在配置文件中装配/声明bean之间的关系：</span><br><span class="line">    定义应用的多个组件之间的依赖关系/协作关系；</span><br><span class="line">Spring中实现装配的方式：</span><br><span class="line">    <span class="number">1</span> 使用XML配置文件；</span><br><span class="line">    参考：knight.xml</span><br><span class="line">    <span class="number">2</span> 使用java类来描述配置；</span><br><span class="line">    参考：KnightConfig.java</span><br></pre></td></tr></table></figure>



<hr>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span> 装载XML配置文件到Spring容器/上下文，然后启动应用</span><br><span class="line">任务：装载<span class="keyword">bean的定义到Spring容器并把多个bean按照指定关系组装起来；</span></span><br><span class="line"><span class="keyword">Spring提供的手段：应用上下文（Application </span>Context）；</span><br><span class="line">说明：Spring提供了多种应用上下文的具体实现————这些实现对应于不同的配置方式<span class="comment">;</span></span><br><span class="line">参考：KnightMain.java</span><br><span class="line">    Ⅰ 加载配置文件到应用上下文实例中</span><br><span class="line">    Ⅱ 从应用上下文实例中获取到配置的指定<span class="keyword">bean</span></span><br><span class="line"><span class="keyword"> </span>   Ⅲ 调用<span class="keyword">bean的方法</span></span><br><span class="line"><span class="keyword"> </span>   Ⅳ 关闭上下文对象</span><br><span class="line"></span><br><span class="line">装配的过程是使用DI实现的——DI能够使各个组件保持松散耦合</span><br></pre></td></tr></table></figure>



<hr>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">3</span> <span class="string">专注于业务逻辑————分离出横切关注点（面向切面编程）</span></span><br><span class="line"><span class="meta">常见的横切关注点（aka</span> <span class="string">大家都会用到的功能，最好能够单独提取出来。被所有方法复用）：</span></span><br><span class="line">    <span class="attr">1</span> <span class="string">日志；</span></span><br><span class="line">    <span class="attr">2</span> <span class="string">事务管理；</span></span><br><span class="line">    <span class="attr">3</span> <span class="string">安全；</span></span><br><span class="line"><span class="attr">手段：AOP；</span></span><br><span class="line"><span class="attr">用法：</span></span><br><span class="line">    <span class="attr">1</span> <span class="string">实现横切关注点；</span></span><br><span class="line">    <span class="attr">2</span> <span class="string">以声明的方式添加关注点/切面到指定连接点处；</span></span><br><span class="line"><span class="attr">特征：</span></span><br><span class="line">    <span class="attr">1</span> <span class="string">业务代码更加专注————代码中完全不需要处理任何的横切关注点；</span></span><br><span class="line">    <span class="attr">2</span> <span class="string">横切关注点可以添加在多个方法/连接点上；</span></span><br><span class="line"><span class="attr">参考：</span></span><br><span class="line">    <span class="attr">Minstrel</span> <span class="string">吟游诗人（一个POJO类）</span></span><br><span class="line">    <span class="attr">BraveKnight</span> <span class="string">游侠骑士</span></span><br><span class="line"><span class="attr">SOP</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">1</span> <span class="string">把minstrel声明为一个切面；</span></span><br><span class="line">    <span class="attr">参考：minstrel.xml</span></span><br><span class="line">        <span class="meta">添加aop</span>:<span class="string">aspect命名空间</span></span><br><span class="line">        <span class="attr">添加bean到Spring管理</span></span><br><span class="line">        <span class="attr">添加bean的切面相关信息：</span></span><br><span class="line">            <span class="attr">切点（多个连接点）、前置通知、后置通知</span></span><br><span class="line">    <span class="attr">特征：</span></span><br><span class="line">        <span class="attr">1</span> <span class="string">Minstrel仍旧是一个POJO类；</span></span><br><span class="line">        <span class="attr">2</span> <span class="string">在XML配置后，这个POJO类就成了Spring中的一个切面；</span></span><br><span class="line">        <span class="attr">3</span> <span class="string">Minstrel与Knight之间没有任何相互调用的代码 aka 没有直接耦合</span></span><br><span class="line">        <span class="attr">由于配置文件的存在，Knight与Minstrel组件之间被解除耦合了</span></span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">Spring简化<span class="keyword">java开发第4弹————消除样板(boilerplate)代码；</span></span><br><span class="line"><span class="keyword">手段：Spring内置的模板</span></span><br><span class="line"><span class="keyword">说明：尽管java </span>APIs提供了统一的编程规范，但是它同样也产生了大量重复的<span class="keyword">boilerplate代码</span></span><br><span class="line"><span class="keyword">参考：使用java </span><span class="keyword">JDBC原生提供的APIs编写代码操作数据库 </span>VS. 使用Spring提供的模板来操作数据库</span><br><span class="line">注：一般在项目中会直接集成第三方的框架（MyBatis等）</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p> Spring容器</p>
</blockquote>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">Spring</span>中的大管家：Spring容器</span><br><span class="line">作用：管理Spring中所有的<span class="keyword">bean对象（CRUD </span><span class="keyword">and </span>more~）</span><br><span class="line">特征：</span><br><span class="line">    <span class="number">1</span> Spring容器借助DI管理<span class="keyword">bean之间的关系；</span></span><br><span class="line"><span class="keyword"> </span>   <span class="number">2</span> Spring提供的容器实现有两种大类：<span class="keyword">beanFactory（基础容器） </span>VS. ApplicationContext（更高级的容器）</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">Spring中应用上下文的具体实现：</span><br><span class="line">    说明：这些实现类的不同在于————加载应用上下文的方式不同</span><br><span class="line">    <span class="number">1</span> AnnotationConfigApplicationContext<span class="comment">;   加载应用上下文的方式：java配置类</span></span><br><span class="line">    <span class="number">2</span> AnnotationConfigWebApplicationContext<span class="comment">;    加载Web应用上下文？？？</span></span><br><span class="line">    <span class="number">3</span> ClassPathXmlApplicationContext<span class="comment">;       加载应用上下文的方式：类路径中的xml配置文件</span></span><br><span class="line">    <span class="number">4</span> FileSystemXmlApplicationContext<span class="comment">;      加载应用上下文的方式：文件系统中的xml配置文件</span></span><br><span class="line">    <span class="number">5</span> XmlWebApplicationContext<span class="comment">;     加载应用上下文的方式：Web应用中的xml配置文件</span></span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">获取到应用上下文实例之后，如何使用这个容器来管理bean的声明周期呢？</span><br><span class="line">Spring容器管理下bean生命周期（比较费劲）：</span><br><span class="line">    <span class="number">1</span> 实例化；</span><br><span class="line">    <span class="number">2</span> 填充属性/初始化；</span><br><span class="line">    <span class="number">3</span> 调用BeanNameAware的setBeanName()方法；</span><br><span class="line">    <span class="number">4</span> 调用BeanFactoryAware的setBeanFactory()方法；</span><br><span class="line">    <span class="number">5</span> 调用ApplicationContextAware的setApplicationContext()方法；</span><br><span class="line">    ---</span><br><span class="line">    <span class="number">6</span> 调用BeanPostProcessor的预初始化方法；</span><br><span class="line">    <span class="number">7</span> 调用InitializingBean的afterPropertiesSet()方法；</span><br><span class="line">    <span class="number">8</span> 调用自定义的初始化方法；</span><br><span class="line">    <span class="number">9</span> 调用BeanPostProcessor的后初始化方法；</span><br><span class="line">    --- bean能够正常使用了</span><br><span class="line">    <span class="number">10</span> 容器关闭时，调用DisposableBean的destroy()方法</span><br><span class="line">    <span class="number">11</span> 调用自定义的销毁方法</span><br><span class="line">    注：程序员还可以根据自己需要再添加新的生命阶段</span><br></pre></td></tr></table></figure>



<p>源码备注：<a href="https://www.manning.com/books/spring-in-action-fourth-edition">https://www.manning.com/books/spring-in-action-fourth-edition</a></p>
<p>注：使用Gradle工具构建的项目，可能会踩一些莫名其妙的坑。这时候你需要了解一下Gradle的用法</p>
]]></content>
  </entry>
  <entry>
    <title>Spring的特征——面向切面</title>
    <url>/uncategorized/2020/05/04/Spring%E7%9A%84%E7%89%B9%E5%BE%81%E2%80%94%E2%80%94%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2.html</url>
    <content><![CDATA[<h3 id="Spring的特征——面向切面"><a href="#Spring的特征——面向切面" class="headerlink" title="Spring的特征——面向切面"></a>Spring的特征——面向切面</h3><hr>
<p>编程过程中的横切关注点：多个方法的公共需求</p>
<p>任务：在业务代码/方法上，添加横切关注点所代表的功能；</p>
<p>手段1：继承；</p>
<p>手段2：委托；</p>
<p>手段3：把公共的功能（横切关注点）处理成为一个切面类；</p>
<hr>
<p>用法SOP：</p>
<ol>
<li><p>定义通用的功能；</p>
</li>
<li><p>在某个地方声明此功能会被添加到什么地方；</p>
<p>特征：</p>
</li>
</ol>
<p>特征：</p>
<pre><code>1. 多个横切关注点/通用功能能够放在一起管理——这会极大地节省程序员维护代码所用的时间；
 2. 通用功能的代码不会混在逻辑代码中——这样逻辑代码会更易读；</code></pre><hr>
<p>AOP相关的术语：</p>
<p>通知（advice）：切面/横切关注点所表示的功能 &amp; 使用切面的时机；</p>
<p>通知有好几种类型，这个请查词典</p>
<p>连接点（Join point）：切面可以插入的代码位置 aka 程序运行的特定时刻；</p>
<p>切点（PointCut）：指定通知所添加到的连接点的规则——通知会作用到哪一些连接点；</p>
<p>切面（Aspect）：描述横切关注点的功能 &amp; 此功能发挥作用的时机 &amp; 应用此功能的地方； 切面 = 通知（what when） + 切点(where)</p>
<p>引入（introduction）：向现有类添加新方法或属性的行为；</p>
<p>织入（weaving）：把切面应用到目标对象，并创建新的代理对象的过程；</p>
<p>切面类在指定的连接点被织入目标对象中；</p>
<hr>
<p>编译期：切面在目标类编译时就被织入。</p>
<p>特征：这需要特殊的编译器。</p>
<p>类加载期： 切面在目标类加载到JVM时被织入；</p>
<p>特征：这需要特殊的类加载器；</p>
<p>运行期：切面在应用运行的某个时刻被织入；</p>
<p>特征：Spring AOP就是采用运行期织入的方式；</p>
<hr>
<p>Spring 对AOP的几种实现：</p>
<p>1 POJO切面；</p>
<p>把一个自定义的POJO类指定为切面类；</p>
<p>特征：</p>
<pre><code>1. POJO类只是定义了满足切点条件时会被调用的方法
 2. 需要使用XML进行一些需要的配置；</code></pre><p>2 注解驱动的AOP；</p>
<p>特征：这种方式不需要使用XML配置文件；</p>
<hr>
<p>关于Spring AOP框架的一些东西：</p>
<p>1 Spring通知（what &amp; when）</p>
<p>1.1 Spring框架创建的通知都是使用java类编写的；</p>
<p>SO?</p>
<pre><code>1. 可以像开发Java类一样来开发切面（开发AspectJ则需要学习新的内容）</code></pre><p>1.2 定义通知所应用到的切点（where）；</p>
<p>手段1：使用注解；</p>
<p>手段2：在Spring配置文件中使用XML编写；</p>
<p>2 Spring是在运行时把切面织入到目标对象中的；</p>
<p>原理：</p>
<p>​    2.1 Spring会给目标对象创建一个代理对象——这个代理</p>
<p>对象会使用切面包裹目标类（增强）</p>
<p>​    2.2 当程序员调用目标类的方法时，代理类会对此方法的调用</p>
<p>进行拦截，在真正执行目标对象的方法之前，先执行切面逻辑；</p>
<p>3 Spring只支持方法级别的连接点 aka 在方法调用时，可以织入</p>
<p>切面的方法增强</p>
<p>原因：Spring是基于动态代理来实现的AOP，因此只能对方法调用进行拦截；</p>
<hr>
<p>定义切点：指定应用切面的位置（where） aka 那些个匹配切点规则的连接点</p>
<p>手段：使用AspectJ的切点表达式；</p>
<p>特征：Spring支持的AspectJ切点有限，只是xxx的一个子集；</p>
<hr>
<p>编写切点：</p>
<p>该死，这一章既然没有源码…</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个用于织入切面的主题（主题上的各种方法操作都可以作为连接点）</span></span><br><span class="line"><span class="comment">// 表演类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Performance</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">perform</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">任务：在perform()方法被调用时，自动调用指定的通知（advice）</span><br><span class="line">手段：自定义一个切点表达式来声明规则；</span><br><span class="line">	execution(* concert.Performance.perform(..))</span><br><span class="line">    语法：AspectJ指示器(返回类型 方法所属的类.方法(连接点方法所使用的参数))</span><br><span class="line">    execution()指示器用来[what &amp; when]:匹配作为连接点的方法的执行操作；</span><br><span class="line">    * 表示不关心方法的返回值是啥</span><br><span class="line">    类全限定名.方法名(..) ..表示匹配任意入参的perform()方法</span><br></pre></td></tr></table></figure>



<p>this is for now,这种复杂的规则不是用来记忆的，而是用来查询的。</p>
]]></content>
  </entry>
  <entry>
    <title>drill01</title>
    <url>/uncategorized/2020/05/04/drill01.html</url>
    <content><![CDATA[<h3 id="如何使用java代码在控制台打印出hello-world"><a href="#如何使用java代码在控制台打印出hello-world" class="headerlink" title="如何使用java代码在控制台打印出hello world!"></a>如何使用java代码在控制台打印出hello world!</h3><hr>
<ol>
<li><p>创建一个类（Test.java文件）</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span>&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span>&#123;</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"Hello World!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<hr>
<ol start="2">
<li><p>参考文献</p>
<blockquote>
<p>java编程思想</p>
</blockquote>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>我的第二篇博客文章</title>
    <url>/uncategorized/2020/05/03/%E6%88%91%E7%9A%84%E7%AC%AC%E4%BA%8C%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0.html</url>
    <content><![CDATA[<h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><p>内容</p>
<hr>
<h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><p>内容</p>
]]></content>
  </entry>
  <entry>
    <title>我的第一篇博客文章</title>
    <url>/uncategorized/2020/04/12/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0.html</url>
    <content><![CDATA[<h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><p>内容</p>
<hr>
<h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><p>内容</p>
<hr>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="http://www.codepig.cn">www.codepig.cn</a></p>
]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/uncategorized/2020/04/12/hello-world.html</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
</search>
