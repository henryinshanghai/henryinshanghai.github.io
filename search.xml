<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>记一次面试（字节跳动）</title>
    <url>/interview/2020/08/26/interview/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%9D%A2%E8%AF%95%EF%BC%88%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%EF%BC%89.html</url>
    <content><![CDATA[<h3 id="字节跳动（视频面试一面）"><a href="#字节跳动（视频面试一面）" class="headerlink" title="字节跳动（视频面试一面）"></a>字节跳动（视频面试一面）</h3><hr>
<h4 id="关于面试官："><a href="#关于面试官：" class="headerlink" title="关于面试官："></a>关于面试官：</h4><p>​    面试官给我的感觉很好，年龄和我相仿，穿着也很随意。就不会让人产生紧张的情绪，而且问的问题也很有递进性。过程是挺轻松的，结果嘛…</p>
<a id="more"></a>

<h4 id="关于项目："><a href="#关于项目：" class="headerlink" title="关于项目："></a>关于项目：</h4><p>   这个主要问了做过项目中的一些难点问题。但实话讲，做过的项目有些头疼的问题，但都算不上技术难点。于是我先说了公司项目的特征：面向政府机构居多，所以不会存在什么高并发访问的情况。（这是真实情况，也算是降低面试官的期望，别一上来就问大流量情况下如何削峰、限流什么的）</p>
<p>   我说了两点：1 excel表格中大数据导入MySQL数据库的问题；2 后台上传多种格式的资料时的处理；富文本编辑器上传时的格式处理等等</p>
<p>   因为项目总是和业务强相关，面试官可能也不想纠结于细节问题。于是很快就跳到了Java基础的阶段</p>
<h4 id="关于Java基础："><a href="#关于Java基础：" class="headerlink" title="关于Java基础："></a>关于Java基础：</h4><p>这个据我推测，面试官面前可能有一个巨大的Xmind脑图，根据你简历上所写的内容。随机抽取一个点来问你，基本是要考察你对知识点了解的深度；具体问的问题如下：</p>
<h5 id="数据库联合索引与最左匹配原则"><a href="#数据库联合索引与最左匹配原则" class="headerlink" title="数据库联合索引与最左匹配原则"></a>数据库联合索引与最左匹配原则</h5><p>索引：为数据表中的指定字段添加的额外的数据结构；</p>
<p>作用：在查询时，能够通过某个字段的索引来快速定位到满足条件的记录行；</p>
<p>原理：</p>
<ul>
<li>索引一般使用树一类的结构进行存储，因此查询速度很快。</li>
<li>通过索引中的字段值，就能快速定位到数据表中对应的数据行；</li>
</ul>
<p>用法：在SQL查询语句中，使用添加了索引的字段作为查询条件（where xxx=???）。这样就能命中索引，从而实现快速查询；</p>
<p><strong>联合索引</strong>：使用数据表中的多个字段所创建的索引；</p>
<p>作用：在编写SQL语句时，就能够通过多个字段来命中索引——这会使得SQL语句的编写更加灵活；</p>
<p>规则：<strong>最左匹配原则</strong>；（这个我并没有答对）</p>
<p>示例：</p>
<ul>
<li>在创建联合索引时，选择了字段a、b、c；</li>
<li>在编写查询SQL时，<ul>
<li>如果查询的字段以a开头（a、a-b、a-b-c），则能够命中联合索引，从而加速查询；</li>
<li>如果查询的字段不是以a开头（准确的说，是不包含a字段），则无法命中联合索引，查询操作仍旧是遍历的方式；</li>
</ul>
</li>
</ul>
<p>（讲真，我只用Navicat这个可视化工具创建过索引。所以上面的这些东西都是事后找补的   印象分什么的基本就没了）</p>
<h5 id="volatile关键字："><a href="#volatile关键字：" class="headerlink" title="volatile关键字："></a>volatile关键字：</h5><p>（这个我两周之前很细致的看过，但是忘得永远比记住得要快）</p>
<p>是：Java提供的一个关键字；</p>
<p>作用：修饰一个变量，以保证多线程情况下，变量的可见性与有序性；</p>
<p>特征：</p>
<ul>
<li>volatile就只能修饰变量，不能修饰方法啥的；</li>
<li>volatile不能保证多线程操作下的原子性（可能线程A执行了一半后，线程B接管CPU时间片）——需要其他手段来保证；</li>
<li>真正在编码时，这个关键字用得并不多；</li>
</ul>
<p>原理：</p>
<ul>
<li><p>变量对多个线程的可见性：</p>
<ul>
<li><p>JMM（Java 内存模型）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> 每个线程都有自己的工作内存；</span><br><span class="line"><span class="number">2</span> 所有线程共享的变量都在主内存中；</span><br><span class="line"><span class="number">3</span> 线程操作变量时，先从主内存把变量的值拷贝到自己的工作内存中，操作结束后，再把变量的值更新到主内存</span><br><span class="line">中；</span><br></pre></td></tr></table></figure>
</li>
<li><p>结合JMM的3条规则，volatile关键字能够保证所有对变量的更新都即时地同步到主内存中；</p>
</li>
</ul>
</li>
<li><p>变量的有序性：</p>
<ul>
<li><p>JVM指令重排</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">为了提高代码执行的效率，CPU或者编译器可能会对程序员编写的代码进行重新排序；</span><br></pre></td></tr></table></figure>

<ul>
<li>规则：不管如何重新排序，JVM保证在单线程执行时，得到的结果总是相同的；</li>
<li>问题来了，多线程时，指令重排就可能导致程序出现非预期的执行结果；</li>
</ul>
</li>
<li><p>结合以上，volatile关键字能够保证变量的赋值过程（非原子操作）不会出现指令重排，aka，指令的有序性。</p>
</li>
</ul>
</li>
</ul>
<p>应用：实现双重检查锁的单例模式；</p>
<h5 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h5><p>是：Java提供的一个关键字；</p>
<p>作用：为一段代码加锁，从而限制此段代码同一时刻只能被一个线程访问；</p>
<p>特征：早期它的性能很低，但是JDK8中做了很多优化；</p>
<p>用法：</p>
<ul>
<li>修饰实例方法；<ul>
<li>作用：线程在执行实例方法之前，必须要获得当前实例的对象锁；</li>
</ul>
</li>
<li>修饰静态方法；（<em>这里面试官着重问了，但是我没能很好的区分实例锁与类锁</em>）<ul>
<li>作用：线程在执行静态方法之前，必须要获得当前类的对象锁；</li>
</ul>
</li>
<li>修饰代码块；<ul>
<li>作用：线程在执行代码块之前，必须要获得指定对象的锁；</li>
<li>特征：这里的对象可以由程序员手动指定；</li>
</ul>
</li>
</ul>
<p>应用：双重检查校验的单例模式（和volatile配合使用）；</p>
<p>原理：JVM层面的一些东西，在字节码上添加了一些独特的标识；</p>
<h5 id="synchronized关键字-与-ReentrantLock类型（这个面试官没问，可能是因为上面答得不好）"><a href="#synchronized关键字-与-ReentrantLock类型（这个面试官没问，可能是因为上面答得不好）" class="headerlink" title="synchronized关键字 与 ReentrantLock类型（这个面试官没问，可能是因为上面答得不好）"></a>synchronized关键字 与 ReentrantLock类型（这个面试官没问，可能是因为上面答得不好）</h5><p>作用：都能够为代码段加锁，从而限制多个线程对代码块的访问；</p>
<p>相同点：</p>
<ul>
<li>两者都是可重入锁（re-entree）;<ul>
<li>线程可以重复获取到对象的锁——当再次获取对象锁时，计数值+1；</li>
</ul>
</li>
</ul>
<p>不同点：</p>
<ul>
<li>实现层面<ul>
<li>synchronized关键字的实现是在JVM中，而ReentrantLock的实现在JDK的concurrent包中；</li>
</ul>
</li>
<li>用法层面<ul>
<li>synchronized是关键字，用法比较单一（无非修饰不同的成份），而ReentrantLock是一个类，用法就非常灵活了；</li>
</ul>
</li>
<li>功能层面<ul>
<li>ReentrantLock提供了更多的功能：<ul>
<li>1 使等待中的线程放弃等待（去做别的事情）；</li>
<li>2 指定锁的类型（是公平锁，还是非公平锁）；公平锁：等待最久的线程会在锁被释放时，优先获取到锁；</li>
<li>3 实现等待 - 通知机制；</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h5><p>参考：<a href="https://www.jianshu.com/p/f584799f1c77">公平🔒</a></p>
<p>必须：兔子喝水，黑狗看门；</p>
<p>结论：</p>
<ul>
<li>1、若在释放锁的时候总是没有新的兔子来打扰，则非公平锁等于公平锁；</li>
<li>2、若释放锁的时候，正好一个兔子来喝水，而此时位于队列头的兔子还没有被唤醒（因为线程上下文切换是需要不少开销的），此时后来的兔子则优先获得锁，成功打破公平，成为非公平锁；</li>
</ul>
<h5 id="类加载过程中的双亲委派模型"><a href="#类加载过程中的双亲委派模型" class="headerlink" title="类加载过程中的双亲委派模型"></a>类加载过程中的双亲委派模型</h5><p><strong>类加载过程</strong>：</p>
<p>是：一个过程；</p>
<p>作用：把编译器编译生成的class文件，以特定的格式加载到JVM内存中的特定区域；</p>
<p>特征：分为两类；</p>
<ul>
<li>预加载；<ul>
<li>在虚拟机启动时就会被加载到内存中的class文件；比如lang.*与util.*等；</li>
</ul>
</li>
<li>运行时加载；<ul>
<li>在运行程序时，虚拟机根据类的全限定名来去查找并加载对应的class文件；</li>
</ul>
</li>
</ul>
<p>SOP:</p>
<ul>
<li>通过类的全限定名获取到<em>类的二进制字节流</em>；</li>
<li>把<em>字节流所代表的静态存储结构</em>转化为<em>方法区的运行时数据结构</em>；</li>
<li>在JVM内存中生成<em>表示这个类的Class对象</em>——它包含类的一切信息，是反射机制的基础；</li>
</ul>
<p><strong>双亲委派模型</strong>：</p>
<p>是：一个使用类加载器时，推荐遵守的规则；</p>
<p>作用：保证核心类型都能够被安全地加载到内存中；防止不法分子写的String类型被JVM错误加载…</p>
<p>特征：</p>
<p>​    1 这不是一个强制遵守的规则；</p>
<p>​    2 每一层加载器都有自己能够加载的类型范围；</p>
<p>规则描述：</p>
<ul>
<li>当类加载器需要把一个类加载到内存中的时候，先尝试把加载的工作交给更高层的类加载器完成；</li>
<li>然后再转交给更高级的类加载器，so on and so forth,直到到达最高层的类加载器（Bootstrap）；</li>
<li>只有顶层类加载器无法加载的类型（每一层加载器都有自己所能加载的类型范围），才会交给底层的类加载器去加载；</li>
</ul>
<h5 id="Spring-IoC容器"><a href="#Spring-IoC容器" class="headerlink" title="Spring IoC容器"></a>Spring IoC容器</h5><p>是：一个管理对象 以及 对象之间依赖关系的第三方；</p>
<p><em>如何解决循环依赖的问题呢？</em></p>
<p><strong>循环依赖</strong>：</p>
<p>IoC容器中注入了实例a与实例b，实例a依赖于实例b，同时实例b也依赖于实例a；</p>
<p>issue：IoC容器在创建实例a时，需要先创建实例b。但是创建实例b时，又需要先创建实例a，狗咬尾巴</p>
<p>参考：<a href="https://segmentfault.com/a/1190000015221968">Spring对循环依赖的解决</a></p>
<p>解决方案：</p>
<p>1 尝试创建实例a，发现实例a依赖于实例b；</p>
<p>2 尝试创建实例b，发现实例b依赖于实例a；</p>
<p>3 获取到实例a的一个<strong>早期引用</strong>（属性未进行初始化的引用）；</p>
<p>4 把这个早期引用注入到实例b中，使得实例b完成初始化；</p>
<p>5 然后实例a再去获取到实例b的引用，得到实例a的<strong>完全引用</strong>；</p>
<h5 id="AOP（面向切面编程）"><a href="#AOP（面向切面编程）" class="headerlink" title="AOP（面向切面编程）"></a>AOP（面向切面编程）</h5><p>是：一种编程的方式；对标OOP</p>
<p>作用：能够把应用中一些公共的功能（事务、安全等）抽取出来单独实现，然后以声明的方式编织到需要它们的代码中；</p>
<p>特征：AOP是一种思想，不同框架对这种思想的实现会各有差异。比如Spring AOP与AspectJ；</p>
<p>用法：这个步骤比较多，不宜作为面试部分；</p>
<p>原理：Spring AOP的底层原理是动态代理+反射；</p>
<ul>
<li>代理类会封装目标类，并把<em>用于增强的切面类</em>添加到目标类的外围；</li>
<li>动态代理这种方式绝定了Spring AOP<em>只能对方法做一些增强（因为动态代理使用反射实现目标）</em>，而对字段等无能为力；</li>
<li>Java中的动态代理：JDK动态代理（要求被代理的类实现接口） 与 CGLib动态代理（不要求…）；</li>
</ul>
<h5 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h5><p>注：这是一个多线程安全的类型，我在简历中有写看过它的源码，但其实只看了分析的文章。时隔两周，就只记得“分段锁”这三个字了 😭</p>
<p>是：一个容器/集合；</p>
<p>作用：存储键值对；</p>
<p>特征：多线程安全；</p>
<p><strong>多线程安全原理</strong>：</p>
<p>​    JDK1.7的手段：</p>
<ul>
<li><p>把容器表示成多个数据段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcurrentHashMap</span></span>&#123;</span><br><span class="line">    <span class="comment">// Segment数组	Segment类型本身继承了ReentrantLock，可以当作锁</span></span><br><span class="line">    Segment[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>数据段中存储多个键值对：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Segment</span></span>&#123;</span><br><span class="line">    HashEntry[]; <span class="comment">// HashEntry就是一个封装了键值对的类型；</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<ul>
<li>为每个数据段Segment添加一把锁，这样如果多个线程访问的是不同的数据段，就不会出现并发访问；而如果访问的是同一个数据段，仍旧是获取到锁的执行，没有获取到锁的等待</li>
</ul>
<p>​    JDK1.8使用的手段：</p>
<ul>
<li>synchronized关键字 + CAS乐观锁【细节需要看源码】</li>
<li>synchronized关键字只会锁住链表或红黑二叉树的头节点，如果多线程操作没有发生哈希冲突，就不会出现并发访问；如果操作到了同一个哈希位置，仍旧是…;</li>
</ul>
<p><strong>底层结构</strong>：</p>
<p>​    JDK1.7 Segment[] + HashEntry[]；</p>
<p>​    JDK1.8 Node[] + 链表 + 红黑树；</p>
<p>用法：</p>
<p>​    put()方法，前后有8步。</p>
<p>​    get()方法，就是按图索骥的过程，与多线程关系不大（毕竟它只是一个访问操作）；</p>
<blockquote>
<p>in case I don’t see u again, good morning, good afternoon, and good evening!😄</p>
</blockquote>
<p>​    </p>
]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Java stuff</tag>
      </tags>
  </entry>
  <entry>
    <title>奇偶链表_10</title>
    <url>/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8%EF%BC%88%E6%8A%8A%E5%A5%87%E6%95%B0%E4%BD%8D%E7%BD%AE%E4%B8%8E%E5%81%B6%E6%95%B0%E4%BD%8D%E7%BD%AE%E4%B8%8A%E7%9A%84%E8%8A%82%E7%82%B9%E8%BF%9E%E5%9C%A8%E4%B8%80%E8%B5%B7%EF%BC%89_10.html</url>
    <content><![CDATA[<h4 id="把链表中的奇数位置节点与偶数位置节点放在一起"><a href="#把链表中的奇数位置节点与偶数位置节点放在一起" class="headerlink" title="把链表中的奇数位置节点与偶数位置节点放在一起"></a>把链表中的奇数位置节点与偶数位置节点放在一起</h4><h4 id="题设-与-要求"><a href="#题设-与-要求" class="headerlink" title="题设 与 要求"></a>题设 与 要求</h4><p><img src="https://s1.ax1x.com/2020/08/15/dklpjK.md.png" alt="题设与要求"></p>
<a id="more"></a>

<h4 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h4><p><img src="https://s1.ax1x.com/2020/08/15/dkldDU.md.png" alt="测试用例"></p>
<h4 id="附加说明"><a href="#附加说明" class="headerlink" title="附加说明"></a>附加说明</h4><p><img src="https://s1.ax1x.com/2020/08/15/dklLKf.md.png" alt="提示信息"></p>
<h4 id="分析（问题的难点）"><a href="#分析（问题的难点）" class="headerlink" title="分析（问题的难点）"></a>分析（问题的难点）</h4><ul>
<li>如何把奇数/偶数位置的节点都连接起来？</li>
<li>如何把奇数位置节点的集合 与 偶数位置节点的集合连接起来？</li>
</ul>
<h4 id="思路（难点的解决方案）"><a href="#思路（难点的解决方案）" class="headerlink" title="思路（难点的解决方案）"></a>思路（难点的解决方案）</h4><ul>
<li>如何把奇数位置/偶数位置的节点都连接起来？<ul>
<li>答：使用两个指针odd、even，初始化指向第一个节点与第二个节点。然后去创建奇数位置节点链表与偶数位置节点链表；</li>
</ul>
</li>
<li>如何把奇数位置节点集合与偶数位置节点集合连接起来？<ul>
<li>答：只要把odd链表的尾节点连接到even链表的头节点就可以了</li>
</ul>
</li>
</ul>
<h4 id="根据思路进行编码（细节处理）"><a href="#根据思路进行编码（细节处理）" class="headerlink" title="根据思路进行编码（细节处理）"></a>根据思路进行编码（细节处理）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">oddEvenList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 鲁棒性代码</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1 定义需要的实例变量</span></span><br><span class="line">        ListNode odd = head; <span class="comment">// 奇数位置节点的指针	作用：连接奇数位置的节点</span></span><br><span class="line">        ListNode even = head.next; <span class="comment">// 偶数位置节点的指针	作用：连接偶数位置的节点</span></span><br><span class="line">        ListNode evenHead = even; <span class="comment">// 作用：记录偶数节点链表的头节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 遍历当前链表	在循环中：1 创建奇数位置节点链表； 2 创建偶数位置节点链表</span></span><br><span class="line">        <span class="keyword">while</span>(even != <span class="keyword">null</span> &amp;&amp; even.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 创建链表SOP： 1 建立连接； 2 更新指针；</span></span><br><span class="line">            odd.next = even.next;</span><br><span class="line">            odd = odd.next;</span><br><span class="line"></span><br><span class="line">            even.next = odd.next;</span><br><span class="line">            even = even.next; <span class="comment">// even会率先达到链表的尾部</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 把偶数链表连接到奇数链表的尾节点上</span></span><br><span class="line">        odd.next = evenHead;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 返回新链表的头节点（作图可知）</span></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="代码分解SOP"><a href="#代码分解SOP" class="headerlink" title="代码分解SOP"></a>代码分解SOP</h4><ul>
<li>定义需要的实例变量</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ListNode odd = head; <span class="comment">// 用于指向奇数位置的节点</span></span><br><span class="line">ListNode even = head.next; <span class="comment">// 用于指向偶数位置的节点</span></span><br></pre></td></tr></table></figure>

<ul>
<li>遍历当前链表中的所有节点    在循环中：1 创建奇数节点的链表； 2 创建偶数节点的链表</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(ture)&#123; <span class="comment">// 参考：画图</span></span><br><span class="line">    <span class="comment">// 创建连接</span></span><br><span class="line">    odd.next = even.next;</span><br><span class="line">    <span class="comment">// 更新指针</span></span><br><span class="line">    odd = odd.next;</span><br><span class="line">    </span><br><span class="line">    even.next = odd.next;</span><br><span class="line">    even = even.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s1.ax1x.com/2020/08/15/dkteIO.md.jpg" alt="遇事不决画个图"></p>
<ul>
<li>确定循环执行表达式</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据链表中的节点数的不同，循环终结会有两种情况</span></span><br><span class="line"><span class="comment">// 1 链表中的节点数目为偶数个	even.next == null</span></span><br><span class="line"><span class="comment">// 2 链表中的节点数目为奇数个	even == null</span></span><br><span class="line"><span class="comment">// 当这两种情况之一发生时，就要终止循环 所以</span></span><br><span class="line"><span class="keyword">while</span>(even == <span class="keyword">null</span> &amp;&amp; even.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>把偶数链表连接到奇数链表上</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">odd.next = evenHead; <span class="comment">// 连接到记录的最初的偶数链表的头节点</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Bingo! good morning,good afternoon,and good night 🌙</p>
</blockquote>
]]></content>
      <categories>
        <category>ListNode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>分隔链表得到子链表_09</title>
    <url>/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E6%8A%8A%E9%93%BE%E8%A1%A8%E5%88%86%E9%9A%94%E6%88%90k%E4%B8%AA%E5%AD%90%E9%93%BE%E8%A1%A8_09.html</url>
    <content><![CDATA[<h4 id="把链表分隔成k个子链表"><a href="#把链表分隔成k个子链表" class="headerlink" title="把链表分隔成k个子链表"></a>把链表分隔成k个子链表</h4><hr>
<h4 id="题设与要求"><a href="#题设与要求" class="headerlink" title="题设与要求"></a>题设与要求</h4><p><img src="https://s1.ax1x.com/2020/08/15/dFWppn.md.png" alt="题设与要求"></p>
<a id="more"></a>

<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p><img src="https://s1.ax1x.com/2020/08/15/dFICeP.md.png" alt="测试用例"></p>
<h4 id="提示信息"><a href="#提示信息" class="headerlink" title="提示信息"></a>提示信息</h4><p><img src="https://s1.ax1x.com/2020/08/15/dFoZtO.png" alt="提示信息"></p>
<h4 id="分析（题目中的难点）"><a href="#分析（题目中的难点）" class="headerlink" title="分析（题目中的难点）"></a>分析（题目中的难点）</h4><ul>
<li>根据题设，就是要把链表中的节点均分为k份；<ul>
<li>要如何处理(length % k)余下的这些个节点？</li>
</ul>
</li>
<li>k个连续的部分，每个部分相差不超过1；<ul>
<li>说明每个子链表中的节点数会有不一样。可以顺序的让靠前的子链表中多出一个节点，来消耗余下的节点</li>
<li>如何确定到哪一个子链表时，余下的节点已经被消耗完了呢？</li>
</ul>
</li>
<li>如果k &gt; length，缺少的部分补充null作为元素；</li>
</ul>
<h4 id="思路（对难点的解决方案）"><a href="#思路（对难点的解决方案）" class="headerlink" title="思路（对难点的解决方案）"></a>思路（对难点的解决方案）</h4><ul>
<li>定义一个大小为k数组，数组中的第i个元素表示：第i个子链表中应该包含的节点数目；</li>
<li>定义一个循环，每次循环都为数组中的一个元素绑定值<ul>
<li>先求出余数；</li>
<li>每次绑定值时，判断余数是否还大于0.如果是，就把要绑定的值+1； 同时余数-1</li>
<li>每个子节点要绑定的基础数值为：(length / k)</li>
</ul>
</li>
<li>定义一个子链表列表，用于存储分割后的子链表；</li>
<li>定义一个循环，每次循环<ul>
<li>从数组中取出当前子链表应该包含的节点数；</li>
<li>根据上面的节点数目来创建一个子链表，并把子链表绑定到子链表列表的一个元素上；</li>
<li>循环往复，直到链表中的所有节点都被安排了</li>
</ul>
</li>
</ul>
<h4 id="把思路翻译成代码（🙏）"><a href="#把思路翻译成代码（🙏）" class="headerlink" title="把思路翻译成代码（🙏）"></a>把思路翻译成代码（🙏）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode[] splitListToParts(ListNode root, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="comment">// 定义一个指针 作用：作为游标，计算链表的节点长度</span></span><br><span class="line">        ListNode cursor = root;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义一个链表列表 作用：存储分割后的多个子链表；</span></span><br><span class="line">        ListNode[] res = <span class="keyword">new</span> ListNode[k]; <span class="comment">// 默认每个元素绑定的都是一个null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 鲁棒性代码</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算链表长度</span></span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cursor != <span class="keyword">null</span>)&#123;</span><br><span class="line">            length++;</span><br><span class="line">            cursor = cursor.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 比较链表长度length 与 预期分割得到的子链表数目k</span></span><br><span class="line">        <span class="keyword">if</span>(k &gt;= length)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;length; i++)&#123; <span class="comment">// 使用root链表中的节点对res数组的元素进行重新初始化</span></span><br><span class="line">                res[i] = <span class="keyword">new</span> ListNode(root.val);</span><br><span class="line">                root = root.next;</span><br><span class="line">            &#125; <span class="comment">// 只初始化了length个元素。剩下的元素仍旧是null</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 计算出第N个子链表应该包含多少个节点</span></span><br><span class="line">            <span class="keyword">int</span> remainder = length % k;</span><br><span class="line">            <span class="keyword">int</span> part = length / k;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">                counts[i] = remainder &gt; <span class="number">0</span> ? part + <span class="number">1</span> : part;</span><br><span class="line">                remainder--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从原始链表中截取出k个子链表，并添加到链表数组中</span></span><br><span class="line">            ListNode p = root;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;k; i++)&#123;</span><br><span class="line"></span><br><span class="line">                res[i] = p;</span><br><span class="line">                <span class="comment">// 当前子链接中应该包含多少个节点</span></span><br><span class="line">                <span class="keyword">int</span> count = counts[i];</span><br><span class="line">                <span class="keyword">while</span>(--count &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    p = p.next;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 记录下一个节点</span></span><br><span class="line">                ListNode temp = p.next;</span><br><span class="line">                <span class="comment">// 为当前节点绑定null</span></span><br><span class="line">                p.next = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 更新当前节点</span></span><br><span class="line">                p = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回得到的子链表列表</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="代码分解步骤"><a href="#代码分解步骤" class="headerlink" title="代码分解步骤"></a>代码分解步骤</h4><ul>
<li>定义需要的实例变量</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ListNode cursor = head; <span class="comment">// 用于在链表的节点上遍历</span></span><br><span class="line">ListNode[] res = <span class="keyword">new</span> ListNode[k]; <span class="comment">// 一个大小为k的ListNode类型的数组	用于存储分割后的子链表</span></span><br></pre></td></tr></table></figure>



<ul>
<li>求出链表的长度</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(cursor != <span class="keyword">null</span>)&#123;</span><br><span class="line">	length++;</span><br><span class="line">    cursor = cursor.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>比较链表长度length与预期分隔得到的子链表数目k</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(k &gt; length)&#123;</span><br><span class="line">	<span class="comment">// 子链表数目比链表本身的节点还要多		手段：不足的部分补上null</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 子链表数目小于等于链表本身的节点数目	手段：平均分配，盈余的话可能要多分一个</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当子链表数目k比起链表本身的节点length还要多时</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化res数组中前面length个元素</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;length; i++)&#123;</span><br><span class="line">    <span class="comment">// 创建一个新的链表，并绑定到子链表中	为什么要新建链表？</span></span><br><span class="line">    res[i] = <span class="keyword">new</span> ListNode(root.val);</span><br><span class="line">    root = root.next;</span><br><span class="line">&#125; <span class="comment">// 没有绑定子链表的节点，值默认是null 符合题目要求</span></span><br></pre></td></tr></table></figure>

<ul>
<li>当子链表数目小于等于链表本身的节点length时<ul>
<li>Ⅰ 计算出每个子链表应该包含的节点数量，并存储到一个数组中；</li>
<li>Ⅱ 遍历原始链表：<ul>
<li>从中取出正确数量的节点添加到子链表中；</li>
<li>当前子链接添加完成后，截断子链表。并把指针移动到下一个子链表的起始处</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Ⅰ计算出每个子链表应该包含的节点数量，并存储到一个数组中；</span></span><br><span class="line"><span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> perPart = length / k; <span class="comment">// 每个子链表的基础节点数目</span></span><br><span class="line"><span class="keyword">int</span> remainder = (length % k); <span class="comment">// 均分k份之后，余下的节点数量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;k; i++)&#123;</span><br><span class="line">    <span class="comment">// 使用三目运算符来替代一个if/else逻辑</span></span><br><span class="line">    counts[i] = (remainder &gt; <span class="number">0</span>) : perPart + <span class="number">1</span> : perPart;</span><br><span class="line">    remainder--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Ⅱ 遍历原始链表,把原始列表分割成k个子链表</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; k; i++)&#123;</span><br><span class="line">	<span class="comment">/* ① 从原始链表中取出正确数量的节点添加到子链表中 */</span></span><br><span class="line">    <span class="comment">// 创建一个新的指针		指向头节点</span></span><br><span class="line">    ListNode p = root; </span><br><span class="line">    <span class="comment">// 把当前子链表的头节点绑定到res[]的元素上</span></span><br><span class="line">    res[i] = p;</span><br><span class="line">    <span class="comment">// 获取到当前子链接中应该包含的节点数</span></span><br><span class="line">    <span class="keyword">int</span> count = counts[i];</span><br><span class="line">    <span class="comment">// 获取到指定数量的节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;count; j++)&#123; <span class="comment">// 应该向后遍历(count - 1)次</span></span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 当前子链接添加完成后，截断子链表。并把指针移动到下一个子链表的起始处 */</span></span><br><span class="line">    <span class="comment">// 记录下一个节点</span></span><br><span class="line">    ListNode temp = p.next; </span><br><span class="line">    <span class="comment">// 截断当前链表</span></span><br><span class="line">    p.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 更新当前节点</span></span><br><span class="line">    p = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>返回添加了子链表元素的res数组</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure>



<h4 id="启示"><a href="#启示" class="headerlink" title="启示"></a>启示</h4><p>对于循环次数已知的情况，推荐使用for循环。因为它的表达式非常容易写</p>
<p>while循环语法适用于那些循环次数不确定的场合</p>
<blockquote>
<p>until next time 😄</p>
</blockquote>
]]></content>
      <categories>
        <category>ListNode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>回文链表(迭代)_08_2</title>
    <url>/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E9%93%BE%E8%A1%A8%E6%98%AF%E4%B8%8D%E6%98%AF%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8%EF%BC%88%E8%BF%AD%E4%BB%A3%E6%96%B9%E5%BC%8F%EF%BC%89_08_2.html</url>
    <content><![CDATA[<h3 id="判断一个链表是不是回文链表（迭代方式）"><a href="#判断一个链表是不是回文链表（迭代方式）" class="headerlink" title="判断一个链表是不是回文链表（迭代方式）"></a>判断一个链表是不是回文链表（迭代方式）</h3><h4 id="题设与要求"><a href="#题设与要求" class="headerlink" title="题设与要求"></a>题设与要求</h4><p><img src="https://s1.ax1x.com/2020/08/15/diX5I1.png" alt="题设与要求"></p>
<a id="more"></a>

<h4 id="分析（问题的难点）"><a href="#分析（问题的难点）" class="headerlink" title="分析（问题的难点）"></a>分析（问题的难点）</h4><ul>
<li><p>这里不再考虑使用递归的方式，因为上一篇中已经实现了递归的代码；</p>
</li>
<li><p>为了判断链表是不是回文链表，肯定要对其左半边与右半边的节点进行比较；</p>
<p><strong>难点1</strong>：如何确定链表的左半边与右半边？aka 链表的中间节点位置</p>
</li>
<li><p>假设现在已经找到了中间节点的位置，接下来要怎么逐个比较各个节点呢？</p>
<p>方式1 从两边到中间，逐个比较节点的值；</p>
<p>方式2 从中间到两边，逐个比较节点的值；</p>
<p>说明：不管哪一种方式，都会面临一个问题——指针无法逆着链表节点移动；</p>
<p><strong>难点2</strong>：如何能让指针逆着链表的方向移动？</p>
</li>
<li><p>如果上面两个难点都得到解决，接下来就只需要逐个比较节点的值，分分钟无障碍</p>
</li>
</ul>
<h4 id="思路（难点的解决手段）"><a href="#思路（难点的解决手段）" class="headerlink" title="思路（难点的解决手段）"></a>思路（难点的解决手段）</h4><ul>
<li><p>难点1 如何确定链表的中间节点位置？</p>
<p>手段：快慢指针。</p>
<p>具体方法：从head节点开始（具体需要画图确认最佳方案），快指针一次走两个节点，慢指针一次走一个节点。</p>
<p>原理：当快指针指向链表尾节点时，慢指针应该刚好指向链表的中间节点。（或者前面一个节点）</p>
</li>
<li><p>难点2 如何能让指针逆着链表方向移动？</p>
<p>说明：实现这个目标其实有多个手段，比如借助额外空间整一个新链表。但是题目要求O(1)的空间复杂度，so pass this</p>
<p>手段：对链表的左半部分/右半部分进行翻转；</p>
<p>具体方法：翻转链表所需要的3个指针——prev、curr、temp；</p>
<p>原理：如果翻转左半部分，从中间节点到两边的节点进行比较；如果翻转右半部分，则是从两边的节点向中间节点进行比较；</p>
<p>这里我们选择翻转左半部分</p>
</li>
</ul>
<h4 id="把思路翻译成代码"><a href="#把思路翻译成代码" class="headerlink" title="把思路翻译成代码"></a>把思路翻译成代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1 作用：判断一个链表是不是回文链表，并返回布尔值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 迭代方式</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 防止NPE的指针</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用于翻转链表的指针</span></span><br><span class="line">        ListNode prev = dummy;</span><br><span class="line">        ListNode curr = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用于定位到中点的指针</span></span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一边定位，一边创建新的链表   翻转三部曲：1 记录当前节点的下一个节点； 2 改变当前节点的连接   3 更新指针prev与curr</span></span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123; <span class="comment">// slow与curr的位置关系还需要考察</span></span><br><span class="line">            <span class="comment">// 注： 当前节点的下一个节点总是slow,所以第1步省略</span></span><br><span class="line">            curr = slow; <span class="comment">// 3-2 更新指针curr</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新快慢指针</span></span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 翻转链表</span></span><br><span class="line">            curr.next = prev; <span class="comment">// 2 改变连接</span></span><br><span class="line">            prev = curr; <span class="comment">// 3-1 更新指针prev</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据fast的特征判断slow的位置</span></span><br><span class="line">        <span class="keyword">if</span>(fast != <span class="keyword">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过逐个比较两个链表的节点来判断是否为回文链表</span></span><br><span class="line">        <span class="keyword">while</span>(slow != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(curr.val != slow.val)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            curr = curr.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="代码步骤分解"><a href="#代码步骤分解" class="headerlink" title="代码步骤分解"></a>代码步骤分解</h4><ul>
<li>定义需要的实例变量（包括指针变量）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方便定位链表头节点的指针</span></span><br><span class="line">      ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">      dummy.next = head;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 用于翻转链表的指针</span></span><br><span class="line">      ListNode prev = dummy;</span><br><span class="line">      ListNode curr = head;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 用于定位到中点的指针</span></span><br><span class="line">      ListNode slow = head;</span><br><span class="line">      ListNode fast = head;</span><br></pre></td></tr></table></figure>

<ul>
<li>循环中需要做的事情：Ⅰ 定位链表的中间节点；    </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123; <span class="comment">// 2 直到快指针指向链表的尾节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 手段SOP：1 不断更新快慢指针</span></span><br><span class="line">    slow = slow.next;</span><br><span class="line">    fast = fast.next.next;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Ⅱ 对左半部分链表进行翻转；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">    翻转三步曲	</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    // 1 记录当前节点的下一个节点；</span></span><br><span class="line"><span class="comment">    ListNode temp = curr.next;</span></span><br><span class="line"><span class="comment">    // 2 改变当前节点的连接</span></span><br><span class="line"><span class="comment">    curr.next = prev;</span></span><br><span class="line"><span class="comment">    // 3 更新指针prev与curr	把prev更新到curr，把curr更新到temp</span></span><br><span class="line"><span class="comment">    prev = curr;</span></span><br><span class="line"><span class="comment">    curr = temp;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 问题来了：1 当前节点的下一个节点是什么呢？</span></span><br><span class="line">    <span class="comment">// 问题2：左半边的链表应该结束于哪一个节点呢？</span></span><br><span class="line">    <span class="comment">// 解决手段：为了准确定位左半部分链表的边界，把“当前节点的下一个节点”设置为slow指向的节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 知道了“当前节点的下一个节点为slow”后，套用上面的翻转三步曲 */</span></span><br><span class="line">    <span class="comment">// 1 记录当前节点的下一个节点 	手段：直接获取slow就可以了</span></span><br><span class="line">    <span class="comment">// 2 更新当前节点的连接为前一个节点</span></span><br><span class="line">    curr.next = prev; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3 更新指针</span></span><br><span class="line">    prev = curr; </span><br><span class="line">    curr = slow; <span class="comment">// 更新当前指针</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s1.ax1x.com/2020/08/15/dFei4K.md.jpg" alt="翻转图示"></p>
<ul>
<li>确保curr总是落后于slow一个节点</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 手段：把更新curr的语句放在更新快慢指针的语句之前</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    curr = slow; <span class="comment">// 更新当前节点为temp</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更新快慢指针</span></span><br><span class="line">    slow = slow.next;</span><br><span class="line">    fast = fast.next.next;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 翻转链表中的节点</span></span><br><span class="line">    curr.next = prev;</span><br><span class="line">    prev = curr;</span><br><span class="line">    <span class="comment">// 更新curr指针的代码在第一行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>确定循环执行表达式</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参考图示可知，fast应该停留在尾节点 或者 null节点上</span></span><br><span class="line"><span class="comment">// 原则：刚好形成可以一一对比其节点的左半部分链表（已翻转）</span></span><br><span class="line"><span class="keyword">while</span>(fast != <span class="keyword">null</span> || fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>根据情况来移动slow指针——因为这时候左右链表的节点数可能不一样</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参考图示可知：当链表节点数为奇数个时，slow指在最中间节点的位置。这时候右半部分链表的节点多了一个</span></span><br><span class="line"><span class="keyword">if</span>(fast != <span class="keyword">null</span>)&#123; <span class="comment">// fast!=null是这种情况下的特征</span></span><br><span class="line">    slow = slow.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>逐个比较左右两个链表的节点，来判断总链表是不是回文链表</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(curr.val != slow.val)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    curr = curr.next;</span><br><span class="line">    slow = slow.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>确定循环执行表达式</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 由于左右两个链表的节点长度是一样的，所以只要任一一个链表到头，循环就结束</span></span><br><span class="line"><span class="keyword">while</span>(slow != <span class="keyword">null</span>)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>鲁棒性代码</li>
<li>测试用例</li>
</ul>
<h4 id="代码重现（拆解之后的组合）"><a href="#代码重现（拆解之后的组合）" class="headerlink" title="代码重现（拆解之后的组合）"></a>代码重现（拆解之后的组合）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 定义需要的指针</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 翻转所需要用到的指针</span></span><br><span class="line">        ListNode prev = dummy;</span><br><span class="line">        ListNode curr = head;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 寻找中间节点所需要用到的指针</span></span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123; <span class="comment">// 只要有一个为false，循环就会结束</span></span><br><span class="line">            <span class="comment">// 翻转节点 - 2 </span></span><br><span class="line">            curr = slow;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 更新快慢指针</span></span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 翻转节点 - 1</span></span><br><span class="line">            curr.next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果需要，更新slow指针的位置</span></span><br><span class="line">        <span class="keyword">if</span>(fast != <span class="keyword">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历左右链表的每个节点，逐一比较</span></span><br><span class="line">        <span class="keyword">while</span>(slow != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(curr.val != slow.val)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            curr = curr.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>this is loads of code. until next time 😓</p>
</blockquote>
]]></content>
      <categories>
        <category>ListNode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>回文链表_08</title>
    <url>/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E4%B8%BA%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8(%E9%80%92%E5%BD%92%E6%96%B9%E5%BC%8F)_08.html</url>
    <content><![CDATA[<h3 id="判断一个链表是否为回文链表"><a href="#判断一个链表是否为回文链表" class="headerlink" title="判断一个链表是否为回文链表"></a>判断一个链表是否为回文链表</h3><h4 id="题设与要求"><a href="#题设与要求" class="headerlink" title="题设与要求"></a>题设与要求</h4><p><img src="https://s1.ax1x.com/2020/08/15/diX5I1.png" alt="题设与要求"></p>
<a id="more"></a>

<h4 id="分析（问题的难点）"><a href="#分析（问题的难点）" class="headerlink" title="分析（问题的难点）"></a>分析（问题的难点）</h4><p>1 回文链表的定义:左半边与右半边完全对称——这样从左边读起与从右边读起来，读到的内容是相同的。</p>
<p>2 如果使用迭代的方式，比较直观的想法是：头尾节点各一个指针，然后指针向里走。指针每走一次，就要比较一次节点的值。</p>
<ul>
<li>难点：但是由于是单向链表，尾节点的指针没有办法直接向前走。所以在此之前需要把右半边的链表翻转，然后再进行迭代与比较操作。可以预见，需要确定诸多的细节：右半边链表的终点、循环终止条件等</li>
</ul>
<p>3 能不能使用递归的方式呢？</p>
<ul>
<li>把问题转换为更小规模的问题：head头节点 + 中间节点组成的链表 + tail尾节点；<ul>
<li>中间节点组成的链表是不是回文链表，这就是一个更小规模的问题；</li>
</ul>
</li>
<li>更小规模问题的处理结果，能用来解决问题本身吗？<ul>
<li>如果中间节点组成的链表middle是一个回文链表，就只需要判断head.val == tail.val。如果相等，则整个链表就是一个回文链表</li>
</ul>
</li>
</ul>
<h4 id="思路（优先使用递归）"><a href="#思路（优先使用递归）" class="headerlink" title="思路（优先使用递归）"></a>思路（优先使用递归）</h4><p>1 把方法定义为一个递归方法，确定方法的作用与返回值；</p>
<ul>
<li>方法作用：判断一个链表是否为回文链表；    返回值：true/false；</li>
</ul>
<p>2 确定递归的终止条件；</p>
<ul>
<li>链表为null/链表中只有一个节点；    这时候可以认为链表是一个回文链表</li>
</ul>
<p>3 确定本级递归要完成的事情；</p>
<ul>
<li>编码时再具体说明</li>
</ul>
<h4 id="把思路翻译成代码"><a href="#把思路翻译成代码" class="headerlink" title="把思路翻译成代码"></a>把思路翻译成代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ListNode类型的定义省略</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1 方法作用：判断一个链表是否为回文链表；	返回值：true/false；</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 2 递归终结条件</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3 本级递归要做的事情</span></span><br><span class="line">        <span class="comment">// ① 把链表视为：链表头节点head + 中间节点组成的链表middle + 尾节点tail</span></span><br><span class="line">        <span class="comment">// ② 获取到head与tail，判断头节点与尾节点的值是否相等。如果不相等，返回false</span></span><br><span class="line">        <span class="comment">// ③ 如果相等，并且middle也是一个回文链表。则返回true，否则返回false</span></span><br><span class="line">        ListNode cursor = head;</span><br><span class="line">        <span class="keyword">while</span>(cursor.next != <span class="keyword">null</span>)&#123; <span class="comment">// 循环终止时，希望cursor指向尾节点，而不是null</span></span><br><span class="line">            cursor = cursor.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断头节点与尾节点的值是否相等</span></span><br><span class="line">        <span class="keyword">if</span>(head.val != cursor.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 获取到中间节点组成的链表middle</span></span><br><span class="line">            cursor = head.next;</span><br><span class="line">            ListNode middle = cursor;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 删除尾节点：这样其实破坏了原始的链表结构，需要和面试官确认</span></span><br><span class="line">            <span class="keyword">while</span>(cursor != <span class="keyword">null</span> &amp;&amp; cursor.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(cursor.next.next = <span class="keyword">null</span>)&#123;</span><br><span class="line">                    cursor.next = <span class="keyword">null</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cursor = cursor.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 判断middle是不是一个回文链表</span></span><br><span class="line">            <span class="keyword">return</span> isPalindrome(middle);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：这里获取到middle的过程还是差了点意思。</p>
<h4 id="添加鲁棒性的代码"><a href="#添加鲁棒性的代码" class="headerlink" title="添加鲁棒性的代码"></a>添加鲁棒性的代码</h4><h4 id="使用不同的测试用例测试"><a href="#使用不同的测试用例测试" class="headerlink" title="使用不同的测试用例测试"></a>使用不同的测试用例测试</h4><ul>
<li>功能性测试（各种极端情况下的有效输入）</li>
<li>非法输入测试（对各种非法输入是否进行了合适的处理）</li>
</ul>
<blockquote>
<p>until next time😄</p>
</blockquote>
]]></content>
      <categories>
        <category>ListNode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>链表数相加_07</title>
    <url>/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E9%93%BE%E8%A1%A8%E8%A1%A8%E7%A4%BA%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%9B%B8%E5%8A%A0(%E8%BF%AD%E4%BB%A3%E6%96%B9%E5%BC%8F)_07.html</url>
    <content><![CDATA[<h3 id="链表表示的两个数相加"><a href="#链表表示的两个数相加" class="headerlink" title="链表表示的两个数相加"></a>链表表示的两个数相加</h3><h4 id="题设与要求"><a href="#题设与要求" class="headerlink" title="题设与要求"></a>题设与要求</h4><p><img src="https://s1.ax1x.com/2020/08/14/diKVtx.md.png" alt="题目条件与要求"></p>
<a id="more"></a>

<h4 id="分析（面临的核心问题）"><a href="#分析（面临的核心问题）" class="headerlink" title="分析（面临的核心问题）"></a>分析（面临的核心问题）</h4><p>两个数的加法算法，主要的特征：</p>
<ul>
<li>从低位到高位计算（个十百千…）;</li>
<li>计算除了个位以外的位数上的数字时，都需要加上来自后一位的进位（如果没有进位数，默认为0）</li>
<li>位数上的数字 = （第一个数 + 第二个数 + 进位数）% 10；</li>
<li>当前位向高位数提供的进位数 = (第一个数 + 第二个数 + 进位数) / 10；</li>
<li>如果最高位计算时，有进位数。则直接把这个进位数作为加和结果的最高位；</li>
</ul>
<p>问题1：我们需要从低位向高位计算，对于链表来说，就是从链表尾节点到头节点计算。BUT，访问链表中的节点只能从头节点到尾节点。</p>
<p>怎么办？</p>
<p>解决手段：使用栈来存储链表各个节点中的值；</p>
<p>原理：链表这种数据容器的存储特征是“先进后出”——这样在从栈中取出数值时，获取到的其实就是链表尾部节点中的数值；</p>
<p>问题2：两个链表的长度可能不一样，如果在同一个循环中通过pop()来取值的话，肯定会有一个栈调用pop()时会抛出”栈为空”的异常；</p>
<p>解决手段：在调用isEmpty()结果为true时（表示栈已经空了），手动为操作数绑定0；</p>
<p>问题3：如果使用循环，在短链表中的节点用完后，如何保证循环继续进行（继续计算加和）？</p>
<p>手段：循环条件 = （链表A节点 != null || 链表B节点 != null);</p>
<p>问题4：即便使用长链表的节点数来控制循环次数（循环中执行操作数的计算），但是最高位在得到进位后，可能会再产生一个进位。这个进位要怎么处理？</p>
<p>手段：把进位carry !=0 添加到循环执行表达式中。这样上述情况下，循环会再执行一次(0 + 0 + 进位1) 的计算。计算后carry==0，循环退出，进位数也被作为最高位添加到链表中</p>
<h4 id="思路SOP"><a href="#思路SOP" class="headerlink" title="思路SOP"></a>思路SOP</h4><p>1 使用两个栈分别存储两个链表中的所有节点；</p>
<p>2 定义一个循环：</p>
<ul>
<li>从栈中弹出值进行计算。得到数位上的数与进位数；</li>
<li>把位数上的数封装到一个节点，并添加到链表中(使用头插法，即最新的节点总是头节点)； head - xxx - null</li>
</ul>
<p>3 循环结束后，循环中创建的链表就是加和结果；</p>
<h4 id="根据思路SOP来进行编码"><a href="#根据思路SOP来进行编码" class="headerlink" title="根据思路SOP来进行编码"></a>根据思路SOP来进行编码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ListNode类型的定义省略</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 鲁棒性代码</span></span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(l2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 定义两个栈</span></span><br><span class="line">        Stack&lt;Integer&gt; stack_l1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Stack&lt;Integer&gt; stack_l2 = <span class="keyword">new</span> Stack&lt;&gt;(); <span class="comment">// 作用：用于分别存储各个链表中的节点</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用栈来存储对应链表中的节点</span></span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack_l1.push(l1.val);</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack_l2.push(l2.val);</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 定义一个循环 循环中：1 得到位数上的数字； 2 使用1中的数字创建节点，并添加到新链表中</span></span><br><span class="line">        ListNode first = <span class="keyword">null</span>; </span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!stack_l1.isEmpty() || !stack_l2.isEmpty() || carry != <span class="number">0</span>)&#123; <span class="comment">// 循环执行条件:</span></span><br><span class="line">            <span class="comment">// 1 获取到操作数</span></span><br><span class="line">            <span class="keyword">int</span> num1 = stack_l1.isEmpty() ? <span class="number">0</span> : stack_l1.pop();</span><br><span class="line">            <span class="keyword">int</span> num2 = stack_l2.isEmpty() ? <span class="number">0</span> : stack_l2.pop();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 2 进行计算，得到数位上的数值remainder 与 进位数字carry</span></span><br><span class="line">            <span class="keyword">int</span> remainder = (num1 + num2 + carry) % <span class="number">10</span>;</span><br><span class="line">            carry = (num1 + num2 + carry) / <span class="number">10</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 3 使用数位上的数值来创建一个新的节点，并添加到first链表中</span></span><br><span class="line">            ListNode curr = <span class="keyword">new</span> ListNode(remainder);</span><br><span class="line">            curr.next = first;</span><br><span class="line">            first = curr;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回创建的新链表的头节点first</span></span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="编码步骤分解"><a href="#编码步骤分解" class="headerlink" title="编码步骤分解"></a>编码步骤分解</h4><ul>
<li>定义两个栈，并把链表中节点的值添加到对应的栈中</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stack&lt;Integer&gt; stack_l1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">Stack&lt;Integer&gt; stack_l2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把链表节点中的值添加到栈中</span></span><br><span class="line"><span class="keyword">while</span>(l1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">    stack_l1.push(l1.val);</span><br><span class="line">    l1 = l1.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">    stack_l2.push(l2.val);</span><br><span class="line">    l2 = l2.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>定义一个循环 循环中：1 得到位数上的数字；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> carry = <span class="number">0</span>; <span class="comment">// 初始化进位数为0	作用：用于个位数的计算</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    <span class="comment">// 1 从栈中获取到当前的操作数</span></span><br><span class="line">    <span class="keyword">int</span> num1 = stack_l1.isEmpty() ? <span class="number">0</span> : stack_l1.pop();</span><br><span class="line">    <span class="keyword">int</span> num2 = stack_l2.isEmpty() ? <span class="number">0</span> : stack_l2.pop();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2 计算操作数，得到位数上的数字</span></span><br><span class="line">    <span class="keyword">int</span> remainder = (num1 + num2 + carry) % <span class="number">10</span>;</span><br><span class="line">    carry = (num1 + num2 + carry) / <span class="number">10</span>; <span class="comment">// 这里需要计算出新的进位数，这样下次遍历时计算结果才能正确</span></span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>2 使用1中的数字创建节点，并添加到新链表中</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">ListNode first = <span class="keyword">null</span>; <span class="comment">// 一个头节点	作用：作为计算结果的链表容器；	特征：头插法</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 头插法</span></span><br><span class="line">    <span class="comment">// 1 创建新节点</span></span><br><span class="line">    ListNode curr = <span class="keyword">new</span> ListNode(remainder);</span><br><span class="line">    <span class="comment">// 2 连接到first指针所指向的节点</span></span><br><span class="line">    curr.next = first;</span><br><span class="line">    <span class="comment">// 3 更新first指针</span></span><br><span class="line">    first = curr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>确定循环执行的表达式</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 由于栈中的每个数字都需要参与计算，所以最终两个栈要都为空</span></span><br><span class="line"><span class="comment">// 对应于表达式: !satck_l1.isEmpty() || !stack_l2.isEmpty()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最高位计算后，可能会有一个进位————这就要求循环体再执行一次，以便把新的进位添加到链表中。</span></span><br><span class="line"><span class="comment">// 进位添加到链表中后，需要对进位进行更新，以便终止循环</span></span><br><span class="line"><span class="comment">// 更新手段：现有代码 carry = (num1 + num2 + carry) / 10; // 这里需要计算出新的进位数，这样下次遍历时计算结果才能正确</span></span><br><span class="line"><span class="comment">// 此时，由于栈都已经空了。所以num1 = 0、num2 = 0、carry = 1（最高位的进位只会为1）</span></span><br><span class="line"><span class="comment">// 更新后carry的值 = 1 / 10; carry = 0</span></span><br><span class="line"><span class="comment">// 从而应该添加新的条件：carry != 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 综上有：循环执行表达式(!stack_l1.isEmpty() || !stack_l2.isEmpty() || carry != 0)</span></span><br><span class="line"><span class="keyword">while</span>(!stack_l1.isEmpty() || !stack_l2.isEmpty() || carry != <span class="number">0</span>)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>返回循环中创建的链表的头节点</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> first;</span><br></pre></td></tr></table></figure>

<ul>
<li>添加鲁棒性代码（或者叫防御性编程代码）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 鲁棒性代码</span></span><br><span class="line"><span class="keyword">if</span>(l1 == <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> l2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(l2 == <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> l1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用设计的测试用例进行功能测试 &amp; 非法输出测试</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 作用：</span></span><br><span class="line"><span class="comment">// 1 保证代码涵对所有可能的合法输入都有效；</span></span><br><span class="line"><span class="comment">// 2 保证对那些个非法输入，代码都做了合适的处理————不会导致程序崩溃；</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p> this is whole loads of thing. until next time 😄</p>
</blockquote>
]]></content>
      <categories>
        <category>ListNode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>交换链表节点_06_2</title>
    <url>/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9%EF%BC%88%E9%80%92%E5%BD%92%E6%96%B9%E5%BC%8F%EF%BC%89_06_2.html</url>
    <content><![CDATA[<h4 id="两两交换链表中的节点（递归方式）"><a href="#两两交换链表中的节点（递归方式）" class="headerlink" title="两两交换链表中的节点（递归方式）"></a>两两交换链表中的节点（递归方式）</h4><hr>
<h4 id="题设与要求"><a href="#题设与要求" class="headerlink" title="题设与要求"></a>题设与要求</h4><p><img src="https://s1.ax1x.com/2020/08/14/dPzGHH.md.png" alt="题设与要求"></p>
<a id="more"></a>

<h4 id="分析（递归的可行性）"><a href="#分析（递归的可行性）" class="headerlink" title="分析（递归的可行性）"></a>分析（递归的可行性）</h4><ul>
<li>问题能够拆解成更小的同类问题吗？<ul>
<li>答：对链表来说，总是可以把链表拆分成: 头节点head + 剩余节点组成的rest链表（这个链表还可以根据情况再去拆分）</li>
</ul>
</li>
<li>更小同类问题的返回值能够用来帮助解决大问题本身吗？<ul>
<li>答：对rest执行swapParis操作后，返回的是一个节点已经两两交换后的新链表。它可以和剩余的节点连接起来，从而得到一个所有节点都已经两两交换的新链表——大问题；</li>
</ul>
</li>
</ul>
<p>结论：这个问题可以使用递归进行解决；</p>
<h4 id="使用递归实现的SOP"><a href="#使用递归实现的SOP" class="headerlink" title="使用递归实现的SOP"></a>使用递归实现的SOP</h4><ul>
<li>1 明确方法的作用与返回值；</li>
<li>2 明确递归的终结条件（根据方法的作用推理）；</li>
<li>3 描述本次递归需要完成的工作</li>
</ul>
<h4 id="按照SOP进行编码"><a href="#按照SOP进行编码" class="headerlink" title="按照SOP进行编码"></a>按照SOP进行编码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1 方法作用：把链表中的节点两两进行交换，并返回节点交换后的新链表	参考：示例</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">swapParis</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 2 递归的终结条件 链表为null、链表中就只有一个节点</span></span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3 本级递归需要完成的事情</span></span><br><span class="line">    <span class="comment">// ① 把链表拆分为：头节点head + 第二个节点second + 剩余节点组成的链表rest</span></span><br><span class="line">    <span class="comment">// 原因：交换节点需要至少两个节点参与，而且我们不能改变swapPair(rest)的返回值</span></span><br><span class="line">    <span class="comment">// ② 对rest执行swapParis()的操作，并获取到返回值swapedRest</span></span><br><span class="line">    <span class="comment">// ③ 对head、second以及swapedRest进行必要的操作，以得到所有节点都已经两两交换的链表</span></span><br><span class="line">    ListNode second = head.next;</span><br><span class="line">    ListNode swapedRest = swapPairs(second.next);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 交换head与second节点</span></span><br><span class="line">    head.next = swapedRest;</span><br><span class="line">    second.next = head;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>启示</p>
</blockquote>
<p>递归大法好，不像递归那样。循环终止条件就能让人💫</p>
<blockquote>
<p>until next time😄</p>
</blockquote>
]]></content>
      <categories>
        <category>ListNode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>倒数第k个节点_05_2</title>
    <url>/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E8%8A%82%E7%82%B9%EF%BC%88%E4%B8%80%E6%AC%A1%E9%81%8D%E5%8E%86%EF%BC%89_05_2.html</url>
    <content><![CDATA[<h3 id="删除链表中的倒数第n个节点（一次遍历）"><a href="#删除链表中的倒数第n个节点（一次遍历）" class="headerlink" title="删除链表中的倒数第n个节点（一次遍历）"></a>删除链表中的倒数第n个节点（一次遍历）</h3><h4 id="题设-amp-要求"><a href="#题设-amp-要求" class="headerlink" title="题设 &amp; 要求"></a>题设 &amp; 要求</h4><p><img src="https://s1.ax1x.com/2020/08/14/dCLxyj.png" alt="题设 &amp; 要求"></p>
<a id="more"></a>

<h4 id="分析（难点）"><a href="#分析（难点）" class="headerlink" title="分析（难点）"></a>分析（难点）</h4><p>如何能找到倒数第N个节点（预期节点：此节点的上一个节点）？</p>
<h4 id="思路2（难点的解决方案）"><a href="#思路2（难点的解决方案）" class="headerlink" title="思路2（难点的解决方案）"></a>思路2（难点的解决方案）</h4><ul>
<li>定义两个指针front与back，设置两个指针之间的初始间距。</li>
<li>然后把两个指针同时向后移动，直到front指针到达了链表的尾节点。</li>
<li>这时候back指针就会指在某一个可以计算的位置——通过设置指针间的初始间距，就能确定back指针停下的具体位置。</li>
</ul>
<h4 id="实现SOP"><a href="#实现SOP" class="headerlink" title="实现SOP"></a>实现SOP</h4><ul>
<li>1 定义所需要的指针front与back与dummy（并初始化）；    注：画图分析指针初始化的位置；    原则：方便编码；&amp; 避免NPE；</li>
<li>2 画图分析，front指针与back指针之间的初始间距span与n的关系（span = n）；</li>
<li>3 把front与back指针初始化指向dummy节点(这里引入dummy节点只是为了方便计算指针应该移动的距离)；</li>
<li>4 把front指针向前移动n个节点；</li>
<li>5 把front与back指针同时向后移动，直到front指针指向链表的尾节点；</li>
<li>6 back指向预期节点后，对待删除节点进行删除；</li>
</ul>
<h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 实践证明：在删除的时候使用栈不是一个好主意</span></span><br><span class="line">        <span class="comment">// 鲁棒性代码</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 需要的实例变量</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line"></span><br><span class="line">        ListNode front = dummy;</span><br><span class="line">        ListNode back = dummy;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 先让front向前走n个节点   如果只有一个节点，然后要删除倒数第一个节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123; <span class="comment">// 注：front的初始化值会决定循环执行的次数</span></span><br><span class="line">            front = front.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 再让front与back一起先前移动，直到front到达尾节点</span></span><br><span class="line">        <span class="keyword">while</span>(front != <span class="keyword">null</span> &amp;&amp; front.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            front = front.next;</span><br><span class="line">            back = back.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 这里得到的back就是预期删除的节点的前一个节点</span></span><br><span class="line">        <span class="comment">// 执行删除</span></span><br><span class="line">        back.next = back.next.next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="启示"><a href="#启示" class="headerlink" title="启示"></a>启示</h4><p>1 代码的鲁棒性编码在实现了基本功能后，再进行添加；</p>
<p>2 对于循环执行次数已知的情况，使用for语法来实现循环——这样能避免令人纠结的循环执行/终止条件；</p>
<p>3 编写while循环执行表达式的参考：节点的最终状态； &amp;  避免代码中的NPE；</p>
]]></content>
      <categories>
        <category>ListNode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>交换链表节点(迭代)_06</title>
    <url>/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9(%E8%BF%AD%E4%BB%A3%E6%96%B9%E5%BC%8F)_06.html</url>
    <content><![CDATA[<h3 id="两两交换链表中的节点"><a href="#两两交换链表中的节点" class="headerlink" title="两两交换链表中的节点"></a>两两交换链表中的节点</h3><hr>
<h4 id="题设与要求"><a href="#题设与要求" class="headerlink" title="题设与要求"></a>题设与要求</h4><p><img src="https://s1.ax1x.com/2020/08/14/dP37xf.png" alt="题设与要求"></p>
<a id="more"></a>

<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>要求进行节点之间的两两交换。</p>
<p>如果使用迭代的方式，可以每次处理两个相邻节点之间的连接关系；</p>
<p>然后在下次迭代时，再去处理下一批的两个节点之间的连接关系；</p>
<p>还要处理每个区间（2个节点）之间的连接关系，来保证连接的正确性；</p>
<p>说明：</p>
<p>1 当通过这种分析无法得到有效的突破点时，就只好画图来找找规律了，对自己的想象力不要太自信；</p>
<p>2 翻转操作需要3个指针：两个指针用于指向需要交换的节点，一个指针用于迭代链表；</p>
<blockquote>
<p>画图大法(画图找规律)</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/08/14/dPU7kD.md.jpg" alt="节点的交换过程"></p>
<ul>
<li>通过画图可以看出,可以通过连续翻转节点来实现题设中的“两两节点交换”；</li>
<li>节点翻转需要3个指针：curr指向当前节点、temp指向当前节点的下一个节点；prev指向当前节点的前驱节点（用于更新这三个连续的指针）</li>
<li>可以根据预期的指针情况（图3）与当前的指针情况（图2）来推理出指针更新的手段；prev = curr;</li>
</ul>
<h4 id="代码实现的SOP："><a href="#代码实现的SOP：" class="headerlink" title="代码实现的SOP："></a>代码实现的SOP：</h4><p>1 定义所需要的指针，并初始化指针的原始位置；</p>
<p>2 定义一个循环，在循环中完成以下工作：</p>
<ul>
<li>对指针指向的当前节点区间进行翻转；</li>
<li>更新指针，以便进行下一次的翻转操作；</li>
</ul>
<h4 id="代码实现（虽然SOP不复杂，但是代码实现还是挺讲究的）"><a href="#代码实现（虽然SOP不复杂，但是代码实现还是挺讲究的）" class="headerlink" title="代码实现（虽然SOP不复杂，但是代码实现还是挺讲究的）"></a>代码实现（虽然SOP不复杂，但是代码实现还是挺讲究的）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1 定义需要的指针</span></span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>); <span class="comment">// 作用：指向链表的头节点</span></span><br><span class="line">    dummy.next = head;</span><br><span class="line">    </span><br><span class="line">    ListNode prev = dummy; <span class="comment">// </span></span><br><span class="line">    ListNode curr = head;</span><br><span class="line">    <span class="comment">// ListNode temp = curr.next; // 有点不对劲，因为temp都是在遍历过程中临时更新的		参考：翻转链表的操作</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2 定义一个循环，在循环中： 1 完成当前区间内节点的翻转； 2 更新到下一个翻转区间</span></span><br><span class="line">    <span class="keyword">while</span>(curr != <span class="keyword">null</span> &amp;&amp; curr.next != <span class="keyword">null</span>)&#123; <span class="comment">// 循环终止条件：curr == null(对应于奇数个节点) OR curr.next == null (对应于偶数个节点)</span></span><br><span class="line">        <span class="comment">// 1 获取到当前节点的下一个节点 [curr-temp]</span></span><br><span class="line">        ListNode temp = curr.next;</span><br><span class="line">        </span><br><span class="line">         <span class="comment">// 2 完成当前区间内节点的翻转(需要借助temp节点才能实现)</span></span><br><span class="line">        prev.next = temp;</span><br><span class="line">        curr.next = temp.next;</span><br><span class="line">        temp.next = curr;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3 更新到下一个翻转区间[prev-curr]</span></span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = prev.next;</span><br><span class="line">        <span class="comment">// temp = curr.next;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3 返回链表的头节点</span></span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="代码实现过程SOP分解"><a href="#代码实现过程SOP分解" class="headerlink" title="代码实现过程SOP分解"></a>代码实现过程SOP分解</h4><ul>
<li>定义所需要的指针</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">dummy.next = head;	<span class="comment">// 作用：指向链表的头节点</span></span><br><span class="line"></span><br><span class="line">ListNode prev = dummy; <span class="comment">// 作用：翻转区间内的第一个节点</span></span><br><span class="line">ListNode curr = prev.next; <span class="comment">// 作用：翻转区间内的第二个节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 所需要的辅助节点temp（当前节点的下一个节点），在循环中再临时获取</span></span><br></pre></td></tr></table></figure>

<ul>
<li>定义一个循环，在循环中完成<ul>
<li>当前节点区间的节点翻转；</li>
<li>更新当前节点区间；</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    <span class="comment">// 对当前节点区间中的节点进行翻转</span></span><br><span class="line">    <span class="comment">// ① 获取到当前节点的下一个节点	作用：防止链表断裂</span></span><br><span class="line">    ListNode temp = curr.next;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ② 按照下图流程来实现节点的翻转		参考：👇图</span></span><br><span class="line">    prev.next = temp; </span><br><span class="line">    curr.next = temp.next;</span><br><span class="line">    temp.next = curr;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更新当前的区间节点</span></span><br><span class="line">    prev = curr; <span class="comment">// 更新后的翻转区间第一个节点 参考：“分析”部分</span></span><br><span class="line">    curr = prev.next; <span class="comment">// 更新后的翻转区间第二个节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s1.ax1x.com/2020/08/14/dPLV7q.md.jpg" alt="节点翻转流程"></p>
<ul>
<li><p>确定循环执行的条件</p>
<ul>
<li>循环终止条件（直接根据代码不能NPE来反推）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ListNode temp = curr.next;	<span class="comment">// 因此curr != null</span></span><br><span class="line">...</span><br><span class="line">curr.next = temp.next; <span class="comment">// 因此temp != null aka curr.next != null</span></span><br></pre></td></tr></table></figure>

<p>r u kidding me?</p>
<ul>
<li>循环终止条件（极端情况）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 极端情况：prev为倒数第二个节点、curr为尾节点 此时需要翻转prev与curr之间的指向</span></span><br><span class="line"><span class="comment">// 特征:curr.next == null aka 循环执行条件 curr.next != null</span></span><br><span class="line"><span class="comment">// 为了避免循环中的更新操作导致curr为null SO</span></span><br><span class="line"><span class="keyword">while</span>(curr != <span class="keyword">null</span> &amp;&amp; curr.next != <span class="keyword">null</span>)</span><br></pre></td></tr></table></figure>

<p>不很满意这种说法😳</p>
</li>
<li><p>返回新链表的头节点</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 由于每个节点都只有一个next指针，所以dummy其实连接到了新的链表头部</span></span><br><span class="line"><span class="keyword">return</span> dummy.next;</span><br></pre></td></tr></table></figure>

<ul>
<li>添加鲁棒性代码</li>
<li>编写各种测试用例，测试代码：1 功能是否可用； 2 对于各种非法输出是否有合理的输出/提示信息；</li>
</ul>
<h4 id="代码默写-重现"><a href="#代码默写-重现" class="headerlink" title="代码默写/重现"></a>代码默写/重现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1 定义需要用到的指针</span></span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    dummy.next = head; <span class="comment">// 指向链表的头节点</span></span><br><span class="line">    </span><br><span class="line">    ListNode prev = dummy; <span class="comment">// 翻转区间的第一个节点</span></span><br><span class="line">    ListNode curr = prev.next; <span class="comment">// 翻转区间的第二个节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(curr != <span class="keyword">null</span> &amp;&amp; curr.next != <span class="keyword">null</span>)&#123; <span class="comment">// 烦人的循环执行条件</span></span><br><span class="line">        <span class="comment">// 翻转区间中节点的指向</span></span><br><span class="line">        ListNode temp = curr.next;</span><br><span class="line">        </span><br><span class="line">        prev.next = temp;</span><br><span class="line">        curr.next = temp.next;</span><br><span class="line">        temp.next = curr;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 更新翻转区间</span></span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = curr.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>until next time 😄</p>
</blockquote>
]]></content>
      <categories>
        <category>ListNode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>倒数第k个节点_05</title>
    <url>/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9(%E4%B8%A4%E6%AC%A1%E9%81%8D%E5%8E%86)_05.html</url>
    <content><![CDATA[<h3 id="删除链表中的倒数第N个节点"><a href="#删除链表中的倒数第N个节点" class="headerlink" title="删除链表中的倒数第N个节点"></a>删除链表中的倒数第N个节点</h3><h4 id="分析（找到问题的难点）："><a href="#分析（找到问题的难点）：" class="headerlink" title="分析（找到问题的难点）："></a>分析（找到问题的难点）：</h4><ul>
<li>对于单向链表，只能从前往后地查找节点；</li>
<li>删除链表节点的常用手段: curr.next = curr.next.next; // 这样就能把curr后面的一个节点从链表中删除掉</li>
</ul>
<a id="more"></a>

<h4 id="思路（解决问题难点）："><a href="#思路（解决问题难点）：" class="headerlink" title="思路（解决问题难点）："></a>思路（解决问题难点）：</h4><p>如果链表的长度已知，就能通过公式（length - N）来求出待删除节点的正向位置。这样就可以执行删除操作了</p>
<p>可能犯错的地方：找错了节点；</p>
<p>根据分析的第二点，我们应该找到的是待删除节点的上一个节点（预期节点）；</p>
<h4 id="实现SOP"><a href="#实现SOP" class="headerlink" title="实现SOP:"></a>实现SOP:</h4><ul>
<li>1 先计算出链表中的节点的总长度；</li>
<li>2 根据公式(length - N)计算出待删除节点的正向位置索引；</li>
<li>3 找到预期节点，然后删除“待删除的节点”；</li>
</ul>
<h4 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ListNode类型的定义省略</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 0 鲁棒性代码</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1 定义需要的指针</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>); <span class="comment">// 备用</span></span><br><span class="line">        dummy.next = head;</span><br><span class="line">        </span><br><span class="line">        ListNode cursor = head;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2 计算链表中节点的总长度</span></span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cursor != <span class="keyword">null</span>)&#123;</span><br><span class="line">            length++;</span><br><span class="line">            cursor = cursor.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3 计算预期节点的位置</span></span><br><span class="line">        <span class="keyword">int</span> expect_postion = length - n;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4 通过迭代的方式找到预期节点</span></span><br><span class="line">        cursor = head; <span class="comment">// 把游标拨回链表头节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i &lt; expect_position; i++)&#123;</span><br><span class="line">            cursor = cursor.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 5 找到预取节点后，对待删除节点执行删除操作</span></span><br><span class="line">        cursor.next = cursor.next.next; <span class="comment">// 由于题设已经保证n是有效的，所以这里不会出现NPE</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 6 返回删除节点后的链表</span></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="添加鲁棒性代码"><a href="#添加鲁棒性代码" class="headerlink" title="添加鲁棒性代码"></a>添加鲁棒性代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">参考 <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>



<h4 id="算法特征"><a href="#算法特征" class="headerlink" title="算法特征"></a>算法特征</h4><p>1 需要两次遍历：第一次遍历用来计算链表中的节点总长度；第二次遍历用来找到“预期的节点”，以便执行删除</p>
<h4 id="优化（只需要进行一次遍历）"><a href="#优化（只需要进行一次遍历）" class="headerlink" title="优化（只需要进行一次遍历）"></a>优化（只需要进行一次遍历）</h4><p>原理：通过前后指针来找到预期位置，而不是用（length - N）的方式。</p>
<blockquote>
<p>until NEXT time 😄</p>
</blockquote>
]]></content>
      <categories>
        <category>ListNode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>链表去重_04_2</title>
    <url>/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%EF%BC%88%E9%80%92%E5%BD%92%E6%96%B9%E5%BC%8F%EF%BC%89_04_2.html</url>
    <content><![CDATA[<h3 id="删除有序链表中的重复元素（递归方式）"><a href="#删除有序链表中的重复元素（递归方式）" class="headerlink" title="删除有序链表中的重复元素（递归方式）"></a>删除有序链表中的重复元素（递归方式）</h3><h4 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h4><p><img src="https://s1.ax1x.com/2020/08/14/dCTVln.png" alt="题设与要求"></p>
<a id="more"></a>

<h4 id="分析（确定思路）"><a href="#分析（确定思路）" class="headerlink" title="分析（确定思路）"></a>分析（确定思路）</h4><ul>
<li><p>使用递归的可行性；</p>
<ul>
<li>问题能够被分解为规模更小的问题吗？</li>
</ul>
<p>答：可以。手段：把链表视为：头节点head + 剩余节点组成的链表rest;</p>
<ul>
<li>可以在更小的问题上应用当前操作，并用它的返回值来帮助解决大问题吗？</li>
</ul>
<p>答：可以。对递归调用的返回值做一些额外的处理，就能得到整个链表删除重复元素之后的结果。</p>
</li>
</ul>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> val)&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1 递归方法的作用：删除链表中的重复元素并返回更新后的链表/头节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 2 递归终结条件 链表为空 OR 链表中就只有一个节点</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3 本级递归需要做的事情</span></span><br><span class="line">        <span class="comment">// ① 把链表视为：头节点head + 剩余节点构成的链表rest；</span></span><br><span class="line">        <span class="comment">// ② 对rest链表执行删除重复节点的操作（假设已经有一个功能可用的API）；</span></span><br><span class="line">        <span class="comment">// ③ 对返回值进行必要的处理</span></span><br><span class="line">        ListNode rest = deleteDuplicates(head.next); <span class="comment">// ② </span></span><br><span class="line">        <span class="keyword">if</span>(head.val == rest.val)&#123; <span class="comment">// 头节点的值与rest头节点的值相等... 重复了</span></span><br><span class="line">             <span class="comment">// 更新head指针</span></span><br><span class="line">             head = rest;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 把rest连接到head上</span></span><br><span class="line">            head.next = rest;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回新链表的头节点</span></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="代码实现步骤SOP分解"><a href="#代码实现步骤SOP分解" class="headerlink" title="代码实现步骤SOP分解"></a>代码实现步骤SOP分解</h4><ul>
<li>确定递归的可行性</li>
<li>确定递归方法的作用与返回值</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1 递归方法的作用：删除链表中的重复元素并返回更新后的链表/头节点</span></span><br></pre></td></tr></table></figure>



<ul>
<li>确定递归方法的终结条件</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2 递归终结条件 链表为空 OR 链表中就只有一个节点</span></span><br><span class="line"><span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br></pre></td></tr></table></figure>

<ul>
<li>确定本级递归需要完成的事情</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 3 本级递归需要做的事情</span></span><br><span class="line"><span class="comment">// ① 把链表视为：头节点head + 剩余节点构成的链表rest；</span></span><br><span class="line"><span class="comment">// ② 对rest链表执行删除重复节点的操作（假设已经有一个功能可用的API）；</span></span><br><span class="line"><span class="comment">// ③ 对返回值进行必要的处理</span></span><br><span class="line">ListNode rest = deleteDuplicates(head.next); <span class="comment">// ② </span></span><br><span class="line"><span class="keyword">if</span>(head.val == rest.val)&#123; <span class="comment">// 头节点的值与rest头节点的值相等... 重复了</span></span><br><span class="line">    <span class="comment">// 更新head指针</span></span><br><span class="line">    head = rest;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 把rest连接到head上</span></span><br><span class="line">    head.next = rest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>返回正确链表的头指针（最好画图确认）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回新链表的头节点</span></span><br><span class="line"><span class="keyword">return</span> head;</span><br></pre></td></tr></table></figure>



<h4 id="启示"><a href="#启示" class="headerlink" title="启示"></a>启示</h4><p>在分析递归可行的情况下，对递归调用的返回值还需要进一步处理。</p>
<p>基本的原则是：使用递归调用的返回值来解决本级递归所需要解决的问题；</p>
<blockquote>
<p>until next time 😄</p>
</blockquote>
]]></content>
      <categories>
        <category>ListNode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>链表去重_04</title>
    <url>/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0(%E8%BF%AD%E4%BB%A3%E6%96%B9%E5%BC%8F)_04.html</url>
    <content><![CDATA[<h3 id="删除排序链表中的重复元素"><a href="#删除排序链表中的重复元素" class="headerlink" title="删除排序链表中的重复元素"></a>删除排序链表中的重复元素</h3><hr>
<h4 id="题目要求："><a href="#题目要求：" class="headerlink" title="题目要求："></a>题目要求：</h4><p><img src="https://s1.ax1x.com/2020/08/14/dCy9C8.png" alt="题目要求"></p>
<p><img src="https://s1.ax1x.com/2020/08/14/dCguPP.png" alt="测试用例示例"></p>
<a id="more"></a>

<h4 id="题设分析："><a href="#题设分析：" class="headerlink" title="题设分析："></a>题设分析：</h4><ul>
<li>1 链表已经是有序的了，aka，重复的元素会相邻在一起；</li>
<li>2 删除元素时，只需要删除重复多次的部分，使元素只会出现一次；</li>
</ul>
<h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>最直观的方式：</p>
<ul>
<li>遍历整个链表，逐个比较当前节点curr与当前节点的下一个节点next的值。</li>
<li>如果curr.val == next.val,就想办法删除掉当前节点；</li>
<li>如果不相等，就更新curr指针，以便迭代下一个节点；</li>
</ul>
<h4 id="代码实现的SOP"><a href="#代码实现的SOP" class="headerlink" title="代码实现的SOP"></a>代码实现的SOP</h4><ul>
<li>创建一个指针curr，初始化为链表的头节点head；    作用：用于迭代链表；</li>
<li>创建一个指针dummy,初始化为null； 作用：用于指向链表的头节点，方便返回更新后的链表；</li>
<li>循环链表中的每一个节点，判断节点是否是重复节点；<ul>
<li>如果是，删除此节点；</li>
<li>如果不是，继续执行循环，直到所有节点都已经被遍历了</li>
</ul>
</li>
</ul>
<h4 id="完整的代码实现"><a href="#完整的代码实现" class="headerlink" title="完整的代码实现"></a>完整的代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    </span><br><span class="line">    ListNode(<span class="keyword">int</span> val)&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 1 定义需要的指针</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        </span><br><span class="line">        ListNode curr = head;</span><br><span class="line">        <span class="comment">// 2 遍历链表中的每一个节点，判断是否为重复节点，并执行相应的操作</span></span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="keyword">null</span> &amp;&amp; curr.next != <span class="keyword">null</span>)&#123; <span class="comment">// 循环执行条件：当前节点与当前节点的下一个节点都不为null	根据画图的边界条件推导 并使用代码中可能的NPE来验证</span></span><br><span class="line">            <span class="keyword">if</span>(curr.val == curr.next.val)&#123;</span><br><span class="line">                curr.next = curr.next.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                curr = curr.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3 遍历完成后，返回新链表的头节点</span></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="实现过程SOP"><a href="#实现过程SOP" class="headerlink" title="实现过程SOP"></a>实现过程SOP</h4><ul>
<li><p>定义需要的指针</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1 定义需要的指针</span></span><br><span class="line">ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);	</span><br><span class="line">dummy.next = head; <span class="comment">// dummy指针	作用：指向链表的头节点，方便无脑地返回链表的头节点</span></span><br><span class="line"></span><br><span class="line">ListNode curr = head; <span class="comment">// 作用：在链表中遍历所有节点（结合循环）</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>定义一个循环，在循环中执行判重与删除操作 &amp; 迭代链表的操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">	<span class="keyword">if</span>(curr.val == curr.next.val)&#123; <span class="comment">// 判重</span></span><br><span class="line">        <span class="comment">// 删除</span></span><br><span class="line">        curr.next = curr.next.next; <span class="comment">// 把当前节点连接到下下个节点上</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        curr = curr.next; <span class="comment">// 更新指针	作用：实现遍历链表</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>确定循环()表达式的内容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 临界情况：比较倒数第一与倒数第二个节点，判断倒数第一个节点是否需要删除</span></span><br><span class="line"><span class="comment">// curr为倒数第二个节点，curr.next为倒数第一个节点</span></span><br><span class="line"><span class="comment">// 为了循环能够正常执行，要求两个节点均不为null</span></span><br><span class="line"><span class="keyword">while</span>(curr != <span class="keyword">null</span> &amp;&amp; curr.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>确定方法的返回值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 由于定义了指向原始链表头节点的指针dummy,而且没有改变链表中的连接方向，SO</span></span><br><span class="line"><span class="keyword">return</span> dummy.next; <span class="comment">// 直接返回dummy的下一个节点 aka 链表的头节点</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="代码重现"><a href="#代码重现" class="headerlink" title="代码重现"></a>代码重现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicats</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1 定义所需要的指针</span></span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    dummy.next = head;</span><br><span class="line">    </span><br><span class="line">    ListNode curr = dummy;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2 迭代链表中的节点，并完成必要的操作</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(curr.val == curr.next.val)&#123;</span><br><span class="line">            curr.next = curr.next.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 这里必须要有else字句，因为链表中可能出现连续重复的节点</span></span><br><span class="line">            <span class="comment">// 更新指针指向下一个节点</span></span><br><span class="line">            curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3 返回更新后的节点</span></span><br><span class="line">    <span class="keyword">return</span> dummy.next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>until next time 😄</p>
</blockquote>
]]></content>
      <categories>
        <category>ListNode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>合并链表_03_2</title>
    <url>/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%EF%BC%88%E9%80%92%E5%BD%92%E6%96%B9%E5%BC%8F%EF%BC%89_03_2.html</url>
    <content><![CDATA[<h3 id="合并两个有序链表（递归方式）"><a href="#合并两个有序链表（递归方式）" class="headerlink" title="合并两个有序链表（递归方式）"></a>合并两个有序链表（递归方式）</h3><hr>
<p><img src="https://s1.ax1x.com/2020/08/11/aOHNlD.png" alt="题目要求"></p>
<a id="more"></a>

<h4 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h4><ul>
<li><p>使用递归的可行性；</p>
<p>把第一个链表叫做l1，第二个链表叫做l2。可以把 l1 分解为（head + rest）,然后拿rest与l2进行合并操作，合并得到的结果再连接到head；</p>
<p>结论：可行</p>
</li>
<li><p>递归三部曲回顾：</p>
<p>1 方法的作用与返回值；</p>
<p>2 递归的终结条件（根据方法的作用推演）；</p>
<p>3 本级递归需要完成的工作（假设已经有了一个功能完整实现的API）；</p>
</li>
</ul>
<hr>
<h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>一旦确定是可以递归的，这种方式需要关注的细节其实很少</p>
<hr>
<h4 id="完整实现"><a href="#完整实现" class="headerlink" title="完整实现"></a>完整实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ListNode定义的代码省略（参考其他文章）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1 作用：合并两个有序的列表，并返回合并后的列表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 2 递归终结条件</span></span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(l2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3 本级递归需要做的事情</span></span><br><span class="line">        <span class="comment">// ① 比较两个原始链表的头节点谁更小，对更小的那个链表进行拆分；</span></span><br><span class="line">        <span class="comment">// ② 把拆分后的rest链表与原始链表中的另一个进行合并操作，得到新的链表tempMerge</span></span><br><span class="line">        <span class="comment">// ③ 再对head头节点与tempMerge进行合并</span></span><br><span class="line">        <span class="keyword">if</span>(l1.val &lt; l2.val)&#123;</span><br><span class="line">            l1.next = mergeTwoLists(l1.next, l2); <span class="comment">// 把得到的新链表直接连接到头节点上</span></span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l2.next = mergeTwoLists(l2.next, l1);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h4><p>参考代码中的1、2、3</p>
<hr>
<h4 id="启示"><a href="#启示" class="headerlink" title="启示"></a>启示</h4><p>递归的代码真的非常简洁（不需要考虑很多的边界细节），而且只要确定可行性，代码一般不会太复杂</p>
<blockquote>
<p>until next time😄</p>
</blockquote>
]]></content>
      <categories>
        <category>ListNode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>合并链表_03</title>
    <url>/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8-%E5%BE%97%E5%88%B0%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%EF%BC%88%E8%BF%AD%E4%BB%A3%E6%96%B9%E5%BC%8F%EF%BC%89_03.html</url>
    <content><![CDATA[<h3 id="合并两个有序链表，得到一个新的有序链表（迭代方式）"><a href="#合并两个有序链表，得到一个新的有序链表（迭代方式）" class="headerlink" title="合并两个有序链表，得到一个新的有序链表（迭代方式）"></a>合并两个有序链表，得到一个新的有序链表（迭代方式）</h3><a id="more"></a>



<h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>1 创建一个链表就只需要想某个节点上不断连接其他节点就行了；</p>
<p>2 对两个链表对应位置节点的值进行比较，把较小的节点先连接到链表中；</p>
<p>3 如果出现某一个链表中的节点比较多（另一个链表中的节点已经用完了），直接把链表剩余的节点连接到正在创建的链表上就行了（因为剩余的这些节点都已经是有序的了，并且值也更大）</p>
<hr>
<h4 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h4><p>1 创建链表就只需要一个指针就可以；    </p>
<p>创建链表的SOP:</p>
<ul>
<li>1 连接到下一个节点；</li>
<li>2 更新当前指针到下一个节点；以便重复步骤1</li>
</ul>
<p>2 为了方便比较两个链表对应位置上的节点，这里需要添加一个假节点dummy；它总是指向链表的头节点</p>
<hr>
<h4 id="根据上面的分析尝试写代码"><a href="#根据上面的分析尝试写代码" class="headerlink" title="根据上面的分析尝试写代码"></a>根据上面的分析尝试写代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> val)&#123; <span class="keyword">this</span>.val = val;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 准备指针，用于生成链表</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>); <span class="comment">// 指向链表的头节点</span></span><br><span class="line">        ListNode cursor = dummy; <span class="comment">// 用于不管更新链表的指针</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 迭代并比较两个链表中节点的大小，并根据比较结果把节点连接到链表中</span></span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>)&#123; <span class="comment">// 循环执行条件：haed to describe</span></span><br><span class="line">            <span class="keyword">if</span>(l1.val &lt; l2.val)&#123;</span><br><span class="line">                <span class="comment">// 创建链表step1：连接到下一个节点</span></span><br><span class="line">                cursor.next = l1;</span><br><span class="line">                <span class="comment">// 更新l1链表的指针到下一个位置	作用：实现迭代</span></span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 作用同上</span></span><br><span class="line">                cursor.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 创建链表step2：更新链表的指针	作用：方便连接到下一个节点</span></span><br><span class="line">            cursor = cursor.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// always safe to use this to refer the ListNode, cus it always point to the first node of the ListNode</span></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h4><p>step1 定义需要的指针</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>); <span class="comment">// 方便新链表的创建</span></span><br><span class="line">ListNode cursor = dummy; <span class="comment">// cursor的意思是游标，我感觉比起指针更形象一些	用于创建新链表</span></span><br></pre></td></tr></table></figure>



<p>step2 通过迭代的方式，遍历两个子链表中的指针，并连接到新链表中；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">	<span class="keyword">if</span>(l1.val &lt; l2.val)&#123;</span><br><span class="line">		<span class="comment">// 为新链表连接到下一个节点	扩展新链表</span></span><br><span class="line">		cursor.next = l1;</span><br><span class="line">		<span class="comment">// 找到原始链表中的下一个节点 用于比较两个原始链表之间的节点</span></span><br><span class="line">		l1 = l1.next;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		cursor.next = l2;</span><br><span class="line">		l2 = l2.next;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 更新cursor指针	用于扩展链表</span></span><br><span class="line">	cursor = cursor.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>step3 确定循环执行条件的表达式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1 当表达式的值为true时，循环执行；</span></span><br><span class="line"><span class="comment">// 2 循环的作用：为新链表连接一个新节点，并且做一些方便连接下一个节点的操作</span></span><br><span class="line"><span class="comment">// 3 当某个链表的节点用尽时，应该终止循环：因为这时候不再需要进行节点间的比较</span></span><br><span class="line"><span class="comment">// 4 链表节点用尽的情况：l1 == null、l2 == null</span></span><br><span class="line"><span class="comment">// 这两种情况之间的逻辑关系是什么？只要有一个成立，循环就应该终止。对应地，为了让循环执行，应该两者都不为null aka l1 != null &amp;&amp; l2 != null</span></span><br><span class="line"><span class="keyword">while</span>(l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>)&#123; ... &#125;  <span class="comment">// this is truly a piece of work</span></span><br></pre></td></tr></table></figure>



<p>step4 处理某个原始链表中没有添加进新链表的节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 为什么出现节点没有被添加的情况？ 因为另外一个链表中的节点已经用完了，它里面的节点值都比较小</span></span><br><span class="line"><span class="comment">// 如何确定是哪一个链表的节点没有被用完？ 没有被用完的链表指针不为null</span></span><br><span class="line"><span class="comment">// 如何处理没有被添加的节点？ 直接连接到新链表中即可 找对节点</span></span><br><span class="line"><span class="comment">// 这时候最好边看着操作图，边编写代码 	因为某些边界条件很容易弄错</span></span><br><span class="line"><span class="keyword">if</span>(l1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">    cursor.next = l2;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span>(l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">    cursor.next = l1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>step5 返回创建的新链表的头节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> dummy.next;</span><br></pre></td></tr></table></figure>



<p>step6 编写基础测试用例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">main()&#123;</span><br><span class="line">	<span class="comment">// 测试用例代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>step7 添加鲁棒性代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 鲁棒性代码一般添加在开始的地方，来对参数进行校验</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>until next time😄</p>
</blockquote>
]]></content>
      <categories>
        <category>ListNode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>翻转链表_02_2</title>
    <url>/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E9%93%BE%E8%A1%A8%E7%BF%BB%E8%BD%AC%E4%B9%8B%E9%80%92%E5%BD%92%E8%A7%A3%E6%B3%95_02_2.html</url>
    <content><![CDATA[<h3 id="链表翻转之递归解法"><a href="#链表翻转之递归解法" class="headerlink" title="链表翻转之递归解法"></a>链表翻转之递归解法</h3><a id="more"></a>

<hr>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>并不是所有的情况都能使用递归解决，能用递归解决的问题需要有两个特征：</p>
<ul>
<li>1 能够通过某种方式把问题的规模变小；</li>
<li>2 对于1中更小规模的问题，可以使用同样的操作去处理它；</li>
</ul>
<p>现在先看看“翻转链表”这样的操作是不是符合上面的两个特征：</p>
<h5 id="能够通过某种方式把问题的规模变小"><a href="#能够通过某种方式把问题的规模变小" class="headerlink" title="能够通过某种方式把问题的规模变小"></a>能够通过某种方式把问题的规模变小</h5><p>由于链表本身就是递归的结构，所以总是可以把链表分为：头节点head + 剩余节点所组成的链表rest；</p>
<h5 id="对于更小规模的问题，可以使用同样的操作去处理它"><a href="#对于更小规模的问题，可以使用同样的操作去处理它" class="headerlink" title="对于更小规模的问题，可以使用同样的操作去处理它"></a>对于更小规模的问题，可以使用同样的操作去处理它</h5><p>在对rest做翻转操作后，我们就能得到一个已经翻转了的链表。接下来就只要想办法把头节点head连接进来即可</p>
<hr>
<h4 id="使用递归的三部曲"><a href="#使用递归的三部曲" class="headerlink" title="使用递归的三部曲"></a>使用递归的三部曲</h4><ul>
<li><p>1 明确方法的作用与返回值；</p>
</li>
<li><p>2 找到递归的终结条件——这个条件会停止递归，并开始弹出调用栈；</p>
</li>
<li><p>3 确定本级递归需要完成的工作；（这时候要假设已经有了功能可用的API给自己调用）</p>
</li>
</ul>
<p>注：一般而言，递归方法可以按照这3步来编写。但不尽然，有些递归方法的实现可能会surprise us</p>
<hr>
<h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 0 作用：翻转指定的链表，并返回链表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1 递归的终结条件</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 本级递归需要做的事情</span></span><br><span class="line">        <span class="comment">// ① 把链表视为：头节点 + 剩下节点组成的链表rest</span></span><br><span class="line">        <span class="comment">// ② 对rest中的节点执行翻转操作————翻转后，rest指向新链表的头节点</span></span><br><span class="line">        ListNode rest = reverseList(head.next);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ③ 把原始的头节点连接到新链表的尾节点</span></span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rest;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="代码重现"><a href="#代码重现" class="headerlink" title="代码重现"></a>代码重现</h4><blockquote>
<p>step0 画个图，理清思路；需要什么东西，应该做怎样的操作；</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/08/11/aOaGT0.md.jpg" alt="递归下的链表"></p>
<blockquote>
<p>step1 确定方法的作用与返回值；</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法作用：翻转链表，并返回翻转后的链表；</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>step2 编写递归终结条件；</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实现翻转链表的最简情况是什么？ 答：空链表或者只有一个节点的链表</span></span><br><span class="line"><span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head; <span class="comment">// 这两种情况可以分开写，一起写只是为了让代码简洁一些</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>step3 本级递归需要做的事情；</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	① 把链表拆分为：头节点head + 剩下的节点所组成的链表rest;</span></span><br><span class="line"><span class="comment">	② 对rest链表执行“翻转”操作————翻转后的链表头节点为旧链表的尾节点；</span></span><br><span class="line"><span class="comment">	③ 处理head节点与rest链表，使得整个链表中的所有节点都被翻转；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 对rest链表执行“翻转”操作</span></span><br><span class="line">ListNode rest = reverseList(head.next);</span><br><span class="line"><span class="comment">// 把head节点添加到rest链表的末尾</span></span><br><span class="line">head.next.next = head;</span><br><span class="line"><span class="comment">// 为head连接一个null——表示链表结束</span></span><br><span class="line">head.next = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<h4 id="测试用例（检查代码功能与代码的健壮性）"><a href="#测试用例（检查代码功能与代码的健壮性）" class="headerlink" title="测试用例（检查代码功能与代码的健壮性）"></a>测试用例（检查代码功能与代码的健壮性）</h4><ul>
<li>极端情况下，功能是否正常工作； 传入的链表为空/只有一个节点</li>
</ul>
<h4 id="启示"><a href="#启示" class="headerlink" title="启示"></a>启示</h4><p>链表节点之间的关系，最好画张图比较容易弄清楚。</p>
<p>比如“把head连接到rest链表的末尾”这一步，刚开始我是想沿着链表找到rest的尾节点，然后再连接到head</p>
<p>但如果画图就能看出来，获取rest链表尾节点可以用head.next；</p>
<p>拆解一下head.next.next = head;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取到rest的尾节点</span></span><br><span class="line">ListNode lastOfRest = head.next;</span><br><span class="line"><span class="comment">// 把获取到的尾节点连接到head上</span></span><br><span class="line">lastOfRest.next = head;</span><br><span class="line"><span class="comment">// 把head连接到一个null	这一步必须有，否则head与lastOfRest节点之间就会有环出现 这会导致报错</span></span><br><span class="line">head.next = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>until next time 😄</p>
</blockquote>
]]></content>
      <categories>
        <category>ListNode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>交换链表节点_02_1</title>
    <url>/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E5%AF%B9%E9%93%BE%E8%A1%A8%E8%BF%9B%E8%A1%8C%E7%BF%BB%E8%BD%AC(%E8%BF%AD%E4%BB%A3%E6%96%B9%E5%BC%8F)_02_1.html</url>
    <content><![CDATA[<h3 id="对链表进行翻转（使用迭代的方式）"><a href="#对链表进行翻转（使用迭代的方式）" class="headerlink" title="对链表进行翻转（使用迭代的方式）"></a>对链表进行翻转（使用迭代的方式）</h3><hr>
<p><img src="https://s1.ax1x.com/2020/08/11/aLKOne.png" alt="翻转链表"></p>
<a id="more"></a>

<hr>
<h3 id="分析-👇👇👇"><a href="#分析-👇👇👇" class="headerlink" title="分析:👇👇👇"></a>分析:👇👇👇</h3><h4 id="节点翻转示意图"><a href="#节点翻转示意图" class="headerlink" title="节点翻转示意图"></a>节点翻转示意图</h4><p><img src="https://s1.ax1x.com/2020/08/11/aL1MgP.md.jpg" alt="节点翻转示意图"></p>
<p>1 既然是要翻转链表，那每个节点的连接方向都会发生变化；</p>
<p>2 每个节点都只能有一个连接。当它指向自己的前一个节点时，它就不能再指向自己的下一个节点；</p>
<p>3 需要处理链表中的每一个节点，但是根据2可知，节点连接方向改变后，无法再沿着链表获取到下一个节点；</p>
<p>解决手段：在改变节点的连接方向之前，使用一个临时变量保存当前节点的下一个节点；</p>
<blockquote>
<p>实现SOP</p>
</blockquote>
<p>1 为了能够遍历链表，我们需要一个指针；</p>
<p>2 为了能够改变节点的连接方向，我们需要另一个指针来指向当前节点的前一个节点；</p>
<blockquote>
<p>完整代码(不包含测试用例，可以自己编写main()函数作为测试用例)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 链表/节点的类定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val; <span class="comment">// 节点中存储的值</span></span><br><span class="line">    ListNode next; <span class="comment">// 节点连接到的下一个节点</span></span><br><span class="line">    ListNode(<span class="keyword">int</span> x) &#123;val = x;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 0 作用：翻转指定的链表，并返回链表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 迭代的方式</span></span><br><span class="line">        ListNode prev = <span class="keyword">null</span>; </span><br><span class="line">        ListNode curr = head; <span class="comment">// 翻转链表需要前后两个指针：一个用于更新头节点，一个用于创建链表的连接</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 记录原始的下一个节点 防止链表断掉</span></span><br><span class="line">            ListNode temp = curr.next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 建立链表的连接</span></span><br><span class="line">            curr.next = prev;</span><br><span class="line">            <span class="comment">// 更新两个指针</span></span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="实现过程☕☕☕"><a href="#实现过程☕☕☕" class="headerlink" title="实现过程☕☕☕"></a>实现过程☕☕☕</h3><h4 id="step1-定义两个指针，用来遍历和翻转链表；"><a href="#step1-定义两个指针，用来遍历和翻转链表；" class="headerlink" title="step1 定义两个指针，用来遍历和翻转链表；"></a>step1 定义两个指针，用来遍历和翻转链表；</h4><p>问题：如何初始化这两个指针？/这两个指针最开始应该指向什么位置？</p>
<p>答：参考上面的 [链表翻转示意图](#### 节点翻转示意图)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ListNode prev = <span class="keyword">null</span>; <span class="comment">// 初始化指向一个null节点</span></span><br><span class="line">ListNode curr = head; <span class="comment">// 初始化指向链表的头节点（head与curr一样，都是头节点的一个指针）</span></span><br></pre></td></tr></table></figure>



<h4 id="step2-遍历链表中的节点，并进行节点间的翻转；（每次翻转两个节点的连接）"><a href="#step2-遍历链表中的节点，并进行节点间的翻转；（每次翻转两个节点的连接）" class="headerlink" title="step2 遍历链表中的节点，并进行节点间的翻转；（每次翻转两个节点的连接）"></a>step2 遍历链表中的节点，并进行节点间的翻转；（每次翻转两个节点的连接）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123; <span class="comment">// 循环终止条件一般是比较容易出错的地方，所以放在最后再完成</span></span><br><span class="line">	<span class="comment">// 1 保存当前节点的下一个节点		作用：这样在遍历时才能直到下一个节点是哪一个</span></span><br><span class="line">    Node temp = curr.next;</span><br><span class="line">    <span class="comment">// 2 把当前节点连接到当前节点的前一个节点		说明：这个相邻节点的关系需要手动维护</span></span><br><span class="line">    curr.next = prev;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3 维护相邻节点的关系	作用：支持2</span></span><br><span class="line">    prev = curr;</span><br><span class="line">    <span class="comment">// 4 更新当前节点为当前节点的下一个节点		作用：实现遍历链表操作</span></span><br><span class="line">    curr = curr.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="step3-确定循环终止条件"><a href="#step3-确定循环终止条件" class="headerlink" title="step3 确定循环终止条件"></a>step3 确定循环终止条件</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">分析极端情况：</span></span><br><span class="line"><span class="comment">	1 当前节点指针指向链表的尾节点（非null）时，还需要一次循环来翻转last与其上一个节点之间的连接方向；</span></span><br><span class="line"><span class="comment">	2 当前节点指针指向null时，所有翻转都已经完成，循环结束；</span></span><br><span class="line"><span class="comment">	所以循环终止条件为：curr == null;		相应地，(表达式)就应该为curr != null</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">while</span>(curr != <span class="keyword">null</span>)&#123;...&#125;</span><br></pre></td></tr></table></figure>



<h4 id="step4-确定返回值"><a href="#step4-确定返回值" class="headerlink" title="step4 确定返回值"></a>step4 确定返回值</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原则：总是应该返回预期链表的头节点</span></span><br><span class="line"><span class="comment">// 手段：查看循环终止时，各个指针的指向情况		翻转后链表的头节点应该是prev</span></span><br><span class="line"><span class="keyword">return</span> prev;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="代码重现-🦇🦇🦇"><a href="#代码重现-🦇🦇🦇" class="headerlink" title="代码重现 🦇🦇🦇"></a>代码重现 🦇🦇🦇</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    </span><br><span class="line">    ListNode(<span class="keyword">int</span> x)&#123; <span class="keyword">this</span>.val = x&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> <span class="title">Solution</span>(<span class="title">ListNode</span> <span class="title">head</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 定义两个指针并初始化	作用：用于连接与遍历</span></span><br><span class="line">    ListNode prev = <span class="keyword">null</span>;</span><br><span class="line">    ListNode curr = head;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 开始遍历，并在遍历的过程中进行节点连接的翻转</span></span><br><span class="line">    <span class="keyword">while</span>(curr != <span class="keyword">null</span>)&#123; <span class="comment">// 循环执行条件</span></span><br><span class="line">        <span class="comment">// 记录当前节点（开始时是头节点）的下一个节点	作用：实现遍历</span></span><br><span class="line">        ListNode temp = curr.next;</span><br><span class="line">        <span class="comment">// 更新当前节点的连接</span></span><br><span class="line">        curr.next = prev; <span class="comment">// 连接到前一个节点	说明：需要维护这种节点的相邻关系</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 维护节点的相邻关系 &amp; 实现遍历</span></span><br><span class="line">        prev = curr; <span class="comment">// 1 把prev指向curr所指向的节点</span></span><br><span class="line">        curr = temp; <span class="comment">// 2 更新curr到链表的下一个节点	由于节点的连接方向已经变化，所以不能使用curr.next 使用预先存储的节点temp</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回链表的头节点</span></span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="启示"><a href="#启示" class="headerlink" title="启示"></a>启示</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">知道为什么这么写后，才能把思路翻译成代码。不然就是在背代码了</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>ListNode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>两个链表的交点_01</title>
    <url>/ListNode/2020/08/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E6%B1%82%E4%B8%A4%E4%B8%AA%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E4%BA%A4%E7%82%B9_01.html</url>
    <content><![CDATA[<h3 id="求两个相交链表的交点"><a href="#求两个相交链表的交点" class="headerlink" title="求两个相交链表的交点"></a>求两个相交链表的交点</h3><hr>
<p><img src="https://s1.ax1x.com/2020/08/11/aLZ7UP.png" alt="图片无法显示"></p>
<a id="more"></a>

<p><strong>要求</strong></p>
<ul>
<li>如果两个链表没有交点，返回null</li>
<li>返回结果后，两个链表必须仍保持原有的结构；</li>
<li>默认链表中不存在环；</li>
<li>尽量满足O(n)的时间复杂度与O(1)的空间复杂度。</li>
</ul>
<hr>
<p>思路：</p>
<p>既然两个链表有长度差异，计算出差出来的长度，想办法消除这个多余长度的影响。就可以一一比较节点了</p>
<p>手段SOP：</p>
<p>1 为两个链表的头节点分别添加一个指针；</p>
<p>2 计算出链表之间的长度差异，然后让较长的那个链表的游标向后移动等长的节点；</p>
<p>3.再让两个游标同步移动，并比较所指向节点是否相等。直到找到相等/相交的节点或者到达链表的末端</p>
<hr>
<p>把上述SOP翻译成代码：</p>
<ol>
<li>先定义表示链表的类型；</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以直接作为一个内部类与Solution类定义在同一个文件中</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x)&#123;</span><br><span class="line">        val = x;</span><br><span class="line">        next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="2">
<li>实现上述SOP（完整实现 + 分解动作）</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123; <span class="comment">// 两个链表结构</span></span><br><span class="line">        <span class="comment">// 最优解法（目前）：1 先计算出两个链表直接的长度差距； 2 再使用两个前后指针解决问题</span></span><br><span class="line">        <span class="comment">// 原理：1 起点相同的两个人，沿同一个方向以相同的速度移动。每时每刻，两个人都在同一个位置上；</span></span><br><span class="line">        <span class="comment">// 2 当两个链表相遇时，节点就重合了</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 鲁棒性代码</span></span><br><span class="line">        <span class="keyword">if</span>(headA == <span class="keyword">null</span> || headB == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode cursorA = headA;</span><br><span class="line">        ListNode cursorB = headB;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算headA与headB的长度</span></span><br><span class="line">        <span class="keyword">int</span> lengthA = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cursorA!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            lengthA++;</span><br><span class="line">            cursorA = cursorA.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> lengthB = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cursorB!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            lengthB++;</span><br><span class="line">            cursorB = cursorB.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算出两个链表之间的距离差————这个就是哨兵指针需要前进的节点数</span></span><br><span class="line">        <span class="keyword">int</span> diff = lengthA - lengthB; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里问题来了，我们需要确定一个信息：哪个链表更长？（这样才能正确地设置指针）</span></span><br><span class="line">        <span class="comment">// 手段：先假设A更长，然后根据真实情况进行更新</span></span><br><span class="line">        ListNode fronter = headA;</span><br><span class="line">        ListNode follower = headB;</span><br><span class="line">        <span class="keyword">if</span>(diff &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            fronter = headB;</span><br><span class="line">            follower = headA;</span><br><span class="line"></span><br><span class="line">            diff = lengthB - lengthA;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 让fronter指针先向前走diff个节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; diff; i++)&#123;</span><br><span class="line">            fronter = fronter.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 让fronter和follwer同时沿着节点先前移动，并比较节点是否为同一个节点</span></span><br><span class="line">        ListNode firstCommon = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(follower != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fronter == follower)&#123;</span><br><span class="line">                firstCommon = fronter;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fronter = fronter.next;</span><br><span class="line">            follower = follower.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> firstCommon;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<ol start="3">
<li>分解实现过程</li>
</ol>
<p>step1 定义两个指针，分别指向两个链表的头节点；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ListNode cursorA = headA;</span><br><span class="line">ListNode cursorB = headB;</span><br></pre></td></tr></table></figure>



<p>step2 计算headA链表与headB链表的长度；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> lengthA = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(cursorA != <span class="keyword">null</span>)&#123;</span><br><span class="line">	lengthA++;</span><br><span class="line">	cursorA = cursorA.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> lengthB = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(cursorB != <span class="keyword">null</span>)&#123;</span><br><span class="line">	lengthB++;</span><br><span class="line">	cursorB = cursorB.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>step3 计算两个链表之间的节点数量差;这个值就是长链表的指针需要前进的距离</p>
<blockquote>
<p>问题来了，怎么知道哪个链表更长呢？为了向前移动指针，一定需要一个正数；</p>
<p>手段：先绑定值，再通过判断来更新值；（其实就是if/else）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> diff = lengthA - lengthB;</span><br><span class="line"></span><br><span class="line">ListNode fronter = headA;</span><br><span class="line">ListNode follower = headB;</span><br><span class="line"><span class="keyword">if</span>(diff &lt; <span class="number">0</span>)&#123;</span><br><span class="line">	fronter = headB;</span><br><span class="line">	follower = headA;</span><br><span class="line">	</span><br><span class="line">	diff = lengthB - lengthA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>step4 把长链表的指针沿着链表向前移动diff个节点；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 让fronter指针先向前走diff个节点</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; diff; i++)&#123;</span><br><span class="line">   	fronter = fronter.next;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<p>step5 同时移动长链表的指针fronter与短链表的指针follower，并比较指针指向的节点是否是同一个节点；</p>
<p>直到（这个循环终止的条件）：1 找到了两个链表的第一个交点； 2 迭代到了链表的尾部，没有任何交点；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ListNode firstCommon = <span class="keyword">null</span>; <span class="comment">// 用于存储找到的第一个节点</span></span><br><span class="line"><span class="keyword">while</span>(fronter != <span class="keyword">null</span>)&#123;</span><br><span class="line">	<span class="keyword">if</span>(fronter == follower)&#123;</span><br><span class="line">		firstCommon = fronter;</span><br><span class="line">		<span class="keyword">break</span>; <span class="comment">// 找到了第一个交点</span></span><br><span class="line">	&#125;</span><br><span class="line">	fronter = fronter.next;</span><br><span class="line">	follower = follower.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>step6 把找到的交点节点返回；（如果没有交点，firstCommon的值不会被更新，也就是为null）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> firstCommon;</span><br></pre></td></tr></table></figure>



<p>step7 检查所有的变量名拼写；（在编辑器没有智能提示的情况下，拼写很容易出错）</p>
<p>step8 添加鲁棒性代码，增强代码的健壮性；最常见的就是参数判空</p>
<blockquote>
<p>启示：虽然把所有的成员变量写在一起看上去很规整，但是看代码的时候却不能重现写代码时的思路；</p>
<p>所以最好在需要变量的时候才添加这些变量，并且写在需要的地方。这会增加可读性</p>
</blockquote>
]]></content>
      <categories>
        <category>ListNode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Web应用第一谈（请求处理的中枢DispatcherServlet）</title>
    <url>/uncategorized/2020/05/17/Spring%20Web%E5%BA%94%E7%94%A8%E7%AC%AC%E4%B8%80%E8%B0%88%EF%BC%88%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E7%9A%84%E4%B8%AD%E6%9E%A2DispatcherServlet%EF%BC%89.html</url>
    <content><![CDATA[<p>Spring Web应用第一谈（请求处理的中枢DispatcherServlet）</p>
<hr>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Web应用？</span><br><span class="line">是：一个能够提供CURD功能的程序；</span><br><span class="line">作用：为用户提供服务；</span><br><span class="line">特征：</span><br><span class="line">	<span class="number">1</span> 用户通过浏览器来访问应用中的功能；</span><br><span class="line">	<span class="number">2</span> 程序需要运行在一个Web容器中（这样它才能被用户访问到）；</span><br><span class="line">	<span class="number">3</span> 用户不需要安装任何东西，他只需要一个能够访问网络的浏览器；</span><br></pre></td></tr></table></figure>



<h4 id="1-SpringMVC框架对一个URL请求的处理流程"><a href="#1-SpringMVC框架对一个URL请求的处理流程" class="headerlink" title="1.SpringMVC框架对一个URL请求的处理流程"></a>1.SpringMVC框架对一个URL请求的处理流程</h4><hr>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">SpringMVC处理URL请求的流程：</span><br><span class="line">1 请求发送给DispatcherServlet；</span><br><span class="line">	作用：DS作为一个前端控制器，把请求委托给应用程序的其他组件</span><br><span class="line">2 DispatcherServlet查询处理器映射（<span class="keyword">Handler</span> <span class="keyword">Mapping</span>）来确定把请求发送给哪一个映射器(Hanlder)进行处理；</span><br><span class="line">	</span><br><span class="line"><span class="number">3</span> 根据查询的结果，DS把请求发送给指定的映射器(<span class="keyword">Handler</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">4</span> 控制器把处理后的<span class="keyword">model</span>数据与视图名称(<span class="keyword">View</span>)发送给DS；</span><br><span class="line"></span><br><span class="line"><span class="number">5</span> DispatcherServlet使用视图解析器（ViewResolver）来通过视图名称找到对应的视图文件；</span><br><span class="line"></span><br><span class="line"><span class="number">6</span> DS把<span class="keyword">model</span>渲染到视图文件中，并最终返回到用户浏览器上;</span><br></pre></td></tr></table></figure>

<h5 id="Q1-不就是处理个请求吗？不应该最多两步吗？SpringMVC怎么一下搞了这么多有的没的，设计者是咋想的？-○´･д･-ﾉ"><a href="#Q1-不就是处理个请求吗？不应该最多两步吗？SpringMVC怎么一下搞了这么多有的没的，设计者是咋想的？-○´･д･-ﾉ" class="headerlink" title="#Q1 不就是处理个请求吗？不应该最多两步吗？SpringMVC怎么一下搞了这么多有的没的，设计者是咋想的？(○´･д･)ﾉ"></a>#Q1 不就是处理个请求吗？不应该最多两步吗？SpringMVC怎么一下搞了这么多有的没的，设计者是咋想的？(○´･д･)ﾉ</h5><h5 id="A1-DS其实在这个过程中，相当于是一个前端控制器。作用就是委托请求，有点子想Nginx"><a href="#A1-DS其实在这个过程中，相当于是一个前端控制器。作用就是委托请求，有点子想Nginx" class="headerlink" title="#A1 DS其实在这个过程中，相当于是一个前端控制器。作用就是委托请求，有点子想Nginx"></a>#A1 DS其实在这个过程中，相当于是一个前端控制器。作用就是委托请求，有点子想Nginx</h5><p>配张图，描述整个过程：</p>
<p>​    Web 请求 —&gt; DispatcherServlet - (!@#$%^)</p>
<hr>
<h4 id="2-创建SpringMVC的请求处理系统"><a href="#2-创建SpringMVC的请求处理系统" class="headerlink" title="2.创建SpringMVC的请求处理系统"></a>2.创建SpringMVC的请求处理系统</h4><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">--</span><br><span class="line"><span class="number">1</span> 配置DispatcherServlet；</span><br><span class="line">作用：把URL请求路由到具体的Spring组件中；</span><br><span class="line">手段<span class="number">1</span>：在web.xml中对DS进行配置</span><br><span class="line">手段<span class="number">2</span>：使用java类对DS进行配置（aka 在Servlet容器中声明前端控制器）</span><br><span class="line">参考：HelloWorldInitializer.java</span><br><span class="line"></span><br><span class="line">--</span><br><span class="line"><span class="number">2</span> 启用SpringMVC,并添加视图解析器的配置</span><br><span class="line">手段：添加注解@EnableWebMvc</span><br><span class="line">参考：WebConfig.java</span><br><span class="line"></span><br><span class="line"><span class="number">3</span> 创建管理其他非Web组件的上下文contextLoaderListener</span><br><span class="line">参考：RootConfig.java</span><br><span class="line"></span><br><span class="line">注：RootConfig先于WebConfig执行，所以：</span><br><span class="line">	<span class="number">1</span> 预期交给WebConfig管理的组件需要在RootConfig中过滤掉；</span><br><span class="line">	<span class="number">2</span> WebConfig中的Bean所依赖的组件可以在RootConfig中先行声明；</span><br></pre></td></tr></table></figure>

<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">说明：直接导入书上的源码到IDEA中运行会各种报错（百度无果的报错）；</span><br><span class="line">最终按照外网上的一个教程，搭建Web项目运行成功。</span><br><span class="line">参考链接：<span class="keyword">http</span>://websystique.com/springmvc/spring<span class="number">-4</span>-mvc-helloworld-tutorial-annotation-javaconfig-full-example/</span><br><span class="line"></span><br><span class="line">然后按照Spring实战书上的代码对项目进行更新，发现书上的代码是可以工作的。</span><br><span class="line">踩坑报错：xxx</span><br><span class="line">原因：一般测试某种手段是否可行时，我都会把原有文件拷贝一份，命名为xxx_backup.java。这样才测试方案不可行时能够快速恢复到初始状态。</span><br><span class="line">但是对Controller类来说，这种做法会导致<span class="built_in">URL</span>的歧义性</span><br><span class="line">参考:Servlet规范<span class="title">_05</span>(本地文件 如何引用？)</span><br><span class="line">引用：既然应用的上下文路径决定了Web应用中内容的<span class="built_in">URL</span>命名空间，Web容器必须要拒绝web应用定义一个在此<span class="built_in">URL</span>命名空间中可能导致冲突的上下文路径</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-1-按照控制器的方式来对控制器进行测试"><a href="#2-1-按照控制器的方式来对控制器进行测试" class="headerlink" title="2.1 按照控制器的方式来对控制器进行测试"></a>2.1 按照控制器的方式来对控制器进行测试</h5><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">需求：按照控制器的方式来测试控制器：</span><br><span class="line">SOP：</span><br><span class="line">    <span class="number">1</span> 创建控制器对象；</span><br><span class="line">    手段：<span class="built_in">new</span></span><br><span class="line">    <span class="number">2</span> 创建SpringMvc mock对象；</span><br><span class="line">    手段：standaloneSetup(xxx).build()		这是Spring框架test模块中的一个静态方法</span><br><span class="line">    <span class="number">3</span> 使用mock对象发起请求并验证响应结果；</span><br><span class="line">    手段：<span class="keyword">perform</span>()方法[执行] + andExcept()方法[断言预期结果]		同样是test框架提供的方法</span><br><span class="line">特征：不需要启动Tomcat就能能够对控制器进行测试；</span><br><span class="line">参考：HomeControllerTest.java</span><br><span class="line">结果：报错“java.lang.NoSuchMethodError: org.springframework.util.StreamUtils.emptyInput()Ljava/io/InputStream;”</span><br><span class="line">解决参考：https://blog.csdn.net/weixin_30487317/article/details/<span class="number">95601425</span></span><br><span class="line">原因：test的版本与spring-mvc版本不一致</span><br><span class="line">解决手段：test的版本参考spring-mvc的版本</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-2-把模型数据传递到视图中"><a href="#2-2-把模型数据传递到视图中" class="headerlink" title="2.2 把模型数据传递到视图中"></a>2.2 把模型数据传递到视图中</h5><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">需求：把模型数据传递到视图中</span></span><br><span class="line"><span class="attr">SOP</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">1</span> <span class="string">定义用来与数据库交互的接口SpittleRepository；</span></span><br><span class="line">    <span class="attr">2</span> <span class="string">定义域数据表对应的实体类Spittle；</span></span><br><span class="line">    <span class="attr">3</span> <span class="string">编写针对于新的Controller控制器的测试类；</span></span><br><span class="line">    <span class="attr">参考：SpittleControllerTest.java</span></span><br><span class="line">    <span class="attr">4</span> <span class="string">编写新的控制器Controller</span></span><br><span class="line"><span class="attr">为什么先编写测试类，后编写控制器？？？😳</span></span><br></pre></td></tr></table></figure>

<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">编写完成后，重启Tomcat时，项目启动失败；</span><br><span class="line">报错：找不到指定的bean；</span><br><span class="line">原因：</span><br><span class="line">    原理：</span><br><span class="line">    Spring对不同类型的组件，创建的时机会不一样；</span><br><span class="line">        <span class="number">1</span> 对于Web相关的组件（aka 控制器对象），由DispatcherServlet所创建的上下文(WebConfig)管理；</span><br><span class="line">        <span class="number">2</span> 其他类型的组件（比如dao层的对象），由ContextLoaderListener所创建的上下文（RootConfig）进行管理；</span><br><span class="line">        <span class="number">3</span> RootConfig先于WebConfig执行，它服务于整个项目；</span><br><span class="line">    具体原因：</span><br><span class="line">        在RootConfig扫描的时候就扫描到controller中的类：</span><br><span class="line">            <span class="number">1</span> bean初始化就要找自动装填的 实现SpitterRepository接口的对象(A)，</span><br><span class="line">            <span class="number">2</span> 但我把A放在WebConfig里了，环境中找不到这个Bean，于是报错。</span><br><span class="line">        所以我在RootConfig中的ComponentScan里添加了过滤，不扫描spittr.web，这样controller中的bean就不会在NoSuchBean的情况下提前初始化了，启动成功。</span><br><span class="line">    同样的原因，SpittleRepository的声明应该放在RootConfig中，否则控制器初始化时也会找不到依赖Bean而报错</span><br><span class="line">参考：https:<span class="comment">//blog.csdn.net/q5738415/article/details/78197508</span></span><br></pre></td></tr></table></figure>

<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line">这里虽然有dao层的执行方法，但是却并没有配置数据库。它是怎么实现的呢？</span><br><span class="line"><span class="params">...</span> <span class="keyword">to</span> be continue <span class="params">...</span></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-3-向控制器方法发送请求时携带参数"><a href="#2-3-向控制器方法发送请求时携带参数" class="headerlink" title="2.3 向控制器方法发送请求时携带参数"></a>2.3 向控制器方法发送请求时携带参数</h5><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">需求：向控制器发送请求时携带参数；</span><br><span class="line">参数类型（按功能分类）：</span><br><span class="line">    <span class="number">1</span> 查询参数；</span><br><span class="line">    <span class="number">2</span> 表单参数；</span><br><span class="line">    <span class="number">3</span> 路径变量；</span><br></pre></td></tr></table></figure>



<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--</span></span><br><span class="line">1 控制器接收查询参数： /spittles/<span class="keyword">show</span>?spittle_id=<span class="number">12345</span></span><br><span class="line">需求：分页列表展示xxx</span><br><span class="line">手段：调用控制器方法时，传入两个参数————页面中第一个xxx的<span class="keyword">ID</span> + 页面中xxx的总条数；</span><br><span class="line">    <span class="keyword">before</span>参数：当前页面xxx列表的左边界；</span><br><span class="line">    <span class="keyword">count</span>参数：当前页面中要包含的xxx数量</span><br><span class="line">实现方法： com.websystique.springmvc.controller.SpittleController.spittles()方法</span><br><span class="line">测试:shouldShowPagedSpittles()</span><br></pre></td></tr></table></figure>



<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">--</span><br><span class="line"><span class="number">2</span> 控制器接收路径参数：/spittles/<span class="number">12345</span></span><br><span class="line">特征：</span><br><span class="line">    <span class="number">1</span> 这种描述方式更加面向资源：<span class="number">12345</span>就是要查询的资源</span><br><span class="line">    <span class="number">2</span> 查询参数的描述方式表示：这是一个带有参数的操作；（通过HTTP发起的RPC）</span><br><span class="line">-</span><br><span class="line">先编写测试方法：</span><br><span class="line">参考：testSpittle()</span><br><span class="line">测试方法fail？？？</span><br><span class="line"></span><br><span class="line">项目访问URL：失败<span class="number">400</span></span><br><span class="line">这都是因为热部署延迟 😳</span><br><span class="line"></span><br><span class="line">-</span><br><span class="line">进入方法后，跳转视图页面时。报错<span class="number">404.</span>..</span><br><span class="line">/spring_mvc/spittles/WEB-INF/views/spittle.jsp</span><br><span class="line">在其他的控制器方法中都可以正常跳转，为什么这个方法就不行？</span><br><span class="line">原因：在配置视图解析器时，没有添加前缀/</span><br><span class="line">参考：https:<span class="comment">//blog.csdn.net/xujin_chen/article/details/53557463</span></span><br><span class="line">原理：不晓得😵[又是半夜无眠]</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-4-向控制器方法发送请求时携带表单参数"><a href="#2-4-向控制器方法发送请求时携带表单参数" class="headerlink" title="2.4 向控制器方法发送请求时携带表单参数"></a>2.4 向控制器方法发送请求时携带表单参数</h5><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">需求：向控制器发送请求时携带表单数据；</span><br><span class="line">实现手段：</span><br><span class="line">    <span class="number">1</span> 处理用户通过表单提交的数据；</span><br><span class="line">    参考：show<span class="constructor">RegistrationForm()</span>方法</span><br><span class="line">    完整流程SOP:</span><br><span class="line">        <span class="number">1</span> 编写控制器方法的测试方法：<span class="module-access"><span class="module"><span class="identifier">SpitterController</span>.</span></span>show<span class="constructor">RegistrationForm()</span></span><br><span class="line">        <span class="number">2</span> 编写视图文件；registerForm.jsp</span><br><span class="line">        <span class="number">3</span> 编写表单提交到的控制器方法 aka 保存表单的控制器方法；<span class="module-access"><span class="module"><span class="identifier">SpitterController</span>.</span></span>processRegistration</span><br><span class="line">        <span class="number">4</span> 编写保存表单的方法的测试方法：should<span class="constructor">ProcessRegistration()</span></span><br><span class="line">        <span class="number">5</span> 编写保存表单后所跳转到的控制器方法；  show<span class="constructor">SpitterProfile()</span></span><br><span class="line">        <span class="number">6</span> 编写控制器方法跳转到的对应页面：profile.jsp</span><br><span class="line">访问链接：http:<span class="comment">//localhost:8088/spring_mvc/spitter/jbauer</span></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-5-对表单中的字段值进行校验"><a href="#2-5-对表单中的字段值进行校验" class="headerlink" title="2.5 对表单中的字段值进行校验"></a>2.5 对表单中的字段值进行校验</h5><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">需求：对表单中的字段值进行校验；</span><br><span class="line">校验类型：</span><br><span class="line">    <span class="number">1</span> 字段值不能为空；</span><br><span class="line">    <span class="number">2</span> 字段值的长度不能超过指定边界；</span><br><span class="line">手段<span class="number">1</span>：在控制方法中对用户提交的表单字段进行逐一验证；</span><br><span class="line">手段<span class="number">2</span>：java校验API接口（SpringMVC框架支持此接口）；</span><br><span class="line">具体方法SOP：</span><br><span class="line">    <span class="number">1</span> 在类路径下包含Java校验API接口的具体实现（比如Hibernate Validator）：</span><br><span class="line">        手段：引用jar包</span><br><span class="line">    <span class="number">2</span> 在java类的属性上添加所需要的注解；</span><br><span class="line">        手段：@NotNull、@Size</span><br><span class="line">    <span class="number">3</span> 在控制器方法中启用校验功能；</span><br><span class="line">        手段：为方法的POJO类型参数添加 @Valid 注解————通知Spring对此参数进行校验；</span><br><span class="line">    <span class="number">4</span> 在控制器方法中处理校验未通过的错误</span><br><span class="line">        手段：使用Errors对象来获取到校验失败的具体信息；</span><br><span class="line">特征：</span><br><span class="line">    <span class="number">1</span> 即便校验没有通过，用户仍旧能够提交表单。aka 控制器方法仍旧会被调用</span><br><span class="line">    <span class="number">2</span> 为了使Errors对象能够获取到校验失败的信息，需要让Errors参数紧跟在@Valid注解的参数后面</span><br><span class="line">    <span class="number">3</span> 在控制器方法中，第一步就应该查看是否出现校验错误————如果校验有错，后面的逻辑就不用再执行了</span><br><span class="line">参考：SpitterController.processRegistration()</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-6-java校验API"><a href="#2-6-java校验API" class="headerlink" title="2.6 java校验API"></a>2.6 java校验API</h5><figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">Java校验API：</span><br><span class="line">作用：对Java类的属性进行校验；</span><br><span class="line">手段：提供多个用于特定校验规则的注解；</span><br><span class="line">用法：把特定的注解放到属性上，就能够限制属性的值。</span><br><span class="line">特征：所有的这些个注解都在javax.validation.constraints包中提供；</span><br><span class="line">常用的校验注解：</span><br><span class="line">    <span class="symbol">@NotNull</span>：限制被注解的属性的值不能为<span class="literal">null</span></span><br><span class="line">    <span class="symbol">@Size</span>：限制被注解的属性的值必须是<span class="built_in">String</span>、数组或者集合，并且长度要符合给定的范围；</span><br><span class="line">参考：Spitter类 （这是Spittr应用的用户）</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-额外收获"><a href="#3-额外收获" class="headerlink" title="3.额外收获"></a>3.额外收获</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">有趣的点：</span></span><br><span class="line">    <span class="number">1</span> <span class="string">SpitterRepository接口的实现类是在WebConfig中配置Bean的时候实现的：</span></span><br><span class="line">        <span class="string">如果没提供这个实现类。创建Controller时注入依赖就会失败</span></span><br><span class="line">    <span class="number">2</span> <span class="string">这里的save()方法并没有把值存储到数据库中，而是添加到一个map对象中。</span></span><br><span class="line">        <span class="string">尽管对象会在每次重启JVM时消失，但是作为一个容器，它是可以当成临时数据库来使用的</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">小结：</span><br><span class="line">大需求：编写应用程序的Web部分；</span><br><span class="line">手段：使用SpringMVC框架（这是Spring框架的一个模块）；</span><br><span class="line">特征：</span><br><span class="line">    <span class="number">1</span> 这种开发方式几乎就是在写POJO类；</span><br><span class="line">    <span class="number">2</span> 编写控制器方法与编写普通java方法无异，唯一的区别在于————你要想办法让方法能够接收到页面发来的参数</span><br><span class="line">    <span class="number">3</span> SpringMVC编写的控制器非常容易测试；</span><br><span class="line">    手段：Mockito框架 + Spring test模块</span><br><span class="line">NexT？</span><br><span class="line">Spring视图相关的一堆东西</span><br></pre></td></tr></table></figure>













]]></content>
  </entry>
  <entry>
    <title>Spring AOP第二谈（与AspectJ AOP的对比）</title>
    <url>/uncategorized/2020/05/11/Spring%20AOP%E7%AC%AC%E4%BA%8C%E8%B0%88%EF%BC%88%E4%B8%8EAspectJ%20AOP%E7%9A%84%E5%AF%B9%E6%AF%94%EF%BC%89.html</url>
    <content><![CDATA[<p>Spring AOP第二谈（与AspectJ AOP的对比）</p>
<hr>
<h4 id="1-AOP的实现方案"><a href="#1-AOP的实现方案" class="headerlink" title="1.AOP的实现方案"></a>1.AOP的实现方案</h4><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">方案<span class="number">1</span>：Spring AOP；</span><br><span class="line">方案<span class="number">2</span>：AspectJ；</span><br><span class="line">特征：AspectJ提供了很多其他的切点类型（Spring AOP只能提供方法调用的切点类型）</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="2-在创建对象时应用指定的通知"><a href="#2-在创建对象时应用指定的通知" class="headerlink" title="2. 在创建对象时应用指定的通知"></a>2. 在创建对象时应用指定的通知</h4><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">需求：在创建对象时应用指定的通知；</span><br><span class="line">说明：创建对象需要调用<span class="keyword">Bean的构造器，但是Spring </span>AOP无法指定这样的连接点/切点类型</span><br><span class="line">为什么Spring AOP实现不了呢？</span><br><span class="line">答：因为它基于代理实现，只能做一些方法层面的操作；</span><br><span class="line">手段：使用AspectJ提供的AOP功能；</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="3-管理由AspectJ创建的切面bean所依赖的Spring组件"><a href="#3-管理由AspectJ创建的切面bean所依赖的Spring组件" class="headerlink" title="3. 管理由AspectJ创建的切面bean所依赖的Spring组件"></a>3. 管理由AspectJ创建的切面bean所依赖的Spring组件</h4><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">说明：一个通知方法可能需要依赖其他的类来实现功能。</span><br><span class="line">需求：管理通知方法所依赖的其他类</span><br><span class="line">手段：把通知方法所依赖的<span class="keyword">Bean注入到切面类中</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">--</span></span><br><span class="line"><span class="keyword">需求：为演出创建一个评论员的角色；</span></span><br><span class="line"><span class="keyword">功能：观看演出，并在观看完成后提出一些批评意见</span></span><br><span class="line"><span class="keyword">参考：CriticAspect </span>+ CriticismEngine + CriticismEngineImpl + <span class="keyword">bean_declare_xmlconfig</span></span><br><span class="line"><span class="keyword">特征：</span></span><br><span class="line"><span class="keyword"> </span>   <span class="number">1</span> AspectJ切面不需要Spring就可以织入到我们的应用中<span class="comment">;</span></span><br><span class="line">    <span class="number">2</span> 但是如果想要使用Spring来管理AspectJ的一些个依赖，就需要把AspectJ切面来声明成一个Spring <span class="keyword">bean</span></span><br><span class="line"><span class="keyword"> </span>   参考：<span class="keyword">bean_declare_xmlconfig.xml</span></span><br><span class="line"><span class="keyword"> </span>   <span class="number">3</span> AspectJ切面<span class="keyword">bean不是Spring容器创建的，而是AspectJ在运行时创建的；</span></span><br><span class="line"><span class="keyword"> </span>   <span class="number">4</span> 为了能够在Spring中获取到AspectJ切面的实例，需要调用切面类的aspectOf()方法————此方法返回切面类的一个单例</span><br></pre></td></tr></table></figure>



<h4 id="4-AOP小结"><a href="#4-AOP小结" class="headerlink" title="4.AOP小结"></a>4.AOP小结</h4><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line"><span class="comment">------</span></span><br><span class="line">AOP：</span><br><span class="line">是：一种编程方式；</span><br><span class="line">作用：把分散在应用各处的行为集中在一个模块中（方便管理），并作为重用模块（方便引用）</span><br><span class="line">特征：</span><br><span class="line">    <span class="number">1</span> 使程序员编写的类更加简洁、准确；</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">需求：支持AOP形式的编程风格；</span><br><span class="line">Spring提供的手段：Spring AOP；</span><br><span class="line">原理：</span><br><span class="line">    在程序员进行必要的操作后，Spring AOP会创建一个代理类，在代理类中把切面插入到目标方法执行的周围；</span><br><span class="line">必要的操作：</span><br><span class="line">    <span class="number">1</span> 程序员通过自定义切面来声明预期插入到目标类/方法中的功能；</span><br><span class="line">    <span class="number">2</span> 程序员通过编写切点表达式来声明应用切面中的通知；</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">应用：</span><br><span class="line">    <span class="number">1</span> 把通知织入/应用前置、后置和环绕方法的调用中；</span><br><span class="line">    <span class="number">2</span> 为异常处理添加自定义的行为————抛出异常时的通知方法；</span><br><span class="line">    <span class="number">3</span> 与DI一起，支持程序员创建松散耦合的应用</span><br><span class="line">用法SOP:</span><br><span class="line">    <span class="number">1</span> 声明切面类；</span><br><span class="line">    <span class="number">2</span> 配置切面类中的通知方法（when + where + what）</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>SpringAOP第一谈（术语 &amp; SOP）</title>
    <url>/uncategorized/2020/05/11/SpringAOP%E7%AC%AC%E4%B8%80%E8%B0%88%EF%BC%88%E6%9C%AF%E8%AF%AD%20&amp;%20SOP%EF%BC%89.html</url>
    <content><![CDATA[<p>面向切面编程AOP第一谈：术语 &amp; Java配置方式 &amp; XML配置方式</p>
<hr>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">面向切面编程；</span><br><span class="line"></span><br><span class="line">是：一种编程方式；</span><br><span class="line"></span><br><span class="line">作用：</span><br><span class="line"></span><br><span class="line">​	<span class="number">1</span> 分离应用程序中的业务逻辑点与横切关注点；</span><br><span class="line"></span><br><span class="line">​	<span class="number">2</span> 使业务逻辑点的代码更加简洁清晰；</span><br><span class="line"></span><br><span class="line">​	<span class="number">3</span> 使所有的横切关注点能够集中起来，方便管理；</span><br><span class="line"></span><br><span class="line">特征：</span><br><span class="line"></span><br><span class="line">​	<span class="number">1</span> 通过声明的方式来引用切面中的通知方法到指定的目标方法；</span><br><span class="line"></span><br><span class="line">​	<span class="number">2</span> 切面类是一个POJO类；</span><br></pre></td></tr></table></figure>





<hr>
<h4 id="1-切点"><a href="#1-切点" class="headerlink" title="1.切点"></a>1.切点</h4><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">切点：</span><br><span class="line">作用：定义切面实际作用到的代码位置；</span><br><span class="line">原理：选择切点表达式所匹配到的连接点；</span><br><span class="line">手段：使用AspectJ的切点表达式定义切点；</span><br><span class="line">特征：</span><br><span class="line">    <span class="number">1</span> Spring仅仅支持AspectJ切点指示器的一个子集；</span><br><span class="line">    <span class="number">2</span> Spring所支持的指示器中：</span><br><span class="line">        只有execution指示器是用来执行匹配的；</span><br><span class="line">        其他的指示器都只是限制匹配的；</span><br><span class="line">    <span class="number">3</span> execution指示器是编写切点时，最常使用到的指示器；</span><br></pre></td></tr></table></figure>



<p>1.1 定义切点</p>
<p>手段：编写切点表达式；</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="comment">---</span></span><br><span class="line">任务：编写切点表达式；</span><br><span class="line">前提：需要一个主题————应用切面的目标；</span><br><span class="line">参考：Performance.java</span><br><span class="line"></span><br><span class="line"><span class="comment">--</span></span><br><span class="line">连接点：Performance接口中的<span class="keyword">perform</span>()方法</span><br><span class="line">需求：当<span class="keyword">perform</span>()被调用时，触发自定义的通知；</span><br><span class="line">手段：编写一个切点表达式；</span><br><span class="line">execution(* concert.Performance.<span class="keyword">perform</span>(..))</span><br><span class="line">语义：在方法执行时触发 不关心方法的返回值类型 方法的全限定名(任意参数)</span><br><span class="line">作用：通过此切点表达式，选择了连接点为Performance的<span class="keyword">perform</span>()方法</span><br><span class="line"></span><br><span class="line"><span class="comment">--</span></span><br><span class="line">需求：通过切点表达式的多个规则来选择多个连接点</span><br><span class="line">手段：切点表达式A &amp;&amp; 切点表达式B</span><br><span class="line">具体表达式：execution(* concert.Performance.<span class="keyword">perform</span>(..)) &amp;&amp; <span class="keyword">within</span>(concert.*)</span><br><span class="line"><span class="keyword">within</span>()指示器用来限制连接点匹配指定的类型</span><br><span class="line">&amp;&amp;/<span class="keyword">and</span> 表示连接点必须匹配所有的指示器</span><br><span class="line"></span><br><span class="line"><span class="comment">--</span></span><br><span class="line">任务：在切点中选择指定的Bean</span><br><span class="line">原理：使用bean ID或bean名称来选择指定的bean</span><br><span class="line">需求：执行Performance的<span class="keyword">perform</span>()方法时来应用通知，但是仅限于bean ID为woodstock的bean实例上的方法调用</span><br><span class="line">手段：bean()指示器</span><br><span class="line">切点表达式：</span><br><span class="line">    execution(* concert.Performance.<span class="keyword">perform</span>(..)) <span class="keyword">and</span> bean(<span class="string">'woodstock'</span>)</span><br><span class="line"></span><br><span class="line">需求：限制bean ID不为woodstock的bean实例上，执行xxx方法时，应用通知；</span><br><span class="line">切点表达式：</span><br><span class="line">    execution(* concert.Performance.<span class="keyword">perform</span>(..)) <span class="keyword">and</span> !bean(<span class="string">'woodstock'</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-定义切面（通知-切点）"><a href="#2-定义切面（通知-切点）" class="headerlink" title="2.定义切面（通知 + 切点）"></a>2.定义切面（通知 + 切点）</h4><p>手段：编写切面类；</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">任务：编写切面类；</span><br><span class="line">手段：编写POJO类，然后使用AspectJ5提供的注解声明它是一个切面类；</span><br><span class="line">默念：插入切面、应用/织入通知、选择连接点、匹配切点</span><br><span class="line">应用：对于一场演出来说，观众就可以视为一个切面（可以单独分离出来的功能）；</span><br><span class="line">SOP:</span><br><span class="line">    Ⅰ 声明切面类及通知细节</span><br><span class="line">    <span class="number">1</span> 通过@Aspect注解来声明一个作为切面的类；</span><br><span class="line">    <span class="number">2</span> 在类中定义通知方法：功能实现 + 应用时机；</span><br><span class="line">    <span class="number">3</span> 如果出现了同一个切点表达式被多次书写的情况，把切点表达式单独使用@Pointcut注解定义为一个方法————导出调用</span><br><span class="line">    参考：Audience.java</span><br><span class="line">    ---</span><br><span class="line">    Ⅱ 告诉Spring为定义为切面的类创建代理：</span><br><span class="line">    手段：启用自动代理功能；</span><br><span class="line">    具体方法<span class="number">1</span>：如果使用java类来配置的话，注解@EnableAspectJAutoProxy</span><br><span class="line">        参考：ConcertConfig.java</span><br><span class="line">    具体方法<span class="number">2</span>：使用xml文件配置，aop:aspectj-<span class="built_in">auto</span>proxy标签</span><br><span class="line">        参考：aspect-audience-config.xml</span><br><span class="line">    作用：</span><br><span class="line">        <span class="number">1</span> AspectJ自动代理会给bean创建一个代理————这个代理会包围切点所匹配的bean，以提供切面的功能</span><br><span class="line">        <span class="number">2</span> Audience切面类中的通知方法会在切点所指定的连接点perform()方法调用的前后执行[<span class="keyword">this</span> <span class="keyword">is</span> the <span class="keyword">final</span> propose]</span><br></pre></td></tr></table></figure>



<hr>
<p>Spring对AOP的实现：Spring AOP</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">特征：</span><br><span class="line">    <span class="number">1</span> 使用@AspectJ来声明切面类；</span><br><span class="line">    <span class="number">2</span> 只能够对方法调用这样的操作进行通知；因为代理类就只能对方法的调用进行代理</span><br><span class="line">原理：为被通知的类创建一个代理类，在代理类中实现目标对象的增强（通知方法）</span><br></pre></td></tr></table></figure>



<h5 id="1-为目标方法创建一个环绕通知"><a href="#1-为目标方法创建一个环绕通知" class="headerlink" title="1.为目标方法创建一个环绕通知"></a>1.为目标方法创建一个环绕通知</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">创建环绕通知（round</span> <span class="string">advice）</span></span><br><span class="line"><span class="string">作用：使用自定义的逻辑包围被通知的目标方法；</span> <span class="string">aka</span> <span class="string">前置通知</span> <span class="string">+</span> <span class="string">后置通知</span></span><br><span class="line"><span class="string">应用参考：aop.Audience.watchPerformance()环绕通知方法</span></span><br></pre></td></tr></table></figure>



<h5 id="2-在通知方法中使用目标方法中的参数"><a href="#2-在通知方法中使用目标方法中的参数" class="headerlink" title="2.在通知方法中使用目标方法中的参数"></a>2.在通知方法中使用目标方法中的参数</h5><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">issue：当被通知的目标方法有参数时，通知方法要怎样才能使用这些参数呢？</span><br><span class="line">需求：记录光盘中某个磁道被播放的次数</span><br><span class="line">手段<span class="number">1</span>：在play<span class="constructor">Track()</span>方法中添加一个计数器————每次play<span class="constructor">Track()</span>方法被调用后，都更新计数器的值；</span><br><span class="line">手段<span class="number">2</span>：既然这个需求与播放磁道是不同的任务，把这个需求放在切面中来完成；</span><br><span class="line">参考：<span class="module-access"><span class="module"><span class="identifier">TrackCounter</span>.</span></span>java</span><br><span class="line">验证：</span><br><span class="line">	<span class="number">1</span> 通过代码显式地播放某个磁道多次（play<span class="constructor">Track()</span>）;</span><br><span class="line">	<span class="number">2</span> 然后调用计数器counter的get<span class="constructor">PlayCount()</span>来判断记录的次数是否正确</span><br><span class="line">特征：get<span class="constructor">PlayCount()</span>并没有在CD的方法中，但是同样获取到了方法的调用次数</span><br></pre></td></tr></table></figure>



<h5 id="3-为目标类添加新的方法"><a href="#3-为目标类添加新的方法" class="headerlink" title="3.为目标类添加新的方法"></a>3.为目标类添加新的方法</h5><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">任务：为目标对象添加新的方法：</span><br><span class="line">实现手段：代理对象在实现目标类接口的同时，再实现新添加的接口； aka 为目标对象引入（<span class="built_in">int</span>roduce）新的接口方法</span><br><span class="line">原理：代理会把对目标对象的所有方法调用都委托到底层的具体实现；</span><br><span class="line">特征：</span><br><span class="line">    <span class="number">1</span> 对客户端程序员来说，他只是在一个对象上调用方法（他用的其实是一个代理对象）；</span><br><span class="line">    <span class="number">2</span> 在底层，其实把这一个bean实例的实现分散到了多个类中；</span><br><span class="line">应用：</span><br><span class="line">    在不改动类的原始代码的情况下，灵活地为现有类添加新方法</span><br><span class="line">SOP:</span><br><span class="line">    <span class="number">1</span> 创建一个新的切面类；</span><br><span class="line">    参考：EncoreableIntroducer</span><br><span class="line">    <span class="number">2</span> 在IoC容器中，把切面类声明为一个Spring Bean；</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="3-使用XML来实现上面的所有任务-需求"><a href="#3-使用XML来实现上面的所有任务-需求" class="headerlink" title="3.使用XML来实现上面的所有任务/需求"></a>3.使用XML来实现上面的所有任务/需求</h4><h5 id="3-1-声明一个类为切面；"><a href="#3-1-声明一个类为切面；" class="headerlink" title="3.1 声明一个类为切面；"></a>3.1 声明一个类为切面；</h5><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">特征：</span><br><span class="line">    <span class="number">1</span> 能够在没有组件源码的情况下（比如说使用的第三方组件），能够对组件进行插入切面的操作；</span><br><span class="line">    <span class="number">2</span> 相比于“java配置类”的手段，使用XML配置没有侵入性。也就是说，这种方式不要求你对原始代码做出任何的改动 </span><br><span class="line">实现手段：Spring的aop命名空间下的多个元素；</span><br><span class="line">    例：</span><br><span class="line">        aop:aspectj-autoproxy</span><br><span class="line">        作用：自动创建代理对象————代理由<span class="meta">@AspectJ</span>所注解的通知类</span><br><span class="line">SOP:</span><br><span class="line">    <span class="number">1</span> 去掉添加在切面类上的所有AspectJ提供的注解：<span class="meta">@AspectJ</span>、<span class="meta">@Before</span>、<span class="meta">@After</span>、<span class="meta">@Around</span></span><br><span class="line">    现在有的只是一个单纯的POJO类</span><br><span class="line"></span><br><span class="line">    <span class="number">2</span> 在XML中声明这个类为一个通知类（通知 + 切点 = 切面）</span><br><span class="line">    通知是一个类、切点是一个表达式、切面是一个概念（<span class="keyword">when</span>、<span class="keyword">where</span>、what）</span><br><span class="line">    参考：announce-audience-via-xmlconfig.xml</span><br><span class="line">    使用切点方法对切点表达式的usage进行简化</span><br></pre></td></tr></table></figure>

<h5 id="3-2-在XML声明环绕通知"><a href="#3-2-在XML声明环绕通知" class="headerlink" title="3.2 在XML声明环绕通知"></a>3.2 在XML声明环绕通知</h5><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">环绕通知：</span><br><span class="line">原理：通知方法会包装目标方法，然后在目标方法调用前后添加一些功能；</span><br><span class="line">特征：</span><br><span class="line">    <span class="number">1</span> 等同于前置通知方法 + 后置通知方法；</span><br><span class="line">    <span class="number">2</span> 能够省去前置通知方法 与 后置通知方法中的通信问题（多线程时，方法之间使用成员变量进行通信会有线程安全的问题）</span><br><span class="line">环绕通知方法：watchPerformance()</span><br><span class="line">手段：aop命名空间中的aop:around元素</span><br><span class="line">参考：announce-audience-via-xmlconfig.xml</span><br></pre></td></tr></table></figure>



<h5 id="3-3-在通知方法中使用目标方法中的参数"><a href="#3-3-在通知方法中使用目标方法中的参数" class="headerlink" title="3.3 在通知方法中使用目标方法中的参数"></a>3.3 在通知方法中使用目标方法中的参数</h5><figure class="highlight less"><table><tr><td class="code"><pre><span class="line">手段：为“通知方法”传递参数;</span><br><span class="line">特征：为通知方法所传递的参数应该是目标方法中的参数</span><br><span class="line"><span class="attribute">SOP</span>:</span><br><span class="line">    <span class="number">1</span> 去掉切面类上添加的<span class="variable">@AspectJ</span>注解</span><br><span class="line">    参考：TrackCounterWithoutAnnotation</span><br><span class="line">    <span class="number">2</span> 通过XML配置的方式把TrackCounter声明为一个切面类</span><br><span class="line">    参考：announce-trackcounter-as-aspect-via-xmlconfig.xml</span><br></pre></td></tr></table></figure>



<h5 id="3-4-为目标类添加-引入新的方法"><a href="#3-4-为目标类添加-引入新的方法" class="headerlink" title="3.4 为目标类添加/引入新的方法"></a>3.4 为目标类添加/引入新的方法</h5><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">手段：Spring</span> <span class="string">aop命名空间中的&lt;aop:declare-parents&gt;元素；</span></span><br><span class="line"><span class="attr">参考：add_new_methods_into_target_via_xmlconfig.xml</span></span><br><span class="line"><span class="attr">SOP</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">1</span> <span class="string">在aop:config中声明一个切面类的配置</span></span><br><span class="line">    <span class="attr">2</span> <span class="string">指定预期会被通知的Bean</span></span><br><span class="line">    <span class="attr">3</span> <span class="string">指定预期会为Bean的父类结构所添加的新接口</span></span><br><span class="line">    <span class="attr">4</span> <span class="string">指定为添加的新接口所编写的具体实现</span></span><br><span class="line"><span class="meta">that'a</span> <span class="string">all.</span></span><br></pre></td></tr></table></figure>





]]></content>
  </entry>
  <entry>
    <title>更高级的bean装配第五谈</title>
    <url>/uncategorized/2020/05/05/%E6%9B%B4%E9%AB%98%E7%BA%A7%E7%9A%84bean%E8%A3%85%E9%85%8D%E7%AC%AC%E4%BA%94%E8%B0%88.html</url>
    <content><![CDATA[<p>更高级的bean装配第五谈</p>
<hr>
<h4 id="在运行时向方法中装配-注入值"><a href="#在运行时向方法中装配-注入值" class="headerlink" title="在运行时向方法中装配/注入值"></a>在运行时向方法中装配/注入值</h4><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">需求：避免在声明bean时使用硬编码；</span><br><span class="line">手段：使原来硬编码的值推迟到运行时再确定；</span><br><span class="line">具体方法：Spring提供的再运行时求值的方式</span><br><span class="line">    <span class="number">1</span> 属性占位符（<span class="keyword">Property</span><span class="title"> </span>placeholder）</span><br><span class="line">    <span class="number">2</span> Spring表达式语言（SpEL）</span><br></pre></td></tr></table></figure>

<h5 id="使用属性表达式来动态注入值"><a href="#使用属性表达式来动态注入值" class="headerlink" title="使用属性表达式来动态注入值"></a>使用属性表达式来动态注入值</h5><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">手段SOP：</span><br><span class="line">    <span class="number">1</span> 把属性单独定义到一个properties文件中（外部文件）</span><br><span class="line">    <span class="number">2</span> 在java配置类中加载属性文件到Spring的Environment中</span><br><span class="line">    <span class="number">3</span> 在java代码中从Environment中获取到属性值————用于替换占位符所占的位置</span><br><span class="line">参考：EnvironmentConfig</span><br></pre></td></tr></table></figure>

<hr>
<p>Spring中的Environment实例：getProperty()方法的各种重载</p>
<hr>
<h6 id="在xml配置文件中使用属性占位符"><a href="#在xml配置文件中使用属性占位符" class="headerlink" title="在xml配置文件中使用属性占位符"></a>在xml配置文件中使用属性占位符</h6><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">SOP:</span><br><span class="line">	<span class="number">1</span> 在java配置类中声明PropertySourcesPlaceholderConfigurer这个bean；</span><br><span class="line">    或者在xml配置文件中，使用context命名空间中的<span class="keyword">property</span>-placeholder元素</span><br><span class="line">	<span class="number">2</span> 在需要属性值的地方使用属性占位符</span><br><span class="line">作用：用于解析占位符；</span><br><span class="line">特征：</span><br><span class="line">    <span class="number">1</span> 把值得注入操作推迟到运行时；</span><br><span class="line">    <span class="number">2</span> 属性表达式需要放在$&#123;xxx&#125;中</span><br><span class="line">原理：根据名称来解析来自于Spring Environment和属性源中的属性值</span><br></pre></td></tr></table></figure>

<hr>
<h6 id="使用SpEL表达式来动态注入值"><a href="#使用SpEL表达式来动态注入值" class="headerlink" title="使用SpEL表达式来动态注入值"></a>使用SpEL表达式来动态注入值</h6><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">作用：把一个变量装配到bean的方法中</span><br><span class="line">特征：变量的值在运行时才会计算出来</span><br><span class="line">用法：</span><br><span class="line">    <span class="number">1</span> SpEL表达式要放在#&#123;xxx&#125;中</span><br><span class="line">    <span class="number">2</span> 引用字面量的值</span><br><span class="line">    <span class="number">3</span> 引用bean、属性以及方法</span><br><span class="line">    <span class="number">4</span> 访问类作用域的方法与常量：T()运算符   语法：T(java类型)</span><br><span class="line">    <span class="number">5</span> 使用运算符来创建复杂的表达式</span><br><span class="line">        使用三目运算符来检查<span class="literal">null</span>值</span><br><span class="line">    <span class="number">6</span> 匹配正则表达式的模式</span><br><span class="line">    <span class="number">7</span> 计算集合</span><br><span class="line">太强不记 有点子像正则表达式哈</span><br></pre></td></tr></table></figure>

<p>it’s running late,call it a day~</p>
]]></content>
  </entry>
  <entry>
    <title>更高级的bean装配第四谈</title>
    <url>/uncategorized/2020/05/05/%E6%9B%B4%E9%AB%98%E7%BA%A7%E7%9A%84bean%E8%A3%85%E9%85%8D%E7%AC%AC%E5%9B%9B%E8%B0%88.html</url>
    <content><![CDATA[<p>更高级的bean装配第四谈</p>
<hr>
<h4 id="Spring中bean实例的作用域"><a href="#Spring中bean实例的作用域" class="headerlink" title="Spring中bean实例的作用域"></a>Spring中bean实例的作用域</h4><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">说明：Spring应用上下文中的<span class="keyword">bean默认都是单例的；</span></span><br><span class="line"><span class="keyword">单例：一个类就只会创建一个bean实例；</span></span><br><span class="line"><span class="keyword">特征：</span></span><br><span class="line"><span class="keyword"> </span>   <span class="number">1</span> <span class="keyword">bean实例没有状态，对所有的其他bean都是一样的；</span></span><br><span class="line"><span class="keyword"> </span>   <span class="number">2</span> 能够在应用中反复使用；</span><br></pre></td></tr></table></figure>

<p>pickle：如果对象需要保持自己的状态，这时候再反复重用就行不通了（单例作用域也就不适用了）</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">解决手段：</span><br><span class="line">Spring为bean实例提供了多种作用域；</span><br><span class="line">    <span class="number">1</span> 单例：整个应用中，就只有一个bean实例；[这是默认的作用域]</span><br><span class="line">    <span class="number">2</span> 原型：</span><br><span class="line">        <span class="number">01</span> 每次注入/装配时，</span><br><span class="line">        <span class="number">02</span> 每次通过Spring容器获取时，都会创建一个新的bean实例</span><br><span class="line">    <span class="number">3</span> 会话：</span><br><span class="line">        为web应用中的每一个会话创建一个bean实例；</span><br><span class="line">        特征：适用于购物车需求</span><br><span class="line">    <span class="number">4</span> 请求：</span><br><span class="line">        在Web应用中，为每个请求创建一个bean实例；</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">需求：在配置Bean时，手动指定bean实例的作用域；</span><br><span class="line">手段：使用<span class="meta">@Scope</span>注解声明bean实例的作用域</span><br><span class="line">参见：Notepad.java</span><br><span class="line">    <span class="comment">// 获取可配置的bean工厂的静态常量xxx作为注解的参数</span></span><br><span class="line">    <span class="meta">@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span> <span class="comment">// 手动指定bean实例的作用域</span></span><br></pre></td></tr></table></figure>



<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">需求：Web应用中的购物车；</span><br><span class="line">参考：<span class="module-access"><span class="module"><span class="identifier">ShoppingCart</span>.</span></span>java</span><br><span class="line">作用：每个会话中，只会有一个购物车实例；</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">需求：把会话&#x2F;请求作用域的bean注入到单例bean中；</span><br></pre></td></tr></table></figure>

<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="string">//</span> 单例Bean</span><br><span class="line">	<span class="string">...</span> <span class="string">//</span> 装配/注入一个会话域的bean作为参数</span><br><span class="line"></span><br><span class="line"><span class="string">//</span> 会话作用域的Bean</span><br><span class="line">@Scope<span class="params">(<span class="attr">value</span>=WebApplicationContext.SCOPE_SESSION, <span class="attr">proxyMode</span>=ScopedProxyMode.INTERFACES)</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure>

<h5 id="pickle-one"><a href="#pickle-one" class="headerlink" title="pickle one:"></a>pickle one:</h5><p>1 storeService是一个单例的bean实例——它会在Spring应用上下文被加载的时候创建；<br>2 在创建1中的bean实例时，Spring会尝试把ShoppingCart bean实例注入到方法中。但是此时shoppingCart bean实例还不存在<br>说明：会话作用域的bean实例在用户登录系统创建了会话之后才会创建；</p>
<hr>
<h5 id="pickle-two"><a href="#pickle-two" class="headerlink" title="pickle two:"></a>pickle two:</h5><p>3 应用中会包含多个shoppingCart的Bean实例，注入setter方法的时候。使用任何一个具体的bean都不好</p>
<h4 id="Spring给出的解决方案：proxyMode属性"><a href="#Spring给出的解决方案：proxyMode属性" class="headerlink" title="Spring给出的解决方案：proxyMode属性"></a>Spring给出的解决方案：proxyMode属性</h4><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">原理：不装配/注入某个具体的bean实例，而是注入一个bean的代理；</span><br><span class="line">特征：</span><br><span class="line">        <span class="number">1</span> 客户端可以无差别地像使用目标对象一样使用代理</span><br><span class="line">        <span class="number">2</span> 当调用shoppingCart的方法时，代理会对此调用进行懒加载</span><br><span class="line">        <span class="number">3</span> 代理会把调用委托给会话作用域中真正的bean</span><br></pre></td></tr></table></figure>



<hr>
<p>proxyMode语义说明：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="attribute">proxyMode</span>=ScopedProxyMode.INTERFACES</span><br><span class="line">语义：声明代理需要实现xxx接口； 基于xxx接口的代理</span><br><span class="line">这里的xxx就是方法的返回值</span><br></pre></td></tr></table></figure>

<p>如果方法的返回值不是接口类型，而是具体类型呢？</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">手段：以生成目标类扩展的方式创建代理；</span><br><span class="line">具体方法：<span class="selector-tag">ScopedProxyMode</span><span class="selector-class">.TARGET_CLASS</span></span><br></pre></td></tr></table></figure>

<hr>
<p>ProxyMode是如何解决上面的pickle one + two的？</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">pickle1</span>：进行注入时，购物车的<span class="keyword">bean实例还不存在；</span></span><br><span class="line"><span class="keyword">解决手段：对方法调用进行懒解析，从而延迟注入的操作</span></span><br></pre></td></tr></table></figure>



<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">pickle2</span>：注入<span class="keyword">bean时，不应该注入具体的bean。而应该注入当前会话中的bean实例</span></span><br><span class="line"><span class="keyword">解决手段：不是注入具体的bean实例，而是注入一个代理对象</span></span><br></pre></td></tr></table></figure>



<h4 id="XML的替换方案"><a href="#XML的替换方案" class="headerlink" title="XML的替换方案"></a>XML的替换方案</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">使用xml来配置会话作用域/请求作用域的bean：</span></span><br><span class="line"><span class="number">1</span> <span class="string">配置bean为会话作用域；</span></span><br><span class="line"><span class="string">手段：bean元素的scope属性；</span></span><br><span class="line"><span class="number">2</span> <span class="string">如何设置代理模式呢？</span></span><br><span class="line"><span class="string">手段：Spring</span> <span class="string">aop命名空间的&lt;aop:scoped-proxy&gt;元素</span></span><br><span class="line"><span class="string">作用：告诉Spring为bean创建一个作用域代理；</span></span><br><span class="line"><span class="string">特征：</span></span><br><span class="line">    <span class="number">1</span> <span class="string">默认情况下会使用CGLib来创建目标类的代理；</span></span><br><span class="line">    <span class="number">2</span> <span class="string">通过添加proxy-target-class=false，可以指定Spring生成基于接口的代理；</span></span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>更高级的bean装配第三谈</title>
    <url>/uncategorized/2020/05/05/%E6%9B%B4%E9%AB%98%E7%BA%A7%E7%9A%84bean%E8%A3%85%E9%85%8D%E7%AC%AC%E4%B8%89%E8%B0%88.html</url>
    <content><![CDATA[<p>更高级的bean装配第三谈</p>
<hr>
<p>自动装配面临的问题：进行装配时，如果有多个bean实例满足需求，装配进来哪一个呢？</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line">场景：</span><br><span class="line">自动装配一个setter()方法，装配进一个接口类型的参数；</span><br><span class="line">该接口类型有多个实现类；</span><br><span class="line">所有的实现类都添加了<span class="meta">@Component</span>注解；</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">说明：注入Bean时出现歧义的情况是非常罕见的；</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="当出现多个满足需求的bean实例时，可以有下面这些个解决方案："><a href="#当出现多个满足需求的bean实例时，可以有下面这些个解决方案：" class="headerlink" title="当出现多个满足需求的bean实例时，可以有下面这些个解决方案："></a>当出现多个满足需求的bean实例时，可以有下面这些个解决方案：</h5><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">手段<span class="number">1</span> 标志出首选的bean</span><br><span class="line">具体方法：使用@Primary注解标识一个指定的bean</span><br></pre></td></tr></table></figure>



<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">手段<span class="number">2</span>：使用Spring提供的限定符@Qualifier(<span class="string">"bean id"</span>)</span><br><span class="line">特征：</span><br><span class="line">    <span class="number">1</span> 能够把满足条件的bean限定到只有一个</span><br><span class="line">    <span class="number">2</span> 依赖于String类型的参数，所以无法应对Bean的类名被重构的情况</span><br></pre></td></tr></table></figure>



<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">手段<span class="number">3</span>：创建并使用自定义的限定符注解</span><br><span class="line">特征：</span><br><span class="line">    <span class="number">1</span> 在注入依赖的位置，可以使用多个自定义的限定符————把目标Bean的可选范围缩小到<span class="number">1</span>个</span><br><span class="line">    <span class="number">2</span> 不再显式指定依赖关系，而是使用自定义的特性限定符来指定；</span><br><span class="line">    <span class="number">3</span> setter()方法与具体的Dessert实现进行解耦；</span><br></pre></td></tr></table></figure>



]]></content>
  </entry>
  <entry>
    <title>更高级的Bean装配第二谈</title>
    <url>/uncategorized/2020/05/05/%E6%9B%B4%E9%AB%98%E7%BA%A7%E7%9A%84Bean%E8%A3%85%E9%85%8D%E7%AC%AC%E4%BA%8C%E8%B0%88.html</url>
    <content><![CDATA[<p>更高级的Bean装配第二谈</p>
<hr>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">对<span class="keyword">Bean进行条件化地管理</span></span><br><span class="line"><span class="keyword">根据指定条件是否成立来决定是否创建某个bean实例；</span></span><br></pre></td></tr></table></figure>



<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">什么叫条件化地管理？</span><br><span class="line">    只有在满足特定条件后，才会创建对应的bean</span><br><span class="line">常见的条件：</span><br><span class="line">    <span class="number">1</span> 应用类路径下包含特定的库；</span><br><span class="line">    <span class="number">2</span> 另一个相关bean被声明为Spring组件；</span><br><span class="line">    <span class="number">3</span> 某个特定的环境变量绑定了值；</span><br><span class="line">    ...</span><br><span class="line">实现手段：@<span class="constructor">Conditional(<span class="params">xxx</span>)</span></span><br><span class="line"></span><br><span class="line">应用案例：对于MagicBean类，只有当magic环境属性绑定值后，才创建它的bean实例；否则不创建bean实例</span><br><span class="line">参考：<span class="module-access"><span class="module"><span class="identifier">MagicConfig</span>.</span></span>java</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">@Conditional(xxx)的参数说明:</span><br><span class="line">    <span class="number">1</span> xxx是实现了Condition接口的一个具体实现类的Class对象；</span><br><span class="line">    <span class="number">2</span> Condition接口中，只有一个抽象方法<span class="built_in">bool</span>ean matches(ConditionContext context, AnnotatedTypeMetadata metadata);</span><br><span class="line">    <span class="number">3</span> 从context参数中就能得到所有期望的条件参数...</span><br><span class="line">    太多不看</span><br><span class="line">注：使用IDEA能够快捷地追踪源码,但源码一般比较抽象。能看出大概是在做什么就可以了</span><br></pre></td></tr></table></figure>

<p><img src="C:%5CUsers%5CHenryInSH%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200505175236602.png" alt="image-20200505175236602"></p>
<p><img src="C:%5CUsers%5CHenryInSH%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200505175305356.png" alt="image-20200505175305356"></p>
<p><img src="C:%5CUsers%5CHenryInSH%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200505175341452.png" alt="image-20200505175341452"></p>
<p><img src="C:%5CUsers%5CHenryInSH%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200505175452986.png" alt="image-20200505175452986"></p>
<hr>
<p>extra bonus</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">Spring4中,@Profile()注解是使用@Conditional()注解来实现的</span></span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>更高级的bean配置第一谈</title>
    <url>/uncategorized/2020/05/05/%E6%9B%B4%E9%AB%98%E7%BA%A7%E7%9A%84bean%E9%85%8D%E7%BD%AE%E7%AC%AC%E4%B8%80%E8%B0%88.html</url>
    <content><![CDATA[<p>更高级的bean配置第一谈</p>
<hr>
<p>应用：根据那个激活的profile来决定是否要创建某个bean；</p>
<p>说明：同一个项目，在不同的阶段，某个bean实例的获取方式可能是不一样的；</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">开发时的常见操作（表示没用过）：</span><br><span class="line">    使用嵌入式数据库；</span><br><span class="line">    作用：快速获取到一个dataSource，并预先加载测试数据；</span><br><span class="line">    参考：EmbeddedDatabaseBuilder</span><br><span class="line"></span><br><span class="line">生产环境中的常见操作：</span><br><span class="line">    使用<span class="keyword">JNDI从容器中获取一个DataSource；</span></span><br><span class="line"><span class="keyword"> </span>   作用：由容器决定如何创建这个DataSource；</span><br><span class="line">    特征：</span><br><span class="line">        有一定的复杂性</span><br><span class="line"></span><br><span class="line">QA环境中的常见操作：</span><br><span class="line">    其他获取dataSource的方式</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="Problem-amp-Solution"><a href="#Problem-amp-Solution" class="headerlink" title="Problem &amp; Solution"></a>Problem &amp; Solution</h4><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">现象说明：不同环境中的某一个<span class="keyword">bean实例可能会有所不同。</span></span><br><span class="line"><span class="keyword">解决思路：通过某种技术，使得dataSource能够在不同的环境下选择对应的配置；</span></span><br><span class="line"><span class="keyword">实现手段1：单独配置每一种bean实例，然后在构建时决定把哪一个bean实例的配置编译到可部署的应用中</span></span><br><span class="line"><span class="keyword">特征：</span></span><br><span class="line"><span class="keyword"> </span>   需要重复地构建应用</span><br><span class="line"></span><br><span class="line">实现手段<span class="number">2</span>：Spring提供的profile <span class="keyword">bean；</span></span><br><span class="line"><span class="keyword">作用：根据环境来决定该创建哪一个bean；</span></span><br><span class="line"><span class="keyword">特征：</span></span><br><span class="line"><span class="keyword"> </span>   <span class="number">1</span> 在运行时才确定使用哪一个<span class="keyword">bean的配置；</span></span><br><span class="line"><span class="keyword"> </span>   <span class="number">2</span> 这使得同一个部署包适用于所有的环境，部署时不需要重新进行构建；</span><br></pre></td></tr></table></figure>



<hr>
<p>Spring提供的profile bean用法SOP：</p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">用法SOP:</span><br><span class="line">    <span class="number">1</span> 把所有的bean定义添加到/绑定到一个<span class="keyword">profile</span>中；</span><br><span class="line">    手段：在配置类/方法上添加@Profile(<span class="string">"dev"</span>)注解；</span><br><span class="line">    作用：告诉Spring，当前配置类中的bean/方法所绑定的bean[使用@Bean声明]只有在dev <span class="keyword">profile</span>激活时才会创建</span><br><span class="line">    参考：DataSourceConfig.java</span><br><span class="line">    特征：</span><br><span class="line">        <span class="number">1</span> 对于添加了@Profile的bean：当指定的<span class="keyword">profile</span>被激活时，它修饰的bean才会被创建</span><br><span class="line">        <span class="number">2</span> 没有添加@Profile的bean：总是会被创建</span><br><span class="line">        <span class="number">3</span> 通过XML配置文件能完成同样的功能（略）</span><br><span class="line"></span><br><span class="line">    <span class="number">2</span> 在把应用部署到指定环境时，确保该环境对应的<span class="keyword">profile</span>处于激活状态</span><br><span class="line">    手段：设置 spring.profiles.active / spring.<span class="keyword">profile</span>.<span class="keyword">default</span> 这个属性的值；</span><br><span class="line">    如何设置这两个属性的值呢？</span><br><span class="line">    推荐方式：使用DispatcherServlet的参数来把spring.<span class="keyword">profile</span>.<span class="keyword">default</span>设置为开发环境的<span class="keyword">profile</span></span><br><span class="line">    具体方法<span class="number">1</span>：在servlet上下文（web.xml）中进行设置</span><br><span class="line">        参考：web.xml</span><br><span class="line">            <span class="variable">&lt;servlet&gt;</span></span><br><span class="line">                <span class="variable">&lt;init-param&gt;</span></span><br><span class="line">                    <span class="variable">&lt;param-name&gt;</span>xxx&lt;/param-name&gt;</span><br><span class="line">                ...</span><br><span class="line">            ...</span><br><span class="line">        特征：</span><br><span class="line">            <span class="number">1</span> 项目中的所有成员拉取代码后，都能使用开发环境的设置来运行代码。不需要任何额外的配置</span><br><span class="line">            <span class="number">2</span> 在部署项目到其他环境时，部署人员可以再对应设置spring.profiles.active属性的值</span><br></pre></td></tr></table></figure>

<hr>
<p>启示：xml文件可以在项目上直接进行改动。不需要对项目进行重新构建</p>
<hr>
<p>功能测试： </p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">测试说明：</span><br><span class="line">在我指定激活了某个<span class="keyword">profile</span>后：</span><br><span class="line">	<span class="number">1</span> 绑定到此<span class="keyword">profile</span>上的bean是否被正常创建；</span><br><span class="line">	<span class="number">2</span> 绑定到其他<span class="keyword">profile</span>上的bean是否符合预期——没有被创建；</span><br><span class="line">	<span class="number">3</span> 没有绑定任何<span class="keyword">profile</span>的bean是否仍旧正常创建；</span><br></pre></td></tr></table></figure>



<p>需求：在运行测试代码时，指定要激活的某个profile；</p>
<p>手段：Spring提供的<strong>@ActiveProfiles(“dev”)</strong>注解</p>
<hr>
<p>see this in a higher view</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">任务：根据<span class="string">"那个激活的profile"</span>来决定是否要创建某个<span class="keyword">bean；</span></span><br><span class="line"><span class="keyword">手段：1 </span>把<span class="keyword">bean添加到某个profile中； </span><span class="number">2</span> 在web.xml中声明被激活的profile；</span><br><span class="line"></span><br><span class="line">任务扩展：根据<span class="string">"指定的条件"</span>来决定是否要创建某个<span class="keyword">bean；</span></span><br><span class="line"><span class="keyword">手段：条件化的bean</span></span><br></pre></td></tr></table></figure>



<p>emoji: 😄</p>
]]></content>
  </entry>
  <entry>
    <title>Spring中bean的创建&amp;装配（第三谈）</title>
    <url>/uncategorized/2020/05/05/Spring%E4%B8%ADbean%E7%9A%84%E5%88%9B%E5%BB%BA&amp;%E8%A3%85%E9%85%8D%EF%BC%88%E7%AC%AC%E4%B8%89%E8%B0%88%EF%BC%89.html</url>
    <content><![CDATA[<p>Spring中bean的创建&amp;装配（第三谈）</p>
<hr>
<h4 id="方式3：使用xml文件进行配置"><a href="#方式3：使用xml文件进行配置" class="headerlink" title="方式3：使用xml文件进行配置"></a>方式3：使用xml文件进行配置</h4><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">SOP</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">1</span> <span class="string">创建一个xml文件；</span></span><br><span class="line">    <span class="attr">2</span> <span class="string">在文件顶部声明多个XML模式文件（XSD）————这些文件指定了在xml文件中的可用标签</span></span><br><span class="line">    <span class="attr">3</span> <span class="string">在spring-bean模式下添加beans元素————作为所有bean配置的根元素；</span></span><br><span class="line">    <span class="attr">4</span> <span class="string">在beans中声明所有需要Spring bean实例的配置</span></span><br></pre></td></tr></table></figure>



<h5 id="实现手段1：构造器方式注入-装配-DI"><a href="#实现手段1：构造器方式注入-装配-DI" class="headerlink" title="实现手段1：构造器方式注入/装配/DI"></a>实现手段1：构造器方式注入/装配/DI</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">声明构造器方式的DI（注入引用）</span></span><br><span class="line">    <span class="string">ref属性</span></span><br><span class="line">    <span class="string">ConstructorArgReferenceTest-context.xml</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">使用c命名空间声明构造器DI(注入引用)</span></span><br><span class="line">    <span class="string">c:xx-ref="bean</span> <span class="string">id"</span></span><br><span class="line">    <span class="string">CNamespaceReferenceTest-context.xml</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">声明构造器方式的DI(注入字面量值)：</span></span><br><span class="line">    <span class="string">value="xxx"</span></span><br><span class="line"><span class="string">说明：c命名空间会有另一套规则</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">构造器方式的DI(装配字面量集合):</span></span><br><span class="line">    <span class="string">&lt;constructor-arg&gt;</span></span><br><span class="line">        <span class="string">&lt;list&gt;</span></span><br><span class="line">            <span class="string">&lt;value&gt;...&lt;/value&gt;</span></span><br><span class="line">            <span class="string">...</span></span><br><span class="line">        <span class="string">&lt;/list&gt;</span></span><br><span class="line">    <span class="string">&lt;...&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">构造器方式的DI(装配引用集合)</span></span><br><span class="line">    <span class="string">...</span></span><br><span class="line">        <span class="string">...</span></span><br><span class="line">            <span class="string">&lt;ref&gt;...&lt;/ref&gt;</span></span><br><span class="line"><span class="string">说明：在装配集合时，constructor-arg原生元素比c命名空间更好用</span></span><br></pre></td></tr></table></figure>



<hr>
<h5 id="实现手段2：属性设置方式的注入-装配-DI"><a href="#实现手段2：属性设置方式的注入-装配-DI" class="headerlink" title="实现手段2：属性设置方式的注入/装配/DI"></a>实现手段2：属性设置方式的注入/装配/DI</h5><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">通过setter方法注入依赖</span><br><span class="line">原则：对强依赖使用构造器注入，对可选性的依赖使用setter注入；</span><br><span class="line">用法：</span><br><span class="line">    &lt;<span class="keyword">property</span> <span class="built_in">name</span>=<span class="string">"属性名"</span> <span class="keyword">ref</span>=<span class="string">"bean id"</span>/&gt;</span><br><span class="line"></span><br><span class="line">setter注入的替换方案：p-命名空间</span><br><span class="line">又是一套烦人的语法</span><br></pre></td></tr></table></figure>



<hr>
<p>多种配置方式的共用</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line"><span class="comment">-----------</span></span><br><span class="line">多种装配方式的混用mix</span><br><span class="line">说明：显式的xml配置总是必不可少，因为自动扫描+装配的方式需要先启动注解扫描<span class="keyword">context</span>:<span class="keyword">component</span>-sacn；</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>Spring中Bean的创建&amp;装配（第二谈）</title>
    <url>/uncategorized/2020/05/05/Spring%E4%B8%ADBean%E7%9A%84%E5%88%9B%E5%BB%BA&amp;%E8%A3%85%E9%85%8D%EF%BC%88%E7%AC%AC%E4%BA%8C%E8%B0%88%EF%BC%89.html</url>
    <content><![CDATA[<p>Spring中Bean的创建与装配（第二谈）</p>
<hr>
<p>方式2：使用java配置类</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="attribute">SOP</span>:</span><br><span class="line">    <span class="number">1</span> 声明一个配置类</span><br><span class="line">    手段：<span class="variable">@Configuration</span></span><br><span class="line">    <span class="number">2</span> 在配置类中声明bean</span><br><span class="line">    手段：编写一个方法，方法会返回需要类型的bean实例；</span><br><span class="line">    <span class="number">3</span> 声明方法的返回对象要作为Spring组件；</span><br><span class="line">    手段：<span class="variable">@Bean</span></span><br><span class="line">特征：方法体中可以使用任意的java语法</span><br></pre></td></tr></table></figure>

<p>bean的引用id</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">默认情况下，bean实例的ID与<span class="meta">@Bean</span>所注解的方法名相同；</span><br><span class="line">需求：手动指定bean实例的ID</span><br><span class="line">手段：<span class="meta">@Bean(name=<span class="meta-string">"《预期为bean实例指定的ID》"</span>)</span></span><br></pre></td></tr></table></figure>

<p>对bean实例进行装配</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">对声明的<span class="keyword">bean进行装配：</span></span><br><span class="line"><span class="keyword">手段01：通过“引用创建bean的方法”来装配；</span></span><br><span class="line"><span class="keyword">特征：</span></span><br><span class="line"><span class="keyword"> </span>   <span class="number">1</span> 每次方法调用得到的都是同一个<span class="keyword">bean实例；</span></span><br><span class="line"><span class="keyword"> </span>   <span class="number">2</span> 不推荐使用</span><br><span class="line">原理：</span><br><span class="line">    Spring会拦截对方法的调用：</span><br><span class="line">        如果Spring容器中已经存在了对应的<span class="keyword">bean实例，就直接返回。</span></span><br><span class="line"><span class="keyword"> </span>       如果不存在<span class="keyword">bean实例，才对方法进行调用。从而创建bean实例</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">手段02：在声明Bean时，通过方法参数指定要装配的bean；</span></span><br><span class="line"><span class="keyword">说明：这是DI的一种方式</span></span><br><span class="line"><span class="keyword">特征：</span></span><br><span class="line"><span class="keyword"> </span>   <span class="number">1</span> 由于使用方法参数，所以要装配的<span class="keyword">bean可以从外部注入；</span></span><br><span class="line"><span class="keyword"> </span>   <span class="number">2</span> 由于从外部注入，待装配的<span class="keyword">bean可以使用其他方式配置（自动扫描 </span><span class="keyword">OR </span>XML配置）</span><br><span class="line">    <span class="number">3</span> 这是推荐的方式</span><br></pre></td></tr></table></figure>

<p>DI的几种方式</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">DI（注入依赖）的几种实现方式：</span><br><span class="line"><span class="number">1</span> 构造器注入</span><br><span class="line"><span class="number">2</span> setter()方法注入</span><br><span class="line"><span class="number">3</span> 其他注入方式</span><br><span class="line"></span><br><span class="line">注入的本质上都是给bean属性绑定值</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>Spring中的Bean创建&amp;装配</title>
    <url>/uncategorized/2020/05/05/Spring%E4%B8%AD%E7%9A%84Bean%E5%88%9B%E5%BB%BA&amp;%E8%A3%85%E9%85%8D.html</url>
    <content><![CDATA[<h3 id="Spring中的Bean创建-amp-装配"><a href="#Spring中的Bean创建-amp-装配" class="headerlink" title="Spring中的Bean创建&amp;装配"></a>Spring中的Bean创建&amp;装配</h3><hr>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">装配（wiring）：建立应用中不同bean之间的依赖关系/关联关系；</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">任务：完成装配的工作；</span></span><br><span class="line"><span class="string">实现手段：DI</span></span><br><span class="line"><span class="string">具体方法：</span></span><br><span class="line">    <span class="number">1</span> <span class="string">在XML显示配置装配关系</span></span><br><span class="line">    <span class="number">2</span> <span class="string">在java中显示配置装配关系</span></span><br><span class="line">    <span class="number">3</span> <span class="string">使用Spring的bean发现</span> <span class="string">&amp;</span> <span class="string">自动装配技术</span></span><br></pre></td></tr></table></figure>



<p>方式1 自动发现 + 自动装配</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> Spring的自动化装配<span class="keyword">bean技术</span></span><br><span class="line"><span class="keyword">原理：① </span>发现<span class="keyword">bean </span>+ ② 建立<span class="keyword">bean之间的依赖关系</span></span><br><span class="line"><span class="keyword">手段：</span></span><br><span class="line"><span class="keyword"> </span>   ① 组件扫描（component <span class="keyword">scanning）：Spring框架通过扫描操作来发现由Spring容器/应用上下文所创建的bean</span></span><br><span class="line"><span class="keyword"> </span>   ② 自动装配（autowiring）：Spring框架根据发现的<span class="keyword">bean来建立bean之间的依赖关系</span></span><br><span class="line"><span class="keyword">疑问：</span></span><br><span class="line"><span class="keyword"> </span>   <span class="number">1</span> 有哪些工作是Spring完成的？</span><br><span class="line">    <span class="number">2</span> 我作为一个程序员，需要做哪些操作？</span><br><span class="line">    <span class="number">3</span> 我做的这些个操作具体是什么作用？</span><br><span class="line"></span><br><span class="line">用法：</span><br><span class="line">    参考：对音响系统中的组件进行装配；</span><br><span class="line">    CompactDisc.<span class="keyword">java </span>压缩碟片 CD</span><br></pre></td></tr></table></figure>



<h4 id="验证Spring上下文是否为Spring组件创建了bean"><a href="#验证Spring上下文是否为Spring组件创建了bean" class="headerlink" title="验证Spring上下文是否为Spring组件创建了bean"></a>验证Spring上下文是否为Spring组件创建了bean</h4><hr>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">音响系统的组件列表：</span></span><br><span class="line">    <span class="number">1</span> <span class="string">CD：音乐容器</span></span><br><span class="line">    <span class="string">参考：CompactDisc</span></span><br><span class="line">    <span class="number">2</span> <span class="string">CD</span> <span class="string">Player：播放CD的工具</span></span><br><span class="line"></span><br><span class="line"><span class="string">Spring要完成的工作：</span></span><br><span class="line">    <span class="number">1</span> <span class="string">发现项目中有@Component注解的类；</span></span><br><span class="line">    <span class="number">2</span> <span class="string">为这些个类创建其Spring</span> <span class="string">bean；</span></span><br><span class="line">    <span class="number">3</span> <span class="string">装配这些bean的依赖关系？</span></span><br><span class="line"></span><br><span class="line"><span class="string">程序员要做的工作：</span></span><br><span class="line">    <span class="number">1</span> <span class="string">为预期会交给Spring管理的类添加@Component注解</span></span><br><span class="line">        <span class="string">参考：SgtPeppers.java</span></span><br><span class="line">    <span class="number">2</span> <span class="string">在Spring配置文件中，手动开启组件扫描</span></span><br><span class="line">        <span class="string">手段1：CDPlayerConfig.java</span> <span class="string">[这是通过java配置类来开启组件扫描]</span></span><br><span class="line">        <span class="string">手段2：soundsystem.xml</span> <span class="string">[这是通过xml的方式来开启组件扫描]</span></span><br><span class="line">    <span class="number">3</span> <span class="string">需要装配的时候，使用@Autowired来声明依赖关系/注入依赖</span></span><br></pre></td></tr></table></figure>



<p>测试过程</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">测试：</span><br><span class="line">    在把CompactDisc声明为Spring组件后，Spring容器/上下文有没有创建出这个组件的实例呢？</span><br><span class="line">手段：Junit单元测试</span><br><span class="line">参考：<span class="module-access"><span class="module"><span class="identifier">CDPlayerTest</span>.</span></span>java</span><br><span class="line">SOP:</span><br><span class="line">    <span class="number">1</span> 使用JUnit框架完成两件事：</span><br><span class="line">        Ⅰ 自动创建Spring上下文的实例</span><br><span class="line">        Ⅱ 指定在什么地方加载配置信息</span><br><span class="line">    <span class="number">2</span> 在Test中注入需要被测试的Spring组件：</span><br><span class="line">        @Autowired</span><br><span class="line">        xxx</span><br><span class="line">    <span class="number">3</span> 在测试方法中，查看这个Spring组件的bean实例有没有被创建出来</span><br><span class="line">        <span class="keyword">assert</span><span class="constructor">NotNull(<span class="params">cd</span>)</span>; <span class="comment">// Junit所提供的方法</span></span><br></pre></td></tr></table></figure>



<hr>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">拾遗：</span><br><span class="line">    声明Spring组件：<span class="meta">@Component</span></span><br><span class="line">    java配置类：<span class="meta">@Configuration</span></span><br><span class="line">    开启组件扫描：<span class="meta">@Component</span> + <span class="string">context:</span>component-scan</span><br><span class="line">    实现自动装配：<span class="meta">@Autowired</span></span><br><span class="line">目的：使Spring上下文能够：</span><br><span class="line">    ① 自动发现Spring组件；</span><br><span class="line">    ② 创建它们的bean实例；</span><br><span class="line">    ③ 管理这些bean实例之间的依赖关系（aka 装配工作）</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="更多注解相关的细节"><a href="#更多注解相关的细节" class="headerlink" title="更多注解相关的细节"></a>更多注解相关的细节</h4><h5 id="指定bean实例的引用"><a href="#指定bean实例的引用" class="headerlink" title="指定bean实例的引用"></a>指定bean实例的引用</h5><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">引用<span class="keyword">bean实例：</span></span><br><span class="line"><span class="keyword">对于Spring通过组件扫描所创建的bean实例————bean实例的默认id：类名的首字母小写；</span></span><br><span class="line"><span class="keyword">需求：手动指定bean实例的id：</span></span><br><span class="line"><span class="keyword">手段：@Component("《预期的id》")</span></span><br></pre></td></tr></table></figure>



<h5 id="自动装配的规则"><a href="#自动装配的规则" class="headerlink" title="自动装配的规则"></a>自动装配的规则</h5><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">建立组件之间的依赖关系：自动装配</span><br><span class="line">原理：Spring会根据指定规则,在Spring容器中查找bean01所需要的其他bean</span><br><span class="line">手段：@Autowired注解</span><br><span class="line">具体方法：</span><br><span class="line">    <span class="number">1</span> 在类A的有参构造方法上使用@Autowired注解</span><br><span class="line">    作用：Spring上下文在创建类A的实例bean时，会自动创建类B的实例bean。并注入到构造器中</span><br><span class="line"></span><br><span class="line">    <span class="number">2</span> 在setter方法上使用@Autowired注解</span><br><span class="line">    作用：Spring上下文在初始化时，会尽可能满足bean的依赖；</span><br><span class="line"></span><br><span class="line">    <span class="number">3</span> 用在其他方法上...</span><br><span class="line">说明：Spring会尝试满足方法参数所声明的依赖；</span><br><span class="line">注入成功的条件：Spring应用上下文中有且只有一个bean满足依赖需求；</span><br><span class="line">装配不成功：</span><br><span class="line">    <span class="number">1</span> Spring上下文中没有找到符合条件的依赖bean：</span><br><span class="line">        结果：抛出一个异常；</span><br><span class="line">        说明：使用required=<span class="literal">false</span>能够避免这种情况下抛出异常</span><br><span class="line">    <span class="number">2</span> Spring上下文中有多个bean满足依赖需求：</span><br><span class="line">        结果：Spring无法决定使用哪个实例bean进行注入，抛出异常</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>Spring初体验</title>
    <url>/uncategorized/2020/05/05/Spring%E5%88%9D%E4%BD%93%E9%AA%8C.html</url>
    <content><![CDATA[<h3 id="Spring初体验"><a href="#Spring初体验" class="headerlink" title="Spring初体验"></a>Spring初体验</h3><hr>
<p>降低bean之间的耦合程度：DI</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> 在配置文件中装配/声明bean之间的关系：</span><br><span class="line">    定义应用的多个组件之间的依赖关系/协作关系；</span><br><span class="line">Spring中实现装配的方式：</span><br><span class="line">    <span class="number">1</span> 使用XML配置文件；</span><br><span class="line">    参考：knight.xml</span><br><span class="line">    <span class="number">2</span> 使用java类来描述配置；</span><br><span class="line">    参考：KnightConfig.java</span><br></pre></td></tr></table></figure>



<hr>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span> 装载XML配置文件到Spring容器/上下文，然后启动应用</span><br><span class="line">任务：装载<span class="keyword">bean的定义到Spring容器并把多个bean按照指定关系组装起来；</span></span><br><span class="line"><span class="keyword">Spring提供的手段：应用上下文（Application </span>Context）；</span><br><span class="line">说明：Spring提供了多种应用上下文的具体实现————这些实现对应于不同的配置方式<span class="comment">;</span></span><br><span class="line">参考：KnightMain.java</span><br><span class="line">    Ⅰ 加载配置文件到应用上下文实例中</span><br><span class="line">    Ⅱ 从应用上下文实例中获取到配置的指定<span class="keyword">bean</span></span><br><span class="line"><span class="keyword"> </span>   Ⅲ 调用<span class="keyword">bean的方法</span></span><br><span class="line"><span class="keyword"> </span>   Ⅳ 关闭上下文对象</span><br><span class="line"></span><br><span class="line">装配的过程是使用DI实现的——DI能够使各个组件保持松散耦合</span><br></pre></td></tr></table></figure>



<hr>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">3</span> <span class="string">专注于业务逻辑————分离出横切关注点（面向切面编程）</span></span><br><span class="line"><span class="meta">常见的横切关注点（aka</span> <span class="string">大家都会用到的功能，最好能够单独提取出来。被所有方法复用）：</span></span><br><span class="line">    <span class="attr">1</span> <span class="string">日志；</span></span><br><span class="line">    <span class="attr">2</span> <span class="string">事务管理；</span></span><br><span class="line">    <span class="attr">3</span> <span class="string">安全；</span></span><br><span class="line"><span class="attr">手段：AOP；</span></span><br><span class="line"><span class="attr">用法：</span></span><br><span class="line">    <span class="attr">1</span> <span class="string">实现横切关注点；</span></span><br><span class="line">    <span class="attr">2</span> <span class="string">以声明的方式添加关注点/切面到指定连接点处；</span></span><br><span class="line"><span class="attr">特征：</span></span><br><span class="line">    <span class="attr">1</span> <span class="string">业务代码更加专注————代码中完全不需要处理任何的横切关注点；</span></span><br><span class="line">    <span class="attr">2</span> <span class="string">横切关注点可以添加在多个方法/连接点上；</span></span><br><span class="line"><span class="attr">参考：</span></span><br><span class="line">    <span class="attr">Minstrel</span> <span class="string">吟游诗人（一个POJO类）</span></span><br><span class="line">    <span class="attr">BraveKnight</span> <span class="string">游侠骑士</span></span><br><span class="line"><span class="attr">SOP</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">1</span> <span class="string">把minstrel声明为一个切面；</span></span><br><span class="line">    <span class="attr">参考：minstrel.xml</span></span><br><span class="line">        <span class="meta">添加aop</span>:<span class="string">aspect命名空间</span></span><br><span class="line">        <span class="attr">添加bean到Spring管理</span></span><br><span class="line">        <span class="attr">添加bean的切面相关信息：</span></span><br><span class="line">            <span class="attr">切点（多个连接点）、前置通知、后置通知</span></span><br><span class="line">    <span class="attr">特征：</span></span><br><span class="line">        <span class="attr">1</span> <span class="string">Minstrel仍旧是一个POJO类；</span></span><br><span class="line">        <span class="attr">2</span> <span class="string">在XML配置后，这个POJO类就成了Spring中的一个切面；</span></span><br><span class="line">        <span class="attr">3</span> <span class="string">Minstrel与Knight之间没有任何相互调用的代码 aka 没有直接耦合</span></span><br><span class="line">        <span class="attr">由于配置文件的存在，Knight与Minstrel组件之间被解除耦合了</span></span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">Spring简化<span class="keyword">java开发第4弹————消除样板(boilerplate)代码；</span></span><br><span class="line"><span class="keyword">手段：Spring内置的模板</span></span><br><span class="line"><span class="keyword">说明：尽管java </span>APIs提供了统一的编程规范，但是它同样也产生了大量重复的<span class="keyword">boilerplate代码</span></span><br><span class="line"><span class="keyword">参考：使用java </span><span class="keyword">JDBC原生提供的APIs编写代码操作数据库 </span>VS. 使用Spring提供的模板来操作数据库</span><br><span class="line">注：一般在项目中会直接集成第三方的框架（MyBatis等）</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p> Spring容器</p>
</blockquote>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">Spring</span>中的大管家：Spring容器</span><br><span class="line">作用：管理Spring中所有的<span class="keyword">bean对象（CRUD </span><span class="keyword">and </span>more~）</span><br><span class="line">特征：</span><br><span class="line">    <span class="number">1</span> Spring容器借助DI管理<span class="keyword">bean之间的关系；</span></span><br><span class="line"><span class="keyword"> </span>   <span class="number">2</span> Spring提供的容器实现有两种大类：<span class="keyword">beanFactory（基础容器） </span>VS. ApplicationContext（更高级的容器）</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">Spring中应用上下文的具体实现：</span><br><span class="line">    说明：这些实现类的不同在于————加载应用上下文的方式不同</span><br><span class="line">    <span class="number">1</span> AnnotationConfigApplicationContext<span class="comment">;   加载应用上下文的方式：java配置类</span></span><br><span class="line">    <span class="number">2</span> AnnotationConfigWebApplicationContext<span class="comment">;    加载Web应用上下文？？？</span></span><br><span class="line">    <span class="number">3</span> ClassPathXmlApplicationContext<span class="comment">;       加载应用上下文的方式：类路径中的xml配置文件</span></span><br><span class="line">    <span class="number">4</span> FileSystemXmlApplicationContext<span class="comment">;      加载应用上下文的方式：文件系统中的xml配置文件</span></span><br><span class="line">    <span class="number">5</span> XmlWebApplicationContext<span class="comment">;     加载应用上下文的方式：Web应用中的xml配置文件</span></span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">获取到应用上下文实例之后，如何使用这个容器来管理bean的声明周期呢？</span><br><span class="line">Spring容器管理下bean生命周期（比较费劲）：</span><br><span class="line">    <span class="number">1</span> 实例化；</span><br><span class="line">    <span class="number">2</span> 填充属性/初始化；</span><br><span class="line">    <span class="number">3</span> 调用BeanNameAware的setBeanName()方法；</span><br><span class="line">    <span class="number">4</span> 调用BeanFactoryAware的setBeanFactory()方法；</span><br><span class="line">    <span class="number">5</span> 调用ApplicationContextAware的setApplicationContext()方法；</span><br><span class="line">    ---</span><br><span class="line">    <span class="number">6</span> 调用BeanPostProcessor的预初始化方法；</span><br><span class="line">    <span class="number">7</span> 调用InitializingBean的afterPropertiesSet()方法；</span><br><span class="line">    <span class="number">8</span> 调用自定义的初始化方法；</span><br><span class="line">    <span class="number">9</span> 调用BeanPostProcessor的后初始化方法；</span><br><span class="line">    --- bean能够正常使用了</span><br><span class="line">    <span class="number">10</span> 容器关闭时，调用DisposableBean的destroy()方法</span><br><span class="line">    <span class="number">11</span> 调用自定义的销毁方法</span><br><span class="line">    注：程序员还可以根据自己需要再添加新的生命阶段</span><br></pre></td></tr></table></figure>



<p>源码备注：<a href="https://www.manning.com/books/spring-in-action-fourth-edition">https://www.manning.com/books/spring-in-action-fourth-edition</a></p>
<p>注：使用Gradle工具构建的项目，可能会踩一些莫名其妙的坑。这时候你需要了解一下Gradle的用法</p>
]]></content>
  </entry>
  <entry>
    <title>Spring的特征——面向切面</title>
    <url>/uncategorized/2020/05/04/Spring%E7%9A%84%E7%89%B9%E5%BE%81%E2%80%94%E2%80%94%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2.html</url>
    <content><![CDATA[<h3 id="Spring的特征——面向切面"><a href="#Spring的特征——面向切面" class="headerlink" title="Spring的特征——面向切面"></a>Spring的特征——面向切面</h3><hr>
<p>编程过程中的横切关注点：多个方法的公共需求</p>
<p>任务：在业务代码/方法上，添加横切关注点所代表的功能；</p>
<p>手段1：继承；</p>
<p>手段2：委托；</p>
<p>手段3：把公共的功能（横切关注点）处理成为一个切面类；</p>
<hr>
<p>用法SOP：</p>
<ol>
<li><p>定义通用的功能；</p>
</li>
<li><p>在某个地方声明此功能会被添加到什么地方；</p>
<p>特征：</p>
</li>
</ol>
<p>特征：</p>
<pre><code>1. 多个横切关注点/通用功能能够放在一起管理——这会极大地节省程序员维护代码所用的时间；
 2. 通用功能的代码不会混在逻辑代码中——这样逻辑代码会更易读；</code></pre><hr>
<p>AOP相关的术语：</p>
<p>通知（advice）：切面/横切关注点所表示的功能 &amp; 使用切面的时机；</p>
<p>通知有好几种类型，这个请查词典</p>
<p>连接点（Join point）：切面可以插入的代码位置 aka 程序运行的特定时刻；</p>
<p>切点（PointCut）：指定通知所添加到的连接点的规则——通知会作用到哪一些连接点；</p>
<p>切面（Aspect）：描述横切关注点的功能 &amp; 此功能发挥作用的时机 &amp; 应用此功能的地方； 切面 = 通知（what when） + 切点(where)</p>
<p>引入（introduction）：向现有类添加新方法或属性的行为；</p>
<p>织入（weaving）：把切面应用到目标对象，并创建新的代理对象的过程；</p>
<p>切面类在指定的连接点被织入目标对象中；</p>
<hr>
<p>编译期：切面在目标类编译时就被织入。</p>
<p>特征：这需要特殊的编译器。</p>
<p>类加载期： 切面在目标类加载到JVM时被织入；</p>
<p>特征：这需要特殊的类加载器；</p>
<p>运行期：切面在应用运行的某个时刻被织入；</p>
<p>特征：Spring AOP就是采用运行期织入的方式；</p>
<hr>
<p>Spring 对AOP的几种实现：</p>
<p>1 POJO切面；</p>
<p>把一个自定义的POJO类指定为切面类；</p>
<p>特征：</p>
<pre><code>1. POJO类只是定义了满足切点条件时会被调用的方法
 2. 需要使用XML进行一些需要的配置；</code></pre><p>2 注解驱动的AOP；</p>
<p>特征：这种方式不需要使用XML配置文件；</p>
<hr>
<p>关于Spring AOP框架的一些东西：</p>
<p>1 Spring通知（what &amp; when）</p>
<p>1.1 Spring框架创建的通知都是使用java类编写的；</p>
<p>SO?</p>
<pre><code>1. 可以像开发Java类一样来开发切面（开发AspectJ则需要学习新的内容）</code></pre><p>1.2 定义通知所应用到的切点（where）；</p>
<p>手段1：使用注解；</p>
<p>手段2：在Spring配置文件中使用XML编写；</p>
<p>2 Spring是在运行时把切面织入到目标对象中的；</p>
<p>原理：</p>
<p>​    2.1 Spring会给目标对象创建一个代理对象——这个代理</p>
<p>对象会使用切面包裹目标类（增强）</p>
<p>​    2.2 当程序员调用目标类的方法时，代理类会对此方法的调用</p>
<p>进行拦截，在真正执行目标对象的方法之前，先执行切面逻辑；</p>
<p>3 Spring只支持方法级别的连接点 aka 在方法调用时，可以织入</p>
<p>切面的方法增强</p>
<p>原因：Spring是基于动态代理来实现的AOP，因此只能对方法调用进行拦截；</p>
<hr>
<p>定义切点：指定应用切面的位置（where） aka 那些个匹配切点规则的连接点</p>
<p>手段：使用AspectJ的切点表达式；</p>
<p>特征：Spring支持的AspectJ切点有限，只是xxx的一个子集；</p>
<hr>
<p>编写切点：</p>
<p>该死，这一章既然没有源码…</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个用于织入切面的主题（主题上的各种方法操作都可以作为连接点）</span></span><br><span class="line"><span class="comment">// 表演类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Performance</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">perform</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">任务：在perform()方法被调用时，自动调用指定的通知（advice）</span><br><span class="line">手段：自定义一个切点表达式来声明规则；</span><br><span class="line">	execution(* concert.Performance.perform(..))</span><br><span class="line">    语法：AspectJ指示器(返回类型 方法所属的类.方法(连接点方法所使用的参数))</span><br><span class="line">    execution()指示器用来[what &amp; when]:匹配作为连接点的方法的执行操作；</span><br><span class="line">    * 表示不关心方法的返回值是啥</span><br><span class="line">    类全限定名.方法名(..) ..表示匹配任意入参的perform()方法</span><br></pre></td></tr></table></figure>



<p>this is for now,这种复杂的规则不是用来记忆的，而是用来查询的。</p>
]]></content>
  </entry>
  <entry>
    <title>drill01</title>
    <url>/uncategorized/2020/05/04/drill01.html</url>
    <content><![CDATA[<h3 id="如何使用java代码在控制台打印出hello-world"><a href="#如何使用java代码在控制台打印出hello-world" class="headerlink" title="如何使用java代码在控制台打印出hello world!"></a>如何使用java代码在控制台打印出hello world!</h3><hr>
<ol>
<li><p>创建一个类（Test.java文件）</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span>&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span>&#123;</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"Hello World!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<hr>
<ol start="2">
<li><p>参考文献</p>
<blockquote>
<p>java编程思想</p>
</blockquote>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>我的第二篇博客文章</title>
    <url>/uncategorized/2020/05/03/%E6%88%91%E7%9A%84%E7%AC%AC%E4%BA%8C%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0.html</url>
    <content><![CDATA[<h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><p>内容</p>
<hr>
<h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><p>内容</p>
]]></content>
  </entry>
  <entry>
    <title>我的第一篇博客文章</title>
    <url>/uncategorized/2020/04/12/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0.html</url>
    <content><![CDATA[<h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><p>内容</p>
<hr>
<h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><p>内容</p>
<hr>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="http://www.codepig.cn">www.codepig.cn</a></p>
]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/uncategorized/2020/04/12/hello-world.html</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
</search>
